<?xml version="1.0"?><st-source><component-created><name>SmaCC Namespace</name> <type>package</type></component-created><parcel-loaded><name>SmaCC Namespace</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'SmaCC' 'SmaCC Namespace.pcl'))</filename></parcel-loaded><component-created><name>SmaCC Runtime</name> <type>package</type></component-created><parcel-loaded><name>SmaCC Runtime</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'SmaCC' 'SmaCC Runtime.pcl'))</filename></parcel-loaded><component-created><name>ExtraEmphases</name> <type>package</type></component-created><parcel-loaded><name>ExtraEmphases</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'ExtraEmphases.pcl'))</filename></parcel-loaded><component-created><name>TextHighlighting</name> <type>package</type></component-created><parcel-loaded><name>TextHighlighting</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'TextHighlighting.pcl'))</filename></parcel-loaded><component-created><name>HighlightingStyles</name> <type>package</type></component-created><parcel-loaded><name>HighlightingStyles</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'HighlightingStyles.pcl'))</filename></parcel-loaded><component-created><name>RBCodeHighlighting</name> <type>package</type></component-created><parcel-loaded><name>RBCodeHighlighting</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'RBCodeHighlighting.pcl'))</filename></parcel-loaded><component-created><name>AutoComplete</name> <type>package</type></component-created><parcel-loaded><name>AutoComplete</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'AutoComplete.pcl'))</filename></parcel-loaded><component-created><name>ClassCloning</name> <type>package</type></component-created><parcel-loaded><name>ClassCloning</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'ClassCloning.pcl'))</filename></parcel-loaded><component-created><name>Method Wrapper Base</name> <type>package</type></component-created><parcel-loaded><name>Method Wrapper Base</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'MethodWrappers' 'Method Wrapper Base.pcl'))</filename></parcel-loaded><component-created><name>RBDynamicRefactorings</name> <type>package</type></component-created><parcel-loaded><name>RBDynamicRefactorings</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'RBDynamicRefactorings.pcl'))</filename></parcel-loaded><component-created><name>RBDynamicRefactoringUI</name> <type>package</type></component-created><parcel-loaded><name>RBDynamicRefactoringUI</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'RBDynamicRefactoringUI.pcl'))</filename></parcel-loaded><component-created><name>RBPrimitivesBrowsing</name> <type>package</type></component-created><parcel-loaded><name>RBPrimitivesBrowsing</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'RBPrimitivesBrowsing.pcl'))</filename></parcel-loaded><component-created><name>BlockIndent</name> <type>package</type></component-created><parcel-loaded><name>BlockIndent</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'BlockIndent.pcl'))</filename></parcel-loaded><component_selector_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.UI.TextEditorController</definitionName> <meta>false</meta> <selector>normalCharacterKey:</selector> <definitionChange>removed</definitionChange></component_selector_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.SymbolTableSearch</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>SymbolTableSearch</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>SymbolTableSearch</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.NoMatch</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NoMatch</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NoMatch</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.BehaviorSelectorSearch</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>BehaviorSelectorSearch</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>BehaviorSelectorSearch</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.ParagraphSearch</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ParagraphSearch</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ParagraphSearch</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.InstanceVariableSearch</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>InstanceVariableSearch</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>InstanceVariableSearch</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.MenuEventDispatcherWithKeyboard</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>MenuEventDispatcherWithKeyboard</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>MenuEventDispatcherWithKeyboard</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.MultiMatch</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>MultiMatch</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>MultiMatch</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.SingleMatch</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>SingleMatch</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>SingleMatch</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.Match</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Match</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Match</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.CompositeWordSearch</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>CompositeWordSearch</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>CompositeWordSearch</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AutoComplete.Search</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Search</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Search</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>AutoComplete</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>AutoComplete</staticKey> <definitionChange>added</definitionChange></component_static_change><component_definition_change><name>AutoComplete</name> <type>parcel</type><definitionName>Root.Smalltalk.AnObsoleteAutoComplete</definitionName> <definitionChange>removed</definitionChange></component_definition_change><component-unloaded><name>AutoComplete</name> <type>parcel</type></component-unloaded><component-unloaded><name>AutoComplete</name> <type>package</type></component-unloaded><component-created><name>AutoComplete</name> <type>package</type></component-created><parcel-loaded><name>AutoComplete</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'contributed' 'AutoComplete.pcl'))</filename></parcel-loaded><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 11, 2014' '2:33:18 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 2:33:18 PM on February 11, 2014."</do-it><component-created><name>CS474</name> <type>package</type></component-created><component-property><name>CS474</name> <type>package</type><property>notice</property> <value>'None.'</value></component-property><component-property><name>CS474</name> <type>package</type><property>comment</property> <value>'Package for CS 474 Homework'</value></component-property><class><name>BSTNode</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><class><name>BST</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><comment><class-id>BST</class-id><body>Encapsulates a binary search tree.Instance Variables	root	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	The binary search tree data structure</body></comment><class><name>UserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>s1 s2 input </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>BSTNode class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^super new initialize</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="=">= t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^self value = t1 value</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="~=">~= t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^self value ~= t1 value</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&lt;">&lt; t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^self value &lt; t1 value</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&lt;=">&lt;= t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^self value &lt;= t1 value</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&gt;=">&gt;= t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^self value &gt;= t1 value</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&gt;">&gt; t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^self value &gt; t1 value</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="max">max	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t1 |	right isNil		ifTrue: [t1 := value]		ifFalse: [t1 := right max].	^t1</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="contains:">contains: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t2 |	t2 := false.	value = t1		ifTrue: [t2 := true]		ifFalse: 			[(value &lt; t1 and: [left isNil not])				ifTrue: [t2 := left contains: t1].			(value &gt; t1 and: [right isNil not])				ifTrue: [t2 := right contains: t1]].	^t2</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right:">right: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	right := t1.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="min">min	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t1 |	left isNil		ifTrue: [t1 := value]		ifFalse: [t1 := left min].	^t1</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left:">left: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	left := t1.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="hasChildren">hasChildren	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	left isNil not ifTrue: [^true].	^right isNil not</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right">right	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^right</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="value">value	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^value</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="value:">value: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	value := t1.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left">left	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^left</body></methods><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="copy">copy	| temp |	(temp := BSTNode new) value: self value.	self left = nil ifFalse: [temp left: left copy].	self right = nil ifFalse: [temp right: right copy].	^temp</body></methods><methods><class-id>BSTNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	super initialize.	left := nil.	right := nil.	value := nil.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t2 |	t2 := self.	value = t1		ifTrue: [self hasChildren				ifTrue: [left isNil						ifTrue: [t2 := right]						ifFalse: 							[value := left max.							left := left remove: value]]				ifFalse: [t2 := nil]]		ifFalse: [t1 &lt; value				ifTrue: [left isNil ifFalse: [left := left remove: t1]]				ifFalse: [right isNil ifFalse: [right := right remove: t1]]].	^t2</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="do:">do: aBlock	left isNil ifFalse: [left do: aBlock].	aBlock value: (self value).	right isNil ifFalse: [right do: aBlock].	^self</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="add:">add: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t2 |	t2 := nil.	t1 = value ifFalse: [t1 &lt; value			ifTrue: [left isNil					ifTrue: 						[(t2 := BSTNode new) value: t1.						left := t2]					ifFalse: [left add: t1]]			ifFalse: [right isNil					ifTrue: 						[(t2 := BSTNode new) value: t1.						right := t2]					ifFalse: [right add: t1]]].	^t2</body></methods><methods><class-id>BSTNode</class-id> <category>printing</category><body package="CS474" selector="printString">printString	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t1 |	t1 := String new.	left isNil not ifTrue: [t1 := left printString].	t1 := t1 , value printString , ' '.	right isNil not ifTrue: [t1 := t1 , right printString].	^t1</body></methods><methods><class-id>BST class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copy:">copy: anotherBST	root := anotherBST root copy.	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject	root isNil ifFalse: [root := root remove: anObject].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="add:">add: anObject	root isNil		ifTrue: 			[root := BSTNode new.			root value: anObject]		ifFalse: [root add: anObject].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="swap:">swap: anotherBST	| temp |	temp := root.	root := anotherBST root.	anotherBST root: temp.	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="clear">clear	root := nil.	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[temp := self copy.			anotherBST root do: [:value | temp remove: value].			temp root do: [:value | self remove: value]].	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="map:">map: aBlock	| temp |	root isNil		ifFalse: 			[temp := BST new.			root do: [:x | temp add: (aBlock value: x)].			root := temp].	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="union:">union: anotherBST	anotherBST root isNil		ifFalse: [anotherBST root do: [:value | self add: value]].	^self</body></methods><methods><class-id>BST</class-id> <category>printing</category><body package="CS474" selector="printString">printString	root isNil ifTrue: [^''].	^root printString</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="root">root	^root</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="root:">root: anObject	root := anObject</body></methods><methods><class-id>BST</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	root := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 672 318 1248 762 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#model: #s1 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#model: #s2 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="union">union	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="intersection">intersection	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	s1 := input value.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="remove">remove	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="clear">clear	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="save">save	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="switch">switch	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>UserInterface</class-id> <category>aspects</category><body package="CS474" selector="s1">s1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^s1 isNil		ifTrue:			[s1 := String new asValue]		ifFalse:			[s1]</body></methods><methods><class-id>UserInterface</class-id> <category>aspects</category><body package="CS474" selector="input">input	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^input isNil		ifTrue:			[input := String new asValue]		ifFalse:			[input]</body></methods><methods><class-id>UserInterface</class-id> <category>aspects</category><body package="CS474" selector="s2">s2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^s2 isNil		ifTrue:			[s2 := String new asValue]		ifFalse:			[s2]</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 672 318 1248 762 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#model: #s1 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#model: #s2 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 672 318 1248 762 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s1 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s2 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 672 318 1248 762 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s1 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s2 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 672 318 1248 762 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s1 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	s1 value: (input value).	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s1 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	s1 value: (input value).	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>new</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>new</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	(s1 isNil) ifTrue: [s1 := BST new.].	s1 add: (input value asNumber).	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s1 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	(s1 class = BST) ifFalse: [s1 := BST new.].	s1 add: (input value asNumber).	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s1 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #s2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>s1</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>s1</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>UserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftView s2 input </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	(leftView class = BST) ifFalse: [leftView := BST new.].	leftView add: (input value asNumber).	^self</body></methods><methods><class-id>UserInterface</class-id> <category>aspects</category><body package="CS474" selector="s1">s1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leftView isNil		ifTrue:			[leftView := String new asValue]		ifFalse:			[leftView]</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>s2</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>s2</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>UserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftView rightView input </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>UserInterface</class-id> <category>aspects</category><body package="CS474" selector="s2">s2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^rightView isNil		ifTrue:			[rightView := String new asValue]		ifFalse:			[rightView]</body></methods><class><name>UserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftView rightView input s1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><class><name>UserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftView rightView input s1 s2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	(s1 isNil) ifTrue: [s1 := BST new.].	leftView value: (s1 printString).	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><class><name>UserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftView rightView input s1 s2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #UserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'leftView rightView input s1 s2  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserInterface</class-id> <category>aspects</category><body package="CS474" selector="leftView">leftView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leftView isNil		ifTrue:			[leftView := String new asValue]		ifFalse:			[leftView]</body></methods><class><name>UserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftView rightView input s1 s2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #UserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'leftView rightView input s1 s2  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserInterface</class-id> <category>aspects</category><body package="CS474" selector="rightView">rightView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^rightView isNil		ifTrue:			[rightView := String new asValue]		ifFalse:			[rightView]</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><do-it>UserInterface organization addCategory: #'initialize-release'</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>initialize</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>initialize</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>UserInterface</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	s1 := BST new.	s2 := BST new.	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><remove-selector><class-id>UserInterface</class-id> <selector>s1</selector></remove-selector><remove-selector><class-id>UserInterface</class-id> <selector>s2</selector></remove-selector><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	(s1 isNil) ifTrue: [s1 := BST new].	s1 add: (input value asNumber).	leftView value: (s1 printString).	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="clear">clear	"This stub method was generated by UIDefiner"	s1 = BST new.	leftView = String new.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="clear">clear	"This stub method was generated by UIDefiner"	s1 = BST new.	leftView value: (String new).	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="clear">clear	"This stub method was generated by UIDefiner"	s1 := BST new.	leftView value: (String new).	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>printString</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>printString</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	leftView value: (s1 printString).	rightView value: (s2 printString).	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="remove">remove	"This stub method was generated by UIDefiner"		^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>value</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>value</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="remove">remove	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new] ifFalse: [s1 remove: input value].	leftView value: (s1 printString).	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="remove">remove	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new] ifFalse: [s1 remove: (input value asNumber)].	leftView value: (s1 printString).	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>copy</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>copy</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="save">save	"This stub method was generated by UIDefiner"	(s1 isNil) ifTrue: [s1 := BST new].	s2 := s1 copy.	leftView value: (s1 printString).	rightView value: (s2 printString).	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>temp</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>temp</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="switch">switch	"This stub method was generated by UIDefiner"	| temp |	temp := s1.	s1 := s2.	s2 := temp.	leftView value: (s1 printString).	rightView value: (s1 printString).	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="switch">switch	"This stub method was generated by UIDefiner"	| temp |	temp := s1.	s1 := s2.	s2 := temp.	leftView value: s1 printString.	rightView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="switch">switch	"This stub method was generated by UIDefiner"	| temp |	(s1 isNil) ifTrue: [s1 := BST new.].	(s2 isNil) ifTrue: [s2 := BST new.].	temp := s1.	s1 := s2.	s2 := temp.	leftView value: s1 printString.	rightView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="switch">switch	"This stub method was generated by UIDefiner"	| temp |	(s1 isNil) ifTrue: [s1 := BST new.].	(s2 isNil) ifTrue: [s2 := BST new.].	temp := s1.	s1 := s2.	s2 := temp.	leftView value: s1 printString.	rightView value: s2 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="intersection">intersection	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new].	s2 isNil ifTrue: [s2 := BST new].	s1 := s1 intersection: s2.	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="union">union	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new].	s2 isNil ifTrue: [s2 := BST new].	s1 := s1 union: s2.	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 695 327 1271 771 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 12, 2014' '8:56:47 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 8:56:47 PM on February 12, 2014."</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ifFalse</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ifFalse</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := self copy.					anotherBST root do: [:value | temp remove: value].					temp root do: [:value | self remove: value]]].	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := self copy.					anotherBST root do: [:value | temp remove: value].					temp isNil ifFalse: [temp root do: [:value | self remove: value]]]].	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := self copy.					anotherBST root do: [:value | temp remove: value].					temp root isNil ifFalse: [temp root do: [:value | self remove: value]]]].	^self</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 15, 2014' '12:55:10 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 12:55:10 PM on February 15, 2014."</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>updated</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>updated</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>anObject</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>anObject</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>instance</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>instance</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BST class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new: anObject	"Answer a newly created and initialized instance."	| temp |	temp := super new initialize.	temp value: anObject.	^temp</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="add:">add: anObject	root isNil		ifTrue: [root := BSTNode new: anObject]		ifFalse: [root add: anObject].	^self</body></methods><methods><class-id>BST class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new: anObject	"Answer a newly created and initialized instance."	^super new initialize.</body></methods><remove-selector><class-id>BST class</class-id> <selector>new:</selector></remove-selector><methods><class-id>BSTNode class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new: anObject	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^super new initialize value: anObject</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="add:">add: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t2 |	t2 := nil.	t1 = value ifFalse: [t1 &lt; value			ifTrue: [left isNil					ifTrue: 						[t2 := BSTNode new: t1.						left := t2]					ifFalse: [left add: t1]]			ifFalse: [right isNil					ifTrue: 						[(t2 := BSTNode new) value: t1.						right := t2]					ifFalse: [right add: t1]]].	^t2</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="add:">add: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t2 |	t2 := nil.	t1 = value ifFalse: [t1 &lt; value			ifTrue: [left isNil					ifTrue: 						[t2 := BSTNode new: t1.						left := t2]					ifFalse: [left add: t1]]			ifFalse: [right isNil					ifTrue: 						[t2 := BSTNode new:  t1.						right := t2]					ifFalse: [right add: t1]]].	^t2</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="add:">add: t1	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t2 |	t2 := nil.	t1 = value		ifFalse: 			[t1 &lt; value				ifTrue: 					[left isNil						ifTrue: 							[t2 := BSTNode new: t1.							left := t2]						ifFalse: [left add: t1]]				ifFalse: 					[right isNil						ifTrue: 							[t2 := BSTNode new: t1.							right := t2]						ifFalse: [right add: t1]]].	^t2</body></methods><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="copy">copy	| temp |	temp := BSTNode new: self value.	self left = nil ifFalse: [temp left: left copy].	self right = nil ifFalse: [temp right: right copy].	^temp</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="hasChildren">hasChildren	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."		^left isNil not or: [right isNil not]</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="contains:">contains: t1	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t2 |	t2 := false.	value = t1		ifTrue: [t2 := true]		ifFalse: 			[(value &lt; t1 and: [left isNil not]) ifTrue: [t2 := left contains: t1].			(value &gt; t1 and: [right isNil not]) ifTrue: [t2 := right contains: t1]].	^t2</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| temp |	temp := self.	value = t1		ifTrue: [self hasChildren				ifTrue: [left isNil						ifTrue: [temp := right]						ifFalse: 							[value := left max.							left := left remove: value]]				ifFalse: [temp := nil]]		ifFalse: [t1 &lt; value				ifTrue: [left isNil ifFalse: [left := left remove: t1]]				ifFalse: [right isNil ifFalse: [right := right remove: t1]]].	^temp</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| temp |	temp := self.	value = anObject		ifTrue: [self hasChildren				ifTrue: [left isNil						ifTrue: [temp := right]						ifFalse: 							[value := left max.							left := left remove: value]]				ifFalse: [temp := nil]]		ifFalse: [anObject &lt; value				ifTrue: [left isNil ifFalse: [left := left remove: anObject]]				ifFalse: [right isNil ifFalse: [right := right remove: anObject]]].	^temp</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| temp |	temp := self.	value = anObject		ifTrue: 			[self hasChildren				ifTrue: 					[left isNil						ifTrue: [temp := right]						ifFalse: 							[value := left max.							left := left remove: value]]				ifFalse: [temp := nil]]		ifFalse: 			[anObject &lt; value				ifTrue: [left isNil ifFalse: [left := left remove: anObject]]				ifFalse: [right isNil ifFalse: [right := right remove: anObject]]].	^temp</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := self copy.					anotherBST root do: [:value | temp remove: value].					(temp root isNil) ifFalse: [temp root do: [:value | self remove: value]]]].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="intersection">intersection	"This stub method was generated by UIDefiner"	s1 isNil		ifFalse: 			[s1 := s1 intersection: s2.			leftView value: s1 printString].	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>right</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>right</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| temp |	temp := self.	value = anObject		ifTrue: 			[left isNil				ifTrue: [temp := right]				ifFalse: 					[value := left max.					left := left remove: value]]		ifFalse: 			[anObject &lt; value				ifTrue: [left isNil ifFalse: [left := left remove: anObject]]				ifFalse: [right isNil ifFalse: [right := right remove: anObject]]].	^temp</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [s1 map: input].	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="map:">map: aBlock	| temp |	root isNil		ifFalse: 			[temp := BST new.			root do: [:x | temp add: (aBlock value: x)].			root := temp].	^self</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="add:">add: t1	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| temp |	temp:= nil.	t1 = value		ifFalse: 			[t1 &lt; value				ifTrue: 					[left isNil						ifTrue: 							[temp := BSTNode new: t1.							left := temp]						ifFalse: [left add: t1]]				ifFalse: 					[right isNil						ifTrue: 							[temp := BSTNode new: t1.							right := temp]						ifFalse: [right add: t1]]].	^temp</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="add:">add: anObject	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| temp |	temp:= nil.	anObject = value		ifFalse: 			[anObject &lt; value				ifTrue: 					[left isNil						ifTrue: 							[temp := BSTNode new: anObject.							left := temp]						ifFalse: [left add: anObject]]				ifFalse: 					[right isNil						ifTrue: 							[temp := BSTNode new: anObject.							right := temp]						ifFalse: [right add: anObject]]].	^temp</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="add:">add: anObject	| temp |	temp := nil.	anObject = value		ifFalse: 			[anObject &lt; value				ifTrue: 					[left isNil						ifTrue: 							[temp := BSTNode new: anObject.							left := temp]						ifFalse: [left add: anObject]]				ifFalse: 					[right isNil						ifTrue: 							[temp := BSTNode new: anObject.							right := temp]						ifFalse: [right add: anObject]]].	^temp</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 672 318 1248 762 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 10 22 275 259 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true 					#type: #text ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true 					#type: #text ) ) ) )</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 1; add: 2; add: 3; yourself.^a</do-it><do-it>| a b |a := BST new.b := BST new.a add: 1; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; yourself.^b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 1; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; yourself.^a intersection: b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b </do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := self copy.					anotherBST root do: [:value | temp remove: value].					(temp root isNil) ifFalse: [temp root do: [:value | self remove: value]]]].	^temp</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := anotherBST copy.					 root do: [:value | temp remove: value].					(temp root isNil) ifFalse: [temp root do: [:value | self remove: value]]]].	^temp</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := anotherBST copy.					root do: [:value | temp remove: value].					temp root isNil ifFalse: [temp root do: [:value | self remove: value]]]].	^self</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a remove: 0</do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := anotherBST copy.					root do: [:value | temp remove: value].					temp root isNil						ifFalse: 							[temp root do: [:value | self remove: value].							root := temp]]].	^self</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 18, 2014' '3:33:21 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 3:33:21 PM on February 18, 2014."</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := anotherBST copy.					root do: [:value | temp remove: value].					temp root isNil						ifFalse: 							[temp root do: [:value | self remove: value].							root := temp root]]].	^self</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := anotherBST copy.					root do: [:value | temp remove: value].					temp root isNil ifFalse: [temp root do: [:value | self remove: value]]]].	^self</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := anotherBST copy.					root do: [:value | temp remove: value].					temp root isNil ifFalse: [temp root do: [:value | self remove: value]]]].	Transcript show: root printString.	^self</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := anotherBST copy.					root do: [:value | temp remove: value].					temp root isNil ifFalse: [temp root do: [:value | self remove: value]]]].	Transcript show: root printString.	^self</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^b intersection: a</do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := root copy.					root do: [:value | temp remove: value].					temp root isNil ifFalse: [temp root do: [:value | self remove: value]]]].	Transcript show: root printString.	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := (root copy).					root do: [:value | temp remove: value].					temp root isNil ifFalse: [temp root do: [:value | self remove: value]]]].	Transcript show: root printString.	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := (root copy).					root do: [:value | temp remove: value].					temp isNil ifFalse: [temp root do: [:value | self remove: value]]]].	Transcript show: root printString.	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := (root copy).					root do: [:value | temp remove: value].					temp isNil ifFalse: [temp do: [:value | self remove: value]]]].	Transcript show: root printString.	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	anotherBST root isNil		ifTrue: [root := nil]		ifFalse: 			[root isNil				ifFalse: 					[temp := self copy.					root do: [:value | temp remove: value].					temp root isNil ifFalse: [temp do: [:value | self remove: value]]]].	Transcript show: root printString.	^self</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>anotherBST</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>anotherBST</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copy:">copy: anotherBST		| temp |	temp := BST new.	temp root: anotherBST root copy.	^temp</body></methods><methods><class-id>BST</class-id> <category>copying</category><body package="CS474" selector="copy">copy		| temp |	temp := BST new.	temp root: root copy.	^temp</body></methods><methods><class-id>BST</class-id> <category>copying</category><body package="CS474" selector="copy">copy		| temp |	temp := BST new.	temp root: (root copy).	^temp</body></methods><methods><class-id>BST</class-id> <category>copying</category><body package="CS474" selector="copy">copy	| temp |	temp := BST new.	temp root: root copy.	^temp</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copy">copy		^ BST new root: root copy.</body></methods><remove-selector><class-id>BST</class-id> <selector>copy:</selector></remove-selector><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a intersection: b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b add: 2; add: 1; add: 3; add: 4 yourself.^a := b copy.</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b := a copy.b add: 5.^ b</do-it><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="copy">copy	| temp |	temp := BSTNode new: self value.	left isNil ifFalse: [temp left: left copy].	right isNil ifFalse: [temp right: right copy].	^temp</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b := a copy.b add: 5.^ b</do-it><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject	| temp |	temp := self.	value = anObject		ifTrue: 			[left isNil				ifTrue: [temp := right]				ifFalse: 					[value := left max.					left := left remove: value]]		ifFalse: 			[anObject &lt; value				ifTrue: [left isNil ifFalse: [left := left remove: anObject]]				ifFalse: [right isNil ifFalse: [right := right remove: anObject]]].	^temp</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	temp := anotherBST copy.	root do: [:value | temp remove: value].	temp root isNil ifFalse: [temp do: [:value | self remove: value]].	Transcript show: root printString.	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>aBlock</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>aBlock</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="do:">do: aBlock	root isNil ifFalse: [ root do: aBlock].	^self </body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	temp := self copy.	anotherBST do: [:value | temp remove: value].	temp do: [:value | self remove: value].	Transcript show: root printString.	^self</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b := a copy.b add: 5.^ b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b := a copy.b add: 5.^ a intersection: b</do-it><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b := a copy.a add: 1.b add: 5.^ a intersection: b</do-it><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	temp := self copy.	anotherBST do: [:value | temp remove: value].	temp do: [:value | self remove: value].	^self</body></methods><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.b := a copy.a add: 1.b add: 5.^ b intersection: a</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>input</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>input</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [s1 map: input].		^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [s1 map: input].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [s1 map: (BlockClosure readFromString: input)].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [s1 map: (BlockClosure readFromString: input printString)].	leftView value: s1 printString.	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>a</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>a</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>| a b |a := BST new.b := BST new.a add: 0; add: 2; add: 3; yourself.^ a map: [ :x | x * 2]</do-it><do-it>| a b |a := BST new.a add: 0; add: 2; add: 3; yourself.b := BlockClosure readFromString: '[ :x | x * 2]'.^ a map: b</do-it><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aBlock |	aBlock :=BlockClosure readFromString: input printString.	s1 isNil ifFalse: [s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aBlock |	aBlock :=BlockClosure readFromString: (input printString).	s1 isNil ifFalse: [s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="remove">remove	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new] ifFalse: [s1 remove: input value asNumber].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="switch">switch	"This stub method was generated by UIDefiner"	| temp |	s1 isNil ifTrue: [s1 := BST new].	s2 isNil ifTrue: [s2 := BST new].	temp := s1.	s1 := s2.	s2 := temp.	leftView value: s1 printString.	rightView value: s2 printString.	^self</body></methods><do-it>| a b |a := BST new.a add: 0; add: 2; add: 3; yourself.b := BlockClosure readFromString: '[ :x | x * 2]'.^ a map: b</do-it><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aBlock |	aBlock :=BlockClosure readFromString: (input printString).	s1 isNil ifFalse: [s1 := s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><do-it>| a b |a := BST new.a add: 0; add: 2; add: 3; yourself.b := BlockClosure readFromString: '[ :x | x * 2]'.^ a map: b</do-it><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aString aBlock |	aString := input printString.	aBlock :=BlockClosure readFromString: aString.	s1 isNil ifFalse: [s1 := s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aString aBlock |	aString := input printString.	aBlock :=BlockClosure readFromString: aString.	s1 isNil ifFalse: [s1 := s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aString aBlock |	aString := input printString.	Transcript put: 'blah'.	aBlock :=BlockClosure readFromString: aString.	s1 isNil ifFalse: [s1 := s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><do-it>Transcript</do-it><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aString aBlock |	aString := input printString.	Transcript print: 'blah'.	aBlock :=BlockClosure readFromString: aString.	s1 isNil ifFalse: [s1 := s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aString aBlock |	aString := input printString.	Transcript print: aString.	aBlock :=BlockClosure readFromString: aString.	s1 isNil ifFalse: [s1 := s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aString aBlock |	aString := input.	Transcript print: aString.	aBlock :=BlockClosure readFromString: aString.	s1 isNil ifFalse: [s1 := s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aString aBlock |	aString := input value.	Transcript print: aString.	aBlock :=BlockClosure readFromString: aString.	s1 isNil ifFalse: [s1 := s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	| aBlock |	aBlock :=BlockClosure readFromString: input value.	s1 isNil ifFalse: [s1 := s1 map: aBlock].	leftView value: s1 printString.	^self</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 18, 2014' '4:47:17 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 4:47:17 PM on February 18, 2014."</do-it><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'First Smalltalk Project' 			#bounds: #(#{Graphics.Rectangle} 672 318 1248 762 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 3 ) 					#name: #Label1 					#flags: 8 					#label: 'S1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 296 5 ) 					#name: #Label2 					#flags: 8 					#label: 'S2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 285 273 342 292 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 356 272.5 413 292.5 ) 					#name: #ActionButton2 					#model: #display 					#label: 'Display' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 248 359 305 379 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 150 359 207 379 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 145 272.5 202 292.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 216 272.5 273 292.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: 'Switch' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 346 359 403 379 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 209 393 266 413 ) 					#name: #ActionButton8 					#model: #union 					#label: 'Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 282 393 339 413 ) 					#name: #ActionButton9 					#model: #intersection 					#label: 'Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 163 324 393 352 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 284 22 549 259 ) 					#name: #InputField3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #s1 ) 					#tabable: false 					#isReadOnly: true 					#type: #text ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 22 0 275 0 259 0 ) 					#name: #InputField2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#tabable: false 					#isReadOnly: true 					#type: #text ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 465 343 565 442 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#bounds: #(#{Graphics.Rectangle} 849 346 1425 790 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 351 167 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 69 371 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 208 351 265 371 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><class><name>UserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftView rightView input s1 s2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #UserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'leftView rightView input s1 s2  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserInterface</class-id> <category>aspects</category><body package="CS474" selector="leftView">leftView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^leftView isNil		ifTrue:			[leftView := ((Text2.Document new: 0)) asValue]		ifFalse:			[leftView]</body></methods><methods><class-id>UserInterface</class-id> <category>aspects</category><body package="CS474" selector="rightView">rightView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^rightView isNil		ifTrue:			[rightView := ((Text2.Document new: 0)) asValue]		ifFalse:			[rightView]</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#bounds: #(#{Graphics.Rectangle} 848 346 1424 790 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 351 167 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 69 371 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 208 351 265 371 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#min: #(#{Core.Point} 685 400 ) 			#max: #(#{Core.Point} 685 400 ) 			#bounds: #(#{Graphics.Rectangle} 837 405 1522 805 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 102 351 182 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 92 370 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 191 351 271 370 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>x</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>x</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 19, 2014' '9:52:04 AM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 9:52:04 AM on February 19, 2014."</do-it><do-it>UserInterface organization addCategory: #'user interface'</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>showDisplay</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>showDisplay</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>UserInterface</class-id> <category>user interface</category><body package="CS474" selector="showDisplay">showDisplay	s1 isNil ifFalse: [leftView value: s1 printString].	s2 isNil ifFalse: [rightView value: s2 printString].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	(s1 isNil) ifTrue: [s1 := BST new].	s1 add: (input value asNumber).	self showDisplay.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="clear">clear	"This stub method was generated by UIDefiner"	s1 := BST new.	self showDisplay.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	(s1 isNil) ifTrue: [s1 := BST new].	s1 add: (input value asNumber).	self display.	^self</body></methods><remove-selector><class-id>UserInterface</class-id> <selector>showDisplay</selector></remove-selector><do-it>UserInterface organization removeCategory: #'user interface'</do-it><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [leftView value: s1 printString].	s2 isNil ifFalse: [rightView value: s2 printString].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="clear">clear	"This stub method was generated by UIDefiner"	s1 := BST new.	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	(s1 isNil) ifTrue: [s1 := BST new].	s1 add: (input value asNumber).	"self display."	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#min: #(#{Core.Point} 685 400 ) 			#max: #(#{Core.Point} 685 400 ) 			#bounds: #(#{Graphics.Rectangle} 837 405 1522 805 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 102 351 182 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 92 370 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 191 351 271 370 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	(s1 isNil) ifTrue: [s1 := BST new].	s1 add: (input value asNumber).	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="intersection">intersection	"This stub method was generated by UIDefiner"	s1 isNil		ifFalse: 			[s1 := s1 intersection: s2].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="remove">remove	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new] ifFalse: [s1 remove: input value asNumber].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="remove">remove	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [s1 remove: input value asNumber].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 isNil		ifFalse: [leftView value: s1 printString]		ifTrue: [leftView value: ''].	s2 isNil		ifFalse: [rightView value: s2 printString]		ifTrue: [rightView value: ''].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="clear">clear	"This stub method was generated by UIDefiner"	s1 := nil.	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new].	s1 add: input value asNumber.	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="intersection">intersection	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [s1 := s1 intersection: s2].	self display.	^self</body></methods><do-it>nil copy.</do-it><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="save">save	"This stub method was generated by UIDefiner"	s2 := s1 copy.	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="switch">switch	"This stub method was generated by UIDefiner"	| temp |	temp := s1.	s1 := s2.	s2 := temp.	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 isNil ifFalse: [s1 := s1 map: (BlockClosure readFromString: input value)].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="union">union	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new].	s2 isNil ifTrue: [s2 := BST new].	s1 := s1 union: s2.	BlockClosure readFromString: input value.	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#min: #(#{Core.Point} 685 400 ) 			#max: #(#{Core.Point} 685 400 ) 			#bounds: #(#{Graphics.Rectangle} 838 404 1523 804 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 102 351 182 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 92 370 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 191 351 271 370 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="union">union	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new].	s2 isNil ifTrue: [s2 := BST new].	s1 := s1 union: s2.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="union">union	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := BST new].	s2 isNil ifTrue: [s2 := BST new].	s1 := s1 union: s2.	self display.	^self</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 19, 2014' '12:58:23 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 12:58:23 PM on February 19, 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 19, 2014' '12:58:28 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 12:58:28 PM on February 19, 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 20, 2014' '12:05:57 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 12:05:57 PM on February 20, 2014."</do-it><methods><class-id>BST class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new: value		| temp |	temp := super new initialize.	temp value: value.	^ temp</body></methods><remove-selector><class-id>BST class</class-id> <selector>new:</selector></remove-selector><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 20, 2014' '8:07:56 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 8:07:56 PM on February 20, 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 20, 2014' '8:08:04 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 8:08:04 PM on February 20, 2014."</do-it><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="postCopy">postCopy	left notNil ifTrue: [left :=left copy].	right notNil ifTrue: [right := right copy].	^self </body></methods><methods><class-id>Glorp.Query</class-id> <category>copying</category><body package="GlorpQueries" selector="copyOld">copyOld	^self shallowCopy postCopy.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>copying</category><body package="Store-Database Model" selector="copyOld">copyOld	^self shallowCopy postCopy.</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copyOld">copyOld		^ BST new root: root copy.</body></methods><methods><class-id>Protocols.Struct</class-id> <category>copying</category><body package="Protocols-Common" selector="copyOld">copyOld	^self shallowCopy postCopy</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>copying</category><body package="GlorpCore" selector="copyOld">copyOld	^self shallowCopy postCopy.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions" selector="copyOld">copyOld	| new |	new := super copy.	"We need to make sure we copy these before the base gets set. This is horribly ugly."	new selectListVersion: selectListVersion copy.	new whereClauseVersion: whereClauseVersion copy.	^new.</body></methods><methods><class-id>UI.AssociationTree</class-id> <category>copying</category><body package="UIBasics-Collections" selector="copyOld">copyOld	"Answer another instance just like the receiver, but with a copy of 	the receiver's value and a copy 	of each of the receiver's children."	| cpy tmpChildren |	tmpChildren := children.	children := nil.	cpy := self shallowCopy.	cpy value: value copy.	tmpChildren isNil ifFalse: [tmpChildren do: [:child | cpy addChild: child copy]].	children := tmpChildren.	^cpy</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>actions</category><body package="UIPainter" selector="copyOld">copyOld	| image r newMap |	r := Rectangle			fromUser: magnifiedBitView scale			phase: magnifiedBitView controller sensor globalOrigin.	r extent = (8@8) ifTrue: [^self].	(self apertureIntersectsWithScreenRectangle: r) ifFalse: [^self].	r := self modelRegionFromScreenRegion: r.	image := magnifiedBitView model.	newMap :=		Image			extent: r extent			depth: image depth			bitsPerPixel: image bitsPerPixel			palette: image palette.	newMap		copy: (Rectangle origin: 0 @ 0 corner: r extent)		from: r origin		in: image		rule: RasterOp paint.	self pasteBuffer: newMap</body></methods><methods><class-id>Core.Symbol</class-id> <category>copying</category><body package="Collections-Text" selector="copyOld">copyOld	"Answer the receiver, because Symbols are unique."	^self</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="copyOld">copyOld	"Prevent the baseTable and composeTable from being corrupted if	more than one DispatchTable are sharing them"	shared := true.	^super copy</body></methods><methods><class-id>Graphics.CharacterBlock</class-id> <category>copying</category><body package="Graphics-Text Support" selector="copyOld">copyOld	"Answer another instance just like the receiver."	^self shallowCopy</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>copying</category><body package="GlorpQueries" selector="copyOld">copyOld	^self shallowCopy postCopy.</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="Debugger-Probes" selector="copyOld">copyOld	^self class registerMethod: super copy.</body></methods><methods><class-id>Text2.Document</class-id> <category>copying</category><body package="Graphics-Text2-Document" selector="copyOld">copyOld	"Make a copy of the receiver."	^self copyBetween: 0 and: size</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>copying</category><body package="Store-Database Model" selector="copyOld">copyOld	^self glorpCopyIn: IdentityDictionary new.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>copying</category><body package="GlorpQueries" selector="copyOld">copyOld	^self shallowCopy postCopy.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>copying</category><body package="GlorpQueries" selector="copyOld">copyOld	^self shallowCopy postCopy.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>copying</category><body package="GlorpDatabase" selector="copyOld">copyOld	^self shallowCopy postCopy.</body></methods><methods><class-id>Security.HMAC</class-id> <category>services-basic</category><body package="HashesBase" selector="copyOld">copyOld"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self class new		setIHash: ihash copy		oHash: ohash copy		iPad: ipad copy		oPad: opad copy;		yourself</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>commands</category><body package="Debugger-UI" selector="copyOld">copyOld	buffer := selection value copy.</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="Kernel-Objects" selector="copyOld">copyOld	" Answer another instance just like the receiver.	Subclasses normally override the postCopy	message, but some objects that should not be	copied override copy. "	^self shallowCopy postCopy</body></methods><methods><class-id>Security.MessageDigest</class-id> <category>services-basic</category><body package="HashesBase" selector="copyOld">copyOld"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self subclassResponsibility</body></methods><methods><class-id>Security.Hash</class-id> <category>services-basic</category><body package="HashesBase" selector="copyOld">copyOld"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	| new |	new := self class new.	new restoreRegisters: self backupRegisters.	new restoreBuffer: block total: total position: position.	^new</body></methods><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="copyOld">copyOld	| temp |	temp := BSTNode new: self value.	left isNil ifFalse: [temp left: left copy].	right isNil ifFalse: [temp right: right copy].	^temp</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>compiling</category><body package="Atomic Compiling and Loading" selector="augment:usingBehaviorCompiler:">augment: shadowClass usingBehaviorCompiler: compiler		| newMethod |	newMethod := (Behavior compiledMethodAt: #compilerClass) copyOld.	newMethod		at: 1		put: (ValueHolder new value: compiler).	shadowClass replaceMethodAt: #compilerClass withMethod: newMethod</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>compiling</category><body package="Atomic Compiling and Loading" selector="compilerMethodInShadow:orRealClassDefinesCompiler:">compilerMethodInShadow: aShadowClassOrMetaClass orRealClassDefinesCompiler: aClassOrMetaClass	| compilerMethod |	aShadowClassOrMetaClass ifNotNil: 		[aShadowClassOrMetaClass instanceBehavior == Object ifFalse:			[compilerMethod := aShadowClassOrMetaClass isMeta				ifTrue: [(aShadowClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aShadowClassOrMetaClass compiledMethodAt: #classCompilerClass) copyOld]]				ifFalse: [(aShadowClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aShadowClassOrMetaClass class compiledMethodAt: #compilerClass) copyOld]]]].	compilerMethod ifNotNil: [^compilerMethod].	aClassOrMetaClass ifNil: [^nil].	^aClassOrMetaClass isMeta		ifTrue: [(aClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aClassOrMetaClass compiledMethodAt: #classCompilerClass) copyOld]]		ifFalse: [(aClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aClassOrMetaClass class compiledMethodAt: #compilerClass) copyOld]].</body></methods><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="copyOld">copyOld	| temp |	temp := BSTNode new: self value.	left isNil ifFalse: [temp left: left copyOld].	right isNil ifFalse: [temp right: right copyOld].	^temp</body></methods><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="postCopy">postCopy	left notNil ifTrue: [left :=left copyOld].	right notNil ifTrue: [right := right copyOld].	^self </body></methods><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="copy">copy	| temp |	temp := BSTNode new: self value.	left isNil ifFalse: [temp left: left copyOld].	right isNil ifFalse: [temp right: right copyOld].	^temp</body></methods><methods><class-id>UI.LabeledBooleanView</class-id> <category>display box accessing</category><body package="UIBasics-Components" selector="preferredBounds">preferredBounds	"Compute the preferredBounds for the receiver"	| imageOff imageOn labelOff labelOn |	imageOff := offImage isNil ifTrue: [0@0] ifFalse: [offImage preferredBounds extent].	imageOn := onImage isNil ifTrue: [0@0] ifFalse: [onImage preferredBounds extent].	labelOff := (ComposedText withText: label style: LabelStyle) preferredBounds extent.	labelOn := (ComposedText withText: label asText copyOld allBold style: LabelStyle) preferredBounds extent.	^Rectangle		origin: 0 @ 0		corner:			(imageOff x + labelOff x max: imageOn x + labelOn x) + 4 @			((imageOff y max: labelOff y) max: (imageOn y max: labelOn y))</body></methods><methods><class-id>UI.MotifMenuView</class-id> <category>displaying-privileged</category><body package="UILooks-Motif" selector="displayBeveledBorderOn:in:">displayBeveledBorderOn: aGraphicsContext in: aRectangle	"Display a Motif style raised beveled border (XmSHADOW_OUT) on aGraphicsContext inside aRectangle using the appropriate colors."	| borderPart |	borderPart := aRectangle copyOld.	aGraphicsContext paint: self hiliteColor.	borderPart right: borderPart left + 2.	aGraphicsContext displayRectangle: borderPart.	borderPart right: aRectangle right.	borderPart bottom: borderPart top + 2.	aGraphicsContext displayRectangle: borderPart.	aGraphicsContext paint: self shadowColor.	borderPart top: borderPart bottom.	borderPart bottom: aRectangle bottom.	borderPart left: borderPart right - 2.	aGraphicsContext displayRectangle: borderPart.	borderPart top: borderPart top -1.	borderPart bottom: borderPart top + 1.	borderPart left: borderPart left + 1.	aGraphicsContext displayRectangle: borderPart.	borderPart right: borderPart left - 1.	borderPart left: aRectangle left + 2.	borderPart bottom: aRectangle bottom.	borderPart top: borderPart bottom - 2.	aGraphicsContext displayRectangle: borderPart.	borderPart left: borderPart left -1.	borderPart right: borderPart left + 1.	borderPart top: borderPart top + 1.	aGraphicsContext displayRectangle: borderPart</body></methods><methods><class-id>UI.InputFieldView</class-id> <category>accessing</category><body package="UIBasics-Components" selector="editValue">editValue	"Sending this message will result in an error if the receiver contains 	invalid input that cannot be converted into an object of the required 	kind. The message hasEditValue can be sent beforehand to see 	whether or not the input can be converted, and if necessary the	message displayContents can then be sent to access the	text of any malformed input."	| v |	v := displayContents text copyOld.	converter notNil		ifTrue: [v := converter readValueFrom: v].	^v</body></methods><methods><class-id>UI.InputFieldView</class-id> <category>selection</category><body package="UIBasics-Components" selector="placeSelectionPointAt:">placeSelectionPointAt: characterIndex 	"Place the character before the character at position characterIndex.  Make	certain the selection is in the view but does not display any thing (ie. assumes 	no selection is showing).	This is used by the TextEditor during typing"	| delta |	startBlock := self characterBlockForIndex: characterIndex.	stopBlock := startBlock copyOld.	delta := self findSelectionDelta.	delta ~= Point zero		ifTrue: [self scrollBy: delta negated]		ifFalse: [self scrollTo: scrollOffset value].</body></methods><methods><class-id>UI.InputFieldView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayedSizeOf:">displayedSizeOf: aText	"Answer the size of aText based on the current composed text information"	| composedText |	composedText := self displayContents copyOld text: aText.	^composedText width</body></methods><methods><class-id>UI.ComponentSpec</class-id> <category>accessing</category><body package="UIPainter" selector="savableSpecFor:">savableSpecFor: implementationComponent	^self copyOld</body></methods><methods><class-id>UI.ParcelPropertiesInspector</class-id> <category>initialize-release</category><body package="Tools-Misc" selector="inspect:">inspect: aDictionary	"Set anObject to be the object inspected by the receiver.  First remove all the illegal properties"	| acceptable |	acceptable := aDictionary copyOld.	self class illegalPropertyKeys do: 		[ :aKey | acceptable removeKey: aKey ifAbsent: nil ].	^super inspect: acceptable.</body></methods><methods><class-id>UI.InputEditor</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayLinesOn:">displayLinesOn: aGraphicsContext	| clippingBounds gc |	super displayLinesOn: aGraphicsContext.	document isEmpty ifFalse: [^self].	clippingBounds := aGraphicsContext clippingBounds.	gc := aGraphicsContext copyOld.	(Flow device: aGraphicsContext medium graphicsDevice document: self defaultDocument)		linesIntersecting: clippingBounds do: [:line |			gc translation: aGraphicsContext translation + (0 @ line top).			line displayOn: gc selectingBetween: 0 and: 0]</body></methods><methods><class-id>UI.Win98LookPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="menuName">menuName	^(#Win982k &lt;&lt; #menus &gt;&gt; 'Windows 98/2000') copyOld</body></methods><methods><class-id>UI.AlignmentOrigin</class-id> <category>converting</category><body package="UIBasics-Support" selector="reducedForm">reducedForm	"Answer the most reduced form for representing the receiver.  This	includes reducing floats to integers where possible."	| result |	(leftFraction = 0 and: [topFraction = 0])		ifTrue:			[(topAlignmentFraction = 0 and: [leftAlignmentFraction = 0])				ifTrue: [^Point x: left y: top]]		ifFalse:			[(topAlignmentFraction = 0 and: [leftAlignmentFraction = 0])				ifTrue:					[^LayoutOrigin new						leftOffset: left;						leftFraction:							(leftFraction = 0								ifTrue: [0]								ifFalse:									[leftFraction = 1										ifTrue: [1]										ifFalse: [leftFraction]]);						topOffset: top;						topFraction:							(topFraction = 0								ifTrue: [0]								ifFalse:									[topFraction = 1										ifTrue: [1]										ifFalse: [topFraction]]);						yourself]].	result := self copyOld.	leftFraction = 0	ifTrue: [result leftFraction: 0].	topFraction = 0	ifTrue: [result topFraction: 0].	leftAlignmentFraction = 0	ifTrue: [result leftAlignmentFraction: 0].	topAlignmentFraction = 0	ifTrue: [result topAlignmentFraction: 0].	leftFraction = 1	ifTrue: [result leftFraction: 1].	topFraction = 1	ifTrue: [result topFraction: 1].	leftAlignmentFraction = 1	ifTrue: [result leftAlignmentFraction: 1].	topAlignmentFraction = 1	ifTrue: [result topAlignmentFraction: 1].	^result</body></methods><methods><class-id>UI.UIFeelPolicy</class-id> <category>accessing</category><body package="UIBuilder-Support" selector="dispatchTable">dispatchTable	^self keyboard copyOld</body></methods><methods><class-id>UI.UIFeelPolicy</class-id> <category>keyboard Bindings</category><body package="UIBuilder-Support" selector="keyboardDispatchTable">keyboardDispatchTable	"Initialize the keyboard dispatch table."	| k |	k := self keyboard.	k defaultForCharacters: #normalCharacterKey:.	k defaultForNonCharacters: #ignoreInputKey:.	k bindValue: #deleteKey: to: Cut.	k bindValue: #deleteKey: to: #FwdDelete.	k bindValue: #pasteKey: to: Paste.	k bindValue: #backspaceKey: to: BS.	k bindValue: #backWordKey: toCommand: #legacyTextDeletePreviousWord.	self supportsCodeEditing ifTrue: [		k bindValue: #displayIfTrueKey: toCommand: #codeSnippetIfTrue.		k bindValue: #displayIfFalseKey: toCommand: #codeSnippetIfFalse.		k bindValue: #displayColonEqualKey: toCommand: #codeSnippetColonEqual.		k bindValue: #doItOrDisplayDateKey: toCommand: #doIt.		k bindValue: #printItKey: toCommand: #printIt.		k bindValue: #inspectItKey: toCommand: #inspectIt.		k bindValue: #debugItKey: toCommand: #debugIt.		k bindValue: #explainKey: toCommand: #explain	].	k bindValue: #findDialogKey: toCommand: #find.	k bindValue: #findAgainKey: toCommand: #findNext.	k bindValue: #findAgainKey: toCommand: #findPrevious.	k bindValue: #displayDateKey: toCommand: #codeSnippetInsertDate.	k bindValue: #acceptKey: toCommand: #accept.	k bindValue: #selectAllKey: toCommand: #selectAll.	k bindValue: #replaceKey: toCommand: #replace.	k bindValue: #replaceAgainKey: toCommand: #replaceNext.	k bindValue: #cutKey: toCommand: #cut.	k bindValue: #copyKey: toCommand: #copyOld.	k bindValue: #pasteKey: toCommand: #paste.	" WARNING: some implementations of undo overload it to mean redo when shift is down "	k bindValue: #undoKey: toCommand: #undo.	k bindValue: #redoKey: toCommand: #redo.	k bindValue: #selectCurrentTypeInKey: toCommand: #legacyTextSelectCurrentTypeIn.	k bindValue: #displayCRKey: to: #Enter.	k bindValue: #movePreviousByCharacterKey: toCommand: #movePreviousByCharacter.	k bindValue: #selectPreviousByCharacterKey: toCommand: #selectPreviousByCharacter.	k bindValue: #movePreviousByWordKey: toCommand: #movePreviousByWord.	k bindValue: #selectPreviousByWordKey: toCommand: #selectPreviousByWord.	k bindValue: #movePreviousByLineKey: toCommand: #movePreviousByLine.	k bindValue: #selectPreviousByLineKey: toCommand: #selectPreviousByLine.	k bindValue: #movePreviousByPageKey: toCommand: #movePreviousByPage.	k bindValue: #moveNextByCharacterKey: toCommand: #moveNextByCharacter.	k bindValue: #selectNextByCharacterKey: toCommand: #selectNextByCharacter.	k bindValue: #moveNextByWordKey: toCommand: #moveNextByWord.	k bindValue: #selectNextByWordKey: toCommand: #selectNextByWord.	k bindValue: #moveNextByLineKey: toCommand: #moveNextByLine.	k bindValue: #selectNextByLineKey: toCommand: #selectNextByLine.	k bindValue: #moveNextByPageKey: toCommand: #moveNextByPage.	k bindValue: #moveToStartOfLineKey: toCommand: #moveToStartOfLine.	k bindValue: #selectToStartOfLineKey: toCommand: #selectToStartOfLine.	k bindValue: #moveToEndOfLineKey: toCommand: #moveToEndOfLine.	k bindValue: #selectToEndOfLineKey: toCommand: #selectToEndOfLine.	k bindValue: #moveToStartOfDocumentKey: toCommand: #moveToStartOfDocument.	k bindValue: #selectToStartOfDocumentKey: toCommand: #selectToStartOfDocument.	k bindValue: #moveToEndOfDocumentKey: toCommand: #moveToEndOfDocument.	k bindValue: #selectToEndOfDocumentKey: toCommand: #selectToEndOfDocument.	'&lt;''"[{(' do: [:char | k bindValue: #encloseKey: to: ESC followedBy: char].	'sSuUbBiIx+-' do: [:char | k bindValue: #changeEmphasisKey: to: ESC followedBy: char].	self supportsCodeEditing ifTrue: [k bindValue: #miniFormatKey: to: ESC followedBy: $f].	k bindValue: #selectCurrentTypeInKey: to: ESC followedBy: Tab</body></methods><methods><class-id>UI.PluggableAdaptor</class-id> <category>private</category><body package="Interface-Support" selector="renderingValueUsingSubject:">renderingValueUsingSubject: aSubject	| pair cpy cell |	model isProtocolAdaptor ifFalse: [^self valueUsingSubject: aSubject].	cpy := self copyOld.	pair := Array new: 2.	pair at: 2 put: cpy.	cell := cpy makeAdaptorForRenderingStoreLeafInto: pair.	cell first subjectChannel: aSubject asValue.	^cell last value</body></methods><methods><class-id>UI.PluggableAdaptor</class-id> <category>private</category><body package="Interface-Support" selector="makeAdaptorForRenderingStoreLeafInto:">makeAdaptorForRenderingStoreLeafInto: pair	pair at: 1 put: self.	^(model isProtocolAdaptor)		ifTrue: [model := model copyOld.				model makeAdaptorForRenderingStoreLeafInto: pair]		ifFalse: [pair]</body></methods><methods><class-id>UI.Win95MenuFromMenuBarController</class-id> <category>events</category><body package="UILooks-MSWin" selector="viewHasCursorWithEvent:">viewHasCursorWithEvent: event	"Answer true if the cursor point of the receiver's sensor lies within 	the display box and border of the menu item dropdown.	This is farily unique to stacked menus, but it makes standard windows like behavior"	| localSensor adulteratedBounds |	view == nil ifTrue: [^false].	event hasPoint ifFalse: [^false].	localSensor := self sensor.	adulteratedBounds := view bounds copyOld		top: view bounds top - view container border top.	^adulteratedBounds containsPoint: (localSensor cursorPointFor: event)</body></methods><methods><class-id>UI.SequenceView</class-id> <category>private</category><body package="UIBasics-Components" selector="displaySelectedElement:on:forBounds:">displaySelectedElement: index on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component childGC |	component := self selectedVisualComponentForElementIndex: index.	component ifNil: [^self].	component bounds: elementBounds.	childGC := aGraphicsContext copyOld.	childGC lineGrid: self lineGrid.	component displayOn: childGC</body></methods><methods><class-id>UI.SequenceView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayNormalElement:on:forBounds:">displayNormalElement: index on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component childGC |	component := self visualComponentForElementIndex: index.	component ifNil: [^self].	component bounds: elementBounds.	childGC := aGraphicsContext copyOld.	childGC lineGrid: self lineGrid.	component displayOn: childGC</body></methods><methods><class-id>UI.WindowManager</class-id> <category>damage control</category><body package="Interface-Framework" selector="repairDamagesExcept:">repairDamagesExcept: obj	[outstandingMetaOrDamage]		whileTrue: 			[outstandingMetaOrDamage := false.			[windows copyOld do: [:w | w == obj ifFalse: [w checkForEvents]]]					on: ClosedWindowNotification					do: [:ex | ex retry]]</body></methods><methods><class-id>UI.WindowManager class</class-id> <category>modal windows</category><body package="Interface-Framework" selector="modalWindowChain">modalWindowChain	"Answer a copy of the ordered collection of modal windows."	^ModalCollectionLock critical: [ModalWindowChain copyOld]</body></methods><methods><class-id>UI.WindowManager class</class-id> <category>accessing</category><body package="Interface-Framework" selector="managerRegistryDo:">managerRegistryDo: aBlock 	"We do a check for terminate to cleanup registry before we do aBlock."	self managerRegistry copyOld 		do: [:each | each ifNotNil: [each terminateIfEmpty]].	self managerRegistry do: [:each | each ifNotNil: aBlock]</body></methods><methods><class-id>UI.WindowManager class</class-id> <category>private</category><body package="Interface-Framework" selector="addToRegistry:">addToRegistry: aWindowManager	"Before I add a new one, I do a cleanup via checkForTerminate"	self managerRegistry copyOld do: [:each | each ifNotNil: [each terminateIfEmpty]].	self managerRegistry add: aWindowManager</body></methods><methods><class-id>UI.WindowManager class</class-id> <category>recovery</category><body package="Interface-Framework" selector="purgeDeadWindows">purgeDeadWindows	self managerRegistry copyOld do: [:each | each ifNotNil: [each purgeDeadWindows]]</body></methods><methods><class-id>UI.Label</class-id> <category>printing</category><body package="UIBasics-Support" selector="displayLabel">displayLabel	^self copyOld</body></methods><methods><class-id>UI.Icon</class-id> <category>initialize-release</category><body package="Interface-Support" selector="cleanFigure">cleanFigure	"Window systems may behave oddly when the image has non-zero	pixels where the mask is transparent. This method 'cleans up' the	image to have only zero pixels where transparent. We make this operation      optional in case the odd behavior was really what the user wanted.      Note that we cannot guarantee the same odd behavior on all platforms.	To avoid conversion of the zero pixels to the corresponding color 	value of the mappedPalette when installing the icon, convert &lt;figure&gt; 	to an image with the color depth of the screen before setting pixels to zero."	| msk medium image |	"Figure must have ColorValue as paintBasis, thus the medium is a Pixmap."	medium := Pixmap new.	"Convert image copy to an image with the actual color depth."	image := medium graphicsContext paintPolicy 				representImage: figure asImage copyOld				forMedium: medium.	msk := shape asImage.	0 to: image width - 1		do: 			[:x | 			0 to: image height - 1				do: 					[:y | 					(msk valueAtPoint: x @ y) = CoverageValue transparent 						ifTrue: [image atPoint: x @ y put: 0]]].	figure := CachedImage on: image</body></methods><methods><class-id>UI.ToolBar</class-id> <category>displaying</category><body package="UIBasics-Components" selector="displayBackgroundOn:">displayBackgroundOn: aGraphicsContext	(aGraphicsContext copyOld)		paint: self backgroundColor;		displayRectangle: self bounds</body></methods><methods><class-id>UI.MotifLookPolicy class</class-id> <category>installation</category><body package="UILooks-Motif" selector="menuName">menuName	^(#OSFMotif &lt;&lt; #menus &gt;&gt; 'OSF Motif') copyOld</body></methods><methods><class-id>UI.DataSetScrollWrapper</class-id> <category>private - scrolling</category><body package="UIBasics-Datasets" selector="scrollHorizontallyBy:on:">scrollHorizontallyBy: anInteger on: aGraphicsContext	"Scroll the receiver horizontally by anInteger"	| clippingBox moveBox damageRectangles |	clippingBox := self clippingBounds intersect: aGraphicsContext clippingBounds.	clippingBox := clippingBox intersect: component hScrollBounds.	moveBox := clippingBox copyOld.	anInteger abs &gt;= clippingBox width ifTrue: [^self redisplayRectangle: clippingBox on: aGraphicsContext].	anInteger &lt; 0		ifTrue: [moveBox right: moveBox right + anInteger]		ifFalse: [moveBox left: moveBox left + anInteger].	aGraphicsContext intersectClip: clippingBox.	damageRectangles := aGraphicsContext		copyArea: moveBox		from: aGraphicsContext		sourceOffsetX: 0		y: 0		destinationOffsetX: anInteger negated		y: 0.	1 to: damageRectangles size do: 		[:index |		self 			redisplayRectangle: ((damageRectangles at: index) intersect: clippingBox)			on: aGraphicsContext].	anInteger &lt; 0		ifTrue: [moveBox right: moveBox left - anInteger]		ifFalse: [moveBox left: moveBox right - anInteger].	self redisplayRectangle: moveBox on: aGraphicsContext</body></methods><methods><class-id>UI.DataSetScrollWrapper</class-id> <category>private - scrolling</category><body package="UIBasics-Datasets" selector="scrollVerticallyBy:on:">scrollVerticallyBy: anInteger on: aGraphicsContext	"Scroll the receiver vertically by anInteger"	| clippingBox moveBox damageRectangles |	clippingBox := self clippingBounds intersect: aGraphicsContext clippingBounds.	clippingBox := clippingBox intersect: component vScrollBounds.	moveBox := clippingBox copyOld.	anInteger abs &gt;= clippingBox height ifTrue: [^self redisplayRectangle: clippingBox on: aGraphicsContext].	anInteger &lt; 0		ifTrue: [moveBox bottom: moveBox bottom + anInteger]		ifFalse: [moveBox top: moveBox top + anInteger].	aGraphicsContext intersectClip: clippingBox.	damageRectangles := aGraphicsContext		copyArea: moveBox		from: aGraphicsContext		sourceOffsetX: 0		y: 0		destinationOffsetX: 0		y: anInteger negated.	1 to: damageRectangles size do: 		[:index | 		self 			redisplayRectangle: ((damageRectangles at: index) intersect: clippingBox)			on: aGraphicsContext].	anInteger &lt; 0		ifTrue: [moveBox bottom: moveBox top - anInteger]		ifFalse: [moveBox top: moveBox bottom - anInteger].	self redisplayRectangle: moveBox on: aGraphicsContext</body></methods><methods><class-id>UI.DataSetView</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="displayOn:">displayOn: aGraphicsContext 	"Display the receiver's content on aGraphicsContext."	| graphicsContext visualOfLabels |	self displayBackgroundIfNeededOn: aGraphicsContext in: super bounds.	self setForegroundPaintOn: aGraphicsContext.	graphicsContext := aGraphicsContext copyOld.	graphicsContext intersectClip: (self tableProperBounds translatedBy: self bounds origin).	visualOfLabels := self labelsVisual.	visualOfLabels displayOn: graphicsContext.	graphicsContext := aGraphicsContext copyOld.	graphicsContext intersectClip: (self cellAreaBoundsForDisplay translatedBy: self bounds origin).	self displayVisualsOn: graphicsContext.	self displayGridLinesOn: aGraphicsContext.	editorWrapper notNil ifTrue: 		[ | box frozenColumnEdge |		box := self cellAreaBounds.		self editCell x &gt; self numFrozen 			ifTrue: 				[frozenColumnEdge := self frozenEdge.				frozenColumnEdge &gt; 0 ifTrue: [box left: frozenColumnEdge]]			ifFalse: 				[editorWrapper bounds: ((self 					boundsOfCellIndex: self editCell 					inBounds: self bounds) insetBy: (0 @ 0 corner: 1 @ 1))].			box := box translatedBy: self bounds origin.			(editorWrapper bounds intersects: box) ifTrue: 				[aGraphicsContext intersectClip: box.				editorWrapper displayOn: aGraphicsContext]]</body></methods><methods><class-id>UI.DataSetView</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="displayVisualsOn:">displayVisualsOn: aGraphicsContext	"Display the RowVisuals visible in the receiver's bounds on 	GraphicsContext gc."	| currentSequence rect interval bounds rowVisual visibleRange scrollRange |	((currentSequence := self sequence) == nil or: [currentSequence size == 0])		ifTrue: [^self].	rect := aGraphicsContext clippingBounds.	bounds := self bounds.	interval := self visibleIntervalForBounds: (bounds intersect: rect).	visibleRange := self visibleXIndexRangeFor: bounds.	scrollRange := self scrollableXIndexRangeFor: bounds.	interval first to: (interval last + 1 min: currentSequence size)		do: 			[:index |			rowVisual := self columnRange: scrollRange rowIndex: index.			(useHiliteSelection and: [showingSelection and: [self isSelected: index]])				ifTrue: 					[| visibleBounds graphicsContext |					graphicsContext := aGraphicsContext copyOld.					visibleBounds := self boundsOfElementIndex: index inRange: visibleRange.					visibleBounds right: visibleBounds right - self leftOffsetForDisplay.					graphicsContext paintPreferencesMatchAt: SymbolicPaint foreground put: (graphicsContext paintPreferencesMatchAt: SymbolicPaint selectionBackground).					graphicsContext displayRectangle: visibleBounds.					graphicsContext paintPreferencesMatchAt: self foregroundColor put: (graphicsContext paintPreferencesMatchAt: SymbolicPaint selectionForeground).					rowVisual displayOn: graphicsContext]				ifFalse: [rowVisual displayOn: aGraphicsContext].			rowVisual releaseRenderers]</body></methods><methods><class-id>UI.Win95MenuItemView</class-id> <category>displaying-private</category><body package="UILooks-MSWin" selector="computeComposedTexts">computeComposedTexts	"Compute the composed text object appropriate for the label of the receiver and for the 	shortcutKeyCharacter and cache it."	| theText textStyle theMenuItem |	theMenuItem := self menuItem.	textStyle := self lookPolicyClass systemMenuTextStyle.	theText := theMenuItem labelText.	theText := theText isNil ifTrue: [theMenuItem label asText] ifFalse: [theText copyOld].	composedLabel := Label with: theText attributes: textStyle.	menuView supportsKeyboard ifFalse: [^self].	accessCharacter := theMenuItem accessCharacterPosition.	accessCharacter isNil ifFalse: 			[| indicatorParameters |			indicatorParameters := self computeAccessIndicator.			indicatorParameters notNil ifTrue: 					[accessIndicator := indicatorParameters at: 1.					accessIndicatorThickness := indicatorParameters at: 2]].	theMenuItem hasSubmenu ifTrue: [^self].	theMenuItem hasShortcut ifTrue: [		composedCharacter := Label with: (theMenuItem shortcutModifierString, theMenuItem shortcutKeyString) asText attributes: textStyle	]</body></methods><methods><class-id>UI.Win95MenuItemView</class-id> <category>displaying-private</category><body package="UILooks-MSWin" selector="displayLabelOn:in:selected:">displayLabelOn: aGraphicsContext in: theMenuItemBox selected: isSelected 	"Display the label of the menu item on aGraphicsContext inside theMenuItemBox. isSelected 	indicates if the menu item is to be displayed in it's selected 'highlighted' state."	| theComposedLabel verticalPosition theLabelImage labelPosition labelGraphicsContext offset |	theLabelImage := model labelImage.	labelPosition := menuView commonTextIndent.	theLabelImage notNil ifTrue: 		[| imageBounds imageVerticalPosition |		imageBounds := theLabelImage bounds.		imageVerticalPosition := theMenuItemBox height - imageBounds height // 2.		theLabelImage			displayOn: aGraphicsContext			at: self defaultLabelIndent @ imageVerticalPosition].	theComposedLabel := self composedLabel.	verticalPosition := theMenuItemBox height - theComposedLabel height // 2.	offset := labelPosition @ verticalPosition.	labelGraphicsContext := aGraphicsContext copyOld translateBy: offset.	theComposedLabel		displayOn: labelGraphicsContext		at: 0 @ 0		enabled: self isEnabled.	accessIndicator isNil ifTrue: [^self].	labelGraphicsContext lineWidth: accessIndicatorThickness.	self isEnabled ifFalse: 		[| copyGC |		copyGC := labelGraphicsContext copyOld.		copyGC paint: SymbolicPaint hilite; translateBy: 1 @ 1.		accessIndicator displayStrokedOn: copyGC].	accessIndicator displayStrokedOn: labelGraphicsContext</body></methods><methods><class-id>UI.WidgetSpec</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	"Make sure the callbacksSpec is deep copied."	super postCopy.	callbacksSpec := callbacksSpec copyOld</body></methods><methods><class-id>UI.WidgetSpec</class-id> <category>accessing</category><body package="UIPainter" selector="savableSpecFor:">savableSpecFor: implementationComponent	| result |	result := super savableSpecFor: implementationComponent.	(self model isLiteral) ifFalse: [result model: nil].	callbacksSpec notNil ifTrue: [ result callbacksSpec: callbacksSpec copyOld].	^result</body></methods><methods><class-id>UI.HotRegions</class-id> <category>private</category><body package="UIBasics-Support" selector="compress">compress	"If possible, shrink the mappings image and selectors array"	| achievableBitDepth remapArray oldImage pix |		achievableBitDepth := (2 raisedTo: 		((((self numberOfSlices) highBit -1) max: 0) highBit)	).	achievableBitDepth &lt; regionsImage bitsPerPixel		ifFalse: [^self].	remapArray := regionsSelectors copyOld.	(1 to: remapArray size) inject: 1 into: [ :newVal :index | 		(remapArray at: index) notNil			ifTrue: [ | temp |					remapArray at: index put: newVal. 					temp := regionsSelectors at: index.					regionsSelectors at: index put: nil.					regionsSelectors at: newVal put: temp. 					newVal + 1]			ifFalse: [newVal].	].	oldImage := regionsImage. 	regionsImage := Image extent: oldImage extent depth: achievableBitDepth palette: (CoveragePalette maxPixelValue: (2 raisedTo: achievableBitDepth) -1).	oldImage pixelsDo: [ :x :y |		pix := oldImage atPoint: x@y.		regionsImage atPoint: x@y put: (pix = 0 ifTrue: [0] ifFalse: [remapArray at: pix]).	].	regionsSelectors := regionsSelectors copyFrom: 1 to: (2 raisedTo: achievableBitDepth) -1.</body></methods><methods><class-id>UI.HotRegions</class-id> <category>accessing</category><body package="UIBasics-Support" selector="regionsSelectors:">regionsSelectors: aValue	regionsSelectors := aValue copyOld</body></methods><methods><class-id>UI.Win95LookPolicy</class-id> <category>private</category><body package="UILooks-MSWin" selector="colorsWithButtonBackgroundFor:">colorsWithButtonBackgroundFor: colors 	"Private - Fix background color of all widgets, which shall have a white background."	^colors isNil		ifTrue: [LookPreferences new backgroundColor: SymbolicPaint buttonBackground]		ifFalse: [colors backgroundColor isNil				ifTrue: [colors copyOld backgroundColor: SymbolicPaint buttonBackground]				ifFalse: [colors]]</body></methods><methods><class-id>UI.Win95LookPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="menuName">menuName	^(#Win95NT &lt;&lt; #menus &gt;&gt; 'Windows 95/NT') copyOld</body></methods><methods><class-id>UI.DefaultLookPolicy class</class-id> <category>installation</category><body package="UILooks-Default" selector="menuName">menuName	^(#DefaultLook &lt;&lt; #menus &gt;&gt; 'Default Look') copyOld</body></methods><methods><class-id>UI.WidgetPolicy class</class-id> <category>accessing</category><body package="UIBuilder-Support" selector="defaultWidgetColorsOn:">defaultWidgetColorsOn: aGraphicsDevice 	"Answer the default set of widget color preferences for a graphics device, or nil 	to use the global look preferences."	| colors |	colors := (defaultWidgetColors at: (self indexParameterFor: aGraphicsDevice)) copyOld.	self installPlatformPreferencesFrom: aGraphicsDevice on: colors.	self installCalculatedPaintPreferencesFrom: aGraphicsDevice on: colors.	colors bindConstantCodeArray.	^colors</body></methods><methods><class-id>UI.MultiSelectionDataSetView</class-id> <category>private</category><body package="UIBasics-Datasets" selector="useSweepSelectionIndex:">useSweepSelectionIndex: anIndex	"If multiple selections are possible, add the	current selection and all indices from the	current selection to the previous selection,	to the list of selections."	| save delta list newList listHasChanged |	lastSelectionIndex = self zeroIndex		ifTrue:			[self retractAllSelections.			^self].	save := lastSelectionIndex.	selectionIndex := anIndex.	save &lt; anIndex		ifTrue: [delta := -1]		ifFalse: [delta := 1].	list := self selections copyOld.	newList := (anIndex to: save by: delta).	(list reject: [:each | newList includes: each]) do:		[:each |		selections remove: each ifAbsent: [].		self invalidateElementIndex: each].	(newList reject: [:each | list includes: each]) do:		[:each |		selections add: each.		self invalidateElementIndex: each].	lastSelectionIndex := save.	listHasChanged := ((list allSatisfy: [:each | newList includes: each]) and: [newList allSatisfy: [:each | list includes: each]]) not.	listHasChanged ifTrue: [self triggerEvent: #rowSelectionsChanging].	self selectionChannel value: selections.	listHasChanged ifTrue: [self triggerEvent: #rowSelectionsChanged].</body></methods><methods><class-id>UI.ColumnDraggingTracker</class-id> <category>dragging</category><body package="Interface-Events-Trackers" selector="setupForDraggingIndex:at:">setupForDraggingIndex: index at: aPoint 	| column visualBounds displayPoint |	startedDragging := true.	originalColumnIndex := columnIndex := index.	column := self view columnDescriptors at: index.	self view labelsAsButtons 		ifTrue: 			[visual := column labelAsButton.			"Ensure the column label button bounds appears topmost"			visualBounds := visual bounds.			visualBounds				top: 1;				height: visualBounds height]		ifFalse: 			[visual := column label.			visualBounds := visual bounds].	graphicsContext := self view graphicsContext copyOld clippingRectangle: nil.	dragDisplayOffset := startingPoint - visualBounds origin.	displayPoint := aPoint - dragDisplayOffset.	self createBasicBackingStoreAt: displayPoint from: visualBounds.	labelPixmap displayOn: graphicsContext at: displayPoint.	previousPoint := displayPoint</body></methods><methods><class-id>UI.RowLabelVisualComposite</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="displayOn:">displayOn: aGraphicsContext	| clippingBounds clippedGraphicsContext frozenColumn left right |	left := self bounds left + frozenTranslation.	clippingBounds := aGraphicsContext clippingBounds.	clippedGraphicsContext := aGraphicsContext copyOld.	frozen &gt; 0 ifTrue: [frozenColumn := descriptors at: frozen].	descriptors with: components		do: 			[:descriptor :visualComponent |			right := left + descriptor width.			inhibit ~~ descriptor				ifTrue: 					[| box elementBox |					elementBox := left @ bounds top corner: right @ bounds bottom.					box := elementBox insetBy: self cellInset.					visualComponent bounds: (box moveBy: descriptor offset).					visualComponent bounds left &lt; right						ifTrue: 							[| graphicsContext |							graphicsContext := clippedGraphicsContext copyOld.							graphicsContext intersectClip: elementBox.							visualComponent displayOn: graphicsContext.							self displayAdornment: visualComponent of: descriptor on: graphicsContext]].			left := right.			descriptor = frozenColumn				ifTrue: 					[clippingBounds left: (left max: clippingBounds left).					clippedGraphicsContext clippingRectangle: clippingBounds.					left := left - frozenTranslation]]</body></methods><methods><class-id>UI.Win95GroupBox</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayBorderOn:">displayBorderOn: aGraphicsContext 	| b |	b := self bounds copyOld.	b		 top: b top + (self labelHeight // 2);		 right: b right - 2;		 bottom: b bottom - 2.	b moveBy: 1 @ 1.	aGraphicsContext paint: SymbolicPaint pushButtonHilite; displayRectangularBorder: b.	b moveBy: -1 @ -1.	aGraphicsContext paint: SymbolicPaint pushButtonShadow; displayRectangularBorder: b</body></methods><methods><class-id>UI.MacOSXTabControlBarView</class-id> <category>private-displaying</category><body package="UILooks-MacOSX" selector="displayVisual:index:on:forBounds:">displayVisual: component index: i on: aGraphicsContext forBounds: elementBounds 	"Private - Display the receiver's content on aGraphicsContext and make sure it is pretty much centered"	| computedOffset |	computedOffset := component preferredBounds height &lt; elementBounds bottom		ifFalse: [0]		ifTrue: [((elementBounds bottom - component preferredBounds height) / 2) rounded - 1].	component bounds: (elementBounds insetBy: (6 @ computedOffset extent: -6 @ computedOffset negated)).	aGraphicsContext paint: self foregroundColor.	component displayOn: aGraphicsContext copyOld.</body></methods><methods><class-id>UI.MacOSXBeveledBorder</class-id> <category>displaying</category><body package="UILooks-MacOSX" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRectangle using: colorSource 	"Display the receiver's borders in the specified display box.	Be sure not to permanently side-effect the supplied GraphicsContext.	Only draw colors on the outside, and a full rectangle in black on the inside."	| insideRectangle clipRectangle paint oldPaint paintSet |	clipRectangle := aGraphicsContext clippingBounds.	((self insetDisplayBoxFor: aRectangle) contains: clipRectangle)		ifTrue: [^self].	oldPaint := aGraphicsContext paint.	insideRectangle := aRectangle copyOld extent: aRectangle extent - 1.	paint := self topPaintFor: colorSource.	paintSet := false.	(insideRectangle intersects: clipRectangle) ifTrue: 		[paintSet := true.		aGraphicsContext paint: paint; displayLineFrom: insideRectangle topLeft to: insideRectangle bottomLeft].	(insideRectangle intersects: clipRectangle) ifTrue: 		[paintSet ifFalse: [aGraphicsContext paint: paint].		aGraphicsContext displayLineFrom: insideRectangle topLeft to: insideRectangle topRight].	paint := ColorValue white.	paintSet := false.	(insideRectangle intersects: clipRectangle) ifTrue: 		[paintSet := true.		aGraphicsContext paint: paint; displayLineFrom: insideRectangle bottomLeft to: insideRectangle bottomRight].	(insideRectangle intersects: clipRectangle) ifTrue: 		[paintSet ifFalse: 			[paintSet := true.			aGraphicsContext paint: paint].		aGraphicsContext displayLineFrom: insideRectangle bottomRight to: insideRectangle topRight].	insideRectangle := insideRectangle insetBy: 1.	aGraphicsContext paint: ColorValue black.	aGraphicsContext displayRectangularBorder: insideRectangle.	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.DataSetColumnSpec</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	"width is a value holder, we want to copy it also"	super postCopy.	width := width copyOld</body></methods><methods><class-id>UI.DataSetColumnSpec</class-id> <category>private</category><body package="UIBuilder-Specifications" selector="capitalizeFirstLetterOn:">capitalizeFirstLetterOn: aString	| newString |	aString isEmpty ifTrue: [^aString].	newString := aString copyOld.	newString at: 1 put: ((aString at: 1) asUppercase).	^newString</body></methods><methods><class-id>UI.DataSetColumnSpec</class-id> <category>private</category><body package="UIBuilder-Specifications" selector="camelCase:">camelCase: aStringOrSymbol	| tokens result |	aStringOrSymbol isNil ifTrue: [^'_' copyOld].	aStringOrSymbol isEmpty ifTrue: [^aStringOrSymbol].	tokens := aStringOrSymbol asString tokensBasedOn: (Character space).	result := tokens inject: (String new) into: [:subTotal :next | subTotal,  (self capitalizeFirstLetterOn: next)].	result at: 1 put: (result at: 1) asLowercase.	^result</body></methods><methods><class-id>UI.DataSetSpec</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	"Take care of copying the columns also"	super postCopy.	columns notNil ifTrue: [columns := columns collect: [:col | col copyOld]]</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayTextIn:on:">displayTextIn: aRectangle on: gc	"Display the receiver's text that intersects aRectangle on GraphicsContext gc.	Show all text whether selected or not in one pass."	| first last ss es x lineRange |	gc paint: self foregroundColor.	(self displaySelection not or: [selectionShowing not])		ifTrue: [^self displayObject displayOn: gc copyOld at: self displayOrigin].	displayContents numberOfLines = 0		ifTrue: [^self displayInsertionPointFor: self startBlock on: gc].	lineRange := displayContents				lineRangeFor: (aRectangle translatedBy: self displayOrigin negated).	first := (displayContents lineAt: lineRange first) first.	last := (displayContents lineAt: lineRange last) last.	x := self displayOrigin x.	ss := self startBlock stringIndex.	es := self stopBlock stringIndex.	((ss &gt; last or: [es &lt; first]) or: [ss = es])		ifTrue: 			[self displayObject displayOn: gc copyOld at: self displayOrigin.			^self displayInsertionPointFor: self startBlock on: gc].	ss &gt; first		ifTrue: 			[gc paint: self foregroundColor.			self displayFromCharacter: first to: ss - 1 startX: x on: gc.			first := ss.			x := self startBlock left].	self showSelectionBoxOn: gc within: aRectangle.	gc paint: self selectionForegroundColor.	last &lt; es		ifTrue: 			[self displayFromCharacter: first to: last startX: x on: gc]		ifFalse: 			[self displayFromCharacter: first to: es - 1 startX: x on: gc.			gc paint: self foregroundColor.			x := self stopBlock left.			self displayFromCharacter: es to: last startX: x on: gc]</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>private</category><body package="UIBasics-Components" selector="redisplayAfterReplacementAt:affectedLines:lineDelta:">redisplayAfterReplacementAt: startLine affectedLines: affectedLines lineDelta: lineDelta	"Redisplay the receiver after a change starting at startLine. 	The argument affectedLines is the number of lines that need to be redisplayed. 	The argument lineDelta has the change in total lines. 	This method uses scrolling and only works for tiled views."	| visibleRectangle  stopLine gc |	gc := self graphicsContext.	visibleRectangle := self clippingBox.	self displayObject numberOfLines = 0  ifTrue: [^self simpleRedisplay].	stopLine := startLine + affectedLines - 1.	lineDelta = 0		ifTrue:	[gc paint: self backgroundColor.				gc intersectClip: (visibleRectangle := self							visibleRectangleFrom: startLine							to: stopLine).				gc displayRectangle: visibleRectangle.				gc paint: self foregroundColor.				self displayOn: gc]		ifFalse: [ | obsoleteY newY moveRectangle gc2 rectList |				lineDelta &gt; 0					ifTrue: [obsoleteY := self displayObject topAtLineIndex: startLine+(affectedLines - lineDelta max: 0)]					ifFalse: [obsoleteY := self displayObject topAtLineIndex: startLine + lineDelta negated].				newY := obsoleteY + (self lineGrid * lineDelta).				moveRectangle := self computeMoveRectangleFor: visibleRectangle old: obsoleteY new: newY.				gc2 := gc copyOld.				gc2 intersectClip: visibleRectangle.				rectList := gc2					copyArea: moveRectangle					from: gc2					sourceOffsetX: 0 y: 0					destinationOffsetX: 0 y: ((newY max: visibleRectangle top) - moveRectangle top).					1 to: rectList size  do:						[:j | self redisplayRectangle: ((rectList at: j) intersect: visibleRectangle) on: gc2].	 			self redisplayRectangle: (self visibleRectangleFrom: startLine to: stopLine) on: gc.				lineDelta &lt; 0					ifTrue: [| rr|							rr := visibleRectangle left@((newY+ moveRectangle height) max: visibleRectangle top)									corner: visibleRectangle corner.							self redisplayRectangle: rr on: gc]]</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>private</category><body package="UIBasics-Components" selector="simpleRedisplay">simpleRedisplay	| gc |	state isVisible ifFalse: [^self].	state isOccluded ifTrue: [^self invalidateRectangle: self bounds repairNow: true].	self isOpen ifFalse:[^self].	gc := self graphicsContext.	gc medium supportsInvalidation ifFalse: [^self].	gc medium hasOutstandingDamage ifTrue: [^self invalidateRectangle: self bounds repairNow: true].	(state isOpaque or: [state hasBackgroundColor]) 		ifFalse: [gc copyOld				paint: self backgroundColor;				displayRectangle: self bounds].	self displayOn: gc</body></methods><methods><class-id>UI.UISettings class</class-id> <category>class initialization</category><body package="Interface-Support" selector="updateAllPreferences">updateAllPreferences	"Update the preferences and setting specs."	| devSpecs runSpecs |	PrevPreferences := UserPreferences copyOld.	TempPreferences := Dictionary new: 100.	devSpecs := OrderedCollection new: 50.	runSpecs := OrderedCollection new: 10.	PreferenceInitializers do: [:sel|		(self respondsTo: sel)			ifTrue:				[self perform: sel with: TempPreferences with: devSpecs with: runSpecs]			ifFalse:				[UserNotification raiseSignal: ((#noSuchMessageAs1s &lt;&lt; #dialogs &gt;&gt; 'no such message as &lt;1s&gt;')			expandMacrosWith: sel)]].	UserPreferences isNil ifTrue:		[UserPreferences := Dictionary new: TempPreferences size * 2].	"Update UserPreferences."	TempPreferences associationsDo: [:assoc| UserPreferences add: assoc].	"Now remove all the old preferences."	(UserPreferences keys reject: [:k| TempPreferences includesKey: k]) do:		[:k| UserPreferences removeKey: k].	"Now substitute the new spec lists"	DevelopmentSpecList := devSpecs asArray.	RuntimeSpecList := runSpecs asArray.	"and erase PrevPreferences and TempPreferences."	PrevPreferences := TempPreferences := nil	"UISettings updateAllPreferences"</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="Interface-Support" selector="sourceDirsReset">sourceDirsReset	| list |	list := (self preferenceModelFor: #sourceDirs) value.	list removeAllSuchThat: [:ign| true].	list addAll: (SourceFileManager default sourceFileDirectories collect: [:ea| ea asString]) asSortedStrings.	(self preferenceModelFor: #sourceDirsEditing) value: list copyOld</body></methods><methods><class-id>UI.UISettings class</class-id> <category>user preferences</category><body package="Interface-Support" selector="addVWToolsSectionTo:development:runtime:">addVWToolsSectionTo: aDictionary development: devSpecs runtime: runtimeSpecs	"Add the core set of preferences and settings slices to the arguments."	"UISettings updateAllPreferences"	aDictionary		at: #fileOutType			put: (self preferenceModelFor: #fileOutType default: #ChunkSourceFileFormat);		at: #sources			put: List new asValue;		at: #sourcesEditing			put: List new asValue asValue;		at: #sourceAccept			put: [self sourceAccept];		at: #sourceReset			put: [self sourceReset];		at: #sourceDirs			put: List new asValue;		at: #sourceDirsEditing			put: List new asValue asValue;		at: #sourceDirsAccept			put: [self sourceDirsAccept];		at: #sourceDirsReset			put: [self sourceDirsReset];		at: #parcelPath			put: Parcel searchPathModel;		at: #parcelPathEditing			put: Parcel searchPathModel value copyOld asValue;		at: #parcelPathAccept			put: [self parcelPathAccept];		at: #parcelPathReset			put: [self parcelPathReset].	devSpecs		add: (#SourceFiles &lt;&lt; #labels &gt;&gt; 'Source Files')-&gt;#(#sourcesSpec #sourcesHelp);		add: (#SourceDirs &lt;&lt; #labels &gt;&gt; 'Source Dirs')-&gt;#(#sourceDirsSpec #sourceDirsHelp);		add: (#ParcelPath &lt;&lt; #labels &gt;&gt; 'Parcel Path')-&gt;#(#parcelPathSpec #parcelPathHelp);		add: (#Messages &lt;&lt; #labels &gt;&gt; 'Messages') -&gt; #(#messagesSpec #messagesHelp).	runtimeSpecs		add: (#Messages &lt;&lt; #labels &gt;&gt; 'Messages') -&gt; #(#messagesSpec #messagesHelp)</body></methods><methods><class-id>UI.DocumentView</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayBackgroundIfNeededOn:">displayBackgroundIfNeededOn: aGraphicsContext	| gc |	(widgetState isOpaque or: [settings includesKey: #backgroundColor]) ifFalse: [^self].	gc := aGraphicsContext copyOld.	gc paint: self backgroundColor.	gc displayRectangle: self bounds</body></methods><methods><class-id>UI.DocumentView</class-id> <category>private</category><body package="UIBasics-Text2" selector="setModel:">setModel: aModel	document := aModel value copyOld asDocument.	flow := Flow device: self graphicsDevice document: document pageExtent: self pageExtent.	inputCursor := anchorCursor := self defaultCursorPosition.	super setModel: aModel</body></methods><methods><class-id>UI.DocumentView</class-id> <category>actions - editing</category><body package="UIBasics-Text2" selector="cancel">cancel	"Copy the value model in to the widget, discarding the current changes."	self document: model value copyOld asDocument.	self forget</body></methods><methods><class-id>UI.DocumentView</class-id> <category>actions - clipboard</category><body package="UIBasics-Text2" selector="clipboardCopy">clipboardCopy	"Copy the current selection in to the clipboard."	&lt;state: #active command: #copyOld&gt;	&lt;state: #activeReadOnly command: #copyOld&gt;	flow isForPasswords ifTrue: [^self].	currentEditState := #copyOld.	Screen default putExternalSelection: self selection asString</body></methods><methods><class-id>UI.DocumentView</class-id> <category>actions - editing</category><body package="UIBasics-Text2" selector="accept">accept	"Copy the current document content in to the value model."	&lt;state: #active command: #accept&gt;	model == nil ifTrue: [^self].	model removeDependent: self.	model value: document copyOld.	model addDependent: self.</body></methods><methods><class-id>UI.DocumentView</class-id> <category>events - mouse</category><body package="UIBasics-Text2" selector="mouseRightDown:">mouseRightDown: event	"Open the right click popup menu."	&lt;state: #inactive event: #Button2Down&gt;	&lt;state: #active event: #Button2Down&gt;	&lt;state: #activeReadOnly event: #Button2Down&gt;	| menuView valueResult segment mergedMenu |	self hasFocus ifFalse: [self takeKeyboardFocus].	self invalidateSelectionWhile: [self selectContentUnderMenu: event].	segment := flow segmentAtPixel: (self globalPointToLocal: event point) ifAbsent: [nil].	self hasMenu		ifTrue: [			mergedMenu := self menu copyOld.			segment == nil ifFalse: [				segment menu menuItems do: [:each | mergedMenu addItem: each]]]		ifFalse: [			segment == nil ifTrue: [^self].			mergedMenu := segment menu].	mergedMenu menuItems isEmpty ifTrue: [^self].	self setDynamicPropertiesOn: mergedMenu.	menuView := self widgetPolicy menuViewForMenu: mergedMenu.	valueResult := menuView openFromView: self.	valueResult ifNotNil: [		self invalidateSelectionWhile: [			| performer |			performer := (valueResult truePerformerFor: self) ifNil: [controller menuMessageReceiver].			valueResult value cull: performer]]</body></methods><methods><class-id>UI.DocumentView</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayLinesOn:">displayLinesOn: aGraphicsContext	"Draw the visible lines."		| clippingBounds gc selectionStartPosition selectionStopPosition nativeGUIPolicy |	selectionStartPosition := self selectionStartPosition.	selectionStopPosition := self selectionStopPosition.	clippingBounds := aGraphicsContext clippingBounds.	gc := aGraphicsContext copyOld.	"Determine if we must apply a selection foreground to our text when selected."	nativeGUIPolicy := flow device nativeGUIPolicy.	nativeGUIPolicy shouldUseSelectedTextForegroundColor ifTrue: [		gc clientDataAt: #selectionForegroundColor ifAbsent: [			gc clientDataAt: #selectionForegroundColor put: (nativeGUIPolicy selectedTextForegroundColorFocused: self isFocused)]].	flow linesIntersecting: clippingBounds do: [:line |		gc translation: aGraphicsContext translation + (0 @ line top).		line displayOn: gc selectingBetween: selectionStartPosition and: selectionStopPosition]</body></methods><methods><class-id>UI.DocumentView</class-id> <category>initialize-release</category><body package="UIBasics-Text2" selector="defaultShowLineNumbersStyle">defaultShowLineNumbersStyle	^DocumentStyle default copyOld		color: (ColorValue brightness: 0.33);		intern</body></methods><methods><class-id>UI.DocumentView</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayOn:">displayOn: aGraphicsContext	"Draw the content background and foreground that is visible."	self isVisible ifFalse: [^self].	self displayBackgroundIfNeededOn: aGraphicsContext.	aGraphicsContext clientData: settings copyOld.	aGraphicsContext translateBy: margin topLeft.	self displayLineBackgroundsOn: aGraphicsContext.	self displaySelectionOn: aGraphicsContext.	self displayLinesOn: aGraphicsContext.	self displayCursorOn: aGraphicsContext</body></methods><methods><class-id>UI.DocumentView</class-id> <category>updating</category><body package="UIBasics-Text2" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender	aSender == model ifTrue: [		preferredX := 0.		inputCursor := anchorCursor := 0 @ 1.		currentEditState := nil.		document := model value copyOld asDocument.		flow document: document.		currentStyle := flow styleAtCursor: inputCursor ifAbsent: [DocumentStyle default].		self changedPreferredBounds: self preferredBounds.		self initializeHistory.		self invalidate].	super update: anAspectSymbol with: aParameter from: aSender</body></methods><methods><class-id>UI.DocumentView</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayLineBackgroundsOn:">displayLineBackgroundsOn: aGraphicsContext	"Draw the visible line backgrounds."	| clippingBounds gc showLineStriping |	showLineStriping := self showLineStriping.	clippingBounds := aGraphicsContext clippingBounds.	gc := aGraphicsContext copyOld.	flow linesIntersecting: clippingBounds do: [:line |		gc translation: aGraphicsContext translation + (0 @ line top).		(showLineStriping and: [line number even]) ifTrue: [			self showLineStripingColor installOn: gc.			gc displayRectangle: ((margin left negated @ 0) extent: ((self flow pageExtent x + margin left) @ line bounds height))].		line displayBackgroundOn: gc]</body></methods><methods><class-id>UI.DocumentView class</class-id> <category>resources</category><body package="UIBasics-Text2" selector="standardEditMenu">standardEditMenu	"Tools.MenuEditor new openOnClass: self andSelector: #standardEditMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Accept' 				#nameKey: #accept 				#value: #accept 				#enablementSelector: #canAccept 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 'Undo' 				#nameKey: #undo 				#value: #undo 				#enablementSelector: #canUndo 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editUndo ) 				#command: #undo ) 			#(#{UI.MenuItem} 				#rawLabel: 'Redo' 				#nameKey: #redo 				#value: #redo 				#enablementSelector: #canRedo 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editRedo ) 				#command: #redo ) 			#(#{UI.MenuItem} 				#rawLabel: 'Cut' 				#nameKey: #cut 				#value: #clipboardCut 				#enablementSelector: #canCut 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editCut ) 				#command: #cut ) 			#(#{UI.MenuItem} 				#rawLabel: 'Copy' 				#nameKey: #copyOld 				#value: #clipboardCopy 				#enablementSelector: #canCopy 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editCopy ) 				#command: #copyOld ) 			#(#{UI.MenuItem} 				#rawLabel: 'Paste' 				#nameKey: #paste 				#value: #clipboardPaste 				#enablementSelector: #canEdit 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editPaste ) 				#command: #paste ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find...' 				#nameKey: #find 				#value: #find 				#enablementSelector: #canFind 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 'Replace...' 				#nameKey: #replace 				#value: #findAndReplace 				#enablementSelector: #canReplace 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 'Cancel' 				#nameKey: #cancel 				#value: #cancel ) ) #(1 2 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.DocumentView class</class-id> <category>resources</category><body package="UIBasics-Text2" selector="standardViewMenu">standardViewMenu	"Tools.MenuEditor new openOnClass: self andSelector: #standardViewMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Copy' 				#nameKey: #copyOld 				#value: #clipboardCopy 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editCopy ) 				#command: #copyOld ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find...' 				#nameKey: #find 				#value: #find 				#command: #find ) ) #(1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.SpecCollection</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	| new |	super postCopy.	new := Array new: collection size.	1 to: collection size do:		[:i |		new at: i put: (collection at: i) copyOld].	collection := new</body></methods><methods><class-id>UI.WidgetWrapper</class-id> <category>visual properties</category><body package="UIBuilder-Support" selector="lookPreferences">lookPreferences	| lookPreferences |	(lookPreferences := self getLookPreferences) == nil ifFalse: 		[^widget sharesParentLookPreferences			ifTrue: [lookPreferences applyTo: super lookPreferences copyOld]			ifFalse: [lookPreferences]].	^super lookPreferences</body></methods><methods><class-id>UI.Win95VariableBorder</class-id> <category>private-displaying</category><body package="UILooks-MSWin" selector="displayFrameOn:in:paint1:paint2:">displayFrameOn: aGraphicsContext in: rect paint1: paint1 paint2: paint2 	"Private - Display a frame in rect using paint1 for left and top 	and paint2 for bottom and right sides of the frame."	aGraphicsContext paint: paint1.	self hasLeft ifTrue: [aGraphicsContext displayRectangle: (rect copyOld right: rect left + 1)].	self hasTop ifTrue: [aGraphicsContext displayRectangle: (rect copyOld bottom: rect top + 1)].	aGraphicsContext paint: paint2.	self hasBottom ifTrue: [aGraphicsContext displayRectangle: (rect copyOld top: rect bottom - 1)].	self hasRight ifTrue: [aGraphicsContext displayRectangle: (rect copyOld left: rect right - 1)]</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>event driven</category><body package="UIBasics-Support" selector="trackSelectionFrom:to:pivotBlock:showingCaret:">trackSelectionFrom: currentBlock to: newPoint pivotBlock: pivotBlock showingCaret: aBoolean 	| showingCaret pt dy gc nextBlock |	showingCaret := aBoolean.	gc := view graphicsContext.	pt := newPoint.	(dy := self dyForPoint: pt) ~= 0		ifTrue: 			[dy := dy abs &lt; view lineGrid						ifTrue: [dy sign * view lineGrid]						ifFalse: [dy truncateTo: view lineGrid].			view scrollBy: 0 @ dy negated.			gc translateBy: 0 @ dy negated.			pt := dy &lt; 0						ifTrue: [view bounds topLeft]						ifFalse: [view bounds bottomLeft].			self checkForEvents].	nextBlock := view characterBlockAtPoint: pt.	nextBlock = currentBlock		ifFalse: 			[showingCaret				ifTrue: 					[view hideInsertionPointFor: pivotBlock on: gc copyOld.					showingCaret := false].			self				updateSelectionWith: nextBlock				usingPivot: pivotBlock				on: gc copyOld.			self selectionStartIndex = self selectionStopIndex				ifTrue: 					[view displayInsertionPointFor: pivotBlock on: gc copyOld.					showingCaret := true].			gc flush].	^showingCaret</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>private</category><body package="UIBasics-Support" selector="silentCut">silentCut	"Remove the current selection and place it in the paste buffer.  Do not	affect visual selection."	| currentSelection |	self replaceSelectionWith: Text new.	currentSelection := self undoSelection copyOld.	self currentSelection: currentSelection.</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>event driven</category><body package="UIBasics-Support" selector="completeSelectionWithPrevStart:prevStop:pivotBlock:showingCaret:">completeSelectionWithPrevStart: prevStartBlock prevStop: prevStopBlock pivotBlock: pivotBlock showingCaret: showingCaret 	| strt gc word |	view isOpen ifFalse: [^self].	gc := view graphicsContext.	(strt := view startBlock) = view stopBlock 		ifTrue: 			[showingCaret ifFalse: [view displayInsertionPointFor: strt on: gc copyOld].			(prevStartBlock = prevStopBlock and: [prevStartBlock = strt]) 				ifTrue: 					["select a word or bracketed range"					word := self selectWord: pivotBlock stringIndex.					word first = word last 						ifFalse: 							[view hideInsertionPointFor: strt on: gc copyOld.							self selectionStartIndex: word first stopIndex: word last.							view 								displaySelectionFrom: view startBlock								to: view stopBlock								on: gc]]].	gc flush.	self setEmphasisHere.	self view updateSpot: #mouse</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>event driven</category><body package="UIBasics-Support" selector="setUpSelectionAt:">setUpSelectionAt: aPoint 	| gc currentBlock pivotBlock |	gc := view graphicsContext.	currentBlock := view characterBlockAtPoint: aPoint.	view deselect.	self setSelectionStartAndResetTypein.	pivotBlock := currentBlock.	anchorIndex := pivotBlock stringIndex.	view startBlock: pivotBlock.	view stopBlock: pivotBlock.	view displayInsertionPointFor: pivotBlock on: gc copyOld.	view selectionShowing: true.	gc flush.	^pivotBlock</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>menu messages</category><body package="UIBasics-Support" selector="cancel">cancel	"Restore the text of the paragraph to be the text saved since initialization or	the last accept."	self undoSelection: self text copyOld.	view updateDisplayContents</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>menu messages</category><body package="UIBasics-Support" selector="cut">cut	"Remove the current selection and, if non-empty, place it in the paste buffer"	| cur |	self resetTypein.	 self selectionStartIndex = self selectionStopIndex		ifTrue: [^self].	self deselect.	self replaceSelectionWith: Text new.	self selectAndScroll.	cur := self undoSelection copyOld.	self currentSelection: cur.</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>menu messages</category><body package="UIBasics-Support" selector="accept">accept	"Save the current text of the text being edited as the current acceptable	version for purposes of canceling."	self textHasChanged: false.	model value: self text copyOld</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>event driven</category><body package="UIBasics-Support" selector="setUpShiftDownSelectionAt:">setUpShiftDownSelectionAt: aPoint 	"Shift is down and there is a selection; extend it"	| gc prevStartBlock prevStopBlock currentBlock pivotBlock |	gc := view graphicsContext.	prevStartBlock := view startBlock.	prevStopBlock := view stopBlock.	currentBlock := view characterBlockAtPoint: aPoint.	self resetTypein.	prevStartBlock = prevStopBlock ifTrue: [view deselect].	pivotBlock := (currentBlock stringIndex - prevStartBlock stringIndex) abs &gt; (currentBlock stringIndex - prevStopBlock stringIndex) abs				ifTrue: ["extend the end of the selection closest to the current 					cursor position"					prevStartBlock]				ifFalse: [prevStopBlock].	self		updateSelectionWith: currentBlock		usingPivot: pivotBlock		on: gc copyOld.	anchorIndex := pivotBlock stringIndex.	view selectionShowing: true.	gc flush.	^pivotBlock</body></methods><methods><class-id>UI.ParagraphEditor class</class-id> <category>resources</category><body package="UIBasics-Support" selector="editGroup">editGroup	"Tools.MenuEditor new openOnClass: self andSelector: #editGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) 				#value: #cut				#command: #cut ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#value: #copySelection				#command: #copyOld ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) 				#value: #paste				#command: #paste ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#value: #find				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ReplaceDot 					#defaultString: 'Replace...' 					#catalogID: #menus ) 				#value: #replace				#command: #replace ) ) #(3 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.ParagraphEditor class</class-id> <category>resources</category><body package="UIBasics-Support" selector="readOnlyGroup">readOnlyGroup	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(#(#{UI.MenuItem}		#rawLabel: #(#{Kernel.UserMessage}			#key: #Copy			#defaultString: 'Copy'			#catalogID: #menus)		#nameKey: #copySelection		#value: #copySelection		#command: #copyOld		#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copyOld)) #(#{UI.MenuItem}		#rawLabel: #(#{Kernel.UserMessage}			#key: #FindDot			#defaultString: 'Find...'			#catalogID: #menus)		#nameKey: #find		#value: #find #command: #find) #(#{UI.MenuItem}		#rawLabel: #(#{Kernel.UserMessage}			#key: #FindAgain			#defaultString: 'Find Again'			#catalogID: #menus)		#nameKey: #findNext		#value: #findNext #command: #findNext) #(#{UI.MenuItem}		#rawLabel: #(#{Kernel.UserMessage}			#key: #SelectAll			#defaultString: 'Select All'			#catalogID: #menus)		#nameKey: #selectEntireText		#value: #selectEntireText #command: #selectAll)) #(1 2 1) nil) decodeAsLiteralArray</body></methods><methods><class-id>UI.Menu</class-id> <category>copying</category><body package="Interface-Menus" selector="postCopy">postCopy	"Finish doing whatever is required, beyond a shallowCopy, to implement 'copy'."	adornment := adornment copyOld.	items := items collect: [:each | each copyOld].	groupSizes := groupSizes copyOld.	self values: self values copyOld</body></methods><methods><class-id>UI.Menu</class-id> <category>accessing</category><body package="Interface-Menus" selector="augmentFrom:to:menuName:for:">augmentFrom: startClass to: stopClass menuName: name for: definer	| tested class new generator bad oldSize err |	(startClass includesBehavior: stopClass)		ifFalse: 			[(MenuAugmentationError new)				isResumable: false;				messageText: #startStopClass &lt;&lt; #dialogs							&gt;&gt; 'startClass must be same as, or subclass of, stopClass';				raiseSignal].	generator := (MenuAutomaticGenerator new)				menuName: name;				menuDefiner: definer;				yourself.	tested := Set new.	class := startClass.	(items size &gt; 0 and: [items first position == nil])		ifTrue: [self assignBasePositions].	new := List new.	[class == stopClass superclass] whileFalse: 			[class selectorsAndMethodsDo: 					[:sel :meth |					(tested includes: sel)						ifFalse: 							[tested add: sel.							new addAll: (self										menuItems: meth attributeMessages										with: sel										forMenu: generator)]].			class := class superclass].	bad := OrderedCollection new.	oldSize := 0.	[new isEmpty or: [new size = oldSize]] whileFalse: 			[oldSize := new size.			new copyOld do: 					[:itm |					| mnu |					mnu := self.					(itm at: 2) do: 							[:key |							mnu == nil ifFalse: [mnu := mnu atNameKey: key].							mnu == nil ifFalse: [mnu := mnu submenu]].					mnu == nil						ifFalse: 							[new remove: itm.							[mnu addItem: (itm at: 1) atPosition: (itm at: 3)] on: Error								do: 									[:ex |									bad add: itm -&gt; ex.									nil]]]].	new isEmpty		ifFalse: 			[(err := MenuAugmentationError new)				messageText: #errNoSubmenu &lt;&lt; #dialogs &gt;&gt; 'intended submenu does not exist';				parameter: (new collect: [:itm | itm -&gt; err]);				raiseSignal].	bad isEmpty		ifFalse: 			[(MenuAugmentationError new)				parameter: bad;				raiseSignal].	definer notNil ifTrue: [self findGuiResourcesIn: definer]</body></methods><methods><class-id>UI.Menu class</class-id> <category>privileged</category><body package="Interface-Menus" selector="decodeFromLiteralArray:">decodeFromLiteralArray: anArray	"Return a menu based on the information encoded in anArray.  Sent from privileged senders outside the class."	| items values |	items := (anArray at: 2) collect: [:e | e decodeAsLiteralArray].	values := (anArray at: 4).	values ~~ nil ifTrue: [		values := values collect: [:e | e decodeAsLiteralArray]].	^self new menuItems: items menuItemGroups: (anArray at: 3) copyOld values: values</body></methods><methods><class-id>UI.UISpecification</class-id> <category>properties</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	super postCopy.	properties := properties copyOld</body></methods><methods><class-id>UI.UISpecification</class-id> <category>private-labels</category><body package="UIBuilder-Specifications" selector="defaultLabelIn:key:">defaultLabelIn: aBuilder key: aKey	aKey == nil ifTrue: [^nil].	^self hasCharacterOrientedLabel		ifTrue: [aKey copyOld]		ifFalse: [aBuilder visualAt: #emptyImage]</body></methods><methods><class-id>UI.MenuBar</class-id> <category>displaying</category><body package="UIBasics-Components" selector="displayBackgroundOn:">displayBackgroundOn: aGraphicsContext	aGraphicsContext copyOld		paint: self backgroundColor;		displayRectangle: self bounds.</body></methods><methods><class-id>UI.Win95BorderDecorationPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayDownButtonPressedOn:bounds:">displayDownButtonPressedOn: aGraphicsContext bounds: box	"Display a down button on aGraphicsContext."		self clearInsideOn: aGraphicsContext bounds: box.	(aGraphicsContext copyOld)		paint: SymbolicPaint pushButtonBorder;		displayInteriorRectangularBorder: box.	DownArrow		displayOn: aGraphicsContext		at: box center - (DownArrow bounds extent half) + (0 @ 1)</body></methods><methods><class-id>UI.Win95BorderDecorationPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayRightButtonPressedOn:bounds:">displayRightButtonPressedOn: aGraphicsContext bounds: box	"Display a right button on aGraphicsContext."		self clearInsideOn: aGraphicsContext bounds: box.	(aGraphicsContext copyOld)		paint: SymbolicPaint pushButtonBorder;		displayInteriorRectangularBorder: box.	RightArrow		displayOn: aGraphicsContext		at: box center - (RightArrow bounds extent half) + (1 @ 0)</body></methods><methods><class-id>UI.Win95BorderDecorationPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayLeftButtonPressedOn:bounds:">displayLeftButtonPressedOn: aGraphicsContext bounds: box	"Display a left button on aGraphicsContext."		self clearInsideOn: aGraphicsContext bounds: box.	(aGraphicsContext copyOld)		paint: SymbolicPaint pushButtonBorder;		displayInteriorRectangularBorder: box.	LeftArrow		displayOn: aGraphicsContext		at: box center - (DownArrow bounds extent half) + (1 @ 0)</body></methods><methods><class-id>UI.Win95BorderDecorationPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayUpButtonPressedOn:bounds:">displayUpButtonPressedOn: aGraphicsContext bounds: box	"Display an up button on aGraphicsContext."		self clearInsideOn: aGraphicsContext bounds: box.	(aGraphicsContext copyOld)		paint: SymbolicPaint pushButtonBorder;		displayInteriorRectangularBorder: box.	UpArrow		displayOn: aGraphicsContext		at: box center - (UpArrow bounds extent half) + (0 @ 1)</body></methods><methods><class-id>UI.TreeViewIndentedLabelAndIcon</class-id> <category>bounds accessing</category><body package="UIBasics-Support" selector="bounds">bounds	| b |	b := self preferredBounds copyOld.	b height: (boundsHeight max: b height).	^b</body></methods><methods><class-id>UI.MacOSXComboBoxButtonView class</class-id> <category>class initialization</category><body package="UILooks-MacOSX" selector="initialize">initialize	"MacOSXComboBoxButtonView  initialize."	| maskPalette mbImg |	maskPalette := CoveragePalette monoMaskPalette.	mbImg := Image				extent: 16 @ 12				depth: 1				palette: maskPalette				bits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 15 248 0 0 7 240 0 0 3 224 0 0 1 192 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0]				pad: 32.	MenuButtonMask := CachedImage on: mbImg.	self initializeMasks.	TopPart := Image				extent: 22 @ 16				depth: 15				bitsPerPixel: 16				palette: (Graphics.FixedPalette						redShift: 10						redMask: 31						greenShift: 5						greenMask: 31						blueShift: 0						blueMask: 31)				usingBits: (ByteArray						fromPackedString: 'BSDILP$1BSDILP$1BSDILP$1BSDILP$1BSDILP$1BSDILP$1BSE;7''/^^=9N6%L\T11SGEL\T11SGEL\T11SGEL\T11SGEL\T11SGF\9H[PQK0$1IP17/TJYU/)V&gt;%[:U/)V&gt;%[:U/)V&gt;%[:U/)V&gt;%[:U/)V&gt;%[:U/)+V"V8BODD,W/^O''!F7D[\Q-1F7D[\Q-1F7D[\Q-1F7D[\Q-1F7D[\Q-1F7D[\K%(MM@B0R%H.E#):N''(:^#):N''(:^#):N''(:^#):N''(:^#):N''(:^#):N''(.N1EV@KEJT"WTL%$2VSIYL%$2VSIYL%$2VSIYL%$2VSIYL%$2VSIYL%$2VRW9DU\D&lt;$)RI]T2^3Y;L'',6^3I;M'',2^3I;L'',2^3I;L'',2^3Y;L'',6^3I;G]$U&amp;@$TR%H)=S*=N+4:/S*=N+4:/S*=N+4:/S*=N+4:/S*=N+4:/S*=N+4"F!''YCSUJT"''6N+8:/S*&gt;N+4:/#*=N+8:/S*&gt;N+4:/#*=N+8:/S*&gt;N+4:/"X:H_$QU$)RL!\&gt;7#;^O-8&gt;7#;^O-8&gt;7#;^O-8&gt;7#;^O-8&gt;7#;^O-8&gt;7#;^J%(&amp;F!E7R%H6^T\_Q1=GG4\_Q1=GG4\_Q1=GG4\_Q1=GG4\_Q1=GG4\_Q1&lt;.^"XZF[!JT#*YR3=KO4,?R3=KO4,?R3=KO4,?R3=KO4,?R3=KO4,?R3=KO3Z&gt;K''4Y.D)RO+)OW4=_S5=OW4=_S5=OW4=_S5=OW4=_S5=OW4=_S5=OW4=_M+8.WA&amp;8R%H&gt;6$=?S7=O_4=?S7=O_4=?S7=O_4=?S7=O_4=?S7=O_4=?S7&lt;:73J^H_%JT$KZT9=S''5N_T9=S''5N_T9=S''5N_T9=S''5N_T9=S''5N_T9=S''3;?M+&lt;!&gt;T)RQ/)W/5^?U;=W/5^?U;=W/5^?U;=W/5^?U;=W/5^?U;=W/5^?O1&lt;6/17XR%Hb').	MiddlePart := Image				extent: 22 @ 1				depth: 15				bitsPerPixel: 16				palette: (Graphics.FixedPalette						redShift: 10						redMask: 31						greenShift: 5						greenMask: 31						blueShift: 0						blueMask: 31)				usingBits: #[71 26 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 67 63 54 191 29 216 74 82]						copyOld.	BottomPart := Image				extent: 22 @ 3				depth: 15				bitsPerPixel: 16				palette: (Graphics.FixedPalette						redShift: 10						redMask: 31						greenShift: 5						greenMask: 31						blueShift: 0						blueMask: 31)				usingBits: #[75 59 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 67 63 46 126 29 216 74 82 67 25 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 107 90 46 88 74 82 123 222 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 74 82 127 255 127 255]						copyOld.	#(#TopPart #MiddlePart #BottomPart) do: 			[:sym |			self asNameSpace at: sym				put: (Graphics.CachedImage on: (self asNameSpace at: sym) rendered: nil)].	self initializeCaches.	MacOSXMenuButtonView initializeCaches</body></methods><methods><class-id>UI.TreeView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayElement:on:forBounds:">displayElement: i on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component childGC |	component := (self isSelected: i)				ifTrue: [self selectedVisualComponentForElementIndex: i]				ifFalse: [self visualComponentForElementIndex: i].	"This is perverse, but now that we're actually going to display the component, 	 we need to fish back into the TreeNodeWrapper and set the cached lastLabel	 so we can detect clicks on the expand/contract icons."	component component treeNodeWrapper		ifNotNil: [:node | node lastLabel: component bottomComponent].	component bounds: elementBounds.	(targetIndex = i and: [self hasFocus])		ifTrue: [component component highlighted setValue: true].	self displayBackgroundOn: aGraphicsContext in: elementBounds.	displayingObject := sequence at: i.	childGC := aGraphicsContext copyOld.	childGC lineGrid: self lineGrid.	component displayOn: childGC.	displayingObject := nil</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>private - scrolling</category><body package="Interface-Support" selector="scrollBy:on:grid:">scrollBy: pointToMove on: aGraphicsContext grid: grid	"Scroll the receiver by pointToMove modulo the grid." 	| clippingBox moveBox copyGC rects t |	clippingBox := self clippingBounds intersect: aGraphicsContext clippingBounds.	moveBox := clippingBox copyOld.	(pointToMove x abs &gt;= clippingBox width or: [pointToMove y abs &gt;= clippingBox height])		ifTrue: [^self redisplayRectangle: self compositionBounds on: aGraphicsContext].	"Copy the display contents that have just shifted, reshowing only         part that is dragged into view."	"We assume that the post-scrolling clipping bounds can be	smaller than the pre-scrolling clipping bounds only at the	edge being scrolled in.  That is, if we're scrolling forwards,	only the end of the component's translated bounds can be	truncated.  If we're scrolling backwards, only the beginning	of the translated bounds can be truncated.  Because of that	assumption, we rule out the possibility that the move box	calculation (based on the post-scrolling clipping bounds) can	cause invalid display contents to be copied."	moveBox := (clippingBox translatedBy: pointToMove) intersect: clippingBox.	copyGC := aGraphicsContext copyOld.	copyGC intersectClip: clippingBox.	"Do no reporting of the damage cause by the following copyArea action."	t := self topComponent.	t isNil ifFalse: [t sensor skipNextDamage]. 	rects := copyGC				copyArea: moveBox				from: copyGC				sourceOffsetX: 0 y: 0				destinationOffsetX: pointToMove x negated y: pointToMove y negated.	1 to: rects size do:		[:i |		self redisplayRectangle: (rects at: i) on: copyGC].	"Display lines pulled into view."	rects := self compositionBounds areasOutside: (moveBox translatedBy: pointToMove negated).	1 to: rects size do:		[:i |		self redisplayRectangle: (rects at: i) on: aGraphicsContext].	"Restore the skipNextDamage flag."	t isNil ifFalse: [t sensor skipNextDamageNot]</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>private</category><body package="Interface-Support" selector="redisplayRectangle:on:">redisplayRectangle: aRectangle on: aGraphicsContext	"Redisplay the rectangle aRectangle in the receiver on aGraphicsContext."	| gc |	gc := aGraphicsContext copyOld.	gc intersectClip: aRectangle.	gc paint: self backgroundColor.	gc displayRectangle: aRectangle.	gc paint: self foregroundColor.	self displayOn: gc</body></methods><methods><class-id>UI.MultiSelectionTreeView</class-id> <category>private</category><body package="UIBasics-Components" selector="resetSelections">resetSelections	| oldSelections |  	oldSelections := selections copyOld.	oldSelections do: [:each| self retractSelectionIndex: each].	selectionIndex := self zeroIndex.</body></methods><methods><class-id>UI.NamedFontSelector</class-id> <category>notification</category><body package="Interface-Support" selector="showNamedFontAttributes">showNamedFontAttributes	"Update font for text style selection."	| textStyle targetSelection |	textStyle := TextAttributes styleNamed: styleNames selection				ifAbsent: [^self disableNamedFontButtons].	self textAttributesHolder value: (textStyle copyOld 				setCharacterAttributes: textStyle characterAttributes copyOld).	self fontDescriptionHolder value: self fontDescription copyOld.	targetSelection := self allFonts list 				detect: [:each | each = self fontDescription family]				ifNone: [nil].	self allFonts selection: targetSelection.	self fontSizes 		value: (fontDictionary at: targetSelection ifAbsent: [1 to: 72]).	self setSystemFontSample.	self enableNamedFontButtons</body></methods><methods><class-id>UI.NamedFontSelector</class-id> <category>private</category><body package="Interface-Support" selector="unalteredFont">unalteredFont	^(self unalteredTextAttributes characterAttributes defaultQueryFor: nil) copyOld</body></methods><methods><class-id>UI.NamedFontSelector</class-id> <category>private</category><body package="Interface-Support" selector="setUserFontSample">setUserFontSample	| view userFontLabel |	view := self widgetAt: #userTextField.	userFontLabel := self widgetAt: #userFontLabel.		[view textStyle: (self textAttributes copyOld alignment: 2).	view invalidate.	userFontLabel labelString: self textAttributes currentFont fontDescription family.	(self wrapperAt: #assignToNamedFont) enable]			on: FontPolicy noMatchingFontSignal			do: 				[:ex |				view textStyle: nil.				view flash.				userFontLabel labelString: #fontNotFound &lt;&lt; #dialogs &gt;&gt; 'No font match'.				(self wrapperAt: #assignToNamedFont) disable.				ex return]</body></methods><methods><class-id>UI.BorderDecorator</class-id> <category>accessing</category><body package="UIBasics-Support" selector="useLocalEdgeDecorationPolicy">useLocalEdgeDecorationPolicy	"We want to make local modifications to the receiver's policy.  Break sharing"	policy == nil		ifTrue:	[policy := self edgeDecorationPolicy copyOld].</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="foregroundColor:">foregroundColor: aColor	"Answer a copy of the receiver with a new foreground color."	^self copyOld at: #foregroundColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="backgroundColor:">backgroundColor: aColor	"Answer a copy of the receiver with a new background color."	^self copyOld at: #backgroundColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="borderColor:">borderColor: aColor	"Answer a copy of the receiver with a new border color."	^self copyOld at: #borderColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="hiliteColor:">hiliteColor: aColor	"Answer a copy of the receiver with a new hilite color."	^self copyOld at: #hiliteColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="selectionForegroundColor:">selectionForegroundColor: aColor	"Answer a copy of the receiver with a new selection foreground color."	^self copyOld at: #selectionForegroundColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="shadowColor:">shadowColor: aColor	"Answer a copy of the receiver with a new shadow color."	^self copyOld at: #shadowColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="selectionBackgroundColor:">selectionBackgroundColor: aColor	"Answer a copy of the receiver with a new selection background color."	^self copyOld at: #selectionBackgroundColor put: aColor</body></methods><methods><class-id>UI.ArbitraryView</class-id> <category>accessing</category><body package="Interface-Support" selector="display:in:on:">display: aValue in: box on: aGraphicsContext	"Compatibility with Aragon's dataset."		aValue		displayOn: aGraphicsContext copyOld		at: box center - (aValue preferredBounds extent half)</body></methods><methods><class-id>UI.ColorPreferencesDictionary</class-id> <category>private</category><body package="Interface-Support" selector="postCopy">postCopy	preferences := preferences copyOld.	constantCodeArray := constantCodeArray copyOld</body></methods><methods><class-id>UI.MouseEvent</class-id> <category>accessing</category><body package="Interface-Events" selector="translatedBy:">translatedBy: aPoint	^self copyOld translateBy: aPoint</body></methods><methods><class-id>UI.MotifMenuBarButtonView</class-id> <category>displaying</category><body package="UILooks-Motif" selector="displayOn:">displayOn: aGraphicsContext	"Display the receiver according to	the current state of the model."		| box border offset newGraphicsContext |	self isVisible ifFalse: [^self].	self isInTransition		ifFalse: [^self displayUndecoratedOn: aGraphicsContext].	box := self bounds.	border := BeveledBorder raised.	offset := 0 @ 0.	border displayOn: aGraphicsContext forDisplayBox: box using: self.	box := border insetDisplayBoxFor: box.	label == nil ifTrue: [^self].	offset := box center - (label bounds extent half) + offset.	self setPaintOn: aGraphicsContext.	newGraphicsContext := aGraphicsContext copyOld intersectClip: box.	label displayOn: newGraphicsContext at: offset</body></methods><methods><class-id>UI.PropertyListDictionary</class-id> <category>copying</category><body package="UIBuilder-Support" selector="postCopy">postCopy	super postCopy.	valueArray keysAndValuesDo: 		[:index :value |		valueArray at: index put: (valueArray at: index) copyOld]</body></methods><methods><class-id>UI.IndentedTreeSelectionInList</class-id> <category>private</category><body package="UIBasics-Collections" selector="addChild:indentLevel:parent:">addChild: aChild indentLevel: indentLevel parent: parent	"Add aChild to the the receiver's indented list at indentLevel."	| assocTree children |	children := self childrenFor: aChild.	assocTree := (AssociationTreeWithParentWithIndents key: aChild value: indentLevel)		parent: parent ;		children: children asOrderedCollection.	aChild == self root ifFalse:		[assocTree displayableIndents: parent displayableIndents copyOld.		parent children isEmpty ifFalse:			[(aChild = parent children last ) ifFalse:				[assocTree displayableIndents add: indentLevel]].		self cachedObjects add: (assocTree).							self listHolder value add: (self nameFor: aChild indentLevel: indentLevel)].	(self isOpen: aChild) ifTrue: 		[children notNil ifTrue:			[children do: 				[:child | self addChild: child indentLevel: indentLevel + 1 parent: assocTree]]]</body></methods><methods><class-id>UI.LookPreferences class</class-id> <category>class initialization</category><body package="Interface-Support" selector="initializeBordersAndInsets">initializeBordersAndInsets	"LookPreferences initializeBordersAndInsets."	|  dmono |	dmono := Border new.	dmono setBorderColor: ColorValue white.	dmono setBorderWidth: 1.		dmono setBottomColor: ColorValue black.	dmono setRightColor: ColorValue black.	DefaultBorder := Array with: dmono with: dmono copyOld with: dmono copyOld.	DecoratedViewLayout := SmalltalkBorderDecorationPolicy new.	WidgetTypePolicy := SmalltalkWidgetPolicy new.</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - editing</category><body package="Interface-Commands" selector="copyCommand">copyCommand	&lt;command: #copyOld&gt;	^Command			label: (#Copy &lt;&lt; #labels &gt;&gt; 'Copy')			bindings: #(				#isMacOSX #(command C)				#isMSWindows #(ctrl C)				#isX11 #(ctrl C)			)</body></methods><methods><class-id>UI.MenuItem</class-id> <category>copying</category><body package="Interface-Menus" selector="postCopy">postCopy	"Finish doing whatever is required, beyond a shallowCopy, to implement 'copy'. Answer the receiver."	super postCopy.	adornment := adornment copyOld.	^self</body></methods><methods><class-id>UI.ReversingWrapper</class-id> <category>displaying</category><body package="UIBasics-Support" selector="displayOn:">displayOn: aGraphicsContext	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses."	reverse value		ifTrue: [|gc box |				box := container == nil					ifTrue: [self bounds]					ifFalse: [container compositionBoundsFor: self].				box left: box left + offset.				gc := aGraphicsContext copyOld.				self displayReversedBackgroundIn: box on: gc.				super displayOn: gc]		ifFalse: [super displayOn: aGraphicsContext]</body></methods><methods><class-id>UI.Notice</class-id> <category>aspects</category><body package="Interface-Support" selector="textView">textView	"Create a view for holding a mini-transcript of messages."	| tView fDescription tAttributes |	messages := TextCollector new.	messages onChangeSend: #changedMessages to: self.	tView := TextCollectorView new model: messages.	fDescription := tView textStyle defaultFont copyOld.	fDescription pixelSize: 13.	tAttributes := TextAttributes defaultFontQuery: fDescription.	tAttributes gridForFont: nil withLead: 2.	tView textStyle: tAttributes.	^tView</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>private</category><body package="TextHighlighting" selector="startHighlighting:">startHighlighting: delay 	| uiPriority |	self stopHighlighting.	uiPriority := Processor activePriority.	highlightingProcess := 			[| win event localText |			(Delay forMilliseconds: delay) wait.			"Forked process highlights copied text.  Highlighting is placed			 in an error wrapper to avoid throwing exceptions."			localText := self highlighters asSortedCollection inject: self text into:							[:highlightedText :textHighlighter |							[textHighlighter highlight: highlightedText copyOld]								on:	Error								do:	[:ex |									self class ignoreErrors ifFalse: [ex pass].									Transcript show: (#HighlighterException1p2p &lt;&lt; #browser &gt;&gt; 'Highlighter Exception:  highlighter=&lt;1p&gt;, error=&lt;2p&gt;.&lt;n&gt;'															expandMacrosWith: textHighlighter with: ex messageText).									ex return: highlightedText]].			"WindowManager process moves result to UI"			event := 					[localText string = self text string 						ifTrue: 							[self displayWithHighlightedText: localText							"self text setString: self text string setRuns: localText runs.							self view resetSelections.							self view invalidateRectangle: self view bounds repairNow: true"]].						[win := view ifNotNil: [:v | v topComponent].			(win notNil and: [win isInvalid not and: [win isOpen and:[win windowManager notNil]]]) 				ifTrue: [event uiEventFor: win]] 					valueAtPriority: uiPriority	"so window cannot be closed during this block"] 					forkAt: uiPriority - 1</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>private</category><body package="TextHighlighting" selector="displayWithHighlightedText:">displayWithHighlightedText: localText 	| interval oldBounds newBounds selectionShowing start stop |	(selectionShowing := view selectionShowing) 		ifTrue: 			["if something is selected, remember what and deselect"			"NOTE! if no deselect happens, then the selection is displayed at a wrong offset,			so when the selection is drawn again at the end of the method, there may be some			strange text-fragment next to the new selection, which looks ugly"			start := self selectionStartIndex copyOld.			stop := self selectionStopIndex copyOld.			view deselect].	interval := self getIntervalForUpdateFromOriginal: self text				withNew: localText.	oldBounds := view boundsOfInterval: interval.	self text setString: self text string setRuns: localText runs.	newBounds := view boundsOfInterval: interval.	view invalidateRectangle: (oldBounds merge: newBounds) repairNow: true.	selectionShowing 		ifTrue: 			["if something has been selected, select it again and show that"			view selectFrom: start to: stop.			view selectAndScroll]		ifFalse: [view selectAt: self selectionStartIndex]</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>accessing</category><body package="TextHighlighting" selector="menu">menu	(selectable and: [readOnly and: [super menu = TextEditorYellowButtonMenu]])		ifTrue: [^self class readOnlyGroup].	^self highlighters inject: super menu copyOld into: [:menu :highlighter | highlighter modifyContextMenu: menu for: self]</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="labelKeyID:">labelKeyID: aSymbol 	| labelThing |	self suppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifTrue: [labeledValueHolder value label: self labelDefaultString]		ifFalse: 			[labelThing := labeledValueHolder value label.			labeledValueHolder value 				label: ((labelThing isString or: [labelThing == nil]) 						ifTrue: [aSymbol &gt;&gt; labelThing]						ifFalse: [labelThing copyOld key: aSymbol])].	self changed: #value</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="labelDefaultString:">labelDefaultString: aString 	| labelThing trimmed |	labelThing := labeledValueHolder value label.	trimmed := aString trimBlanks.	labeledValueHolder value 		label: ((labelThing isString or: [labelThing == nil]) 				ifTrue: 					[(parentBuilderBlock value aspectAt: #labelFromApplication) value 						ifTrue: [trimmed asSymbol]						ifFalse: [trimmed]]				ifFalse: [labelThing copyOld &gt;&gt; trimmed]).	self changed: #value</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="labelMessageSelector:">labelMessageSelector: aSymbol 	| labelThing |	self suppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifFalse: 			[labelThing := labeledValueHolder value label.			labeledValueHolder value 				label: ((labelThing isString or: [labelThing == nil]) 						ifTrue: 							[(UserMessage new)								defaultString: labelThing;								catalogID: aSymbol;								yourself]						ifFalse: [labelThing copyOld &lt;&lt; aSymbol])].	self changed: #value</body></methods><methods><class-id>UI.Border</class-id> <category>displaying</category><body package="Interface-Support" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRectangle using: colorSource	"Display the receiver's borders in the specified display box.  If colorSource	is non-nil, it may be consulted for the values of the border colors using LookPreferences	accessing protocol (#hiliteColor, #shadowColor, etc.)."	"Be sure not to permanently side-effect the supplied GraphicsContext."	| dBox r clipRectangle paint oldPaint edge |	clipRectangle := aGraphicsContext clippingBounds.	((self insetDisplayBoxFor: aRectangle) contains: clipRectangle) ifTrue: [^self].	oldPaint := aGraphicsContext paint.	dBox := aRectangle.	r := dBox copyOld.	((edge := self top) == 0 or: [(paint := self topColor) == nil]) ifFalse: [		r bottom: dBox top + edge.		r left: r left + self left.		(r intersects: clipRectangle) ifTrue: [			aGraphicsContext paint: paint; displayRectangle: r].		r bottom: dBox bottom.		r left: dBox left].	((edge := self right) == 0 or: [(paint := self rightColor) == nil]) ifFalse: [		r left: dBox right - edge.		r top: r top + self top.		r bottom: r bottom - self bottom.		(r intersects: clipRectangle) ifTrue: [			aGraphicsContext paint: paint; displayRectangle: r].		r left: dBox left.		r top: dBox top.		r bottom: dBox bottom].	((edge := self bottom) == 0 or: [(paint := self bottomColor) == nil]) ifFalse: [		r top: dBox bottom - edge.		r left: r left + self left.		(r intersects: clipRectangle) ifTrue: [			aGraphicsContext paint: paint; displayRectangle: r].		r top: dBox top.		r left: dBox left].	((edge := self left) == 0 or: [(paint := self leftColor) == nil]) ifFalse: [		r right: dBox left + edge.		(r intersects: clipRectangle) ifTrue: [			aGraphicsContext paint: paint; displayRectangle: r]].	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.Border</class-id> <category>display box accessing</category><body package="Interface-Support" selector="insetDisplayBoxFor:">insetDisplayBoxFor: aRectangle	"Answer an inset display box for aRectangle based on the receiver's	edge widths."	| iBox |	iBox := aRectangle copyOld.	iBox left: iBox left + self left.	iBox right: iBox right - self right.	iBox top: iBox top + self top.	iBox bottom: iBox bottom - self bottom.	^iBox</body></methods><methods><class-id>UI.Border</class-id> <category>display box accessing</category><body package="Interface-Support" selector="displayBoxFor:">displayBoxFor: anInnerRectangle	"Answer a display box for anInnerRectangle based on the receiver's	edge widths. This is the inverse of #insetDisplayBoxFor:"	| oBox |	oBox := anInnerRectangle copyOld.	oBox left: oBox left - self left.	oBox right: oBox right + self right.	oBox top: oBox top - self top.	oBox bottom: oBox bottom + self bottom.	^oBox</body></methods><methods><class-id>UI.RowVisualComposite</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="displayOn:">displayOn: aGraphicsContext	"Display frozen columns (if any) from the left edge of aGraphicsContext. 	Then temporarily set the clipping bounds to the right edge of the last 	frozen column and display the remaining columns starting at position 	frozenTranslation. 	Skip display for the column descriptor set to inhibit"	| clippingBounds originalClippingBounds frozenColumn left right clipLeft |	frozen = 0		ifTrue: [left := self bounds left]		ifFalse: 			[left := container bounds left.			frozenColumn := descriptors at: frozen].	clippingBounds := aGraphicsContext clippingBounds.	originalClippingBounds := clippingBounds copyOld.	descriptors with: components		do: 			[:descriptor :visualComponent |			right := left + descriptor width.			inhibit ~~ descriptor				ifTrue: 					[| box elementBox |					elementBox := left @ bounds top corner: right @ bounds bottom.					box := elementBox insetBy: self cellInset.					visualComponent bounds: (box moveBy: descriptor offset).					visualComponent bounds left &lt; right						ifTrue: 							[| graphicsContext |							graphicsContext := aGraphicsContext copyOld.							graphicsContext clippingRectangle: clippingBounds.							graphicsContext intersectClip: elementBox.							visualComponent displayOn: graphicsContext.							self displayAdornment: visualComponent of: descriptor on: graphicsContext]].			left := right.			descriptor = frozenColumn				ifTrue: 					[clipLeft := (left max: clippingBounds left).					clippingBounds left: clipLeft.					aGraphicsContext clippingRectangle: clippingBounds.					left := self bounds left]].	aGraphicsContext clippingRectangle: originalClippingBounds</body></methods><methods><class-id>UI.InputState</class-id> <category>utilities</category><body package="OS-Window System" selector="copyEvent:">copyEvent: anEvent 	"Copy the raw event sent up by the VM. Copy as well any fields whose values 	are mutable and would therefore be lost when the next event overwrites 	'anEvent'"	| copy |	copy := anEvent copyOld.	copy at: 10 put: (self hostEventFrom: anEvent).	^copy</body></methods><methods><class-id>UI.InputState</class-id> <category>utilities</category><body package="OS-Window System" selector="hostEventFrom:">hostEventFrom: anEvent 	"Copy the host event field of anEvent. If we understand how to cast the event to 	a structure, do so"	^(anEvent at: 10) copyOld</body></methods><methods><class-id>UI.WinXPLookPolicy</class-id> <category>building</category><body package="UILooks-WinXP" selector="changeColor:forSpec:">changeColor: colors forSpec: spec	(spec isKindOf: TabControlSpec) ifFalse: [^super changeColor: colors forSpec: spec].	^colors isNil		ifTrue: [LookPreferences new backgroundColor: SymbolicPaint scrollbarBackground]		ifFalse: [colors backgroundColor isNil				ifTrue: [colors copyOld backgroundColor: SymbolicPaint scrollbarBackground]				ifFalse: [colors]]</body></methods><methods><class-id>UI.WinXPLookPolicy class</class-id> <category>private</category><body package="UILooks-WinXP" selector="menuName">menuName	^(#WinXP &lt;&lt; #menus &gt;&gt; 'Windows XP') copyOld</body></methods><methods><class-id>UI.TreeNodeWrapper</class-id> <category>private</category><body package="UIBasics-Support" selector="refreshChildrenInTreeModel:">refreshChildrenInTreeModel: aTreeModel 	"If we find old child which is still there. Reuse its opened state and if it's closed then discard its cached children"	| oldChildren |	oldChildren := children copyOld.	children := nil.	aTreeModel childrenNodesForNode: self.	(oldChildren isNil or: [oldChildren isEmpty]) ifTrue: [^self].	children do: 		[:each | 		| oldChild |		oldChild := oldChildren 			detect: [:eachChild | eachChild value = each value]			ifNone: [nil].		oldChild ifNotNil: 			[each openedChildren: oldChild openedChildren.			each children: oldChild children]]</body></methods><methods><class-id>UI.Win95Border</class-id> <category>private-displaying</category><body package="UILooks-MSWin" selector="displayFrameOn:in:paint1:paint2:">displayFrameOn: aGraphicsContext in: rect paint1: paint1 paint2: paint2 	"Private - Display a frame in rect using paint1 for left and top	and paint2 for bottom and right sides of the frame."	aGraphicsContext		paint: paint1;		displayRectangle: (rect copyOld right: rect left + 1);		displayRectangle: (rect copyOld bottom: rect top + 1);		paint: paint2;		displayRectangle: (rect copyOld top: rect bottom - 1);		displayRectangle: (rect copyOld left: rect right - 1)</body></methods><methods><class-id>UI.Win95Border</class-id> <category>displaying</category><body package="UILooks-MSWin" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRect using: colorSource 	"Display the receiver's borders in the specified display box. If colorSource 	is non-nil, it may be consulted for the values of the border colors using LookPreferences 	accessing protocol (#hiliteColor, #shadowColor, etc.). 	Be sure not to permanently side-effect the supplied GraphicsContext."	thickness = 0 ifTrue: [^self].	((self insetDisplayBoxFor: aRect)		contains: aGraphicsContext clippingBounds)		ifTrue: [^self].	type == #raised1 ifTrue: [^self			displayRaised1On: aGraphicsContext copyOld			forDisplayBox: aRect			using: colorSource].	type == #raised2 ifTrue: [^self			displayRaised2On: aGraphicsContext copyOld			forDisplayBox: aRect			using: colorSource].	type == #inset ifTrue: [^self			displayInsetOn: aGraphicsContext copyOld			forDisplayBox: aRect			using: colorSource].	type == #thinInset ifTrue: [^self			displayThinInsetOn: aGraphicsContext copyOld			forDisplayBox: aRect			using: colorSource].	type == #thinRaised ifTrue: [^self			displayThinRaisedOn: aGraphicsContext copyOld			forDisplayBox: aRect			using: colorSource]</body></methods><methods><class-id>UI.UIDispatcher class</class-id> <category>constants</category><body package="UIBasics-Support" selector="vacuousDispatcher">vacuousDispatcher	^VacuousTranslator copyOld</body></methods><methods><class-id>UI.MotifMenuItemView</class-id> <category>displaying-private</category><body package="UILooks-Motif" selector="displayLabelOn:in:selected:">displayLabelOn: aGraphicsContext in: theMenuItemBox selected: isSelected	"Display the label of the menu item on aGraphicsContext inside theMenuItemBox.  isSelected indicates if the menu item is to be displayed in it's selected 'highlighted' state."	| theComposedLabel verticalPosition theLabelImage labelGraphicsContext |	theLabelImage := model labelImage.	theLabelImage ~~ nil ifTrue: [		| imageBounds imageVerticalPosition |		imageBounds := theLabelImage bounds.		imageVerticalPosition := (theMenuItemBox height - imageBounds height) // 2.		theLabelImage			displayOn: aGraphicsContext 			at: self defaultLabelIndent @ imageVerticalPosition].	theComposedLabel := self composedLabel.	verticalPosition := (theMenuItemBox height - theComposedLabel height) // 2 + 1.	labelGraphicsContext := aGraphicsContext copyOld		translateBy: menuView commonTextIndent @ verticalPosition.	theComposedLabel displayOn: labelGraphicsContext.	accessIndicator == nil ifFalse: [		labelGraphicsContext lineWidth: accessIndicatorThickness.		accessIndicator displayStrokedOn: labelGraphicsContext].</body></methods><methods><class-id>UI.UIBuilder</class-id> <category>adding</category><body package="UIBuilder-Framework" selector="addCollection:">addCollection: aCollection	"Add all the specs in aCollection, embedding copies of them in the 	resulting SpecWrappers."	| wrappers |	wrappers := OrderedCollection new.	aCollection do:		[:s |		self add: s copyOld.		wrappers add: wrapper].	component := nil.	^wrappers</body></methods><methods><class-id>UI.ControlManager</class-id> <category>private</category><body package="Interface-Framework" selector="hasPendingEvents">hasPendingEvents	^(scheduledControllers copyOld 		detect:			[:each | 			[each sensor hasEvents]				on: self class closedWindowSignal				do: [:ex | ex return: false]]		ifNone: [nil]) notNil</body></methods><methods><class-id>UI.TreeNodeVisualWrapper</class-id> <category>displaying</category><body package="UIBasics-Support" selector="displayOn:">displayOn: aGraphicsContext 	"Display the receiver on aGraphicsContext. The receiver may alter 	aGraphicsContext in any way it chooses."	| box textBox oldPaint gc textWidth |	gc := aGraphicsContext copyOld.	gc intersectClip: self bounds.	gc translateBy: origin.	oldPaint := gc paint.	box := container isNil		ifTrue: [self bounds]		ifFalse: [container compositionBoundsFor: self].	textWidth := component measureTextOn: gc.	textBox := Rectangle origin: box left + self offset - 1 @ box top corner: textWidth + 1 @ box bottom.	selected value ifTrue: 		[gc paint: self selectionBackgroundColor.		component fullLineSelect			ifTrue: [gc displayRectangle: box ]			ifFalse: [gc displayRectangle: (textBox insetBy: 1)].		gc paint: self selectionForegroundColor].	highlighted value ifTrue: 		[gc paint: SymbolicPaint traversalHilite.		component fullLineSelect			ifTrue: [(box origin extent: box extent - 1) displayStrokedOn: gc]			ifFalse: [(textBox origin extent: textBox extent - 1) displayStrokedOn: gc].		gc paint: self selectionForegroundColor].	(highlighted value and: [selected value not]) ifTrue: 		[gc paint: oldPaint].	self component displayOn: gc</body></methods><methods><class-id>UI.BeveledBorder</class-id> <category>displaying</category><body package="UIBasics-Support" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRectangle using: colorSource	"Display the receiver's borders in the specified display box.  If colorSource	is non-nil, it may be consulted for the values of the border colors using LookPreferences	accessing protocol (#hiliteColor, #shadowColor, etc.)."	"Be sure not to permanently side-effect the supplied GraphicsContext."	| dBox r clipRectangle paint oldPaint  paintSet|	clipRectangle := aGraphicsContext clippingBounds.	((self insetDisplayBoxFor: aRectangle) contains: clipRectangle) ifTrue:		[^self].	oldPaint := aGraphicsContext paint.	dBox := aRectangle.	r := dBox copyOld.	paint := self topPaintFor: colorSource.	r right: r left + thickness.	paintSet := false.	(r intersects: clipRectangle) ifTrue:		[paintSet := true. aGraphicsContext paint: paint; displayRectangle: r].	r right: dBox right.	r bottom: r top + thickness.	(r intersects: clipRectangle) ifTrue:		[paintSet ifFalse: [aGraphicsContext paint: paint].		aGraphicsContext displayRectangle: r].	paint := self bottomPaintFor: colorSource.	paintSet := false.	r top: r bottom.	r bottom: dBox bottom.	r left: r right - thickness.	(r intersects: clipRectangle) ifTrue:		[paintSet := true.		aGraphicsContext paint: paint; displayRectangle: r].	r top: r top - 1.	r bottom: r top + 1.	r left: r left + 1.	(r intersects: clipRectangle) ifTrue:		[paintSet ifFalse:			[paintSet := true.			aGraphicsContext paint: paint].		aGraphicsContext displayRectangle: r].	r right: r left - 1.	r left: dBox left + thickness.	r bottom: dBox bottom.	r top: r bottom - thickness.	(r intersects: clipRectangle) ifTrue:		[paintSet ifFalse:			[paintSet := true.			aGraphicsContext paint: paint].		aGraphicsContext displayRectangle: r].	r left: r left - 1.	r right: r left + 1.	r top: r top + 1.	(r intersects: clipRectangle) ifTrue:		[paintSet ifFalse:			[paintSet := true.			aGraphicsContext paint: paint].		aGraphicsContext displayRectangle: r].	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.DocumentEditor</class-id> <category>actions - editing</category><body package="UIBasics-Text2" selector="insertParagraphSeparator">insertParagraphSeparator	&lt;state: #active key: #Enter&gt;	| node |	node := document nodeAtPositionBefore: self paragraphStartPosition ifAbsent: [		self insert: (String with: (Character codePoint: 16r2029)).		^self endCurrentEdit].	node value class = Text2.DocumentSpan ifFalse: [		self insertDocument: node value copyOld.		^self endCurrentEdit].	self insert: (String with: (Character codePoint: 16r2029)).	self endCurrentEdit</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>mouse tracking</category><body package="UIPainter" selector="mouseMovedTo:">mouseMovedTo: aPoint	"Selection continues at relative point aPoint."	| oldBounds newBounds redisplayBounds gc |	gc := self editMask graphicsContext.	geometricInProgress notNil ifTrue: [ 		oldBounds := geometricInProgress bounds copyOld.		newBounds := Rectangle vertex: originInProgress vertex: (self geometricConstrain: aPoint).		redisplayBounds := oldBounds merge: newBounds. 	].  	mode == #fill ifTrue: [^self]. 	mode == #rectangle ifTrue: [		geometricInProgress origin: newBounds origin corner: newBounds corner.		gc clear.		undoBuffer displayOn: gc.		gc paint: coveragePaint. 		geometricInProgress displayFilledOn: gc. 	].	mode == #ellipse ifTrue: [		geometricInProgress setBoundingBox: newBounds startAngle: 0 sweepAngle: 360. 		gc clear.		undoBuffer displayOn: gc.		gc paint: coveragePaint. 		geometricInProgress displayFilledOn: gc. 	].	mode == #brush ifTrue: [		| constrainedPoint |		gc paint: coveragePaint. 		constrainedPoint := self brushConstrain: aPoint. 		self brushStrokeOn: gc from: originInProgress to: constrainedPoint.		redisplayBounds := (originInProgress extent: brush extent) merge: (constrainedPoint extent: brush extent).		originInProgress := constrainedPoint. 	]. 	view simpleRedisplayIn: redisplayBounds colorBackgroundIfNeeded: (view backdrop isNil).</body></methods><methods><class-id>UI.InputBoxController</class-id> <category>accessing</category><body package="UIBasics-Controllers" selector="stringValue">stringValue	^self text string copyOld</body></methods><methods><class-id>UI.TableView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayElement:on:forBounds:">displayElement: i on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component gc x y |	component := self visualComponentForElementIndex: i.	component bounds: elementBounds.	gc := aGraphicsContext copyOld.	(self isSelected: i)		ifTrue: [strokedSelection 					ifTrue: [	x := showCGrid ifTrue: [1] ifFalse: [0].							y := showRGrid ifTrue: [1] ifFalse: [0].							component displayOn: gc copyOld.							gc paint: SymbolicPaint foreground.							gc lineWidth: 2.							gc displayInteriorRectangularBorder: (elementBounds insetBy: (0@0 corner: x@y))]					ifFalse: [ self isOptimized							ifTrue: [ 								gc paint: self selectionBackgroundColor.								gc displayRectangle: elementBounds.								gc paint: self selectionForegroundColor.								component displayOn: gc]							ifFalse: [ 								gc paint: (self selectionBackgroundColorAtIndex: i).								gc displayRectangle: elementBounds.								gc paint: (self selectionForegroundColorAtIndex: i).								component displayOn: gc]]]		ifFalse: [self isOptimized ifFalse: [ gc paint: (self foregroundColorAtIndex: i)].				component displayOn: gc].</body></methods><methods><class-id>UI.TableView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayNormalElement:on:forBounds:">displayNormalElement: index on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component |	component := self visualComponentForElementIndex: index.	component bounds: elementBounds.	component displayOn: aGraphicsContext copyOld</body></methods><methods><class-id>UI.TabControlBarView</class-id> <category>private-displaying</category><body package="UIBasics-Components" selector="displayVisual:index:on:forBounds:">displayVisual: component index: i on: aGraphicsContext forBounds: elementBounds 	"Private - Display the receiver's content on aGraphicsContext and make sure it is pretty much centered"	| isSelected computedOffset |	isSelected := i = self selectionIndex.	computedOffset := component preferredBounds height &lt; elementBounds bottom 				ifFalse: [0]				ifTrue: [((elementBounds bottom - component preferredBounds height) / 2) rounded - 1].	component bounds: (elementBounds insetBy: (6 @ computedOffset extent: -6 @ computedOffset negated)).	aGraphicsContext paint: self foregroundColor.	component displayOn: aGraphicsContext copyOld.	(self hasFocus and: [isSelected]) ifFalse: [^self].	self displayTravsersalHighlightIn: elementBounds on: aGraphicsContext</body></methods><methods><class-id>UI.TabControlBarView</class-id> <category>private-displaying</category><body package="UIBasics-Components" selector="displayBorderOn:bounds:index:">displayBorderOn: aGraphicsContext bounds: bounds index: index 	"Private - Display the border of label with index i on aGraphicsContext."	| box showLeftBorder |	box := bounds copyOld.	showLeftBorder := self selectionIndex + 1 ~= (tabOffset + 1 == index 		ifTrue: [0] 		ifFalse: [index]).	aGraphicsContext paint: SymbolicPaint hilite.	showLeftBorder ifTrue: 		[aGraphicsContext displayRectangle: (box topLeft + (0 @ 2) extent: 1 @ (box height - 3)).		aGraphicsContext displayRectangle: (box topLeft + (1 @ 1) extent: 1 @ 1)].	aGraphicsContext displayRectangle: (box topLeft + (2 @ 0) extent: (box width - 4) @ 1).	showLeftBorder ifTrue: [aGraphicsContext displayRectangle: (box topLeft + (1 @ 2) extent: 1 @ (box height - 3))].	aGraphicsContext displayRectangle: (box topLeft + (2 @ 1) extent: (box width - 4) @ 1).	aGraphicsContext paint: SymbolicPaint shadow.	aGraphicsContext displayRectangle: (box topRight + (-2 @ 2) extent: 1 @ (box height - 4)).	aGraphicsContext displayRectangle: (box topRight + (-2 @ 1) extent: 1 @ 1).	aGraphicsContext displayRectangle: (box topRight + (-1 @ 2) extent: 1 @ (box height - 4))</body></methods><methods><class-id>UI.WinXPGroupBox</class-id> <category>private</category><body package="UILooks-WinXP" selector="displayBorderOn:">displayBorderOn: aGraphicsContext	| borderRectangle |	borderRectangle := self  bounds copyOld.	borderRectangle top: borderRectangle top + (self labelHeight // 2).	borderRectangle right: borderRectangle right - 1.	borderRectangle bottom: borderRectangle bottom - 1.	self border displayOn: aGraphicsContext forDisplayBox: borderRectangle using: nil</body></methods><methods><class-id>UI.WindowEnterEvent</class-id> <category>accessing</category><body package="Interface-Events" selector="translatedBy:">translatedBy: aPoint	^self copyOld translateBy: aPoint</body></methods><methods><class-id>UI.MacOSXSliderView</class-id> <category>private</category><body package="UILooks-MacOSX" selector="displayBackgroundIfNeededOn:in:">displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle 	"Display the background of the window."	(aGraphicsContext copyOld) paint: aGraphicsContext paintPreferences backgroundColor; 				displayRectangle: aRectangle</body></methods><methods><class-id>UI.MenuItemAdornment</class-id> <category>copying</category><body package="Interface-Menus" selector="postCopy">postCopy	"Finish doing whatever is required, beyond a shallowCopy, to implement 'copy'. Answer the receiver."	super postCopy.	labelImage := labelImage copyOld.	submenu := submenu copyOld</body></methods><methods><class-id>UI.ProtocolAdaptor</class-id> <category>private</category><body package="Interface-Models" selector="renderingValueUsingSubject:">renderingValueUsingSubject: aSubject	| pair cpy cell |	subject isProtocolAdaptor ifFalse: [^self valueUsingSubject: aSubject].	cpy := self copyOld.	pair := Array new: 2.	pair at: 2 put: cpy.	cell := cpy makeAdaptorForRenderingStoreLeafInto: pair.	cell first subjectChannel: aSubject asValue.	^cell last value</body></methods><methods><class-id>UI.ProtocolAdaptor</class-id> <category>private</category><body package="Interface-Models" selector="makeAdaptorForRenderingStoreLeafInto:">makeAdaptorForRenderingStoreLeafInto: pair	pair at: 1 put: self.	self subjectChannel: nil.	^(subject isProtocolAdaptor)		ifTrue: [subject := subject copyOld.				subject makeAdaptorForRenderingStoreLeafInto: pair]		ifFalse: [pair]</body></methods><methods><class-id>UI.WinXPVariableBorder</class-id> <category>displaying</category><body package="UILooks-WinXP" selector="displayFrameOn:in:paint1:paint2:">displayFrameOn: aGraphicsContext in: rect paint1: paint1 paint2: paint2 	"Private - Display a frame in rect "	| oldPaint |	oldPaint := aGraphicsContext paint.	aGraphicsContext paint: SymbolicPaint textDataBorder.	self hasLeft ifTrue: [aGraphicsContext displayRectangle: (rect copyOld right: rect left + 1)].	self hasTop ifTrue: [aGraphicsContext displayRectangle: (rect copyOld bottom: rect top + 1)].	self hasBottom ifTrue: [aGraphicsContext displayRectangle: (rect copyOld top: rect bottom - 1)].	self hasRight ifTrue: [aGraphicsContext displayRectangle: (rect copyOld left: rect right - 1)].	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.Scrollbar</class-id> <category>marker accessing</category><body package="UIBasics-Components" selector="moveMarker:">moveMarker: anInteger	"Update the marker so that it is translated by an amount corresponding to	a distance of anInteger, constrained within the boundaries of the scroll bar."	| old |	old := self marker copyOld.	self translateMarkerBy: anInteger.	self invalidateRectangle: (old merge: self marker)</body></methods><methods><class-id>UI.CompositeSpec</class-id> <category>accessing</category><body package="UIPainter" selector="savableSpecFor:">savableSpecFor: aComposite	| csc |	csc := CompositeSpecCollection new.	csc compositeSpec: self copyOld.	csc fromCollection: aComposite components.	^csc</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>building</category><body package="UIBuilder-Support" selector="dataSetView:into:">dataSetView: spec into: builder	"Build a DataSetView into the builder. Extract from the model the listHolder, 	selectionChannel and currentRowHolder. Get the column descriptors from 	the spec"	| dataSetView model menu bc performer |	dataSetView := builder isEditing				ifTrue: [self paintedDataSetViewClass new]				ifFalse: 					[(spec multipleSelections						ifTrue: [self multiSelectionDataSetViewClass]						ifFalse: [self dataSetViewClass]) new].	dataSetView labelsAsButtons: spec labelsAsButtons.	model := spec modelInBuilder: builder.	dataSetView model: model listHolder.	dataSetView selectionChannel: model selectionIndexHolder.	builder isEditing		ifFalse: 			[spec multipleSelections				ifTrue: 					[dataSetView						controller: self compliantMultiSelectDataSetControllerClass new]				ifFalse: 					[dataSetView controller: self simpleMultiSelectDataSetControllerClass new]].	(menu := spec getMenuIn: builder) == nil		ifFalse: [dataSetView controller menuHolder: menu].	(performer := spec getPerformerIn: builder) == nil		ifFalse: [dataSetView controller performer: performer].	bc := builder copyOld.	bc setWindow: nil.	bc composite: CompositePart new.	dataSetView setColumnDescriptors: (spec columnsInBuilder: bc).	dataSetView horizontalPolicy: spec horizontalPolicy.	dataSetView verticalPolicy: spec verticalPolicy.	dataSetView showVerticalLines: spec showVerticalLines.	dataSetView showHorizontalLines: spec showHorizontalLines.	dataSetView showLineNumbers: spec showLineNumbers.	dataSetView rowLabelsAsButtons: spec rowLabelsAsButtons.	dataSetView allowSorting: spec allowSorting.	dataSetView allowColumnReordering: spec allowColumnReordering.	dataSetView allowColumnResizing: spec allowColumnResizing.	dataSetView lineGrid: spec rowSize.	self setDispatcherOf: dataSetView fromSpec: spec builder: builder.	spec tabable		ifTrue: [dataSetView widgetState isTabStop: true]		ifFalse: 			[spec labelsAsButtons				ifTrue: 					[dataSetView columnDescriptors do: [:col | col labelAsButtonSpec noTabbing]].			dataSetView widgetState canTakeFocus: true].	dataSetView widgetState isEnabled: spec initiallyEnabled.	builder isEditing		ifFalse: [dataSetView widgetState isVisible: spec initiallyVisible].	builder component: dataSetView.	self manufactureGeneralWrapperFor: spec into: builder.	builder applyLayout: spec layout.	builder wrapWith: (self				simpleWidgetWrapperOn: builder				spec: spec				state: dataSetView widgetState)</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>interface construction</category><body package="Interface-Dialogs" selector="addMessage:textLine:type:boundary:">addMessage: messageString textLine: model type: type boundary: ratio 	| composedText layout spec height field grid messageText lookPolicyClass |	height := builder window displayBox height.	messageText := messageString asText.	(lookPolicyClass := builder policy class) useBoldInDialogText ifTrue: [messageText allBold].	composedText := ComposedText 		withText: messageText 		style: (lookPolicyClass systemWidgetTextStyle copyOld alignment: 0).	grid := composedText bounds height + self defaultGap.	layout := (LayoutFrame new)		leftFraction: 0 offset: 16;		rightFraction: ratio offset: -8;		topOffset: height;		bottomOffset: height + grid.	spec := LabelSpec layout: layout.	spec hasCharacterOrientedLabel: false.	spec setLabel: composedText.	builder add: spec.	layout := (LayoutFrame new)		leftFraction: ratio offset: 8;		rightFraction: 1 offset: -16;		topOffset: height;		bottomOffset: height + grid.	field := InputFieldSpec model: model menu: nil layout: layout.	type notNil ifTrue: [field type: type].	builder add: field.	self addGap: grid.	self minWidth: composedText bounds width * (1 / ratio) ceiling + 48.	^builder wrapper</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>private</category><body package="Interface-Dialogs" selector="computeExtentAndSetLabel:">computeExtentAndSetLabel: aString 	| label composedText textExtent displayExtent labelExtent height width messageText lookPolicyClass |	label := builder componentAt: #label.	aString isString		ifTrue: [messageText := aString asText]		ifFalse: [messageText := aString].	(lookPolicyClass := builder policy class) useBoldInDialogText ifTrue: [messageText allBold].	composedText := ComposedText 		withText: messageText 		style: (lookPolicyClass systemWidgetTextStyle copyOld alignment: 2).	textExtent := composedText preferredBounds extent.	displayExtent := builder window displayBox extent.	labelExtent := label widget preferredBounds extent.	label label: composedText.	textExtent y &gt; labelExtent y		ifTrue: [height := displayExtent y + (textExtent y - labelExtent y)]		ifFalse: [height := displayExtent y].	width := displayExtent x max: textExtent x + 20.	^width @ height</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>interface construction</category><body package="Interface-Dialogs" selector="addMessage:linesCentered:paragraphCentered:maxWidth:">addMessage: messageString linesCentered: linesCentered paragraphCentered: paragraphCentered maxWidth: width 	| composedText layout box spec messageText lookPolicyClass fraction |	box := builder window displayBox.	messageText := messageString asText.	(lookPolicyClass := builder policy class) useBoldInDialogText ifTrue: [messageText allBold].	composedText := ComposedText withText: messageText		style: (lookPolicyClass systemWidgetTextStyle copyOld alignment: (linesCentered ifTrue: [2] ifFalse: [0]))		compositionWidth: width.	fraction := paragraphCentered ifTrue: [0.5] ifFalse: [0]. 	layout := AlignmentOrigin new		leftFraction: fraction;		topOffset: box height;		leftAlignmentFraction: fraction.	spec := LabelSpec layout: layout.	spec hasCharacterOrientedLabel: false.	spec setLabel: composedText.	builder add: spec.	self addGap: composedText bounds height.	self minWidth: composedText bounds width + 20.	^builder wrapper</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>interface construction</category><body package="Interface-Dialogs" selector="addMessage:linesCentered:paragraphCentered:">addMessage: messageString linesCentered: linesCentered paragraphCentered: paragraphCentered	| composedText layout box spec messageText lookPolicyClass fraction | 	box := builder window displayBox.	messageText := messageString asText.	(lookPolicyClass := builder policy class) useBoldInDialogText ifTrue: [messageText allBold].	composedText := ComposedText		withText: messageText		style: (lookPolicyClass systemWidgetTextStyle copyOld alignment: (linesCentered			ifTrue: [2]			ifFalse: [0])).	fraction := paragraphCentered ifTrue: [0.5] ifFalse: [0].	layout := AlignmentOrigin new		leftFraction: fraction;		topOffset: box height;		leftOffset: (paragraphCentered ifTrue: [0] ifFalse: [10]);		leftAlignmentFraction: fraction.	spec := LabelSpec layout: layout.	spec hasCharacterOrientedLabel: false.	spec setLabel: composedText.	builder add: spec.	self addGap: (composedText bounds height min: (Screen default bounds height - 100)).	self minWidth: (composedText bounds width + 20 min: (Screen default bounds width - 30)).	^builder wrapper</body></methods><methods><class-id>UI.TableAdaptor</class-id> <category>copying</category><body package="UIBasics-Collections" selector="postCopy">postCopy	"Answer a copy of the receiver."	self breakDependents.	baseCollection :=  baseCollection copyOld.</body></methods><methods><class-id>UI.WindowExitEvent</class-id> <category>accessing</category><body package="Interface-Events" selector="translatedBy:">translatedBy: aPoint	^self copyOld translateBy: aPoint</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="helpLabelCatalog:">helpLabelCatalog: aSymbol 	| labelThing |	self helpSuppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifTrue: [helpLabeledValueHolder value helpText: self helpLabelDefaultString] 		ifFalse: 			[labelThing := helpLabeledValueHolder value helpText.			helpLabeledValueHolder value 				helpText: ((labelThing isString or: [labelThing == nil]) 						ifTrue: 							[(UserMessage new)								defaultString: labelThing;								catalogID: aSymbol;								yourself]						ifFalse: [labelThing copyOld &lt;&lt; aSymbol])].	 	self changed: #value</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="helpLabelKeyID:">helpLabelKeyID: aSymbol 	| labelThing |	self helpSuppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifTrue: [helpLabeledValueHolder value helpText: self helpLabelDefaultString]		ifFalse: 			[labelThing := helpLabeledValueHolder value helpText.			helpLabeledValueHolder value 				helpText: ((labelThing isString or: [labelThing == nil]) 						ifTrue: [aSymbol &gt;&gt; labelThing]						ifFalse: [labelThing copyOld key: aSymbol])].	self changed: #value</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="helpLabelDefaultString:">helpLabelDefaultString: aString 	| labelThing |	self helpSuppliedByBuilder value ifTrue: [^self].	labelThing := helpLabeledValueHolder value helpText.	helpLabeledValueHolder value 		helpText: ((labelThing isString or: [labelThing == nil]) 				ifTrue: [aString]				ifFalse: [labelThing copyOld &gt;&gt; aString]).	self changed: #value</body></methods><methods><class-id>UI.CompositeSpecCollection</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	super postCopy.	compositeSpec := compositeSpec copyOld</body></methods><methods><class-id>UI.MacOSXMenuFromMenuBarController</class-id> <category>events</category><body package="UILooks-MacOSX" selector="viewHasCursorWithEvent:">viewHasCursorWithEvent: event	"Answer true if the cursor point of the receiver's sensor lies within 	the display box and border of the menu item dropdown.	This is farily unique to stacked menus, but it makes standard windows like behavior"	| localSensor adulteratedBounds |	view == nil ifTrue: [^false].	event hasPoint ifFalse: [^false].	localSensor := self sensor.	adulteratedBounds := view bounds copyOld		top: view bounds top - view container border top.	^adulteratedBounds containsPoint: (localSensor cursorPointFor: event)</body></methods><methods><class-id>UI.EmulationScrollBar</class-id> <category>private</category><body package="UILooks-Support" selector="simpleRedisplayIn:colorBackgroundIfNeeded:">simpleRedisplayIn: aRectangle colorBackgroundIfNeeded: aBoolean	"Redisplay the given area of the receiver without doing a full invalidation if possible."	| graphicsContext  |	self isOpen ifFalse: [^self].	graphicsContext := self graphicsContext.	graphicsContext medium supportsInvalidation ifFalse: [^self].	graphicsContext medium hasOutstandingDamage ifTrue: [^self invalidateRectangle: aRectangle repairNow: true].	graphicsContext intersectClip: aRectangle.	aBoolean ifTrue: 		[graphicsContext copyOld			paint: self backgroundColor;			displayRectangle: aRectangle].	self displayOn: graphicsContext</body></methods><methods><class-id>UI.Panel</class-id> <category>layout algorithms</category><body package="Store-Code Comparison" selector="beFullColumn">beFullColumn	self layoutAlgorithm: 			[:rect :parts |			| bottom |			bottom := rect top.			parts collect: 					[:each |					| top |					top := bottom.					bottom := top + each preferredHeight.					(rect copyOld)						top: top;						bottom: bottom]]</body></methods><methods><class-id>UI.Panel</class-id> <category>layout algorithms</category><body package="Store-Code Comparison" selector="beFullColumnStretchIf:">beFullColumnStretchIf: aPredicateBlock	self layoutAlgorithm: 			[:rect :parts |			| bottom stretchHeight unstretched |			stretchHeight := 0.			unstretched := parts reject: aPredicateBlock.			unstretched size &lt; parts size				ifTrue: 					[stretchHeight := (rect height								- (unstretched inject: 0 into: [:sum :each | sum + each preferredHeight]))									/ (parts size - unstretched size) max: 0].			bottom := rect top.			parts collect: 					[:each |					| top |					top := bottom.					bottom := top + ((aPredicateBlock value: each)										ifTrue: [stretchHeight]										ifFalse: [each preferredHeight]).					(rect copyOld)						top: top;						bottom: bottom]]</body></methods><methods><class-id>UI.MultiSelectionSequenceView</class-id> <category>private</category><body package="UIBasics-Components" selector="useSweepSelectionIndex:">useSweepSelectionIndex: anIndex 	"If multiple selections are possible, add the	current selection and all indices from the	current selection to the previous selection,	to the list of selections."	| save delta list newList |	lastSelectionIndex = self zeroIndex ifTrue: 		[self retractAllSelections.		^self].	save := lastSelectionIndex.	save &lt; anIndex 		ifTrue: [delta := -1] 		ifFalse: [delta := 1].	list := self selections copyOld.	newList := anIndex to: save by: delta.	selectionIndex := self zeroIndex.	(list reject: [:each | newList includes: each]) do: 		[:each | 		selections remove: each ifAbsent: [].		self invalidateElementIndex: each].	(newList reject: [:each | list includes: each]) do: 		[:each | 		selections add: each.		self invalidateElementIndex: each].	lastSelectionIndex := save.	self selectionChannel value: selections</body></methods><methods><class-id>UI.KeyPressedEvent</class-id> <category>converting</category><body package="Interface-Events" selector="forPrefocusPass">forPrefocusPass	"Return my specialized subclass which adds a wasHandled flag to the event."	^(self copyOld changeClassTo: Array)		changeClassTo: PrefocusKeypressEvent</body></methods><methods><class-id>UI.VisualBlock</class-id> <category>displaying</category><body package="UIBasics-Support" selector="displayOn:">displayOn: aGraphicsContext	| copy |	copy := aGraphicsContext copyOld.	paint == nil ifFalse: [copy paint: paint].	block value: copy value: self bounds</body></methods><methods><class-id>UI.TwoDList</class-id> <category>copying</category><body package="UIBasics-Collections" selector="postCopy">postCopy	"Answer a copy of the receiver."	self breakDependents.	collection :=  collection copyOld.</body></methods><methods><class-id>UI.AssociationTree</class-id> <category>copying</category><body package="UIBasics-Collections" selector="copyOld">copyOld	"Answer another instance just like the receiver, but with a copy of 	the receiver's value and a copy 	of each of the receiver's children."	| cpy tmpChildren |	tmpChildren := children.	children := nil.	cpy := self shallowCopy.	cpy value: value copyOld.	tmpChildren isNil ifFalse: [tmpChildren do: [:child | cpy addChild: child copyOld]].	children := tmpChildren.	^cpy</body></methods><methods><class-id>UI.AssociationTree</class-id> <category>copying</category><body package="UIBasics-Collections" selector="copyAndReplaceInSet:">copyAndReplaceInSet: aSet 	"Answer a copy of the receiver with all references to it in aSet 	updated as well."	| cpy tmpChildren |	tmpChildren := children.	children := nil.	cpy := self shallowCopy.	cpy value: value copyOld.	(aSet includes: self)		ifTrue: 			[aSet remove: self.			aSet add: cpy].	tmpChildren isNil ifFalse: [tmpChildren do: [:child | cpy addChild: (child copyAndReplaceInSet: aSet)]].	children := tmpChildren.	^cpy</body></methods><methods><class-id>UI.AssociationTree</class-id> <category>copying</category><body package="UIBasics-Collections" selector="copy">copy	"Answer another instance just like the receiver, but with a copy of 	the receiver's value and a copy 	of each of the receiver's children."	| cpy tmpChildren |	tmpChildren := children.	children := nil.	cpy := self shallowCopy.	cpy value: value copyOld.	tmpChildren isNil ifFalse: [tmpChildren do: [:child | cpy addChild: child copyOld]].	children := tmpChildren.	^cpy</body></methods><methods><class-id>UI.ClickableGraphic class</class-id> <category>utility</category><body package="Graphics-Visual Objects" selector="clickableText:style:">clickableText: aText style: aTextStyle	"(ApplicationWindow new)	component: (self clickableText: 'Click Me'				style: (TextAttributes styleNamed: #fixed));	open"	| clickText baseText |	clickText := self new.	baseText := aText asText.	clickText		idleGraphic: (Label with: (baseText copyOld						addEmphasis: Array new						removeEmphasis: #()						allowDuplicates: false)				attributes: aTextStyle).	clickText		mouseOverGraphic: (Label with: (baseText copyOld						addEmphasis: (Array with: #underline)						removeEmphasis: #()						allowDuplicates: false)				attributes: aTextStyle).	clickText		mouseDownGraphic: (Label with: (baseText copyOld						addEmphasis: (Array with: #color -&gt; ColorValue blue with: #underline)						removeEmphasis: #()						allowDuplicates: false)				attributes: aTextStyle).	clickText		disabledGraphic: (Label with: (baseText copyOld						addEmphasis: (Array with: #color -&gt; SymbolicPaint inactiveForeground)						removeEmphasis: #()						allowDuplicates: false)				attributes: aTextStyle).	^clickText</body></methods><methods><class-id>UI.ClickableGraphic class</class-id> <category>example</category><body package="Graphics-Visual Objects" selector="example">example	"self example"	| me window text |	window := ScheduledWindow new.	window component: CompositePart new.	0 to: 1		do: 			[:x |			0 to: 1				do: 					[:y |					me := self new.					text := (x @ y) printString asText.					me idleGraphic: (Label with: text).					me						mouseOverGraphic: (Label with: (text copyOld emphasizeAllWith: #underline)).					me mouseDownGraphic: (Label with: (text copyOld emphasizeAllWith: #italic)).					me when: Clicked						do: 							[Transcript								show: 'Clicked: ' , (x @ y) printString;								cr].					window component add: me in: (x @ y / 2 extent: 1 asPoint / 2)]].	window openWithExtent: 200 @ 200</body></methods><methods><class-id>UI.ClickableGraphic class</class-id> <category>utility</category><body package="Graphics-Visual Objects" selector="clickableText:">clickableText: aText	"(ApplicationWindow new) component: (self clickableText: 'Click Me'); open"	| clickText baseText |	clickText := self new.	baseText := aText asText.	clickText		idleGraphic: (Label with: (baseText copyOld						addEmphasis: Array new						removeEmphasis: #()						allowDuplicates: false)).	clickText		mouseOverGraphic: (Label with: (baseText copyOld						addEmphasis: (Array with: #underline)						removeEmphasis: #()						allowDuplicates: false)).	clickText		mouseDownGraphic: (Label with: (baseText copyOld						addEmphasis: (Array with: #color -&gt; ColorValue blue with: #underline)						removeEmphasis: #()						allowDuplicates: false)).	clickText		disabledGraphic: (Label with: (baseText copyOld						addEmphasis: (Array with: #color -&gt; SymbolicPaint inactiveForeground)						removeEmphasis: #()						allowDuplicates: false)).	^clickText</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>event driven</category><body package="UIBasics-Controllers" selector="setUpShiftDownSelectionAt:">setUpShiftDownSelectionAt: aPoint	"Shift is down and there is a selection; extend it"	| gc prevStartBlock prevStopBlock currentBlock pivotBlock |	gc := view graphicsContext.	prevStartBlock := view startBlock.	prevStopBlock := view stopBlock.	currentBlock := view characterBlockAtPoint: aPoint.	self resetTypein.	prevStartBlock = prevStopBlock ifTrue: [view deselect].	pivotBlock := (currentBlock stringIndex - prevStartBlock stringIndex) abs				&gt; (currentBlock stringIndex - prevStopBlock stringIndex) abs					ifTrue: 						["extend the end of the selection closest to the current 					cursor position"						prevStartBlock]					ifFalse: [prevStopBlock].	self		updateSelectionWith: currentBlock		usingPivot: pivotBlock		on: gc copyOld.	anchorIndex := pivotBlock stringIndex.	view selectionShowing: true.	gc flush.	^pivotBlock</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>private</category><body package="UIBasics-Controllers" selector="getReadOnlyDispatchTable">getReadOnlyDispatchTable	dispatchTable := DispatchTable new.	dispatchTable defaultForCharacters: #normalCharacterKey:.	dispatchTable defaultForNonCharacters: #ignoreInputKey:.	dispatchTable bindValue: #copyKey: toCommand: #copyOld.	dispatchTable bindValue: #cursorUpKey: to: #Up.	dispatchTable bindValue: #cursorDownKey: to: #Down.	dispatchTable bindValue: #cursorLeftKey: to: #Left.	dispatchTable bindValue: #cursorRightKey: to: #Right.	dispatchTable bindValue: #findDialogKey: toCommand: #find.	dispatchTable bindValue: #findAgainKey: toCommand: #findNext.	dispatchTable bindValue: #findAgainKey: toCommand: #findPrevious.	dispatchTable bindValue: #homeKey: toCommand: #textStartIOfLine.	dispatchTable bindValue: #endKey: toCommand: #textEndOfLine.	dispatchTable bindValue: #pageUpKey: to: #PageUp.	dispatchTable bindValue: #pageDownKey: to: #PageDown.	dispatchTable bindValue: #processTabKey: to: Character tab.	dispatchTable bindValue: #processTabKey: to: #BackTab.	dispatchTable bindValue: #selectAllKey: toCommand: #selectAll.	^dispatchTable</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>event driven</category><body package="UIBasics-Controllers" selector="trackSelectionFrom:to:pivotBlock:showingCaret:">trackSelectionFrom: currentBlock to: newPoint pivotBlock: pivotBlock showingCaret: aBoolean 	| showingCaret gc  pt delta nextBlock singleLineView |	showingCaret := aBoolean.	gc := view graphicsContext.	singleLineView := view isKindOf: InputFieldView.	pt := newPoint.	(delta := self deltaForPoint: pt) ~= Point zero ifTrue: 		[delta y = 0 ifFalse: 			[singleLineView 				ifTrue: [delta y: 0]				ifFalse: 					[delta y abs &lt; view lineGrid						ifTrue: [delta y: delta y sign * view lineGrid]						ifFalse: [delta y: (delta y truncateTo: view lineGrid)]]].		view scrollBy: delta negated.		gc translateBy: delta negated.		delta y &lt; 0			ifTrue: [pt y: view bounds top]			ifFalse: [delta y &gt; 0 ifTrue: [pt y: view bounds bottom]].		delta x &lt; 0			ifTrue: [pt x: view bounds left]			ifFalse: [delta x &gt; 0 ifTrue: [pt x: view bounds right]].		self checkForEvents].	nextBlock := view characterBlockAtPoint: pt.	nextBlock = currentBlock ifFalse: 		[showingCaret ifTrue: 			[view hideInsertionPointFor: pivotBlock on: gc copyOld.			showingCaret := false].		self			updateSelectionWith: nextBlock			usingPivot: pivotBlock			on: gc copyOld.		self selectionStartIndex = self selectionStopIndex ifTrue: 			[view displayInsertionPointFor: pivotBlock on: gc copyOld.			showingCaret := true].		gc flush].	^showingCaret</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu messages</category><body package="UIBasics-Controllers" selector="cut">cut	"Remove the current selection and, if non-empty, place it in the paste buffer"	| cutText |	(cutText := self selection) isEmpty ifTrue: [^self	"nothing to cut"].	self startNextUndo.	self deselect.	self resetTypein.	self silentCut.	(self currentUndo)		beCut;		delete: cutText;		endState: self captureUndoState.	nextUndoBlock := [self startNextUndo].	self selectAndScroll.	self currentSelection: self undoSelection copyOld</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>event driven</category><body package="UIBasics-Controllers" selector="setUpSelectionAt:">setUpSelectionAt: aPoint	| gc currentBlock pivotBlock |	gc := view graphicsContext.	currentBlock := view characterBlockAtPoint: aPoint.	view deselect.	self setSelectionStartAndResetTypein.	pivotBlock := currentBlock.	anchorIndex := pivotBlock stringIndex.	view startBlock: pivotBlock.	view stopBlock: pivotBlock.	view displayInsertionPointFor: pivotBlock on: gc copyOld.	view selectionShowing: true.	gc flush.	^pivotBlock</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>event driven</category><body package="UIBasics-Controllers" selector="completeSelectionWithPrevStart:prevStop:pivotBlock:showingCaret:">completeSelectionWithPrevStart: prevStartBlock prevStop: prevStopBlock pivotBlock: pivotBlock showingCaret: showingCaret	| strt gc word |	view isOpen ifFalse: [^self].	gc := view graphicsContext.	(strt := view startBlock) = view stopBlock		ifTrue: 			[showingCaret ifFalse: [view displayInsertionPointFor: strt on: gc copyOld].			(prevStartBlock = prevStopBlock and: [prevStartBlock = strt])				ifTrue: 					["select a word or bracketed range"					word := self selectWord: pivotBlock stringIndex.					word first = word last						ifFalse: 							[view hideInsertionPointFor: strt on: gc copyOld.							self selectionStartIndex: word first stopIndex: word last.							view								displaySelectionFrom: view startBlock								to: view stopBlock								on: gc]]].	gc flush.	self setEmphasisHere.	self view updateSpot: #mouse</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu messages</category><body package="UIBasics-Controllers" selector="cancel">cancel	"Restore the text of the paragraph to be the text saved since initialization or	the last accept."	self undoSelection: self text copyOld.	view updateDisplayContents</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>private</category><body package="UIBasics-Controllers" selector="silentCut">silentCut	"Remove the current selection and place it in the paste buffer.  Do not	affect visual selection."	| currentSelection |	self replaceSelectionWith: Text new.	currentSelection := self undoSelection copyOld.	self currentSelection: currentSelection</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu processing</category><body package="UIBasics-Controllers" selector="noCopyOrCut">noCopyOrCut	"Make content private and remove copy and cut actions from menu and keyboard, if any."	self menuHolder value		ifNotNil: 			[:menu |			(menu menuItemWithValue: #copySelection ifNone: nil)				ifNotNil: [:item | menu hideItem: item].			(menu menuItemWithValue: #cut ifNone: nil)				ifNotNil: [:item | menu hideItem: item]].	self dispatchTable bindValue: #ignoreInputKey: toCommand: #copyOld.	self dispatchTable bindValue: #ignoreInputKey: toCommand: #cut.</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>private</category><body package="UIBasics-Controllers" selector="privateAccept">privateAccept	"Save the current text of the text being edited."	view triggerEvent: #changing.	accepted := true.	self textHasChanged: false.	model value: self text copyOld.	self valueChange.	view triggerEvent: #changed</body></methods><methods><class-id>UI.TextEditorController class</class-id> <category>resources</category><body package="UIBasics-Controllers" selector="readOnlyGroup">readOnlyGroup	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#nameKey: #copySelection 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copyOld ) 				#command: #copyOld ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#nameKey: #find 				#value: #find				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#nameKey: #findNext 				#value: #findNext				#command: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAll 					#defaultString: 'Select All' 					#catalogID: #menus ) 				#nameKey: #selectEntireText 				#value: #selectEntireText 				#command: #selectAll ) ) #(1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.TextEditorController class</class-id> <category>resources</category><body package="UIBasics-Controllers" selector="editGroup">editGroup	"Tools.MenuEditor new openOnClass: self andSelector: #editGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Undo 					#defaultString: 'Undo' 					#catalogID: #menus ) 				#value: #undo 				#command: #undo ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Redo 					#defaultString: 'Redo' 					#catalogID: #menus ) 				#value: #redo 				#command: #redo ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) 				#value: #cut 				#command: #cut ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#command: #copyOld ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) 				#value: #paste 				#command: #paste ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#value: #find				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ReplaceDot 					#defaultString: 'Replace...' 					#catalogID: #menus ) 				#value: #replace				#command: #replace ) ) #(2 3 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.TextEditorController class</class-id> <category>private</category><body package="UIBasics-Controllers" selector="decorateTextItemsIn:">decorateTextItemsIn: aMenu	(aMenu menuItemWithValue: #undo)		labelImage: (GeneralIcons visualFor: #editUndo);		command: #undo.	(aMenu menuItemWithValue: #redo)		labelImage: (GeneralIcons visualFor: #editRedo);		command: #redo.	(aMenu menuItemWithValue: #cut)		labelImage: (GeneralIcons visualFor: #editCut);		command: #cut.	(aMenu menuItemWithValue: #copySelection)		labelImage: (GeneralIcons visualFor: #editCopy);		command: #copyOld.	(aMenu menuItemWithValue: #paste)		labelImage: (GeneralIcons visualFor: #editPaste);		command: #paste</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="placeSelectionPointAt:">placeSelectionPointAt: characterIndex 	"Place the character before the character at position characterIndex.  Make	certain the selection is in the view but does not display any thing (ie. assumes 	no selection is showing).	This is used by the TextEditor during typing"	| delta |	startBlock := self characterBlockForIndex: characterIndex.	stopBlock := startBlock copyOld.	delta := self findSelectionDelta.	delta ~= 0 ifTrue: [self scrollBy: delta negated]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>updating</category><body package="Debugger-Support" selector="updateTheDisplay">updateTheDisplay	"This is used by the browsers only."	| text changedString |	text := self getContents asText.	changedString := displayContents text string ~= text string.	(changedString or: [displayContents text runs ~= text runs])		ifFalse: 			[self controller.	"Make sure we have a controller"			self resetController.			^self].	"If nothing changed, exit"	self isOpen		ifTrue: 			[displayContents setCompositionWidth: self wrappingBox width.			displayContents text: text asText copyOld]		ifFalse: 			[displayContents setCompositionWidth: ComposedText defaultCompositionWidth.			displayContents setText: text asText copyOld].	changedString ifTrue: [self setToTop].	self startBlock: nil.	self stopBlock: nil.	selectionShowing := true.	self controller.	"Make sure we have a controller"	self resetController.	"redisplay now so selection updates will display correctly"	self invalidateRectangle: self bounds repairNow: true</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>displaying</category><body package="UIBasics-Components" selector="redisplayAfterReplacementAt:affectedLines:lineDelta:">redisplayAfterReplacementAt: startLine affectedLines: affectedLines lineDelta: lineDelta	"Redisplay the reciever after a change starting at startLine. 	The argument affectedLines is the number of lines that need to be redisplayed. 	The argument lineDelta has the change in total lines. 	This method uses scrolling and only works for tiled views."	| visibleRectangle  stopLine gc |	gc := self graphicsContext.	visibleRectangle := self clippingBox.	self displayObject numberOfLines = 0  ifTrue: [^self invalidate].	stopLine := startLine + affectedLines - 1.	lineDelta = 0		ifTrue:	[gc paint: self backgroundColor.				gc intersectClip: (visibleRectangle := self							visibleRectangleFrom: startLine							to: stopLine).				gc displayRectangle: visibleRectangle.				gc paint: self foregroundColor.				self displayOn: gc]		ifFalse: [ | obsoleteY newY moveRectangle gc2 rectList |				lineDelta &gt; 0					ifTrue: [obsoleteY := self displayObject topAtLineIndex: startLine+(affectedLines - lineDelta max: 0)]					ifFalse: [obsoleteY := self displayObject topAtLineIndex: startLine + lineDelta negated].				newY := obsoleteY + (self lineGrid * lineDelta).				moveRectangle := self computeMoveRectangleFor: visibleRectangle old: obsoleteY new: newY.				gc2 := gc copyOld.				gc2 intersectClip: visibleRectangle.				rectList := gc2					copyArea: moveRectangle					from: gc2					sourceOffsetX: 0 y: 0					destinationOffsetX: 0 y: ((newY max: visibleRectangle top) - moveRectangle top).					1 to: rectList size  do:						[:j | self redisplayRectangle: ((rectList at: j) intersect: visibleRectangle) on: gc2].	 			self redisplayRectangle: (self visibleRectangleFrom: startLine to: stopLine) on: gc.				lineDelta &lt; 0					ifTrue: [| rr|							rr := visibleRectangle left@((newY+ moveRectangle height) max: visibleRectangle top)									corner: visibleRectangle corner.							self redisplayRectangle: rr on: gc]]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>initialize-release</category><body package="UIBasics-Components" selector="initializeSelection">initializeSelection 	"Establish the initial conditions for editing the paragraph:  place caret	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	self isOpen		ifTrue: [self selectionStartIndex: 1 stopIndex: 1]		ifFalse: [startBlock := 					CharacterBlock						stringIndex: 1						character: nil						boundingRectangle: (6@0 extent: 0 @ self lineGrid).				stopBlock := startBlock copyOld]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>model access</category><body package="UIBasics-Components" selector="editText:">editText: aText	"The paragraph to be displayed is created from the characters in aString."	self isOpen		ifTrue: 			[self triggerEvent: #changing.			displayContents text: aText asText copyOld.			self setScrollWidth]		ifFalse: 			[displayContents setCompositionWidth: ComposedText defaultCompositionWidth.			displayContents setText: aText asText copyOld].	self setToTop.	startBlock := stopBlock := nil.	selectionShowing := true.	self controller.	"Make sure we have a controller"	self resetController.	self resetTextEditorUndo.	self changedPreferredBounds: nil.	self invalidate.	self isOpen ifTrue: [self triggerEvent: #changed]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="hideInsertionPointFor:on:">hideInsertionPointFor: aCharacterBlock on: aGraphicsContext 	"Remove the insertion point on aGraphicsContext for aCharacterBlock."	| r clipRect gc |	clipRect := aGraphicsContext clippingBounds.	r := self insertionPointBoundingBoxFor: aCharacterBlock.	(r intersects: clipRect) ifFalse: [^self].	gc := aGraphicsContext copyOld.	gc intersectClip: r.	gc paint: self backgroundColor.	gc displayRectangle: r.	gc paint: self foregroundColor.	displayContents displayOn: gc at: self displayOrigin</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayTextIn:on:">displayTextIn: aRectangle on: gc	"Display the receiver's text that intersects aRectangle on GraphicsContext gc.	Show all text whether selected or not in one pass."	| first last ss es x lineRange |	gc paint: self foregroundColor.	(displaySelection not or: [selectionShowing not])		ifTrue: [^self displayObject displayOn: gc copyOld at: self displayOrigin].	displayContents numberOfLines = 0		ifTrue: [^self displayInsertionPointFor: self startBlock on: gc].	lineRange := displayContents				lineRangeFor: (aRectangle translatedBy: self displayOrigin negated).	first := (displayContents lineAt: lineRange first) first.	last := (displayContents lineAt: lineRange last) last.	x := self displayOrigin x.	ss := self startBlock stringIndex.	es := self stopBlock stringIndex.	((ss &gt; last or: [es &lt; first]) or: [ss = es])		ifTrue: 			[self displayObject displayOn: gc copyOld at: self displayOrigin.			^self displayInsertionPointFor: self startBlock on: gc].	ss &gt; first		ifTrue: 			[gc paint: self foregroundColor.			self displayFromCharacter: first to: ss - 1 startX: x on: gc.			first := ss.			x := self startBlock left].	self showSelectionBoxOn: gc within: aRectangle.	gc paint: self selectionForegroundColor.	last &lt; es		ifTrue: 			[self displayFromCharacter: first to: last startX: x on: gc]		ifFalse: 			[self displayFromCharacter: first to: es - 1 startX: x on: gc.			gc paint: self foregroundColor.			x := self stopBlock left.			self displayFromCharacter: es to: last startX: x on: gc]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>displaying</category><body package="UIBasics-Components" selector="redisplayRectangle:on:">redisplayRectangle: aRectangle on: aGraphicsContext	"Redisplay the receiver's rectangle aRectangle on aGraphicsContext."	| gc |	gc := aGraphicsContext copyOld.	gc intersectClip: aRectangle.	gc paint: self backgroundColor.	gc displayRectangle: aRectangle.	gc paint: self foregroundColor.	self displayTextIn: aRectangle on: gc</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="selectionStartIndex:stopIndex:">selectionStartIndex: aStartIndex stopIndex: aStopIndex	"Set the receiver's selection start and stop index to the given arguments."	startBlock := self characterBlockForIndex: aStartIndex.	aStartIndex = aStopIndex		ifTrue: [stopBlock := startBlock copyOld]		ifFalse: [stopBlock := self characterBlockForIndex: aStopIndex]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="selectAt:">selectAt: characterIndex 	"Place the caret before the character at position characterIndex.  Make	certain the selection is in the view."	self deselect.	startBlock := self characterBlockForIndex: characterIndex.	stopBlock := startBlock copyOld.	self selectAndScroll</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="setStartSelectionToStopSelection">setStartSelectionToStopSelection	"Set the receiver's start selection to the stop selection."	startBlock = stopBlock		ifFalse: [startBlock :=  self stopBlock copyOld]</body></methods><methods><class-id>UI.WindowDisplayPolicy</class-id> <category>displaying</category><body package="Interface-Support" selector="displayDamageList:in:">displayDamageList: aDamageList in: aWindow	"Repair damage in aWindow for the list of rectangles aDamageList.  None of the rectangles are assumed to not contain another of the rectangles, but they may intersect."	| windowGraphicsContext windowVisual |	windowGraphicsContext := aWindow graphicsContext.	windowGraphicsContext paint: aWindow background.	1 to: aDamageList size do: [:i |		windowGraphicsContext displayRectangle: (aDamageList at: i)].	(windowVisual := aWindow component) == nil ifTrue: [^self].	windowGraphicsContext paint: aWindow foregroundColor.	1 to: aDamageList size do: [:i |		windowGraphicsContext clippingRectangle: (aDamageList at: i).		windowVisual displayOn: windowGraphicsContext copyOld].	aWindow flush</body></methods><methods><class-id>UI.Win95MenuBorder</class-id> <category>displaying</category><body package="UILooks-MSWin" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRectangle using: colorSource 	"Display the receiver's borders in the specified display box. If colorSource 	is non-nil, it may be consulted for the values of the border colors using LookPreferences 	accessing protocol (#hiliteColor, #shadowColor, etc.)."	"Be sure not to permanently side-effect the supplied GraphicsContext."	| r clipRectangle oldPaint |	clipRectangle := aGraphicsContext clippingBounds.	((self insetDisplayBoxFor: aRectangle)		contains: clipRectangle)		ifTrue: [^self].	oldPaint := aGraphicsContext paint.	r := aRectangle copyOld.	r top: aRectangle bottom - 2; bottom: aRectangle bottom - 1.	(r intersects: clipRectangle)		ifTrue: [aGraphicsContext paint: colorSource shadowColor; displayRectangle: r].	r top: aRectangle bottom - 1; bottom: aRectangle bottom.	(r intersects: clipRectangle)		ifTrue: [aGraphicsContext paint: colorSource hiliteColor; displayRectangle: r].	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.TransientWindow</class-id> <category>private</category><body package="Interface-Framework" selector="displayDamageEvent:">displayDamageEvent: aDamageList	"Repair damage for the list of rectangles aDamageList."	| gc |	gc := self graphicsContext.	gc paint: self background.	1 to: aDamageList size do: [:i | gc displayRectangle: (aDamageList at: i)].	self component == nil ifTrue: [^self].	1 to: aDamageList size do: [:i |		gc clippingRectangle: (aDamageList at: i).		self component displayOn: gc copyOld].	self flush</body></methods><methods><class-id>AtomicLoader</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="initializeClassesIn:">initializeClassesIn: aPackageModel	"Keep trying until there are either none to do, or the number to do doesn't change.	If there are any still unable to be initialized, go and raise MNU on each after setting doNotMarkClean to true"	| sortedClasses workingSize workingClasses |	classesToInitialize isEmpty ifTrue: [^self].	sortedClasses := SystemUtils sortForLoading: (classesToInitialize collect: [:each | each key]).	workingClasses := sortedClasses copyOld.	workingSize := -1.	[workingSize ~= sortedClasses size and: [sortedClasses notEmpty]] whileTrue:		[workingSize := sortedClasses size.		sortedClasses do:			[:each | 			[each postLoad: aPackageModel.			workingClasses remove: each]				on: InitializerFailedError				do:					[:exception | 					exception return: nil]].			sortedClasses := workingClasses copyOld].	sortedClasses notEmpty ifTrue:		[doNotMarkClean := true.		sortedClasses do: 			[:each |			[each postLoad: aPackageModel]				on: InitializerFailedError				do: [:exception | exception resignalAs: MessageNotUnderstood new]]]</body></methods><methods><class-id>AtomicLoader</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="compileBindingInitializersIn:">compileBindingInitializersIn: aPackageModel		| initialized |	initialized := (bindingsToInitialize collect: [:each | each environment]) asSet.	initialized := initialized copyOld reject: [:each | each isNameSpace].	initialized do: [:each | aPackageModel recompileSunshineMethodsFor: each].</body></methods><methods><class-id>AtomicLoader</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="initializeBindings">initializeBindings	"Keep trying until there are either none to do, or the number to do doesn't change"	| workingBindings workingSize copyBindings |	bindingsToInitialize isEmpty ifTrue: [^self].	workingBindings := bindingsToInitialize copyOld.	copyBindings := workingBindings copyOld.	workingSize := -1.	[workingSize ~= workingBindings size and: [workingBindings notEmpty]] whileTrue:		[workingSize := workingBindings size.		workingBindings do:			[:each |			[each recompile.			each initialize.			each ifNotNil: [copyBindings remove: each]]				on: MessageNotUnderstood				do: [:exception | exception resume]].			workingBindings := copyBindings copyOld]</body></methods><methods><class-id>OS.IOAccessor class</class-id> <category>utilities</category><body package="OS-Support" selector="convertSimpleStringFromPlatform:">convertSimpleStringFromPlatform: aStringOrBytes	"Convert aStringOrBytes, which has platform character encoding,	to conform to one of Smalltalk's single- or double-byte encodings."	^aStringOrBytes isString		ifTrue: [aStringOrBytes copyOld]		ifFalse: [aStringOrBytes asStringEncoding: #default]</body></methods><methods><class-id>OS.IOAccessor class</class-id> <category>utilities</category><body package="OS-Support" selector="convertStringForPlatform:">convertStringForPlatform: aString 	"Convert aString, which has a single- or double-byte encoding	and CR line-end convention, to conform to the platform's default	encoding and line-end convention."	| conv str |	conv := self defaultLineEndConvention.	(conv = LineEndCR or: [conv = LineEndTransparent])		ifTrue: [str := aString]		ifFalse: 			[conv = LineEndLF 				ifTrue: [str := aString copyOld replaceAll: CR with: LF]				ifFalse: 					[conv = LineEndCRLF 						ifTrue: 							[str := aString copyReplaceAll: (String with: CR)										with: (String with: CR with: LF)]						ifFalse: 							[self error: (#errUndefinedLF &lt;&lt; #dialogs &gt;&gt; 'Undefined line-end convention')]]].	str := self convertSimpleStringForPlatform: str.	^str	"IOAccessor convertStringForPlatform: 'abcdefghij'"</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>utilities</category><body package="OS-MacOSX" selector="encodeSelection:">encodeSelection: aString	^(aString copyOld replaceAll: Character cr with: Character lf) asByteArrayEncoding: #UTF8</body></methods><methods><class-id>OS.PCFilename</class-id> <category>file utilities</category><body package="OS-PC" selector="directoryContents">directoryContents	"Receiver is a directory name.  Return an array of strings	naming files contained in this directory."	(osName last = 16r5C and: [publicName last ~= self separator])		ifTrue: [^self copyOld withSeparator directoryContents].	^super directoryContents</body></methods><methods><class-id>OS.PCFilename class</class-id> <category>utilities</category><body package="OS-PC" selector="decodeFilename:">decodeFilename: aStringOrBytes	^aStringOrBytes isString		ifTrue: [aStringOrBytes copyOld]		ifFalse: [aStringOrBytes asStringEncoding: OSSystemSupport concreteClass vmPreferredEncoding]</body></methods><methods><class-id>OS.ExternalStream class</class-id> <category>accessing</category><body package="OS-Streaming" selector="closeOpenStreamsNamed:">closeOpenStreamsNamed: aFilename	"Enumerate over the currently open streams, closing any that are open on aFilename."	OpenStreams copyOld do:		[:stream|		(stream ioConnection notNil		and: [stream fileName = aFilename asFilename]) ifTrue:			[stream close]]</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>examples</category><body package="Examples" selector="exampleTalkServer">exampleTalkServer	"This example creates a simple UDP server that accepts 	single packets from anybody and broadcasts them to all 	clients that have connected so far. It could be used as the 	basis for a 'talk' server. Start the server (by executing the	following comment), then run exampleTalkClient. To stop	the server, press the &lt;window&gt; button on the mouse."	"[SocketAccessor exampleTalkServer]			forkAt: Processor userInterruptPriority"	| socket address buffer msgSize clients |	clients := Set new.	address := IPSocketAddress new.	buffer := String new: 1024.	"Create a socket on the port server's port."	socket := self newUDPserverAtPort: 6666.	"Announce the server's availability."	Transcript cr; show: (#talkServerStart &lt;&lt; #dialogs &gt;&gt; 'Talk server starting') asString.	"Wait for data until &lt;window&gt; button is pressed or timeout."	[[InputState default mouseButtons = 4] whileFalse: [		(socket readWaitWithTimeoutMs: 200) ifFalse: [			"Get the next message and store its length."				msgSize := socket 				receiveFrom: address 				buffer: buffer 				start: 1 				for: buffer size.			"Add the client to the set of broadcast receivers."			clients add: address copyOld.			"Broadcast the packet to each client."			clients do: [ :clientAddress | 				socket 					sendTo: clientAddress 					buffer: buffer 					start: 1 					for: msgSize]]]]	ensure:		[Transcript cr; show: (#talkServerShutDown &lt;&lt; #dialogs &gt;&gt; 'Talk server shutting down') asString.		socket close]</body></methods><methods><class-id>OS.Filename</class-id> <category>parsing</category><body package="OS-Support" selector="tail">tail	"Answer the filename suffix as a String."	| index nm |	nm := self asString.	(index := self lastSeparatorIndex) notNil		ifTrue:	[^nm copyFrom: index+1 to: nm size]		ifFalse:	[^nm copyOld]</body></methods><methods><class-id>OS.Filename class</class-id> <category>utilities</category><body package="OS-Support" selector="expandEnvironmentIn:">expandEnvironmentIn: aFilePattern	"Answer a new file pattern whose elements of the form $VARNAME have been expanded"	"Filename expandEnvironmentIn: '$(HOME)/$(USER)/$(UNDEFINED_VARIABLE)/file'"	"Filename expandEnvironmentIn: '$(COMSPEC)\$(windir)\$(UNDEFINED_VARIABLE)\file'"	| sep in out elem value |	sep := self separator.	in := aFilePattern readStream.	out := aFilePattern copyOld writeStream.	[in atEnd] whileFalse:		[sep == in peek			ifTrue: [in next. out nextPut: sep]			ifFalse:				[((elem := in upTo: sep) size &gt; 3				and: [elem first == $$				and: [(elem at: 2) == $(				and: [elem last == $)				and: [(value := SystemUtils getEnvironmentVariable: (elem copyFrom: 3 to: elem size - 1)									ifAbsent: []) ~~ nil]]]])					ifTrue: [out nextPutAll: value]					ifFalse: [out nextPutAll: elem].				in atEnd					ifFalse: [out nextPut: sep]]].	^out contents</body></methods><methods><class-id>OS.Filename class</class-id> <category>parsing</category><body package="OS-Support" selector="splitPath:">splitPath: fullName	"Answer an Array with: head with: tail."	| sepIndex head tail |	sepIndex := fullName lastIndexOf: self separator.	sepIndex &lt; 1		ifTrue: [^Array with: '' with: fullName copyOld].	head := fullName copyFrom: 1 to: sepIndex.	tail := fullName size &gt; sepIndex		ifTrue: [fullName copyFrom: sepIndex + 1 to: fullName size]		ifFalse: [''].	^Array with: head with: tail</body></methods><methods><class-id>OS.Filename class</class-id> <category>defaults</category><body package="OS-Support" selector="defaultDirectoryName">defaultDirectoryName	"Answer the default directory (e.g. interpretation starting point for	relative names)."	^DefaultDirectoryString copyOld</body></methods><methods><class-id>OS.Filename class</class-id> <category>utilities</category><body package="OS-Support" selector="decodeFilename:">decodeFilename: aStringOrBytes	^aStringOrBytes isString		ifTrue: [aStringOrBytes copyOld]		ifFalse: [aStringOrBytes asStringEncoding: #default]</body></methods><methods><class-id>OS.MacOSXFilename class</class-id> <category>utilities</category><body package="OS-MacOSX" selector="decodeFilename:">decodeFilename: aStringOrBytes	^aStringOrBytes isString		ifTrue: [aStringOrBytes copyOld]		ifFalse: [UnicodeCollationAlgorithm new normalizeC: (aStringOrBytes asStringEncoding: #UTF8)]</body></methods><methods><class-id>OS.CEnvironment class</class-id> <category>instance creation</category><body package="OS-Support" selector="fromStrings:">fromStrings: aCollection 	"Create an instance by converting from the external format."	| ce |	ce := self new: aCollection size + (aCollection size // 3).	aCollection do: 		[:elem | 		| lhs rhs eep es |		es := elem size.		eep := elem indexOf: $=.		lhs := eep = 0					ifTrue: [elem copyOld]					ifFalse: [elem copyFrom: 1 to: eep - 1].		rhs := eep = 0 | (eep = es)					ifTrue: [String new]					ifFalse: [elem copyFrom: eep + 1 to: es].		ce at: lhs put: rhs].	^ce</body></methods><methods><class-id>OS.HandleRegistry</class-id> <category>initialize-release</category><body package="OS-Support" selector="releaseHandles">releaseHandles	"Broadcast a releaseHandle message to all registrants."	| vals execs |	vals := valueArray copyOld.	execs := executors copyOld.	1 to: valueArray size do:		[:index | | value |		value := vals at: index.		(value == nil or: [value == valueArray tombstone])			ifFalse: [value releaseHandle].		value := execs at: index.		value == nil			ifFalse: [value releaseHandle]].	1 to: self basicSize do: [:i | self basicAt: i put: nil]</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>copying</category><body package="URISupport" selector="postCopy">postCopy	super postCopy.	path := path copyOld.	query := query copyOld</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="construct:">construct:  aFileComponent	^self copyOld 		addComponent: aFileComponent;		yourself</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="withComponent:">withComponent: component	"Create a new URL with the argument component appended.	The new component is assumed to be already URL-encoded."	| p |	p := (self path isEmpty not and: [self path last = ''])		ifTrue: [self path copyFrom: 1 to: self path size-1]		ifFalse: [self path].	^self copyOld		query: nil;		fragment: nil;		path: p;		addComponent: component</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>private</category><body package="URISupport" selector="mergePartial:">mergePartial: aPartialURL	self fragment: aPartialURL fragment.	aPartialURL hasNoPath ifTrue: [^aPartialURL query ifNotNil: [self query: aPartialURL query]].	self query: aPartialURL query.	aPartialURL isAbsolute		ifTrue:	[self mergeAbsolutePath: aPartialURL path copyOld]		ifFalse:	[self mergeRelativePath: aPartialURL path copyOld]</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="withComponents:">withComponents: comps	"Create a new URL with the argument components appended.	The new components are assumed to be already URL-encoded."	| p uri |	p := (self path isEmpty not and: [self path last = ''])		ifTrue: [self path copyFrom: 1 to: self path size-1]		ifFalse: [self path].	uri := self copyOld		query: nil;		fragment: nil;		path: p.	comps do: [:s | uri addComponent: s].	^uri</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="resolvePath:">resolvePath: aPath	| aURI |	aURI := aPath asURI.	aURI isPartial ifFalse: [^aURI copyOld].	^self copyOld		mergePartial: aURI;		yourself</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="save">save	"This stub method was generated by UIDefiner"	s2 := s1 copyOld.	self display.	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	temp := self copyOld.	anotherBST do: [:value | temp remove: value].	temp do: [:value | self remove: value].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copy">copy		^ BST new root: root copyOld.</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copyOld">copyOld		^ BST new root: root copyOld.</body></methods><methods><class-id>ExtraEmphases.BackHalf</class-id> <category>accessing</category><body package="ExtraEmphases" selector="computeWidthTable">computeWidthTable	widthTable := baseFont widthTable copyOld.	widthTable 		nonEmptyIndicesDo: [:i | widthTable at: i put: (widthTable at: i) // 2].	^widthTable</body></methods><methods><class-id>ExtraEmphases.LeadingInsert</class-id> <category>accessing</category><body package="ExtraEmphases" selector="computeWidthTable">computeWidthTable	| extra |	widthTable := baseFont widthTable copyOld.	extra := self extraWidth.	widthTable 		nonEmptyIndicesDo: [:i | widthTable at: i put: (widthTable at: i) + extra].	^widthTable</body></methods><methods><class-id>ExtraEmphases.TrailingInsert</class-id> <category>accessing</category><body package="ExtraEmphases" selector="computeWidthTable">computeWidthTable	| extra |	widthTable := baseFont widthTable copyOld.	extra := graphic preferredBounds width.	widthTable 		nonEmptyIndicesDo: [:i | widthTable at: i put: (widthTable at: i) + extra].	^widthTable</body></methods><methods><class-id>ExtraEmphases.Substitute</class-id> <category>accessing</category><body package="ExtraEmphases" selector="computeWidthTable">computeWidthTable	| sameWidth |	widthTable := baseFont widthTable copyOld.	sameWidth := graphic preferredBounds width.	"widthTable nonEmptyIndicesDo: [:i | widthTable at: i put: sameWidth]."widthTable atAllPut: sameWidth.	^widthTable</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="from:">from: aCompiledBlock	"Recursively create a new ProbedCompiledBlock from aCompliedBlock."	| flags |	probeStart := aCompiledBlock numLiterals + 2.	self at: probeStart - 1 put: #actOn:.	1 to: aCompiledBlock numLiterals do: 		[:i | | lit cl bm |		lit := aCompiledBlock literalAt: i.		cl := lit class.		cl == CompiledBlock			ifTrue: 				[self literalAt: i put: (lit := ProbedCompiledBlock from: lit).				lit outerMethod: self]			ifFalse:				[cl == BlockClosure					ifTrue: 						[self literalAt: i put: (lit := lit copyOld).						bm := ProbedCompiledBlock from: lit method.						lit method: bm.						bm outerMethod: self]					ifFalse: [self literalAt: i put: lit]]].	flags := 16rE0 + (aCompiledBlock usesContextInstVars ifTrue: [16] ifFalse: [0]).	bytes := (ByteArray				with: flags				with: aCompiledBlock numArgs				with: aCompiledBlock numTempsOnly				with: aCompiledBlock frameSize) , aCompiledBlock bytes.	^self</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>probes - recompiling</category><body package="Debugger-Probes" selector="basicReinsertProbesAndIndices:into:">basicReinsertProbesAndIndices: probesAndIndices into: probedMethod	| probesInError |	probesInError := OrderedCollection new.	probesAndIndices do:		[:ac | | probe index newRecord |		probe := ac key baseParent copyOld.		index := ac value.		newRecord := probedMethod probeRecordFor: (index to: index).		probe record: newRecord.		(probe updateTempVarForMethod: probedMethod)			ifTrue: [probedMethod addProbe: probe]			ifFalse:				[newRecord updateMethod: probedMethod.		"update mclass and selector for reporting"				probesInError add: probe]].	probesInError addAll: probedMethod recompileProbes.	ProbedCompiledMethod reportOnFailedProbes: probesInError."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="parent:">parent: aProbe	parent := aProbe.	probeRecord := parent probeRecord copyOld.</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="ifNecessaryCopy:andRebindFrom:">ifNecessaryCopy: aMethod andRebindFrom: oldVariables	"This method returns a new method with rebound variables if	rebinding is needed.  Otherwise, the original method is returned."	| nuMethod keepCopy vars |	variables == nil		ifTrue: [^aMethod].	nuMethod := aMethod copyOld.	keepCopy := false.	vars := OrderedCollection new.	oldVariables associationsDo: [:ac | vars add: ac].	nuMethod withAllBlockMethodsDo:		[:meth |		1 to: meth numLiterals do:			[:i | | lit |			lit := meth at: i.			(vars contains: [:obj | obj == lit])				ifTrue:					[keepCopy := true.					meth at: i put: (variables bindingFor: lit key)]]].	keepCopy		ifFalse: [^aMethod].	^nuMethod</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>commands</category><body package="Debugger-UI" selector="paste">paste	patternList list add: buffer copyOld beforeIndex: patternList selectionIndex + 1.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>commands</category><body package="Debugger-UI" selector="copy">copy	buffer := selection value copyOld.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>commands</category><body package="Debugger-UI" selector="copyOld">copyOld	buffer := selection value copyOld.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor class</class-id> <category>resources</category><body package="Debugger-UI" selector="menuBar">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #pdp) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #pdp) 							#value: #newPattern ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Remove #defaultString: 'Remove' #catalogID: #pdp) 							#value: #removePattern 							#enablementSelector: #patternIsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Undo #defaultString: 'Undo' #catalogID: #pdp) 							#nameKey: #undo 							#value: #undo 							#enablementSelector: #canUndo ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #pdp) 							#value: #copyOld 							#enablementSelector: #patternIsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #pdp) 							#value: #paste 							#enablementSelector: #canPaste ) ) #(2 1 2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor class</class-id> <category>resources</category><body package="Debugger-UI" selector="menu">menu	"MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #pdp) 				#value: #newPattern ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Remove #defaultString: 'Remove' #catalogID: #pdp) 				#value: #removePattern 				#enablementSelector: #patternIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Undo #defaultString: 'Undo' #catalogID: #pdp) 				#nameKey: #undo 				#value: #undo 				#enablementSelector: #canUndo ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #pdp) 				#value: #copyOld 				#enablementSelector: #patternIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #pdp) 				#value: #paste 				#enablementSelector: #canPaste ) ) #(2 1 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>private</category><body package="Debugger-Probes" selector="createWindow">createWindow	| aView subViews visual labelBottom |	window := ScheduledWindow				model: self				label: (#WatchWindow &lt;&lt; #pdp &gt;&gt; 'Watch window')				minimumSize: 200@100.	aView := WatchWindowView model: self.	aView controller performer: self.	aView controller menuHolder:		(ValueHolder with: (Menu 			labelList: #((again undo) (#copyOld cut paste) ('do it' 'print it' 'inspect') 						(cancel) (hardcopy) ('log on' 'log off'))			values: #(again undo copySelection cut paste doIt printIt						inspectIt cancel hardcopy doLog dontLog))).	subViews := CompositePart new.	visual := label asText allBold asParagraph.	labelBottom := visual preferredBounds height + 4.	labelView := BorderedWrapper			on: visual			in: (LayoutFrame					leftFraction: 0 offset: 0					rightFraction: 1 offset: 0					topFraction: 0 offset: 0					bottomFraction: 0 offset: labelBottom)			border: LookPreferences defaultBorder.	subViews add: labelView.	subViews		add: (LookPreferences edgeDecorator on: aView)		in: (LayoutFrame					leftFraction: 0 offset: 0					rightFraction: 1 offset: 0					topFraction: 0 offset: labelBottom					bottomFraction: 1 offset: 0).	window component: subViews.	^window</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="Debugger-Probes" selector="copy">copy	^self class registerMethod: super copyOld.</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="Debugger-Probes" selector="copyOld">copyOld	^self class registerMethod: super copyOld.</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="from:full:">from: aCompiledMethod full: fullFlag	| adjustedMethod compiler |	original := aCompiledMethod.	mclass := aCompiledMethod mclass.	sourceCode := aCompiledMethod sourcePointer.	(mclass compilerClass == Compiler		or: [(mclass compilerClass respondsTo: #treatsAsSimpleSmalltalk:)			and: [mclass compilerClass treatsAsSimpleSmalltalk: self getSource]])		ifFalse: [^self error: (#CannotInsertIncompatibleCompiler &lt;&lt; #pdp &gt;&gt; 'Cannot insert probe, selected class uses incompatible compiler.')].	compiler := ProbeExprCompiler new.	fullFlag		ifTrue: [compiler setCompileForProbes].	methodHolder := compiler			parse: aCompiledMethod getSource			in: mclass			environment: aCompiledMethod environment			allowReceiver: true			noPattern: aCompiledMethod usuallyHasSelector not			notifying: nil.	adjustedMethod := methodHolder generate.	probeStart := adjustedMethod numLiterals + 2.	self at: probeStart - 1 put: #actOn:.	1 to: adjustedMethod numLiterals do: 		[:i | | lit cl bm |		lit := adjustedMethod literalAt: i.		cl := lit class.		cl == CompiledBlock			ifTrue: 				[self literalAt: i put: (lit := ProbedCompiledBlock from: lit).				lit outerMethod: self]			ifFalse:				[cl == BlockClosure					ifTrue: 						[self literalAt: i put: (lit := lit copyOld).						bm := ProbedCompiledBlock from: lit method.						lit method: bm.						bm outerMethod: self]					ifFalse: [self literalAt: i put: lit]]].	self initializeBytes.	^self</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>selection moving-sizing</category><body package="UIPainter" selector="doVerticalSizing:spacing:">doVerticalSizing: aSymbol spacing: anIntegerOrNil	| selectedWidgets newHeight |	(selectedWidgets := self selectionList) size &gt; 1 ifFalse: [^self].  	self hideHandles.	aSymbol == #absolute 	ifTrue: 		[newHeight := anIntegerOrNil].	aSymbol == #first ifTrue:		[newHeight := self computeAlignmentPosition: [:bounds | bounds height] forceNoPrimary: false].	aSymbol == #max ifTrue:		[newHeight := selectedWidgets inject: 0 into: [:sum :each | sum max: each bounds height]].	aSymbol == #min ifTrue:		[newHeight := selectedWidgets inject: SmallInteger maxVal into: [:sum :each | sum min: each bounds height]].	selectedWidgets do:		[:each  | | boundingBox |		boundingBox := each bounds.		view newBounds: (boundingBox copyOld height: newHeight) oldBounds: boundingBox forWrapper: each].	self showHandles.	self canvasHasChanged: true.	view invalidate</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>commands</category><body package="UIPainter" selector="doDefine">doDefine	model definer		interactivelyUpgradeDefns: self selectionList copyOld		for: self</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private-grouping</category><body package="UIPainter" selector="embedLayout:for:containedBy:">embedLayout: layout for: bounds containedBy: containingBounds	| l |	l := layout copyOld.	(layout isKindOf: LayoutOrigin)		ifTrue: [(layout leftFraction &gt; 0 and: [layout leftOffset ~= 0])					ifTrue: [l leftFraction: bounds left asFloat / containingBounds width offset: 0].				(layout topFraction &gt; 0 and: [layout topOffset ~= 0])					ifTrue: [l topFraction: bounds top asFloat / containingBounds height offset: 0].				(layout isKindOf: LayoutFrame) ifFalse: [^l].				(layout rightFraction &gt; 0 and: [layout rightOffset ~= 0])					ifTrue: [l rightFraction: bounds right asFloat / containingBounds width offset: 0].				(layout bottomFraction &gt; 0 and: [layout bottomOffset ~= 0])					ifTrue: [l bottomFraction: bounds bottom asFloat / containingBounds height offset: 0]].	^l</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>selection moving-sizing</category><body package="UIPainter" selector="doHorizontalSizing:spacing:">doHorizontalSizing: aSymbol spacing: anIntegerOrNil	| selectedWidgets newWidth |	(selectedWidgets := self selectionList) size &gt; 1 ifFalse: [^self].  	self hideHandles.	aSymbol == #absolute 	ifTrue: 		[newWidth := anIntegerOrNil].	aSymbol == #first ifTrue:		[newWidth := self computeAlignmentPosition: [:bounds | bounds width] forceNoPrimary: false].	aSymbol == #max ifTrue:		[newWidth := selectedWidgets inject: 0 into: [:sum :each | sum max: each bounds width]].	aSymbol == #min ifTrue:		[newWidth := selectedWidgets inject: SmallInteger maxVal into: [:sum :each | sum min: each bounds width]].	selectedWidgets do:		[:each  | | boundingBox |		boundingBox := each bounds.		view newBounds: (boundingBox copyOld width: newWidth) oldBounds: boundingBox forWrapper: each].	self showHandles.	self canvasHasChanged: true.	view invalidate</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private-grouping</category><body package="UIPainter" selector="extractLayout:for:containedBy:">extractLayout: layout for: bounds containedBy: containingBounds	| l |	l := layout copyOld.	(layout isKindOf: LayoutFrame)		ifTrue: [(layout leftFraction = 0 and: [layout leftOffset = 0 and: [(layout rightFraction + layout topFraction + layout bottomFraction) ~= 0]])					ifTrue: [l leftFraction: bounds left asFloat / containingBounds width].				(layout topFraction = 0 and: [layout topOffset = 0 and: [(layout bottomFraction + layout leftFraction + layout rightFraction ) ~= 0]])					ifTrue: [l topFraction: bounds top asFloat / containingBounds height]]		ifFalse: [(layout isKindOf: LayoutOrigin)					ifTrue: [(layout leftFraction = 0 and: [layout leftOffset = 0 and: [layout topFraction ~= 0]])								ifTrue: [l leftFraction: bounds left asFloat / containingBounds width].							(layout topFraction = 0 and: [layout topOffset = 0 and: [layout leftFraction ~= 0]])								ifTrue: [l topFraction: bounds top asFloat / containingBounds height]]].	^l</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private</category><body package="UIPainter" selector="fractionalConstraintDialogForOriginal:frame:">fractionalConstraintDialogForOriginal: sel frame: aFrame	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method could be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol, but for the moment we	are trying to minimize changes to the base product."	|  frame  leftOffset leftFraction topOffset topFraction  alignmentX alignmentY dialog bounds  box newLeftFraction newTopFraction newLeftOffset newTopOffset newAlignmentX newAlignmentY builder |	frame := aFrame.	leftFraction := self frameValueHolderFor: frame leftFraction.	(leftOffset := self frameValueHolderFor: frame leftOffset)		compute:			[:v |			(leftFraction value = '' and: [(v = '') not])				ifTrue: [leftFraction value: '0']].	topFraction := self frameValueHolderFor: frame topFraction.	(topOffset := self frameValueHolderFor: frame topOffset)		compute:			[:v |			(topFraction value = '' and: [(v = '') not])				ifTrue: [topFraction value: '0']].	(frame isKindOf: AlignmentOrigin)		ifTrue: [alignmentX := self frameValueHolderFor: frame leftAlignmentFraction.				alignmentY := self frameValueHolderFor: frame topAlignmentFraction]		ifFalse: [alignmentX := self frameValueHolderFor: 0.				alignmentY := self frameValueHolderFor: 0].	dialog :=SimpleDialog new.	builder := dialog builder.	builder source: self.	builder aspectAt: #leftOffset put: leftOffset.	builder aspectAt: #leftFraction put: leftFraction.	builder aspectAt: #topOffset put: topOffset.	builder aspectAt: #topFraction put: topFraction.	builder aspectAt: #alignmentX put: alignmentX.	builder aspectAt: #alignmentY put: alignmentY.	builder aspectAt: #leftSlide put: (TypeConverter on: leftFraction) stringToNumber.	builder aspectAt: #topSlide put: (TypeConverter on: topFraction) stringToNumber.	builder aspectAt: #alignmentXSlide put: (TypeConverter on: alignmentX) stringToNumber.	builder aspectAt: #alignmentYSlide put: (TypeConverter on: alignmentY) stringToNumber.	builder aspectAt: #emptyAlignmentX put: [alignmentX value: ''].	builder aspectAt: #emptyAlignmentY put: [alignmentY value: ''].	builder aspectAt: #emptyLeft put: [leftOffset value: ''. leftFraction value: ''].	builder aspectAt: #emptyTop put: [topOffset value: ''. topFraction value: ''].	(dialog openFrom: (self class interfaceSpecFor: #placementFrameDialogSpec)) ifFalse: [^self].	bounds := self view bounds.	frame := sel layout asLayout copyOld.	box := sel bounds.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box width * frame leftAlignmentFraction]						ifFalse: [0]) -					(bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box height * frame topAlignmentFraction]						ifFalse: [0]) -					(bounds height * newTopFraction) rounded)].	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	newAlignmentX := self frameNumberFor: alignmentX.	newAlignmentY := self frameNumberFor: alignmentY.	(newAlignmentX notNil or: [newAlignmentY notNil])		ifTrue:			[((newAlignmentX ~= 0 or: [newAlignmentY ~= 0]) and:					[(frame isKindOf: AlignmentOrigin) not])				ifTrue: [frame := frame asAlignmentOrigin]].	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newAlignmentX notNil				ifTrue:					[frame leftOffset: frame leftOffset +						(((newAlignmentX -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame leftAlignmentFraction]								ifFalse: [0])) * box width) rounded)]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newAlignmentY notNil				ifTrue:					[frame topOffset: frame topOffset +						(((newAlignmentY -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame topAlignmentFraction]								ifFalse: [0])) * box height) rounded)]].	(frame isKindOf: AlignmentOrigin)		ifTrue:			[newAlignmentX notNil				ifTrue: [frame leftAlignmentFraction: newAlignmentX].			newAlignmentY notNil				ifTrue: [frame topAlignmentFraction: newAlignmentY]].	(self validateFrame: frame for: sel widget)		ifFalse: [^self].	sel newLayout: frame reducedForm.	view bounds: view bounds.	view topComponent display.	self canvasHasChanged: true.	^self</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private</category><body package="UIPainter" selector="fractionalConstraintDialogForRectangular:frame:">fractionalConstraintDialogForRectangular: sel frame: aFrame	|  frame  leftOffset leftFraction rightOffset rightFraction topOffset topFraction bottomOffset bottomFraction dialog bounds oldFrame box newLeftFraction newTopFraction newLeftOffset newTopOffset newRightFraction newBottomFraction newRightOffset newBottomOffset builder |	frame := aFrame.	(leftFraction := self frameValueHolderFor: frame leftFraction)		compute: [:v | self correctFraction: leftFraction].	(leftOffset := self frameValueHolderFor: frame leftOffset)		compute: [:v | self defaultFraction: leftFraction forOffsetString: v].	(rightFraction := self frameValueHolderFor: frame rightFraction)		compute: [:v | self correctFraction: rightFraction].	(rightOffset := self frameValueHolderFor: frame rightOffset)		compute: [:v | self defaultFraction: rightFraction forOffsetString: v].	(topFraction := self frameValueHolderFor: frame topFraction)		compute: [:v | self correctFraction: topFraction].	(topOffset := self frameValueHolderFor: frame topOffset)		compute: [:v | self defaultFraction: topFraction forOffsetString: v].	(bottomFraction := self frameValueHolderFor: frame bottomFraction)		compute: [:v | self correctFraction: bottomFraction].	(bottomOffset := self frameValueHolderFor: frame bottomOffset)		compute: [:v | self defaultFraction: bottomFraction forOffsetString: v].	dialog :=SimpleDialog new.	builder := dialog builder.	builder source: self.	builder aspectAt: #leftOffset put: leftOffset.	builder aspectAt: #leftFraction put: leftFraction.	builder aspectAt: #topOffset put: topOffset.	builder aspectAt: #topFraction put: topFraction.	builder aspectAt: #rightOffset put: rightOffset.	builder aspectAt: #rightFraction put: rightFraction.	builder aspectAt: #bottomOffset put: bottomOffset.	builder aspectAt: #bottomFraction put: bottomFraction.	builder aspectAt: #leftSlide put: (TypeConverter on: leftFraction) stringToNumber.	builder aspectAt: #topSlide put: (TypeConverter on: topFraction) stringToNumber.	builder aspectAt: #rightSlide put: (TypeConverter on: rightFraction) stringToNumber.	builder aspectAt: #bottomSlide put: (TypeConverter on: bottomFraction) stringToNumber.	builder aspectAt: #emptyLeft put: [leftOffset value: ''. leftFraction value: ''].	builder aspectAt: #emptyTop put: [topOffset value: ''. topFraction value: ''].	builder aspectAt: #emptyRight put: [rightOffset value: ''. rightFraction value: ''].	builder aspectAt: #emptyBottom put: [bottomOffset value: ''. bottomFraction value: ''].	(dialog openFrom: (self class interfaceSpecFor: #layoutFrameDialogSpec)) ifFalse: [^self].	bounds := self view bounds.	frame := sel layout asLayout copyOld.	oldFrame := frame copyOld.	box := sel bounds.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left - (bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top - (bounds height * newTopFraction) rounded)].	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	(newRightFraction := self frameNumberFor: rightFraction) notNil		ifTrue:			[frame rightFraction: newRightFraction.			frame rightOffset:				(box right - (bounds width * newRightFraction) rounded)].	(newBottomFraction := self frameNumberFor: bottomFraction) notNil		ifTrue:			[frame bottomFraction: newBottomFraction.			frame bottomOffset:				(box bottom - (bounds height * newBottomFraction) rounded)].	newRightOffset := self frameNumberFor: rightOffset.	newBottomOffset := self frameNumberFor: bottomOffset.	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newRightOffset notNil				ifTrue:					[frame leftOffset:						frame leftOffset							+ (bounds width * (newRightFraction - oldFrame rightFraction)) rounded							+ newRightOffset - oldFrame rightOffset]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newBottomOffset notNil				ifTrue:					[frame topOffset:						frame topOffset							+ (bounds height * (newBottomFraction - oldFrame bottomFraction)) rounded							+ newBottomOffset - oldFrame bottomOffset]].	newRightOffset notNil		ifTrue: [frame rightOffset: newRightOffset]		ifFalse:			[newLeftOffset notNil				ifTrue:					[frame rightOffset:						frame rightOffset							+ (bounds width * (newLeftFraction - oldFrame leftFraction)) rounded							+ newLeftOffset - oldFrame leftOffset]].	newBottomOffset notNil		ifTrue: [frame bottomOffset: newBottomOffset]		ifFalse:			[newTopOffset notNil				ifTrue:					[frame bottomOffset:						frame bottomOffset							+ (bounds height * (newTopFraction - oldFrame topFraction)) rounded							+ newTopOffset - oldFrame topOffset]].	(self validateFrame: frame for: sel widget)		ifFalse: [^self].	sel newLayout: frame reducedForm.	view bounds: view bounds.	view topComponent display.	self canvasHasChanged: true.	^self</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private</category><body package="UIPainter" selector="replaceSubCanvasesOfClass:andSelector:">replaceSubCanvasesOfClass: aClassName andSelector: aSelector	|  targetWrappers oldSels oldState |	oldSels := self selectionList copyOld.	targetWrappers := IdentitySet new.	view		downcastEvent: #mapBlock		with:			[:wrpr |			| spec |			((wrpr respondsTo: #spec) and: [((spec := wrpr spec) isKindOf: SubCanvasSpec) and:				[spec majorKey asQualifiedReference = aClassName asQualifiedReference and:					[spec minorKey == aSelector]]])				ifTrue:					[targetWrappers add: wrpr]]		from: view.	targetWrappers isEmpty ifTrue: [^self].	"The subcanvas that needs updating may be buried at any depth within the	structure."	targetWrappers copyOld do:		[:wrpr |		(view components includes: wrpr)			ifFalse:				[targetWrappers remove: wrpr.				targetWrappers addAll: (self model definer findSelectablesIn: self havingSpecs: (Array with: wrpr spec))]].	oldState := self canvasHasChanged.	targetWrappers do:		[:wrpr |		| new |		new := self replaceElement: wrpr basedOnSpec: wrpr spec.		(oldSels includes: wrpr)			ifTrue: [self quietlySelect: new]].	canvasHasChanged := oldState.	"The canvas that we just updated ourselves for may not be present in some	subcanvas structures that include us, simply because those structures were	built before the canvas was created.  Force the dependents that know about	us to update themselves.  This is going to result in some canvases getting	multiply updated; not nice, but better than missing updates."	(self model targetClass notNil and: [self model targetSelector notNil])		ifTrue:			[UIFinderVW2 changed: #installedCanvas					with: (Array with: model targetClass with: model targetSelector)]</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>class initialization</category><body package="UIPainter" selector="initializeDispatchTable">initializeDispatchTable	"Initialize the keyboard dispatch table"	"UIPainterController initializeDispatchTable."	KeyboardDispatchTable := DispatchTable new.	KeyboardDispatchTable defaultForCharacters: #ignoreInputKey:.	KeyboardDispatchTable defaultForNonCharacters: #ignoreInputKey:.	KeyboardDispatchTable bindValue: #cutKey: to: Character del.	KeyboardDispatchTable bindValue: #pasteKey: to: Character lf.	KeyboardDispatchTable bindValue: #cutKey: to: Character backspace.	"Sun convention compatibility"	KeyboardDispatchTable bindValue: #undoKey: to: #L4.	KeyboardDispatchTable bindValue: #copyKey: to: #L6.	KeyboardDispatchTable bindValue: #pasteKey: to: #L8.	KeyboardDispatchTable bindValue: #cutKey: to: #L10.	"Mac convention compatibility"	KeyboardDispatchTable bindValue: #undoKey: toCommand: #undo.	KeyboardDispatchTable bindValue: #cutKey: toCommand: #cut.	KeyboardDispatchTable bindValue: #copyKey: toCommand: #copyOld.	KeyboardDispatchTable bindValue: #pasteKey: toCommand: #paste.		KeyboardDispatchTable bindValue: #circulateBackKey: toCommand: #uipainterCirculateBackwards.	KeyboardDispatchTable bindValue: #circulateFrontKey: toCommand: #uipainterCirculateFrontwards.	KeyboardDispatchTable bindValue: #tabSelectKey: to: Character tab.	KeyboardDispatchTable bindValue: #bumpUpKey: to: #Up.	KeyboardDispatchTable bindValue: #bumpDownKey: to: #Down.	KeyboardDispatchTable bindValue: #bumpLeftKey: to: #Left.	KeyboardDispatchTable bindValue: #bumpRightKey: to: #Right.	KeyboardDispatchTable bindValue: #alignTopKey: toCommand: #uipainterAlignTop.	KeyboardDispatchTable bindValue: #alignBottomKey: toCommand: #uipainterAlignBottom.	KeyboardDispatchTable bindValue: #alignRightKey: toCommand: #uipainterAlignRight.	KeyboardDispatchTable bindValue: #alignLeftKey: toCommand: #uipainterAlignLeft.	KeyboardDispatchTable bindValue: #alignDialogKey: toCommand: #uipainterAlign.	KeyboardDispatchTable bindValue: #distributeDialogKey: toCommand: #uipainterDistribute.	KeyboardDispatchTable bindValue: #equalizeDialogKey: toCommand: #uipainterEqualize.	KeyboardDispatchTable bindValue: #layoutKey: toCommand: #uipainterLayout.	KeyboardDispatchTable bindValue: #dialogKey: toCommand: #uipainterDialog.	KeyboardDispatchTable bindValue: #groupKey: toCommand: #uipainterGroup.	KeyboardDispatchTable bindValue: #ungroupKey: toCommand: #uipainterUngroup.	KeyboardDispatchTable bindValue: #beRelativeKey: toCommand: #uipainterBeRelative.	KeyboardDispatchTable bindValue: #beFixedKey: toCommand: #uipainterBeFixed.	KeyboardDispatchTable bindValue: #snapSelectionToGridKey: toCommand: #uipainterSnapSelectionToGrid.	KeyboardDispatchTable bindValue: #installKey: toCommand: #uipainterInstall.</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>resources</category><body package="UIPainter" selector="canvasMenu">canvasMenu	"MenuEditor new openOnClass: self andSelector: #canvasMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #UIPainter) 							#value: #doCopy #command: #copyOld ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #UIPainter) 							#value: #doCut #command: #cut ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #UIPainter) 							#value: #doPaste #command: #paste ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #UIPainter) 							#value: #accept #command: #accept) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: #(#{Kernel.UserMessage} #key: #Confirm #defaultString: 'Confirm' #catalogID: #UIPainter) 										#value: #cancel ) ) #(1 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Spawn #defaultString: 'Spawn' #catalogID: #UIPainter) 							#value: #doSpawn ) ) #(3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Tools #defaultString: 'Tools' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ImageEditor #defaultString: 'Image Editor' #catalogID: #UIPainter) 							#value: #maskEditor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #MenuEditor #defaultString: 'Menu Editor' #catalogID: #UIPainter) 							#value: #menuEditor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #HotRegionsEditor #defaultString: 'Hot Regions Editor' #catalogID: #UIPainter) 							#value: #regionsEditor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ReusableDataFormComponents #defaultString: 'Reusable Data Form Components' #catalogID: #UIPainter) 							#nameKey: #openReusableComponents							#value: #openReusableComponents ) ) #(3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Layout #defaultString: 'Layout' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Fixed #defaultString: 'Fixed' #catalogID: #UIPainter) 							#nameKey: #doLayoutFixed							#value: #doLayoutFixed #command: #uipainterBeFixed ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Relative #defaultString: 'Relative' #catalogID: #UIPainter) 							#nameKey: #doLayoutRelative							#value: #doLayoutRelative #command: #uipainterBeRelative ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Constrained #defaultString: 'Constrained...' #catalogID: #UIPainter) 							#nameKey: #fractionalConstraintDialog							#value: #fractionalConstraintDialog ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BeBounded #defaultString: 'Be Bounded' #catalogID: #UIPainter) 							#nameKey: #doMakeBounded							#value: #doMakeBounded ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BeUnbounded #defaultString: 'Be Unbounded' #catalogID: #UIPainter) 							#nameKey: #doMakeUnBounded							#value: #doMakeUnBounded ) ) #(3 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Arrange #defaultString: 'Arrange' #catalogID: #UIPainter) 				#nameKey: #arrange				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SnapToGrid #defaultString: 'Snap To Grid' #catalogID: #UIPainter) 							#value: #doSnapSelectionToGrid #command: #uipainterSnapSelectionToGrid ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Group #defaultString: 'Group' #catalogID: #UIPainter) 							#nameKey: #doGroup 							#value: #doGroup #command: #uipainterGroup ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Ungroup #defaultString: 'Ungroup' #catalogID: #UIPainter) 							#nameKey: #doUngroup 							#value: #doUngroup #command: #uipainterUngroup ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BringToFront #defaultString: 'Bring To Front' #catalogID: #UIPainter) 							#value: #toVisualFront   #command: #uipainterCirculateToFront ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BringForward #defaultString: 'Bring Forward' #catalogID: #UIPainter) 							#value: #toVisualFrontOne  #command: #uipainterCirculateFrontwards ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SendToBack #defaultString: 'Send To Back' #catalogID: #UIPainter) 							#value: #toVisualBack   #command: #uipainterCirculateToBack ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SendBackward #defaultString: 'Send Backward' #catalogID: #UIPainter) 							#value: #toVisualBackOne  #command: #uipainterCirculateBackwards ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #AlignDot #defaultString: 'Align...' #catalogID: #UIPainter) 							#nameKey: #alignDialog 							#value: #alignDialog  #command: #uipainterAlign ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #DistributeDot #defaultString: 'Distribute...' #catalogID: #UIPainter) 							#nameKey: #distributeDialog 							#value: #distributeDialog #command: #uipainterDistribute ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #EqualizeDot #defaultString: 'Equalize...' #catalogID: #UIPainter) 							#nameKey: #equalizeDialog 							#value: #equalizeDialog #command: #uipainterEqualize) ) #(1 2 4 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Special #defaultString: 'Special' #catalogID: #UIPainter) 				#nameKey: #special ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PainterTool #defaultString: 'Painter Tool' #catalogID: #UIPainter) 				#value: #doPainterTool ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Palette #defaultString: 'Palette' #catalogID: #UIPainter) 				#value: #doPalette ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InstallDot #defaultString: 'Install...' #catalogID: #UIPainter) 				#value: #doInstall #command: #uipainterInstall ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DefineDot #defaultString: 'Define...' #catalogID: #UIPainter) 				#nameKey: #doDefine				#value: #doDefine ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #BrowseDot #defaultString: 'Browse...' #catalogID: #UIPainter) 				#nameKey: #doBrowse				#value: #doBrowse ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Open #defaultString: 'Open' #catalogID: #UIPainter) 				#nameKey: #doOpen				#value: #doOpen #command: #open ) ) #(5 6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>private</category><body package="UIPainter" selector="reloadSelectionInformation">reloadSelectionInformation	propertiesTool selectionKind == #multi		ifTrue: 			[self disableRead.			"self enableApply."]		ifFalse: 			[| selSpec |			selSpec := propertiesTool spec.			selSpec isNil ifTrue: [^self].			self enableRead.			self disableApply.			self showColorSettingsFor: selSpec colorSelections.			readMode value				ifTrue: 					[(lookPreferences := selSpec colors copyOld) == nil 						ifTrue: [lookPreferences := LookPreferences new].					self showColors]				ifFalse: [self enableApply]].	propertiesTool updateSelectionInTree</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>actions</category><body package="UIPainter" selector="preapply">preapply	| lp painterController |	painterController := propertiesTool controller.	painterController == nil ifTrue: [^self].	(lookPreferences backgroundColor isNil 			and: [lookPreferences foregroundColor isNil 			and: [lookPreferences selectionForegroundColor isNil 			and: [lookPreferences selectionBackgroundColor isNil]]])		ifTrue: [lp := nil]		ifFalse: [lp := lookPreferences copyOld].	propertiesTool selectionKind == #window		ifTrue: 			[| win temp default |			win := painterController sensor window.			lp == nil				ifTrue: [temp := nil]				ifFalse: 					[temp := win lookPreferences copyOld.					default := win defaultLookPreferences copyOld.					temp setForegroundColor: (lookPreferences foregroundColor == nil							ifTrue: [default foregroundColor]							ifFalse: [lookPreferences foregroundColor]).					temp setBackgroundColor: (lookPreferences backgroundColor == nil							ifTrue: [default backgroundColor]							ifFalse: [lookPreferences backgroundColor]).					temp setSelectionForegroundColor: (lookPreferences selectionForegroundColor == nil							ifTrue: [default selectionForegroundColor]							ifFalse: [lookPreferences selectionForegroundColor]).					temp setSelectionBackgroundColor: (lookPreferences selectionBackgroundColor == nil							ifTrue: [default selectionBackgroundColor]							ifFalse: [lookPreferences selectionBackgroundColor]).					temp setHiliteColor: nil.					temp setShadowColor: nil].			propertiesTool spec colors: temp.			win lookPreferences: temp]		ifFalse: 			[propertiesTool spec colors: lp.			propertiesTool selection do: [:wrpr | wrpr lookPreferences: lp]].	painterController canvasHasChanged: true.	self interruptedRead ifTrue: [self readMode value: true]</body></methods><methods><class-id>Tools.ClassFinder class</class-id> <category>resources</category><body package="Tools-Misc" selector="refreshIcon">refreshIcon	"RefreshIcon := nil"	RefreshIcon == nil		ifTrue: [RefreshIcon := self					iconFigure: self refreshIconColor					shape: self refreshIconMask].	^RefreshIcon copyOld</body></methods><methods><class-id>Tools.GridWrapper</class-id> <category>displaying</category><body package="UIPainter" selector="displayGridOn:">displayGridOn: aGraphicsContext 	| rect gc top g bottom left right |	g := grid value.	gc := aGraphicsContext copyOld.	gc paint: self gridPaint.	rect := aGraphicsContext clippingBounds intersect: self bounds.	left := rect left.	right := rect right.	top := rect top + (g // 2) // g * g.	bottom := rect bottom.	(showGrid value == #Show or: [griddedVertically value])		ifTrue: [[top &lt; bottom]				whileTrue: 					[gc displayRectangle: (left @ top corner: right @ (top + 1)).					top := top + g]].	top := rect top.	left := left + (g // 2) // g * g.	(showGrid value == #Show or: [griddedHorizontally value])		ifTrue: [[left &lt; right]				whileTrue: 					[gc displayRectangle: (left @ top corner: left + 1 @ bottom).					left := left + g]]</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>support</category><body package="UIPainter" selector="cancel">cancel	"Reset to the last accepted state."	| view fullSpec win bounds  |	(view := builder composite) controller removeSelections.	view components copyOld do: [:wrapper | view remove: wrapper. wrapper release].	fullSpec := self defaultSpecClass new fromLiteralArrayEncoding: acceptedState.	builder add: fullSpec component.	windowSpec := fullSpec window.	win := builder window.	(windowSpec labelInBuilder: builder) ifNotNil:[:label| win label: label].	self minWindowExtent: windowSpec min.	self maxWindowExtent: windowSpec max.	(bounds := windowSpec bounds) notNil		ifTrue: 			[self prefWindowExtent: bounds extent].	win lookPreferences: windowSpec colors.</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>support</category><body package="UIPainter" selector="changeComponentPolicyTo:">changeComponentPolicyTo: aPolicyName	| aPolicy currentState controller view formerPrimary formerSelections newSelections allComponents |	aPolicy := ( aPolicyName asQualifiedReference value ) basicNew.	controller := (view := builder composite) controller.	controller broadcastPendingSelectionChange.	currentState := self extractFullSpec.	(formerPrimary := controller primarySelection) notNil		ifTrue: [formerPrimary := formerPrimary spec].	formerSelections := controller selectionList collect: [:sw | sw spec].	controller removeSelections.	view components copyOld do:		[:wrapper | view remove: wrapper. wrapper release].	builder policy: aPolicy.	(view := view topComponent)		edgeDecorationPolicy: aPolicy borderLayoutPolicy.	view widgetPolicy: aPolicy widgetPolicy.	self fixBuildersWindow.	builder add: currentState component.	builder window flushCaches.	allComponents := NamedSpec new drilledWrappersFrom: builder composite components.	newSelections := allComponents select: 		[:each | 		(each isKindOf: SpecWrapper) and: [formerSelections includes: each spec]].	formerPrimary notNil		ifTrue:			[controller select: (allComponents				detect: [:each | formerPrimary == each spec]				ifNone: [#()]).			controller appendSelections: newSelections]		ifFalse: [controller selectionList: newSelections]</body></methods><methods><class-id>Tools.PoolDictionaryInspector</class-id> <category>field list</category><body package="Tools-Inspector" selector="noSelectionMenu">noSelectionMenu	"Answer a Menu of operations on the variables that is to be displayed 	when the operate menu button is pressed."	^object == Undeclared		ifTrue: [super noSelectionMenu copyOld					addItem: ((MenuItem labeled: (#RemoveUnusedBindings &lt;&lt; #menus &gt;&gt; 'Remove unused bindings'))									nameKey: #purgeUnusedBindings;									value: #purgeUnusedBindings;									yourself)]		ifFalse: [super noSelectionMenu]</body></methods><methods><class-id>Tools.Workspace class</class-id> <category>resources</category><body package="Tools-Workspace" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_New 								#defaultString: '&amp;New' 								#catalogID: #menus ) 							#nameKey: #fileNew 							#value: #fileNew 							#command: #new							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceNew ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_OpenDot 								#defaultString: '&amp;Open...' 								#catalogID: #menus ) 							#nameKey: #fileOpen 							#value: #fileOpen 							#command: #open							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Save 								#defaultString: '&amp;Save' 								#catalogID: #menus ) 							#nameKey: #fileSave 							#value: #fileSave 							#enablementSelector: #isAtTextPage 							#command: #save							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_AsDot 								#defaultString: 'Save &amp;As...' 								#catalogID: #menus ) 							#nameKey: #fileSaveAs 							#value: #fileSaveAs 							#command: #saveAs							#enablementSelector: #isAtTextPage ) ) #(1 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #menus ) 				#nameKey: #editMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Undo 								#defaultString: '&amp;Undo' 								#catalogID: #menus ) 							#nameKey: #editUndo 							#value: #undo 							#enablementSelector: #canUndo 							#command: #undo ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Cu_t 								#defaultString: 'Cu&amp;t' 								#catalogID: #menus ) 							#nameKey: #editCut 							#value: #cut 							#enablementSelector: #isAtTextPage 							#command: #cut 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Copy 								#defaultString: '&amp;Copy' 								#catalogID: #menus ) 							#nameKey: #editCopy 							#value: #copySelection 							#command: #copyOld							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Paste 								#defaultString: '&amp;Paste' 								#catalogID: #menus ) 							#nameKey: #editPaste 							#value: #paste 							#command: #paste 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FindDots 								#defaultString: '&amp;Find...' 								#catalogID: #menus ) 							#nameKey: #editFind 							#value: #find 							#command: #find ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReplaceDots 								#defaultString: '&amp;Replace...' 								#catalogID: #menus ) 							#nameKey: #editReplace 							#value: #replace 							#command: #replace ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Select_All 								#defaultString: 'Select &amp;All' 								#catalogID: #menus ) 							#nameKey: #editSelectAll 							#value: #selectAll							#command: #selectAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Encoding 								#defaultString: '&amp;Encoding' 								#catalogID: #menus ) 							#nameKey: #editEncoding ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_InDot 								#defaultString: 'Boss &amp;In...' 								#catalogID: #menus ) 							#value: #bossIn 							#enablementSelector: #canBOSSObjects ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_OutDot 								#defaultString: 'Boss &amp;Out...' 								#catalogID: #menus ) 							#value: #bossOut 							#enablementSelector: #canBOSSObjects ) ) #(1 3 2 1 1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Smalltalk 					#defaultString: '&amp;Smalltalk' 					#catalogID: #menus ) 				#nameKey: #smalltalkSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DoIt 								#defaultString: '&amp;Do it' 								#catalogID: #menus ) 							#value: #smalltalkDoIt 							#command: #doIt 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PrintIt 								#defaultString: '&amp;Print it' 								#catalogID: #menus ) 							#value: #smalltalkPrintIt 							#command: #printIt 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InspectIt 								#defaultString: '&amp;Inspect it' 								#catalogID: #menus ) 							#value: #smalltalkInspectIt 							#command: #inspectIt 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #De_bugIt 								#defaultString: 'De&amp;bug it' 								#catalogID: #menus ) 							#value: #smalltalkDebugIt 							#command: #debugIt 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NamespacesDot 								#defaultString: '&amp;Namespaces...' 								#catalogID: #menus ) 							#value: #editImports 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.BehaviorIcons} #Namespace ) ) ) #(4 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #menus ) 				#nameKey: #viewSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Text 								#defaultString: '&amp;Text' 								#catalogID: #menus ) 							#nameKey: #pageText 							#value: #showTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Variables 								#defaultString: '&amp;Variables' 								#catalogID: #menus ) 							#nameKey: #pageVariables 							#value: #showInspectorPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_BecomeMultiPage 								#defaultString: '&amp;Become Multi-Page' 								#catalogID: #menus ) 							#value: #mutateToWorkbook ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Options 					#defaultString: '&amp;Options' 					#catalogID: #menus ) 				#nameKey: #optionsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Toolbar 								#defaultString: '&amp;Toolbar' 								#catalogID: #menus ) 							#nameKey: #toolbar 							#value: #toggleToolbar 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_StatusBar 								#defaultString: '&amp;Status Bar' 								#catalogID: #menus ) 							#nameKey: #toggleStatusBar 							#value: #toggleStatusBar ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Workspace 								#defaultString: '&amp;Workspace' 								#catalogID: #menus ) 							#value: #helpWorkspace 							#command: #help 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(1 1 ) nil ) ) ) #(6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.SettingsDomain</class-id> <category>notifications</category><body package="Tools-Settings" selector="tryInstallingSomeUnappliedSnapshots">tryInstallingSomeUnappliedSnapshots	"Since this is called by #instanceMethodsChanged which may be called often,	be careful about doing things efficiently. In particular, do not instantiate settings	unless it is necessary, and instead dealing with pragmas directly."	| pragmas |	pragmas := Dictionary new.	(Pragma allNamed: #setting: in: self class class) do:		[:each | pragmas at: (each argumentAt: 1) put: each].	(Pragma allNamed: #setting:position: in: self class class) do:		[:each | pragmas at: (each argumentAt: 1) put: each].	unappliedSnapshots copyOld do:		[:each | | pragma setting |		(pragmas includesKey: each id) ifTrue:			[pragma := pragmas at: each id.			setting := self class perform: pragma selector.			[setting restoreFrom: each]				on: InvalidStoredSettingDataError				do: [:ex | ex return].			unappliedSnapshots remove: each]]</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>private</category><body package="Tools-Misc" selector="spawnFile">spawnFile	"Open a FileList if the selected file is a directory otherwise open a file 	editor that edits the current selection."	| state controller splitFileName newFileName |	self isFileInfo ifTrue: [^self spawnFileList].	self isDirectory ifTrue: [^self spawnFileList].	self isFileEditing ifFalse: [^self invalidMenuOptionClicked].	controller := self textEditorController.	state := Array				with: controller text copyOld				with: controller selectionStartIndex				with: controller selectionStopIndex.	splitFileName := Filename splitExtension: fileName.	newFileName := splitFileName first , '-copy.' , splitFileName last.	self class openOnFileNamed: newFileName withTextState: state</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="catalogIDFor:put:">catalogIDFor: item put: aSymbolOrNil	| changed |	changed := true.	item rawLabel isString		ifTrue: 			[aSymbolOrNil isNil 				ifTrue: [changed := false]				ifFalse: 					[item rawLabel: (UserMessage 						defaultString: item rawLabel 						key: nil 						catalogID: aSymbolOrNil)]]		ifFalse: 			[item rawLabel: ((aSymbolOrNil isNil and: [item rawLabel key isNil])				ifTrue: [item rawLabel defaultString]				ifFalse: [item rawLabel copyOld catalogID: aSymbolOrNil])].	changed ifTrue: 		[menuList list			changed: #at:			with: menuList selectionIndexes asArray first].	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="defaultStringFor:put:">defaultStringFor: item put: aStringOrNil	| ensuredString |	ensuredString := aStringOrNil ifNil: [String new] ifNotNil: [aStringOrNil trimBlanks].	(item rawLabel isNil			or: [item rawLabel isString 			or: [item rawLabel key isNil &amp; item rawLabel catalogID isNil]])		ifTrue: [item rawLabel: ensuredString]		ifFalse: [item rawLabel: (item rawLabel copyOld defaultString: ensuredString)].	menuList list		changed: #at:		with: menuList selectionIndexes asArray first.	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>actions</category><body package="UIPainter" selector="read">read	| isMenuBar spec controller mnu sels |	self changeRequest ifFalse: [^self].	isMenuBar := false.	controller := selectionHolder value.	sels := controller selections.	spec := (sels isNil or: [sels isEmpty])		ifTrue:			[isMenuBar := true.			controller model windowSpec]		ifFalse: [controller selections first spec].	"We are relying on Read not being enabled if the selected component's	controller does not understand #menu."	spec menu isNil		ifTrue:			[(isMenuBar not and: [(mnu := sels first widget controller menu copyOld) notNil])				ifFalse:					[Dialog warn: (#GenKey6 &lt;&lt; #UIPainter &gt;&gt; 'The selected component''s propertiesdon''t specify a menu') for: builder window.					^self]]		ifFalse:			[mnu := controller builder menuAt: spec menu].	(mnu isNil or: [((mnu := mnu value) isKindOf: Menu) not])		ifTrue:			[Dialog warn: (#GenKey5 &lt;&lt; #UIPainter &gt;&gt; 'The application did not supply a menu.') for: builder window.			^self].	self initializeFromMenu: mnu.	self targetClass: controller builder source selector: spec menu.</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private</category><body package="UIPainter" selector="pasteBufferDepth:">pasteBufferDepth: newDepth	| delta |	PasteBuffer == nil ifTrue: [PasteBuffer := #()].	delta := PasteBuffer size = 0			ifTrue: [0]			ifFalse: [newDepth-PasteBuffer first value].	^PasteBuffer collect: [:i | i key copyOld-&gt;(i value+delta)]</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private</category><body package="UIPainter" selector="copySelection:">copySelection: list	PasteBuffer := list collect: [:i | i key copyOld-&gt;i value]</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="helpCatalogIDFor:put:">helpCatalogIDFor: item put: aSymbolOrNil 	| changed |	changed := true.	item helpText isString 		ifTrue: 			[aSymbolOrNil isNil 				ifTrue: [changed := false]				ifFalse: [item helpText: (UserMessage 								defaultString: item helpText								key: nil								catalogID: aSymbolOrNil)]]		ifFalse: 			[item helpText: ((aSymbolOrNil isNil and: [item helpText key isNil]) 				ifTrue: [item helpText defaultString]				ifFalse: [item helpText copyOld catalogID: aSymbolOrNil])].	changed ifTrue: 			[menuList list 				changed: #at:				with: menuList selectionIndexes asArray first].	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="labelKeyFor:put:">labelKeyFor: item put: aSymbolOrNil	| changed |	changed := true.	item rawLabel isString 		ifTrue: 			[aSymbolOrNil isNil 				ifTrue: [changed := false]				ifFalse: [item rawLabel: (UserMessage defaultString: item rawLabel key: aSymbolOrNil)]]		ifFalse: 			[item rawLabel: ((aSymbolOrNil isNil and: [item rawLabel catalogID isNil])				ifTrue: [item rawLabel defaultString]				ifFalse: [item rawLabel copyOld key: aSymbolOrNil])].	changed ifTrue: 		[menuList list			changed: #at:			with: menuList selectionIndexes asArray first].	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>editing operations</category><body package="UIPainter" selector="shiftLeft">shiftLeft	"Move all selected items to the left. If one of the	selected items is already at the left margin, do nothing.	If a selected item has a submenu, then the submenu	is also shifted left in order to preserve the integrity of	the menu."	| list sel list1 |	list := menuList selectionIndexes copyOld.	list1 := list copyOld.		"Add in the submenu, but only if it has not		been added before. This means that the left		shift will add extra items ONLY when needed		to preserve the integrity of the menu, which		means that there's a greater chance that a		right shift will be able to undo the edit."	list copyOld do:		[:i | (list1 includes: i+1)			ifFalse: [list addAll: (self indicesForAllChildren: i)]].	menuList selectionIndexes: list.	(list contains: [:i | (menuList list at: i) value = 0])		ifTrue: [^self flash].	list do:		[:i |		sel := menuList list at: i.		sel value: (sel value-1 max: 0).		menuList list changed: #at: with: i.		].	self updateProperties.	self rebuildMenu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="helpLabelKeyFor:put:">helpLabelKeyFor: item put: aSymbolOrNil 	| changed |	changed := true.	item helpText isString 		ifTrue: 			[aSymbolOrNil isNil 				ifTrue: [changed := false]				ifFalse: [item helpText: (UserMessage 								defaultString: item helpText								key: aSymbolOrNil)]]		ifFalse: 			[item helpText: ((aSymbolOrNil isNil and: [item helpText catalogID isNil]) 				ifTrue: [item helpText defaultString]				ifFalse: [item helpText copyOld key: aSymbolOrNil])].	changed ifTrue: 			[menuList list 				changed: #at:				with: menuList selectionIndexes asArray first].	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>resources</category><body package="UIPainter" selector="itemsMenu">itemsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #itemsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #UIPainter ) 				#value: #cutItem 				#shortcutKeyCharacter: $X 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #UIPainter ) 				#value: #copyItem 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copyOld ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #UIPainter ) 				#value: #pasteBelow 				#shortcutKeyCharacter: $V 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Delete 					#defaultString: 'Delete' 					#catalogID: #UIPainter ) 				#value: #removeSelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) ) ) #(3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>resources</category><body package="UIPainter" selector="toolBar">toolBar	"MenuEditor new openOnClass: self andSelector: #toolBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install' #catalogID: #UIPainter) 				#nameKey: #install 				#value: #install 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #installMenu ) 				#helpText: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InsertItem #defaultString: 'Insert Item' #catalogID: #UIPainter) 				#nameKey: #addBelow 				#value: #addBelow 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuItem ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #insertItem 					#defaultString: 'Insert Item' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InsertSeparator #defaultString: 'Insert Separator' #catalogID: #UIPainter) 				#nameKey: #addLine 				#value: #addLine 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuSeparator ) 				#helpText: #(#{Kernel.UserMessage} #key: #InsertSeparator #defaultString: 'Insert Separator' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InsertSubmenuItem #defaultString: 'Insert Submenu Item' #catalogID: #UIPainter) 				#nameKey: #addChild 				#value: #addChild 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newSubmenuItem ) 				#helpText: #(#{Kernel.UserMessage} #key: #InsertSubmenuItem #defaultString: 'Insert Submenu Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CutItem #defaultString: 'Cut Item' #catalogID: #UIPainter) 				#nameKey: #cutItem 				#value: #cutItem 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) 				#helpText: #(#{Kernel.UserMessage} #key: #CutItem #defaultString: 'Cut Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CopyItem #defaultString: 'Copy Item' #catalogID: #UIPainter) 				#nameKey: #copyItem 				#value: #copyItem 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copyOld ) 				#helpText: #(#{Kernel.UserMessage} #key: #CopyItem #defaultString: 'Copy Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PasteItem #defaultString: 'Paste Item' #catalogID: #UIPainter) 				#nameKey: #pasteBelow 				#value: #pasteBelow 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) 				#helpText: #(#{Kernel.UserMessage} #key: #PasteItem #defaultString: 'Paste Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DeleteItem #defaultString: 'Delete Item' #catalogID: #UIPainter) 				#nameKey: #removeSelection 				#value: #removeSelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) 				#helpText: #(#{Kernel.UserMessage} #key: #DeleteItem #defaultString: 'Delete Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveUp #defaultString: 'Move Up' #catalogID: #UIPainter) 				#nameKey: #shiftUp 				#value: #shiftUp 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemUp ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveUp #defaultString: 'Move Up' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveDown #defaultString: 'Move Down' #catalogID: #UIPainter) 				#nameKey: #shiftDown 				#value: #shiftDown 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemDown ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveDown #defaultString: 'Move Down' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveRight #defaultString: 'Move Right' #catalogID: #UIPainter) 				#nameKey: #shiftRight 				#value: #shiftRight 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemRight ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveRight #defaultString: 'Move Right' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveLeft #defaultString: 'Move Left' #catalogID: #UIPainter) 				#nameKey: #shiftLeft 				#value: #shiftLeft 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemLeft ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveLeft #defaultString: 'Move Left' #catalogID: #UIPainter) ) ) #(1 3 4 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>resources</category><body package="UIPainter" selector="editingMenuBar">editingMenuBar	"MenuEditor new openOnClass: self andSelector: #editingMenuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Men_u #defaultString: '&amp;Men&amp;u' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_New #defaultString: '&amp;New' #catalogID: #UIPainter) 							#value: #newMenu 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 8 ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_LoadDot #defaultString: '&amp;Load...' #catalogID: #UIPainter) 							#value: #load 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_InstallDot #defaultString: '&amp;Install...' #catalogID: #UIPainter) 							#value: #install 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #installMenu ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Read #defaultString: '&amp;Read' #catalogID: #UIPainter) 							#value: #read ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_ApplyDot #defaultString: '&amp;Apply...' #catalogID: #UIPainter) 							#value: #apply ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Close #defaultString: '&amp;Close' #catalogID: #UIPainter) 							#value: #closeRequest 							#shortcutKeyCharacter: $Q 							#shortcutModifiers: 8 ) ) #(3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Edit #defaultString: '&amp;Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_NewItem #defaultString: '&amp;New Item' #catalogID: #UIPainter) 							#value: #addBelow 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuItem ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #New_Separator #defaultString: 'New &amp;Separator' #catalogID: #UIPainter) 							#value: #addLine 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuSeparator ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #NewS_ubmenuItem #defaultString: 'New S&amp;ubmenu Item' #catalogID: #UIPainter) 							#value: #addChild 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newSubmenuItem ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cu_tItem #defaultString: 'Cu&amp;t Item' #catalogID: #UIPainter) 							#value: #cutItem 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_CopyItem #defaultString: '&amp;Copy Item' #catalogID: #UIPainter) 							#value: #copyItem 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copyOld ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_PasteItem #defaultString: '&amp;Paste Item' #catalogID: #UIPainter) 							#nameKey: #'$p' 							#value: #pasteBelow 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_DeleteItem #defaultString: '&amp;Delete Item' #catalogID: #UIPainter) 							#nameKey: #'''$d''' 							#value: #removeSelection 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) ) ) #(3 4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Move #defaultString: '&amp;Move' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Up #defaultString: '&amp;Up' #catalogID: #UIPainter) 							#value: #shiftUp 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemUp ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Down #defaultString: '&amp;Down' #catalogID: #UIPainter) 							#value: #shiftDown 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemDown ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Right #defaultString: '&amp;Right' #catalogID: #UIPainter) 							#value: #shiftRight 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemRight ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Left #defaultString: '&amp;Left' #catalogID: #UIPainter) 							#value: #shiftLeft 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemLeft ) ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #V_iew #defaultString: 'V&amp;iew' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_SampleMenuBar #defaultString: '&amp;Sample Menu Bar' #catalogID: #UIPainter) 							#value: #showMenuBar ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Test #defaultString: '&amp;Test' #catalogID: #UIPainter) 				#nameKey: #testItem ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>private</category><body package="UIPainter" selector="frameOriginalSelection:in:">frameOriginalSelection: aSelection in: aController	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method might be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol."	| bounds frame  box newLeftFraction newTopFraction newLeftOffset newTopOffset newAlignmentX newAlignmentY |	bounds := aController view bounds.	frame := aSelection layout asLayout copyOld.	frame copyOld.	box := aSelection bounds.	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	newAlignmentX := self frameNumberFor: alignmentX.	newAlignmentY := self frameNumberFor: alignmentY.	(newAlignmentX notNil or: [newAlignmentY notNil])		ifTrue:			[((newAlignmentX ~= 0 or: [newAlignmentY ~= 0]) and:					[(frame isKindOf: AlignmentOrigin) not])				ifTrue: [frame := frame asAlignmentOrigin]].	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box width * frame leftAlignmentFraction]						ifFalse: [0]) -					(bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box height * frame topAlignmentFraction]						ifFalse: [0]) -					(bounds height * newTopFraction) rounded)].	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newAlignmentX notNil				ifTrue:					[frame leftOffset: frame leftOffset +						(((newAlignmentX -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame leftAlignmentFraction]								ifFalse: [0])) * box width) rounded)]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newAlignmentY notNil				ifTrue:					[frame topOffset: frame topOffset +						(((newAlignmentY -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame topAlignmentFraction]								ifFalse: [0])) * box height) rounded)]].	(frame isKindOf: AlignmentOrigin)		ifTrue:			[newAlignmentX notNil				ifTrue: [frame leftAlignmentFraction: newAlignmentX].			newAlignmentY notNil				ifTrue: [frame topAlignmentFraction: newAlignmentY]].	^frame</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>private</category><body package="UIPainter" selector="frameRectangularSelection:in:">frameRectangularSelection: aSelection in: aController	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method might be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol."	| bounds frame oldFrame box newLeftFraction newTopFraction newLeftOffset newTopOffset newRightFraction newBottomFraction newRightOffset newBottomOffset |	bounds := aSelection container bounds.	frame := aSelection layout asLayout copyOld.	oldFrame := frame copyOld.	box := aSelection bounds.	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left - (bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top - (bounds height * newTopFraction) rounded)].	(newRightFraction := self frameNumberFor: rightFraction) notNil		ifTrue:			[frame rightFraction: newRightFraction.			frame rightOffset:				(box right - (bounds width * newRightFraction) rounded)].	(newBottomFraction := self frameNumberFor: bottomFraction) notNil		ifTrue:			[frame bottomFraction: newBottomFraction.			frame bottomOffset:				(box bottom - (bounds height * newBottomFraction) rounded)].	newRightOffset := self frameNumberFor: rightOffset.	newBottomOffset := self frameNumberFor: bottomOffset.	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newRightOffset notNil				ifTrue:					[frame leftOffset:						frame leftOffset +							(bounds width * (newRightFraction - oldFrame rightFraction)) rounded +							newRightOffset - oldFrame rightOffset]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newBottomOffset notNil				ifTrue:					[frame topOffset:						frame topOffset +							(bounds height * (newBottomFraction - oldFrame bottomFraction)) rounded +							newBottomOffset - oldFrame bottomOffset]].	newRightOffset notNil		ifTrue: [frame rightOffset: newRightOffset]		ifFalse:			[newLeftOffset notNil				ifTrue:					[frame rightOffset:						frame rightOffset +							(bounds width * (newLeftFraction - oldFrame leftFraction)) rounded +							newLeftOffset - oldFrame leftOffset]].	newBottomOffset notNil		ifTrue: [frame bottomOffset: newBottomOffset]		ifFalse:			[newTopOffset notNil				ifTrue:					[frame bottomOffset:						frame bottomOffset +							(bounds height * (newTopFraction - oldFrame topFraction)) rounded +							newTopOffset - oldFrame topOffset]].	^frame</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>private</category><body package="UIPainter" selector="frameSizedOriginSelection:in:">frameSizedOriginSelection: aSelection in: aController	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method might be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol."	| bounds frame box newLeftFraction newTopFraction newLeftOffset newTopOffset newWidth newHeight |	bounds := aController view bounds.	frame := aSelection layout asLayout copyOld.	box := aSelection bounds.	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left - (bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top - (bounds height * newTopFraction) rounded)].	newWidth := self frameNumberFor: sizeWidth.	newHeight := self frameNumberFor: sizeHeight.	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset].	newWidth notNil		ifTrue: [frame width: newWidth].	newHeight notNil		ifTrue: [frame height: newHeight].	^frame</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>private</category><body package="UIPainter" selector="generateMask">generateMask	| oldImage colorWhite newImage opaque transparent takeBuffer putBuffer |	oldImage := magnifiedBitView model copyOld.	colorWhite := oldImage palette indexOf: ColorValue white.	newImage := Image				extent: oldImage extent				depth: 1				palette: CoveragePalette monoMaskPalette				bits: (ByteArray new: ((oldImage width + 31 // 32 * 4) * oldImage height)).	opaque := newImage palette indexOf: CoverageValue opaque.	transparent := newImage palette indexOf: CoverageValue transparent.	takeBuffer := Array new: oldImage width.	putBuffer := Array new: oldImage width.	0 to: oldImage height - 1		do: 			[:rowIndex | 			oldImage rowAt: rowIndex into: takeBuffer.			1 to: takeBuffer size do: [:colIndex | (takeBuffer at: colIndex)					== colorWhite					ifTrue: [putBuffer at: colIndex put: transparent]					ifFalse: [putBuffer at: colIndex put: opaque]].			newImage rowAt: rowIndex putAll: putBuffer].	^newImage</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>private</category><body package="UIPainter" selector="setColorFor:">setColorFor: aButtonId	| currentLookPreferences color colorNumber |	color := (builder componentAt: aButtonId) lookPreferences backgroundColor.	currentLookPreferences := (builder componentAt: #currentColorID) lookPreferences copyOld.	currentLookPreferences setBackgroundColor: color.	colorNumber := magnifiedBitView model  palette indexOf: color ifAbsent: [magnifiedBitView model  palette indexOfPaintNearest: color].	magnifiedBitView controller currentColor: colorNumber.	(builder componentAt: #currentColorID)		lookPreferences: currentLookPreferences</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>actions</category><body package="UIPainter" selector="maskify">maskify	| newImage oldImage colorWhite colorBlack takeBuffer putBuffer |	self accept.	oldImage := magnifiedBitView model copyOld.	newImage := oldImage copyOld.	Cursor execute showWhile:		[colorWhite := oldImage palette indexOf: ColorValue white.		colorBlack := oldImage palette indexOf: ColorValue black.		takeBuffer := Array new: oldImage width.		putBuffer := Array new: oldImage width.		0 to: newImage height -1 do:			[:rowIndex |			oldImage rowAt: rowIndex into: takeBuffer.			1 to: takeBuffer size do:				[:colIndex |				(takeBuffer at: colIndex) = colorWhite					ifTrue: [putBuffer at: colIndex put: colorWhite]					ifFalse: [putBuffer at: colIndex put: colorBlack]].		newImage rowAt: rowIndex putAll: putBuffer].		magnifiedBitView model: newImage; changedPreferredBounds:nil; invalidate.		directBitView model: newImage; changedPreferredBounds:nil; invalidate].	self modified: true</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>actions</category><body package="UIPainter" selector="cancel">cancel	| newImage |	Cursor execute showWhile:		[newImage := self acceptedState copyOld.		magnifiedBitView model: newImage; changedPreferredBounds: nil; invalidate.		directBitView model: newImage; changedPreferredBounds: nil; invalidate].</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>private</category><body package="UIPainter" selector="toColor:">toColor: aColorIndex	| controller point oldImage zeroColor newImage takeBuffer putBuffer |	controller := builder window controller.	oldImage := magnifiedBitView model copyOld.	Cursor crossHair showWhile:		[[controller sensor anyButtonPressed not] whileTrue: [].		[controller sensor anyButtonPressed] whileTrue: []].	point := magnifiedBitView controller sensor cursorPoint.	(magnifiedBitView bounds containsPoint: point) ifFalse: [^self].	point := (point scaledBy: 1 / magnifiedBitView scale) truncated.	(oldImage bounds containsPoint: point)		ifFalse: [^self].	zeroColor := oldImage atPoint: point.	newImage := oldImage copyOld.	takeBuffer := Array new: oldImage width.	putBuffer := Array new: oldImage width.	0 to: newImage height -1 do:		[:rowIndex |		oldImage rowAt: rowIndex into: takeBuffer.		1 to: takeBuffer size do:			[:colIndex |			(takeBuffer at: colIndex) = zeroColor				ifTrue: [putBuffer at: colIndex put: aColorIndex]				ifFalse: [putBuffer at: colIndex put: (takeBuffer at: colIndex)]].		newImage rowAt: rowIndex putAll: putBuffer].	magnifiedBitView model: newImage; changedPreferredBounds:nil; invalidate.	directBitView model: newImage; changedPreferredBounds: nil; invalidate</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>actions</category><body package="UIPainter" selector="accept">accept	self acceptedState: magnifiedBitView model copyOld</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>initialize-release</category><body package="UIPainter" selector="initialize">initialize	| image buffer white colorImage |	super initialize.	Screen default colorDepth == 1		ifTrue: [storeMask := ValueHolder with: true]		ifFalse: [storeMask := ValueHolder with: false].	useCachedImage := ValueHolder with: true.	colorImage := self class colorPaletteImage image.	image := Image				extent: 32 @ 32				depth: colorImage depth				palette: colorImage palette.	buffer := Array new: image width.	white := image palette indexOf: ColorValue white.	1 to: buffer size do: [:colIndex | buffer at: colIndex put: white].	0 to: image height - 1 do: [:rowIndex | image rowAt: rowIndex putAll: buffer].	acceptedState := image copyOld.	magnifiedBitView := ColorBitView model: image.	magnifiedBitView scale: 8 @ 8.	magnifiedBitView controller currentColor: (image palette indexOf: ColorValue black).	directBitView := DirectBitView model: image.	magnifiedBitView changedPreferredBounds: nil.	modified := false.	storeMask onChangeSend: #storeMaskChanged to: self</body></methods><methods><class-id>Tools.UIMaskEditor class</class-id> <category>resources</category><body package="UIPainter" selector="maskEditorMenu">maskEditorMenu	"MenuEditor new openOnClass: self andSelector: #maskEditorMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Image #defaultString: 'Image' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Capture #defaultString: 'Capture' #catalogID: #UIPainter) 							#value: #grab ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #LoadDot #defaultString: 'Load...' #catalogID: #UIPainter) 							#value: #load ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #InstallDot #defaultString: 'Install...' #catalogID: #UIPainter) 							#value: #install ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Read #defaultString: 'Read' #catalogID: #UIPainter) 							#nameKey: #read							#value: #read ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Apply #defaultString: 'Apply' #catalogID: #UIPainter) 							#nameKey: #apply							#value: #apply ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #StoreB__WMask #defaultString: 'Store B&amp;&amp;W Mask' #catalogID: #UIPainter) 							#nameKey: #toggleStoreMask							#value: #toggleStoreMask ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #StoreCachedImage #defaultString: 'Store Cached Image' #catalogID: #UIPainter) 							#nameKey: #toggleUseCache							#value: #toggleUseCache ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ResizeImage #defaultString: 'Resize Image' #catalogID: #UIPainter) 							#value: #clip ) ) #(3 2 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 							#value: #cancel ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #UIPainter) 							#value: #accept ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #UIPainter) 							#value: #cut ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #UIPainter) 							#value: #copyOld ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #UIPainter) 							#value: #paste ) ) #(2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Draw #defaultString: 'Draw' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #FillRectangle #defaultString: 'Fill Rectangle' #catalogID: #UIPainter) 							#nameKey: #fillCurrentColor 							#value: #fillCurrentColor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ReplaceColor #defaultString: 'Replace Color' #catalogID: #UIPainter) 							#nameKey: #toCurrentColor 							#value: #toCurrentColor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ColorToB__W #defaultString: 'Color to B&amp;&amp;W' #catalogID: #UIPainter) 							#value: #maskify ) ) #(3 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>displaying</category><body package="Store-Code Comparison" selector="displayChild:on:">displayChild: aChild on: aGC	| drawDecoration oldPaint detailGC |	oldPaint := aGC paint.	(aChild == self header and: [self hasFocus])		ifTrue: [self displayHeaderFocusOn: aGC].	drawDecoration := self isExpanded and: [aChild == self detailsPanel].	detailGC := aGC copyOld.	drawDecoration ifTrue: [self drawDetailsBackroundOn: detailGC].	super displayChild: aChild on: detailGC.	drawDecoration ifTrue: [self drawDetailsBorderOn: detailGC].	aGC paint: oldPaint</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>actions</category><body package="Tools-Changes" selector="inspectChangeSet">inspectChangeSet	self currentPackage copyOld inspect</body></methods><methods><class-id>Tools.SettingsManagerPageTreeRoot</class-id> <category>private</category><body package="Tools-Settings" selector="findPlaceFor:in:">findPlaceFor: aPage in: rootPages	rootPages do:		[:each |		(aPage isChildOf: each) ifTrue:			[^each findPlaceFor: aPage]].	rootPages add: aPage.	rootPages copyOld do:		[:each |		(each isChildOf: aPage) ifTrue:			[rootPages remove: each.			aPage findPlaceFor: each]]</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>actions</category><body package="HighlightingStyles" selector="acceptRefresh">acceptRefresh	"Perform an acceptance action."	&lt;action: 0&gt;	self emphasisEditor setStyles: (self stylesHolder value collect: [:s | s copyOld])</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>changing</category><body package="HighlightingStyles" selector="changedStyle">changedStyle	"Respond to a change in the emphasis editor."	self stylesHolder isBuffering		ifFalse:			[| attrs style |			self stylesHolder value: self emphasisEditor styles.			style := self textController view textStyle copyOld.			attrs := style characterAttributes copyOld.			attrs attributes: CharacterAttributes extraDefaults copyOld.			style setCharacterAttributes: attrs.			self textController view textStyle: style].	self applyStyles</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>interface opening</category><body package="HighlightingStyles" selector="postBuildWith:">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	self samplesMenu value notNil ifTrue: [self samplesMenu value menuItems first value value].	self emphasisEditor setStyles: (self stylesHolder value collect: [:s | s copyOld]).	self addHighlighters.	self applyStyles.</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>change editing</category><body package="System-Changes" selector="doIts:">doIts: aCollection	specialDoIts removeAll: specialDoIts copyOld; addAll: aCollection</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>store</category><body package="System-Changes" selector="renamedComponent:to:">renamedComponent: aPundle to: newName	"aPundle is being renamed. Move references under old name to new name."	| newKey oldKey changes |	oldKey := ComponentChange fromComponent: aPundle.	newKey := oldKey copyOld componentName: newName.	(changes := componentChanges removeKey: oldKey ifAbsent: nil) == nil ifFalse: 		[componentChanges at: newKey put: changes]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>private</category><body package="UIPainter" selector="removeClassAndAdjustSets:">removeClassAndAdjustSets: aClassID	((SpecBearingClasses remove: aClassID ifAbsent: []) isNil and:			[(RecentlyVisitedClasses remove: aClassID ifAbsent: []) isNil])		ifTrue: [^self].	SpecBearingCategories := Set new.	SpecBearingClasses copyOld do:		[:classID | | cl |		(cl := classID valueOrDo: []) notNil			ifTrue: [SpecBearingCategories add: cl category]			ifFalse: [SpecBearingClasses remove: classID]]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>menus</category><body package="UIPainter" selector="setMenus">setMenus	| viewMenu selMenu noSelMenu classMenu helpMenu list |	viewMenu := self class viewMenu.	selMenu := self class selMenu.	noSelMenu := self class noSelMenu.	classMenu := self class classMenu.	helpMenu := self class helpMenu.	menuBarMenuWithNoSelection := (Menu new) 		addItem: ((MenuItem labeled: (#_View &lt;&lt; #UIPainter &gt;&gt; '&amp;View')) nameKey: #viewMenu; submenu: viewMenu); 		addItem: ((MenuItem labeled: (#_Class &lt;&lt; #UIPainter &gt;&gt; '&amp;Class')) nameKey: #classMenu; submenu: classMenu); 		addItem: ((MenuItem labeled: (#_Resources &lt;&lt; #UIPainter &gt;&gt; '&amp;Resources')) nameKey: #resourcesMenu; submenu: noSelMenu; disable);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: helpMenu).	classMenu := classMenu copyOld.	classMenu menuItems do: [:each | each enable].	(classMenu atNameKey: #showDatabaseApplicationStructure) 		enabled: [(self selectedClassOrDo: []) canUnderstand: #dataModel ].	menuBarMenuWithSelection := (Menu new)		addItem: ((MenuItem labeled: (#_View &lt;&lt; #UIPainter &gt;&gt; '&amp;View')) nameKey: #viewMenu; submenu: viewMenu); 		addItem: ((MenuItem labeled: (#_Class &lt;&lt; #UIPainter &gt;&gt; '&amp;Class')) nameKey: #classMenu; submenu: classMenu); 		addItem: ((MenuItem labeled: (#_Resources &lt;&lt; #UIPainter &gt;&gt; '&amp;Resources')) nameKey: #resourcesMenu; submenu: selMenu; disable);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: helpMenu).	menuBarMenuWithNoCanvasSelected := (Menu new)		addItem: ((MenuItem labeled: (#_View &lt;&lt; #UIPainter &gt;&gt; '&amp;View')) nameKey: #viewMenu; submenu: viewMenu); 		addItem: ((MenuItem labeled: (#_Class &lt;&lt; #UIPainter &gt;&gt; '&amp;Class')) nameKey: #classMenu; submenu: classMenu); 		addItem: ((MenuItem labeled: (#_Resources &lt;&lt; #UIPainter &gt;&gt; '&amp;Resources')) nameKey: #resourcesMenu; submenu: noSelMenu);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: helpMenu).	viewMenu := viewMenu copyOld.	viewMenu menuItems do: [ :item | item label: item label asLowercase.							item label = (#exit &lt;&lt; #UIPainter &gt;&gt; 'exit') asString ifTrue: [ viewMenu hideItem: item ] ].	classMenu := classMenu copyOld.	classMenu menuItems do: [  :item | item label: item label asLowercase].	classListMenuWithSelection := (Menu new)		addItemGroup: (Array with: ((MenuItem labeled: (#view &lt;&lt; #UIPainter &gt;&gt; 'view')) nameKey: #viewMenu; submenu: viewMenu)).	classMenu visibleMenuItemGroups 		do: [ :group | 1 to: group size 			do: [ :i | i == 1 					ifTrue: [ classListMenuWithSelection addItemGroup: (Array with: (group at: 1)) ] 					ifFalse:[ classListMenuWithSelection addItem: (group at: i)  ] ]].	list := classMenu values asOrderedCollection.	list addFirst: nil.	classListMenuWithSelection values: list. 	classListMenuForNoSelection := (Menu new)		addItemGroup: (Array with: ((MenuItem labeled: (#view &lt;&lt; #UIPainter &gt;&gt; 'view')) nameKey: #viewMenu; submenu: viewMenu));		addItemGroup: (Array with: (MenuItem labeled: (#adddots &lt;&lt; #UIPainter &gt;&gt; 'add...'))) values: #(addClass)</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>commands</category><body package="UIPainter" selector="showClassesByLastCategory">showClassesByLastCategory	| categoryClasses |	lastCategory isNil		ifTrue: 			[self showAllClasses.			^self].	self filter: #showClassesByLastCategory.	(builder componentAt: #ClassNameListLabel) widget labelString: ((#x1sClasses &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; Classes')			expandMacrosWith: lastCategory asString).	categoryClasses := Set new.	SpecBearingClasses copyOld		do: 			[:classID |			| cl cln |			(cl := classID valueOrDo: [SpecBearingClasses remove: classID. nil]) notNil				ifTrue:					[cln := cl category.					cln = lastCategory						ifTrue: [categoryClasses add: classID]]].	self showClasses: categoryClasses</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>commands</category><body package="UIPainter" selector="showClassesByCategory">showClassesByCategory	| selector categoryClasses stringSize |	stringSize := UISettings preferenceFor: #toolsLabelStringLimit.	selector := Dialog				choose: (#SelectClassCategory &lt;&lt; #UIPainter &gt;&gt; 'Select class category...')				fromList: (SpecBearingCategories asSortedStrings collect: [:sel | sel contractTo: stringSize])				values: SpecBearingCategories asSortedStrings				lines: 10				cancel: [nil]				for: builder window.	selector == nil		ifFalse: 			[self filter: #showClassesByLastCategory.				(builder componentAt: #ClassNameListLabel) widget labelString: ((#x1sClasses &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; Classes')			expandMacrosWith: selector asString).			categoryClasses := Set new.			lastCategory := selector.			SpecBearingClasses copyOld				do: 					[:classID | | cl cln |					(cl := classID valueOrDo: [SpecBearingClasses remove: classID. nil]) notNil						ifTrue:							[cln := cl category.							cln = selector								ifTrue: [categoryClasses add: classID]]].			self showClasses: categoryClasses]</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>statistics</category><body package="UIPainter" selector="recentlyVisitedClasses">recentlyVisitedClasses	^RecentlyVisitedClasses copyOld</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>interface opening</category><body package="UIPainter" selector="openSourceDialogForResource:">openSourceDialogForResource: resourceType	"Open to collect an existing class and a new or existing selector as 	the 	destination of a UI specification."	| dialog selList newSel results builder ctrl uid finder |	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #clientClass put: (finder := ClassFinder new).	builder aspectAt: #existingSelectors put: (selList := (SelectionInList new) list: List new; selection: nil asValue; yourself).	finder className		compute: 			[:v | | cl |			cl := finder selectedClass.			cl isNil				ifTrue: 					[selList list: Array new.					(dialog builder componentAt: #ClassNameField) flash]				ifFalse: 					[selList list: (self selectorsOfResource: resourceType in: cl class)]].	builder aspectAt: #newSelector put: (newSel := String new asValue).	builder aspectAt: #doAbort put: [dialog close].	dialog		postBuildBlock: 			[:sd :bldr | 			ctrl := (bldr componentAt: #SelectorSIL) widget controller.			uid := ctrl dispatcher copyOld.			uid doubleClick: [(results := self							resultsForClassName: finder selectedClassID							andSelectorList: selList							orSelectorNamed: newSel value							resource: resourceType) notNil					ifTrue: [dialog close]					ifFalse: [(dialog builder componentAt: (finder foundClass								ifFalse: [#ClassNameField]								ifTrue: [#SelectorSIL])) flash]].			ctrl setDispatcher: uid].	builder aspectAt: #doOK put: [(results := self					resultsForClassName: finder selectedClassID					andSelectorList: selList					orSelectorNamed: newSel value					resource: resourceType) notNil			ifTrue: [dialog close]			ifFalse: [(dialog builder componentAt: (finder foundClass						ifFalse: [#ClassNameField]						ifTrue: [#SelectorSIL])) flash]].	dialog openFrom: (self interfaceSpecFor: #sourceDialog).	^results</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>private</category><body package="UIPainter" selector="computeRecentlyVisitedMenu">computeRecentlyVisitedMenu	"UIFinderVW2 computeRecentlyVisitedMenu"	| labels values |	RecentlyVisitedClasses isEmpty		ifTrue:			[Dialog warn: (#GenKey97 &lt;&lt; #UIPainter &gt;&gt; 'There are no recently visited classes')].	labels := OrderedCollection new.	values := OrderedCollection new.	RecentlyVisitedClasses copyOld do:		[:classID |		| list cl |		((cl := classID valueOrDo: [nil]) notNil and:				[(list := cl class organization listAtCategoryNamed: #'interface specs') isEmpty not])			ifTrue:				[labels add: classID asString.				values add:					(list size == 1						ifTrue:							[[UIPainter new openOnClass: cl andSelector: list first]]						ifFalse:							[Menu								labelArray:									(list collect: [:elt | elt asString]) asArray								values:									(list collect:										[:selName |										[UIPainter new openOnClass: cl andSelector: selName]])])]			ifFalse:				[RecentlyVisitedClasses remove: classID ifAbsent: [self error: (#shouldntHappen &lt;&lt; #UIPainter &gt;&gt; 'shouldn''t happen')]]].	^Menu		labelArray: labels asArray		lines: Array new		values: values asArray</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>interface opening</category><body package="UIPainter" selector="openSourceDialogForClass:andResource:">openSourceDialogForClass: aClass andResource: resourceType 	"Open to collect an existing class and a new or existing selector as 	the destination of a UI specification."	| dialog selList newSel results builder ctrl uid listBlock finder |	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #clientClass put: (finder := ClassFinder new).	finder className value: (aClass isNil					ifTrue: [String new]					ifFalse: [aClass fullName]).	listBlock := [:cl | | list |			list := List new.			cl == nil				ifFalse: [cl class selectorsAndMethodsDo:						[:sel :meth |						meth resourceType = resourceType ifTrue: [list add: sel]]].			list sort.			list].	builder aspectAt: #existingSelectors		put: ((selList := SelectionInList new)				list: (listBlock value: aClass);				selection: nil asValue;				yourself).	finder className		compute: 			[:v | | cl |			cl := finder selectedClass.			cl isNil				ifTrue: 					[selList list: Array new.					(dialog builder componentAt: #clientClass) flash]				ifFalse: 					[selList list: (listBlock value: cl)]].	builder aspectAt: #newSelector put: (newSel := String new asValue).	builder aspectAt: #doAbort put: [dialog close].	dialog		postBuildBlock: 			[:sd :bldr | 			ctrl := (bldr componentAt: #SelectorSIL) widget controller.			uid := ctrl dispatcher copyOld.			uid doubleClick: [(results := self							resultsForClassName: finder selectedClassID							andSelectorList: selList							orSelectorNamed: newSel value							resource: resourceType) notNil					ifTrue: [dialog close]					ifFalse: [(dialog builder componentAt: (finder foundClass								ifFalse: [#clientClass]								ifTrue: [#SelectorSIL])) flash]].			ctrl setDispatcher: uid].	builder aspectAt: #doOK put: [(results := self					resultsForClassName: finder selectedClassID					andSelectorList: selList					orSelectorNamed: newSel value					resource: resourceType) notNil			ifTrue: [dialog close]			ifFalse: [(dialog builder componentAt: (finder foundClass						ifFalse: [#clientClass]						ifTrue: [#SelectorSIL])) flash]].	dialog openFrom: (self interfaceSpecFor: #sourceDialog).	^results</body></methods><methods><class-id>Tools.PaintedDataSetView</class-id> <category>private</category><body package="UIPainter" selector="paintSelectedColumnOn:">paintSelectedColumnOn: graphicsContext 	| ci gc first tf |	gc := graphicsContext copyOld.	gc paint: self selectionBackgroundColor.	ci := self xRangesFor: selectionIndex inBounds: self bounds.	(selectionIndex &gt; (numFrozen max: 2) and: [ ci first &lt; (tf := (self xRangesFor: numFrozen inBounds: self bounds) last) ])		ifTrue: [ first := tf ]		ifFalse: [ first := ci first ].	gc displayRectangle: (first @ self bounds top corner: ci last @ self bounds bottom).	self displayDragHandleOn: (gc clippingRectangle: ((first @ self bounds top corner: ci last @ self bounds bottom) intersect: self bounds))</body></methods><methods><class-id>Tools.PaintedDataSetView</class-id> <category>private</category><body package="UIPainter" selector="displayDragHandleOn:">displayDragHandleOn: gc	| handleRect tGc tColor |	tGc := gc copyOld.	handleRect := self dragHandleBounds.	handleRect extent y = 0 ifTrue: [ ^self ].	tColor := tGc paintPreferencesMatchAt: SymbolicPaint selectionForeground.	tGc paintPreferencesMatchAt: SymbolicPaint selectionBackground put: tColor.	tGc displayRectangle: self dragHandleBounds</body></methods><methods><class-id>Tools.FileTools.ParcelFileViewer</class-id> <category>private</category><body package="Tools-File Browser" selector="capitalized:">capitalized: aStringOrSymbol	| copy |	copy := aStringOrSymbol asString copyOld.	copy at: 1 put: copy first asUppercase.	^copy</body></methods><methods><class-id>Tools.FileTools.FileViewer class</class-id> <category>resources</category><body package="Tools-File Browser" selector="readOnlyCodeMenu">readOnlyCodeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyCodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#command: #doIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#command: #inspectIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#command: #debugIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#command: #copyOld				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copyOld ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#value: #findNext				#command: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#value: #selectEntireText				#command: #selectAll ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FileTools.FileTextViewer</class-id> <category>private</category><body package="Tools-File Browser" selector="compareTextWithFile:">compareTextWithFile: aFilename	"Open a Differator on the text currently on the page (on the left) and the text from the file on the right."	| text fileText |	self withTextViewControllerDo:		[:textEditor |		text := textEditor text copyOld.		fileText := [aFilename contentsOfEntireFile]			on: OsError do: [:ex | ex return: String new].		(Differator newOn: text and: fileText) open]</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>resources</category><body package="Tools-File Browser" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Directory 					#defaultString: '&amp;Directory' 					#catalogID: #menus ) 				#nameKey: #directory 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDot 								#defaultString: '&amp;New...' 								#catalogID: #menus ) 							#value: #createSubdirectory 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RenameDot 								#defaultString: '&amp;Rename...' 								#catalogID: #menus ) 							#value: #renameDirectory 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_moveDot 								#defaultString: 'Re&amp;move...' 								#catalogID: #menus ) 							#value: #removeDirectory 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_fresh 								#defaultString: 'Re&amp;fresh' 								#catalogID: #menus ) 							#value: #refreshDirectory 							#enablementSelector: #hasDirectoryInTreeSelected 							#shortcutKeyCharacter: #F5 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #refreshFolder ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_CopyName 								#defaultString: '&amp;Copy Name' 								#catalogID: #menus ) 							#value: #copyDirectoryFilename 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#value: #inspectDirectoryFilename 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GoTo_DefaultDirectory 								#defaultString: 'Go to &amp;Default Directory' 								#catalogID: #menus ) 							#value: #selectDefaultDirectory 							#enablementSelector: #notDefaultDirectorySelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #goToDefaultFolder ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GoToDot 								#defaultString: '&amp;Go to...' 								#catalogID: #menus ) 							#value: #goToDirectory 							#shortcutKeyCharacter: $G 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #goToFolder ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #InitialSelection 								#defaultString: '&amp;Initial Selection' 								#catalogID: #menus ) 							#nameKey: #initialSelection ) ) #(3 3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDot 								#defaultString: '&amp;New...' 								#catalogID: #menus ) 							#nameKey: #create 							#value: #createFile ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RenameDot 								#defaultString: '&amp;Rename...' 								#catalogID: #menus ) 							#value: #renameFileOrDirectory 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_moveDot 								#defaultString: 'Re&amp;move...' 								#catalogID: #menus ) 							#value: #removeFileOrDirectory 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CopyDot 								#defaultString: '&amp;Copy...' 								#catalogID: #menus ) 							#nameKey: #copyOld 							#value: #copyFile 							#enablementSelector: #hasFileSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Encoding 								#defaultString: '&amp;Encoding' 								#catalogID: #menus ) 							#nameKey: #fileEncoding ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #C_opyName 								#defaultString: 'C&amp;opy Name' 								#catalogID: #menus ) 							#value: #copyFilename 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#value: #inspectFilename 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Edit 								#defaultString: '&amp;Edit' 								#catalogID: #menus ) 							#nameKey: #fileEdit 							#value: #fileEdit 							#enablementSelector: #hasFileSelected 							#shortcutKeyCharacter: $E 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{FileBrowser} #editIcon ) ) ) #(4 1 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #menus ) 				#nameKey: #view 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RefreshAll 								#defaultString: '&amp;Refresh All' 								#catalogID: #menus ) 							#value: #fullUpdate 							#shortcutKeyCharacter: #F5 							#shortcutModifiers: 8 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Zoom 								#defaultString: '&amp;Zoom' 								#catalogID: #menus ) 							#nameKey: #viewZoom 							#value: #toggleZoom 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #zoom ) ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileBrowser 								#defaultString: 'File &amp;Browser' 								#catalogID: #menus ) 							#value: #helpFileBrowser 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AboutFiles 								#defaultString: '&amp;Files' 								#catalogID: #menus ) 							#value: #helpFiles ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #aboutVisualWorks ) ) #(2 1 ) nil ) ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>resources</category><body package="Tools-File Browser" selector="baseFileListMenu">baseFileListMenu	"MenuEditor new openOnClass: self andSelector: #baseFileListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_NewDot #defaultString: '&amp;New...' #catalogID: #menus) 				#nameKey: #create 				#value: #createFile ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameDot #defaultString: 'Re&amp;name...' #catalogID: #menus) 				#value: #renameFileOrDirectory 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #defaultString: '&amp;Remove...' #catalogID: #menus) 				#value: #removeFileOrDirectory 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CopyDot #defaultString: '&amp;Copy...' #catalogID: #menus) 				#nameKey: #copyOld 				#value: #copyFile 				#enablementSelector: #hasFileSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Encoding #defaultString: '&amp;Encoding' #catalogID: #menus) 				#nameKey: #fileEncoding ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #C_opyName #defaultString: 'C&amp;opy Name' #catalogID: #menus) 				#value: #copyFilename 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InspectFilename #defaultString: '&amp;Inspect Filename' #catalogID: #menus) 				#value: #inspectFilename 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Edit #defaultString: '&amp;Edit' #catalogID: #menus) 				#value: #fileEdit 				#enablementSelector: #hasFileSelected 				#shortcutKeyCharacter: $E 				#shortcutModifiers: 8 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #editIcon ) ) ) #(4 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ArtificialTreeItemHolder class</class-id> <category>instance creation</category><body package="Tools-Modules" selector="hierarchicallyArranged:usingDirectRelation:">hierarchicallyArranged: aCollection usingDirectRelation: aBlock	| roots |	roots := OrderedCollection new.	aCollection do: 		[:each | | item |		item := self on: each.		roots copyOld do: 			[:eachRoot |			(aBlock value: each value: eachRoot value) ifTrue:				[roots remove: eachRoot.				item addChild: eachRoot]].		(roots anySatisfy: [:some | some maybeAddDirectChild: item using: aBlock])			ifFalse: [roots add: item]].	^(self on: nil) children: roots</body></methods><methods><class-id>Tools.TopLevelParcelGroup</class-id> <category>accessing</category><body package="Tools-Parcel Manager" selector="sortedSubgroups">sortedSubgroups	| extraGroups home sorted |	extraGroups := subgroups copyOld.	extraGroups		remove: visualWorksGroup;		remove: goodiesGroup;		remove: previewGroup.	home := extraGroups detect: [:some | some name = '.'] ifNone: [nil].	sorted := OrderedCollection new.	home notNil ifTrue:		[extraGroups remove: home.		sorted add: home].	sorted 		add: visualWorksGroup;		add: goodiesGroup;		add: previewGroup.	sorted addAll: (extraGroups asSortedCollection: [:a :b | a name &lt;= b name]).	^sorted asArray</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>private</category><body package="UIPainter" selector="currentSpecFor:andController:">currentSpecFor: oneOrMoreUISpecifications andController: aController	"Answer the relevant spec and set the selectionKind for the oneOrMoreUISpecifications selected."	^oneOrMoreUISpecifications size = 0 		ifTrue: 			[selectionKind := #window.			aController model windowSpec copyOld]		ifFalse: 			[oneOrMoreUISpecifications size = 1 				ifTrue: 					[selectionKind := #single.					oneOrMoreUISpecifications first spec copyOld]				ifFalse: 					[selectionKind := #multi.					MultiSpec new]]</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>actions</category><body package="UIPainter" selector="apply">apply	"Copy the information in 'currentSpecCopy' to the selected components."	| labelM labelConstructor |	currentSpecCopy isDataValid ifFalse: [^self].	(controller == nil or: [controller view == nil]) ifTrue: [^self].	lock := true.	client preapply.	selectionKind == #single 		ifTrue: 			["replaceElement:etc. will cause change to be noted, and  select: will cause UIPainterWatchers to be alerted."			| selElem sel spec doReselect doInvalidate |			selElem := selection first.			sel := controller selectionList.			doReselect := sel size = 1 and: [sel first = selElem].			spec := currentSpecCopy copyOld.			doInvalidate := (spec getLabel isNil or: [selElem spec getLabel isNil]) not.			(spec shouldCompareLayouts: selElem spec) ifTrue: 				[spec layout: selElem spec layout.				currentSpecCopy layout = spec layout ifFalse: [currentSpecCopy layout: spec layout]].			selElem := controller 				replaceElement: selElem 				basedOnSpec: spec.			selection := Array with: selElem.			doReselect ifTrue: [controller select: selElem].			doInvalidate ifTrue: [currentView invalidate]]		ifFalse: 			[selectionKind == #multi				ifTrue: 					[| newSelection spec controllerSelections | 					newSelection := OrderedCollection new: selection size.					controllerSelections := controller selectionList.					controllerSelections copyOld do: 						[:selElem | 						spec := selElem spec copyOld.						currentSpecCopy copyPropertiesTo: spec.						newSelection add: (controller 							replaceElement: selElem 							basedOnSpec: spec)].					selection := newSelection.					controller selectionList: newSelection.					self fillCanvasTree.					self updateSelectionInTree]				ifFalse: 					[selectionKind == #window						ifTrue: 							[labelConstructor := (currentSpecBindings at: #labelConstructor ifAbsent: [nil]).							labelM := labelConstructor isNil 								ifTrue: [currentSpecCopy labelInBuilder: controller model builder]								ifFalse: [labelConstructor unsavedLabel].							(currentSpecCopy labelInBuilder: controller model builder) = labelM ifFalse: 								[(currentSpecBindings at: #labelConstructor) acceptUnsavedChanges.								labelM := currentSpecCopy labelInBuilder: controller model builder].							(labelM notNil and: [labelM asString isEmpty and: [(UIPainter preferenceFor: #hostWindowManager) == #OSFMotif]])								ifTrue: 									[self builder window component flash.									^self]. 							controller model windowSpec label: labelM.							controller model windowSpec: currentSpecCopy copyOld.							controller model fixBuildersWindow.							controller model builder window flushCaches.							labelM isNil ifFalse: [controller model builder window label: labelM].							controller canvasHasChanged: true.							canvasTree selection isNil ifTrue: [self updateSelectionInTree].							labelM isNil ifFalse: [canvasTree selection label: labelM]. 							(builder componentAt: #canvasTree) widget updateAt: 1.]]].	self statusBarText value: controller activePainterWindow label asString.	self displayButtonsForUnmodifiedState.	client postapply.	lock := false</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>resources</category><body package="UIPainter" selector="fieldMenu">fieldMenu	^MenuBuilder new		add: (#find &lt;&lt; #UIPainter &gt;&gt; 'find...')-&gt;[:ctrlr | ctrlr find];		add: (#replace &lt;&lt; #UIPainter &gt;&gt; 'replace...')-&gt;			[:ctrlr |			ctrlr replace.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		line;		add: (#undo &lt;&lt; #UIPainter &gt;&gt; 'undo') -&gt;			[:ctrlr |			ctrlr undo.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		line;		add: (#copyOld &lt;&lt; #UIPainter &gt;&gt; 'copy')-&gt;[:ctrlr | ctrlr copySelection];		add: (#cut &lt;&lt; #UIPainter &gt;&gt; 'cut')-&gt;			[:ctrlr |			ctrlr cut.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		add: (#paste &lt;&lt; #UIPainter &gt;&gt; 'paste')-&gt;			[:ctrlr |			ctrlr paste.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		line;		add: (#accept &lt;&lt; #UIPainter &gt;&gt; 'accept')-&gt;[:ctrlr | ctrlr accept];		add: (#cancel &lt;&lt; #UIPainter &gt;&gt; 'cancel')-&gt;[:ctrlr | ctrlr cancel];		menu</body></methods><methods><class-id>Tools.CommandBindingsEditor.BindingPanel</class-id> <category>accessing</category><body package="Tools-Settings-Commands" selector="keystrokes:">keystrokes: aKeystrokeArray	self removeAll: self children copyOld.	(aKeystrokeArray isNil or: [ aKeystrokeArray isEmpty ]) ifTrue: [		self add: (BindingLabel bindingPanel: self keystroke: nil)	] ifFalse: [		aKeystrokeArray do: [ :keystroke |			self add: (BindingLabel bindingPanel: self keystroke: keystroke)		]	]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>private-menus</category><body package="Tools-Changes" selector="buildTextMenu">buildTextMenu	| menu |	menu := Menu				labelList: (Array with: (Array with: #Accept &lt;&lt; #dialogs &gt;&gt; 'Accept')						with: (Array								with: #DoIt &lt;&lt; #dialogs &gt;&gt; 'Do it'								with: #PrintIt &lt;&lt; #dialogs &gt;&gt; 'Print it'								with: #InspectIt &lt;&lt; #dialogs &gt;&gt; 'Inspect it'								with: #DebugIt &lt;&lt; #dialogs &gt;&gt; 'Debug it'))							, TextEditorController editGroupLabels , (Array									with: (Array with: #ChangeTextStyle &lt;&lt; #dialogs &gt;&gt; 'Change Text Style')									with: (Array with: #Format &lt;&lt; #dialogs &gt;&gt; 'Format'											with: #Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))				values: #(#accept #doIt #printIt #inspectIt #debugIt)						, TextEditorController editGroupSelectors							, #(#changeTextStyle #format:from: #cancel).	(menu menuItemWithValue: #accept)		shortcutKeyCharacter: $S;		shortcutModifiers: 2.	#(#doIt #printIt #inspectIt #debugIt #cut #paste)		with: #($D $P $Q $B $X $V)		do: 			[:each :eachKey |			(menu menuItemWithValue: each)				labelImage: (ToolbarIconLibrary visualFor: each);				shortcutKeyCharacter: eachKey;				shortcutModifiers: 2].	(menu menuItemWithValue: #copySelection)		labelImage: (ToolbarIconLibrary visualFor: #copyOld);		shortcutKeyCharacter: $C;		shortcutModifiers: 2.	^menu</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>accessing</category><body package="Tools-Changes" selector="existingText">existingText	"Answer a Text corresponding to the current version of the change	 (method or class) in the system."	| change src conflictText originalText sysCat different srcFragments originalFragments differences |	selectionIndex &lt;= 0 ifTrue: [^self blankText].	"Take a copy of both texts to ensure the emphasis in the text itself is 	not modified by the comparison."	(originalText := self selectionText) isNil ifTrue: [originalText := ''].	originalText := originalText copyOld asText.	(conflictText := self noConflictTextFor: (change := self selection))		== nil			ifFalse: 				[self setValue: originalText.				self changed: #value.				^conflictText].	src := (change cleanSourceFrom: (self conflictTextFor: change)) copyOld				asText.	srcFragments := src smalltalkOrWordAndWhitespaceFragments.	originalFragments := originalText smalltalkOrWordAndWhitespaceFragments.	differences := originalFragments differences: srcFragments.	different := differences anySatisfy: [:each | each isMatch not].	differences do: #applyAnyDifferenceTextEmphases.	self setValue: originalText.	self changed: #value.	^different		ifTrue: [src]		ifFalse: 			[((change isMethodRelated				and: [change category ~= (sysCat := change systemCategory)])					ifTrue: 						[#protocol1s &lt;&lt; #dialogs &gt;&gt; 'protocol &lt;1s&gt;' expandMacrosWith: (sysCat isNil									ifTrue: [ClassOrganizer defaultProtocol]									ifFalse: [sysCat])]					ifFalse: [(#NoConflict &lt;&lt; #dialogs &gt;&gt; 'no conflict') asString]) asText				emphasizeAllWith: #italic]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>private</category><body package="Tools-Changes" selector="updateList">updateList	"Update the current list by recomputing the displayed list from the underlying list.	 Note that we do so lazily to display the visible part of the new list quicker.	 Each actual list entry is calculated in the selectionInList's visualBlocks created	 in the receiver's postBuildWith: method."	Cursor execute showWhile: [		| oldChange newIndex |		selectionIndex &gt; 0 ifTrue: [oldChange := list at: selectionIndex].		filter := nil.		filterList do: [:aSymbol | aSymbol notNil ifTrue: [self addFilter: aSymbol]].		filter isNil			ifTrue: [filter := [:change | true].					list := changes copyOld]			ifFalse: [list := changes select: filter].		newIndex :=			oldChange == nil				ifTrue: [0]				ifFalse: [list identityIndexOf: oldChange].		"Simply set the selectionInList's list to be the empty list.  This speeds		 up redisplay at the cost of slightly slower scrolling."		selectionInList list: (List withSize: list size).		self updateSelection: newIndex]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>accessing</category><body package="Tools-Changes" selector="value:">value: aValue 	"The receiver's text for the currently selected change (if any) has 	changed. Update the text view, and update the change's text."	| thisChange newChange |	value := aValue.	self changed: #value.	(value size &gt; 0 and: [selectionIndex &gt; 0]) ifTrue:		[thisChange := list at: selectionIndex.		thisChange text ~= value asString ifTrue: [			"Since this ChangeList may share changes with others			 (via spawning or Drag+Drop), copy the change to			 ensure the change in text doesn't affect anything else."			newChange := thisChange copyOld.			newChange text: value asString.			list at: selectionIndex				put: (changes						at: (changes indexOf: thisChange)						put: newChange).			self updateSelection: selectionIndex]]</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>private-icons</category><body package="UIPainter" selector="populateSpec:">populateSpec: prototypeSpec 	"Replicate a prototype spec by creating clones and changing the layout.	Also send adaptButton:toRepresent: message to chage button's properties.	The layout algorithm is 'numberOfColumns' icons in a row in the window."	| width height maximumColumns iconPosition currentColumn firstX rows rect finalExtent |	rect := (prototypeSpec layout rectangleRelativeTo: builder window bounds preferred: nil).	width := rect width.	height := rect height.	maximumColumns := self numberOfColumns.	iconPosition := 0 @ 0.	firstX := iconPosition x.	currentColumn := 0. 	activeSpecs		do: 			[:spec | 			| newButtonSpec |			newButtonSpec := prototypeSpec copyOld.			newButtonSpec helpText: spec componentName.			newButtonSpec layout: prototypeSpec layout copyOld.			(newButtonSpec layout) 				leftOffset: newButtonSpec layout leftOffset + iconPosition x;				rightOffset: newButtonSpec layout rightOffset + iconPosition x;				topOffset: newButtonSpec layout topOffset + iconPosition y;				bottomOffset: newButtonSpec layout bottomOffset + iconPosition y.			self adaptButton: newButtonSpec toRepresent: spec.			builder add: newButtonSpec.			currentColumn := currentColumn + 1.			(currentColumn \\ maximumColumns) isZero				ifTrue: 					[iconPosition := iconPosition + (0 @ height).					iconPosition x: firstX]				ifFalse: [iconPosition := iconPosition + (width @ 0)]].	rows := currentColumn - 1 // maximumColumns.	finalExtent := 0 @ (rows * height).	finalExtent := builder window minimumSize + finalExtent.	(builder window) changeExtent: finalExtent; minimumSize: finalExtent; maximumSize: finalExtent.</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>private</category><body package="Tools-Workspace" selector="compareTextWithFile">compareTextWithFile	"Open a Differator on the text currently on the page (on the left) and the text from the file on the right."	| text fileText |	text := self textEditor text copyOld.	fileText := [self filenameWithEncoding contentsOfEntireFile]		on: OsError do: [:ex | ex return: String new].	(Differator newOn: text and: fileText) open</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	profiles := RepositoryManager repositories copyOld asList</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>actions</category><body package="Store-UI" selector="resetProfiles">resetProfiles	profiles := RepositoryManager repositories copyOld asList</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>defining</category><body package="UIPainter" selector="addNamedFontsMethod:using:">addNamedFontsMethod: aSymbol using: aFullSpec	| usedStyles |	usedStyles := aSymbol == #all		ifTrue: [VariableSizeTextAttributes styles copyOld]		ifFalse: [self extractNamedStyles: aFullSpec].	self writeDefineNamedFontsMethod: usedStyles.</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>private</category><body package="Tools-Workspace" selector="capitalized:">capitalized: aString	^aString copyOld		at: 1 put: aString first asUppercase;		yourself</body></methods><methods><class-id>Tools.FileDialogNSSavePanel</class-id> <category>private</category><body package="Tools-Dialogs" selector="asHostPattern:">asHostPattern: aStringOrUserMessage	"Used by compatibility interface."	^aStringOrUserMessage asString copyOld replaceAll: $# with: $?</body></methods><methods><class-id>Tools.Trippy.SequenceInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="privateMoveAllAtIndices:beforeIndex:">privateMoveAllAtIndices: aCollection beforeIndex: anIndex	"Reposition elements at indices listed in aCollection so that they are all located at indices {anIndex, anIndex+1, ...}. The size of the resulting collection is the same as that of the original."	| scratch mobile insertionPoint |	scratch := object copyOld.	aCollection asSortedCollection reverseDo: [:each | scratch removeAtIndex: each].	mobile := aCollection collect: [:each | object at: each].	insertionPoint := aCollection		inject: anIndex		into: [:result :index | index &lt; anIndex ifTrue: [result - 1] ifFalse: [result]].	mobile reverseDo:		[:each | scratch add: each beforeIndex: insertionPoint].	object replaceFrom: 1 to: object size with: scratch startingAt: 1.	^insertionPoint to: insertionPoint + aCollection size - 1</body></methods><methods><class-id>Tools.Trippy.ArrayInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="privateMoveAllAtIndices:beforeIndex:">privateMoveAllAtIndices: aCollection beforeIndex: anIndex	"Reposition elements at indices listed in aCollection so that they are all 	located at indices {anIndex, anIndex+1, ...}. The size of the resulting collection 	is the same as that of the original."	| static mobile insertionPoint newObject |	static := object copyOld asOrderedCollection.	aCollection asSortedCollection reverseDo: [:each | static removeAtIndex: each].	mobile := aCollection collect: [:each | object at: each].	insertionPoint := aCollection		inject: anIndex		into: [:result :index | index &lt; anIndex ifTrue: [result - 1] ifFalse: [result]].	newObject := object class new: object size.	newObject		replaceFrom: 1 to: insertionPoint - 1 with: static startingAt: 1;		replaceFrom: insertionPoint to: insertionPoint + mobile size - 1 with: mobile startingAt: 1;		replaceFrom: insertionPoint + mobile size to: newObject size with: static startingAt: insertionPoint.	newObject become: object.	^insertionPoint to: insertionPoint + aCollection size - 1</body></methods><methods><class-id>Tools.Trippy.TextEditorInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="coerceText:">coerceText: aTextOrString	"Answer the argument as a new instance of a class compatible with that	of the current object. We currently assume that can only be one of String	subclasses or Text."	^(self object isKindOf: Text)		ifTrue: [aTextOrString asText copyOld]		ifFalse: [self object class fromString: aTextOrString asString]</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="augmentTextFieldController:">augmentTextFieldController: aController	"Provide additional tuning of the text controller used in the '#text' widget (the widget where we display the selected object's printStrings)."		| menu item |	aController		initializeMenuForCode;		autoAccept: false.	menu := aController menu copyOld.	item := MenuItem labeled: #AddField &lt;&lt; #inspector &gt;&gt; 'Add Field'.	item value: [self addDerivedField].	menu addItem: item atPosition: 10.2.	aController menuHolder value: menu</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="pickSingleObjectIn:ifCancelled:">pickSingleObjectIn: partCollection ifCancelled: aBlock	| labels objects objectsCopy |	partCollection size = 1 ifTrue: [^partCollection first value].	labels := OrderedCollection new.	objects := OrderedCollection new.	partCollection do:		[:part |		labels add: ('&lt;1s&gt;: &lt;2s&gt;'			expandMacrosWith: part displayString			with: part value displayString).		objects add: part value].	objectsCopy := objects copyOld.	labels add: ((#All1pAsAnArray &lt;&lt; #dialogs &gt;&gt; 'All &lt;1p&gt; as an Array') expandMacrosWith: partCollection size).	objects add: objectsCopy asArray.	labels add: ((#All1pAsAnOC &lt;&lt; #dialogs &gt;&gt; 'All &lt;1p&gt; as an OrderedCollection') expandMacrosWith: partCollection size).	objects add: objectsCopy asOrderedCollection.	labels add: ((#All1pAsASet &lt;&lt; #dialogs &gt;&gt; 'All &lt;1p&gt; as a Set') expandMacrosWith: partCollection size).	objects add: objectsCopy asSet.	^Dialog		choose: (#UseWhichOfTheseObjectsQ &lt;&lt; #dialogs &gt;&gt; 'Use which of these objects?')		fromList: labels		values: objects		lines: 8		cancel: aBlock</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="computeMultiSelectionText">computeMultiSelectionText	| stream |	stream := TextStream on: (String new: 200).	self selections do:		[:each |		stream			nextPutAllText: each displayString copyOld asText allBold;			nextPutAll: ':  ';			nextPutAll: each text.		stream cr].	^stream contents</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector class</class-id> <category>resources</category><body package="Tools-Trippy" selector="fieldListMenu">fieldListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #fieldListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Inspect 					#defaultString: '&amp;Inspect' 					#catalogID: #menus ) 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Dive 					#defaultString: '&amp;Dive' 					#catalogID: #menus ) 				#nameKey: #dive 				#value: #dive ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Back 					#defaultString: '&amp;Back' 					#catalogID: #menus ) 				#nameKey: #back 				#value: #back 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #navigatePrevious ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#nameKey: #editSelectAll 				#value: #selectAllFields 				#command: #selectAll				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #selectFields ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#nameKey: #copyOld 				#value: #copySelection 				#enablementSelector: #canCopy 				#command: #copyOld				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #menus ) 				#nameKey: #paste 				#value: #paste 				#command: #paste				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Refresh 					#defaultString: '&amp;Refresh' 					#catalogID: #menus ) 				#nameKey: #refresh 				#value: #refresh ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.Trippy.Clipboard</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize">initialize	zeroStandIn := '0' copyOld. "unique object to stand in for 0 value"	self empty</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="configureCodeViewController:">configureCodeViewController: aController	| menu |	aController		initializeMenuForCode;		autoAccept: false;		doNotHandleLocally: #formatSelection.	"The menu must be copied before chaging items, or else the shared menu in the class would be changed."	menu := aController menu copyOld.	aController menuHolder value: menu. 	(menu menuItemWithValue: #formatSelection)		label: (#Format &lt;&lt; #menus &gt;&gt; 'Format') asString</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>copying</category><body package="HighlightingStyles" selector="postCopy">postCopy	"Finish copying the receiver.  A shallow copy works fine for everything	 except the emphasis, which effectively must be a deep copy.  This is	 because we must make sure embedded associations are copied.  In	 the normal course of things, the emphasis array itself doesn't matter,	 but rather the contents."	self breakDependents.	emphasis class == Array		ifTrue: [emphasis := emphasis collect: [:e | e copyOld]]		ifFalse: [emphasis := emphasis copyOld]</body></methods><methods><class-id>Tools.FileDialogWin32Surrogate</class-id> <category>accessing</category><body package="Tools-Dialogs" selector="asHostPattern:">asHostPattern: aStringOrUserMessage	"Used by compatibility interface."	^aStringOrUserMessage asString copyOld replaceAll: $# with: $?</body></methods><methods><class-id>Tools.TreeItemHolder</class-id> <category>accessing</category><body package="Tools-Modules" selector="children">children	^(childrenBlock value: value) collect:		[:each | self copyOld value: each]</body></methods><methods><class-id>Tools.SettingsManagerPage</class-id> <category>page tree building</category><body package="Tools-Settings" selector="findPlaceFor:">findPlaceFor: aPage	children do:		[:each |		(aPage isChildOf: each) ifTrue:			[^each findPlaceFor: aPage]].	children add: aPage.	children copyOld do:		[:each |		(each isChildOf: aPage) ifTrue:			[children remove: each.			aPage findPlaceFor: each]].	SequenceableCollectionSorter		sort: children		using: [:a :b | 			a position = b position				ifTrue: [a label asString &lt; b label asString]				ifFalse: [a position &lt; b position]]</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>converting</category><body package="Store-Code Comparison" selector="withoutComponents:">withoutComponents: aCollectionOfCodeComponents	"Return a reduced copy, of me with all members of aCollectionOfCodeComponents and any blueprints that reference them, removed."	| reduced |	reduced := self copyOld.	reduced leftCodeComponents: (leftCodeComponents				reject: [:each | aCollectionOfCodeComponents includes: each]).	reduced rightCodeComponents: (rightCodeComponents				reject: [:each | aCollectionOfCodeComponents includes: each]).	^reduced cleanseUnmatchedChanges</body></methods><methods><class-id>Tools.Workbook</class-id> <category>actions</category><body package="Tools-Workspace" selector="pageTearOff">pageTearOff	"Remove the current text page from the workbook and open it	as a separate workspace (not a workbook). If this was the last text	page, close the current workbook. The new window should have	reasonable size and position--that is same size as the original workbook	and either same or cascaded position, depending on whether the	workbook stays or goes. With the MPUI introduction, if the original window	is closed, it should be done *after* opening the new one."	| thisPage workspace bounds wasLastPage |	bounds := self builder window displayBox.	thisPage := self currentTextPage.	thisPage deactivate.	workspace := Workspace new textPage: thisPage.	locals keysAndValuesDo:		[:key :value | workspace addLocal: key value: value].	wasLastPage := self textPageCount &lt;= 1.	wasLastPage ifFalse:		[self removePage: thisPage.		bounds := Screen default makeRectangleVisible:			(bounds copyOld moveBy: 20@20)].	workspace 		allButOpenInterface: #windowSpec;		finallyOpenIn: bounds withType: #normal.	wasLastPage ifTrue:		[self builder window controller closeAndUnschedule]</body></methods><methods><class-id>Tools.Workbook class</class-id> <category>resources</category><body package="Tools-Workspace" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Page 					#defaultString: '&amp;Page' 					#catalogID: #menus ) 				#nameKey: #pageMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_New 								#defaultString: '&amp;New' 								#catalogID: #menus ) 							#nameKey: #fileNew 							#value: #fileNew 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceNew ) 							#command: #new ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_OpenDot 								#defaultString: '&amp;Open...' 								#catalogID: #menus ) 							#nameKey: #fileOpen 							#value: #fileOpen 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceOpen ) 							#command: #open ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Save 								#defaultString: '&amp;Save' 								#catalogID: #menus ) 							#nameKey: #fileSave 							#value: #fileSave 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $S 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceSave ) 							#command: #save ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_AsDot 								#defaultString: 'Save &amp;As...' 								#catalogID: #menus ) 							#nameKey: #fileSaveAs 							#value: #fileSaveAs 							#enablementSelector: #isAtTextPage 							#command: #saveAs ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RenameDot 								#defaultString: '&amp;Rename...' 								#catalogID: #menus ) 							#nameKey: #pageRename 							#value: #pageRename 							#enablementSelector: #canRenamePage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_TearOff 								#defaultString: '&amp;Tear Off' 								#catalogID: #menus ) 							#nameKey: #pageTearOff 							#value: #pageTearOff 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_move 								#defaultString: 'Re&amp;move' 								#catalogID: #menus ) 							#nameKey: #pageClose 							#value: #pageClose 							#enablementSelector: #canClosePage ) ) #(1 3 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #menus ) 				#nameKey: #editMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Cu_t 								#defaultString: 'Cu&amp;t' 								#catalogID: #menus ) 							#nameKey: #editCut 							#value: #cut 							#enablementSelector: #isAtTextPage 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) 							#command: #cut ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Copy 								#defaultString: '&amp;Copy' 								#catalogID: #menus ) 							#nameKey: #editCopy 							#value: #copySelection 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) 							#command: #copyOld ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Paste 								#defaultString: '&amp;Paste' 								#catalogID: #menus ) 							#nameKey: #editPaste 							#value: #paste 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) 							#command: #paste ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FindDots 								#defaultString: '&amp;Find...' 								#catalogID: #menus ) 							#nameKey: #editFind 							#value: #find 							#command: #find ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReplaceDots 								#defaultString: '&amp;Replace...' 								#catalogID: #menus ) 							#nameKey: #editReplace 							#value: #replace 							#command: #replace ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Select_All 								#defaultString: 'Select &amp;All' 								#catalogID: #menus ) 							#nameKey: #editSelectAll 							#value: #selectAll 							#command: #selectAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Encoding 								#defaultString: '&amp;Encoding' 								#catalogID: #menus ) 							#nameKey: #editEncoding ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_InDot 								#defaultString: 'Boss &amp;In...' 								#catalogID: #menus ) 							#value: #bossIn 							#enablementSelector: #canBOSSObjects ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_OutDot 								#defaultString: 'Boss &amp;Out...' 								#catalogID: #menus ) 							#value: #bossOut 							#enablementSelector: #canBOSSObjects ) ) #(3 2 1 1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Smalltalk 					#defaultString: '&amp;Smalltalk' 					#catalogID: #menus ) 				#nameKey: #smalltalkSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DoIt 								#defaultString: '&amp;Do it' 								#catalogID: #menus ) 							#value: #smalltalkDoIt 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) 							#command: #doIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PrintIt 								#defaultString: '&amp;Print it' 								#catalogID: #menus ) 							#value: #smalltalkPrintIt 							#shortcutKeyCharacter: $P 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) 							#command: #printIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InspectIt 								#defaultString: '&amp;Inspect it' 								#catalogID: #menus ) 							#value: #smalltalkInspectIt 							#shortcutKeyCharacter: $Q 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) 							#command: #inspectIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #De_bugIt 								#defaultString: 'De&amp;bug it' 								#catalogID: #menus ) 							#value: #smalltalkDebugIt 							#shortcutKeyCharacter: $B 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) 							#command: #debugIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileItIn 								#defaultString: '&amp;File it In' 								#catalogID: #menus ) 							#value: #smalltalkFileItIn ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NamespacesDot 								#defaultString: '&amp;Namespaces...' 								#catalogID: #menus ) 							#value: #editImports 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.BehaviorIcons} #Namespace ) ) ) #(4 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Options 					#defaultString: '&amp;Options' 					#catalogID: #menus ) 				#nameKey: #optionsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Toolbar 								#defaultString: '&amp;Toolbar' 								#catalogID: #menus ) 							#nameKey: #toolbar 							#value: #toggleToolbar 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_StatusBar 								#defaultString: '&amp;Status Bar' 								#catalogID: #menus ) 							#nameKey: #toggleStatusBar 							#value: #toggleStatusBar ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Workspace 								#defaultString: '&amp;Workspace' 								#catalogID: #menus ) 							#value: #helpWorkspace 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) 							#command: #help ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(1 1 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.Workbook class</class-id> <category>resources</category><body package="Tools-Workspace" selector="toolBar">toolBar	"Tools.MenuEditor new openOnClass: self andSelector: #toolBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #New 					#defaultString: 'New' 					#catalogID: #menus ) 				#value: #fileNew 				#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceNew ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #New 					#defaultString: 'New' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Open 					#defaultString: 'Open' 					#catalogID: #menus ) 				#value: #fileOpen 				#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceOpen ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Open 					#defaultString: 'Open' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Save 					#defaultString: 'Save' 					#catalogID: #menus ) 				#nameKey: #fileSave 				#value: #fileSave 				#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceSave ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Save 					#defaultString: 'Save' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) 				#nameKey: #cut 				#value: #cut 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#nameKey: #copyOld 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) 				#nameKey: #paste 				#value: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #DoIt 					#defaultString: 'Do it' 					#catalogID: #menus ) 				#value: #smalltalkDoIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #DoIt 					#defaultString: 'Do it' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #PrintIt 					#defaultString: 'Print it' 					#catalogID: #menus ) 				#value: #smalltalkPrintIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #PrintIt 					#defaultString: 'Print it' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InspectIt 					#defaultString: 'Inspect it' 					#catalogID: #menus ) 				#value: #smalltalkInspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #InspectIt 					#defaultString: 'Inspect it' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #DebugIt 					#defaultString: 'Debug it' 					#catalogID: #menus ) 				#value: #smalltalkDebugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #DebugIt 					#defaultString: 'Debug it' 					#catalogID: #menus ) ) ) #(3 3 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.DBProfileListSetting</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	super initialize.	profiles := DBProfileManager profiles copyOld asList</body></methods><methods><class-id>Tools.DBProfileListSetting</class-id> <category>actions</category><body package="Database" selector="resetProfiles">resetProfiles	profiles := DBProfileManager profiles copyOld asList</body></methods><methods><class-id>Tools.SideBySideTextComparisonView</class-id> <category>initialize-release</category><body package="Tools-Differences" selector="leftText:rightText:">leftText: aLeftCharacterArray rightText: aRightCharacterArray	| leftText rightText |	self releaseAllComponents.	leftText := (aLeftCharacterArray ifNil: ['']) asText copyOld.	rightText := (aRightCharacterArray ifNil: ['']) asText copyOld.	self computeDifferencesLeft: leftText right: rightText.	self add: (self createTextEditorFor: leftText asValue).	self add: (self createTextEditorFor: rightText asValue)</body></methods><methods><class-id>Tools.SideBySideTextComparisonView</class-id> <category>initialize-release</category><body package="Tools-Differences" selector="initializeLayoutAlgorithm">initializeLayoutAlgorithm	| frame midX |	self childFramingBlock: 			[:rect :child :index |			frame := rect copyOld bottom: rect top + child preferredBounds height.			midX := rect left midpoint: rect right.			index = 1				ifTrue: [frame right: midX - self halfGapWidth]				ifFalse: [frame left: midX + self halfGapWidth].			frame]</body></methods><methods><class-id>Tools.DiffList</class-id> <category>differating</category><body package="Tools-Differences" selector="pushOntoStack:">pushOntoStack: stack	| stopIndex target n2 start1 start2 |	start1 := match1 key + 1.	start2 := match2 key + 1.	stopIndex := list2 size.	start1 to: list1 size do:		[:n1 |		target := list1 at: n1.		n2 := start2-1.		[(n2 := n2+1) &lt;= stopIndex] whileTrue:			[target = (list2 at: n2)				ifTrue:					[(self copyOld push: n1 with: n2 baseIndex: 1)							mergeWith: stack.					"Revise stopIndex to reflect the new limit."					stopIndex := n2-1.					stopIndex &lt; start2 ifTrue: [^self]]]]</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>public runtime</category><body package="External-Interface" selector="libraryFiles:">libraryFiles: aStringOrArray	"SomeExternalInterface libraryFiles: #('library.so' 'library file with spaces.dll')"	"SomeExternalInterface libraryFiles: 'library.so library.sl'"	"Reset my libraryFiles. To have this take effect immediately, I unload my libraries, so that	a new search for the affected libraries will occur the next time they are invoked.	Alternatively, you can edit my class-definition template accordingly and accept it."	| newList |	newList := self scanFieldNames: aStringOrArray.	libraryFiles isNil		ifTrue:			[libraryFiles := LinkedOrderedCollection new.			superclass libraryFiles notNil				ifTrue: [libraryFiles addBackup: superclass libraryFiles]]		ifFalse:			[(self libraryFilesArray isSameSequenceAs: newList) ifTrue: [^self].			self unloadLibraries.			libraryFiles copyOld				ownDo:					[:each | each isDefinedByAnnotation ifFalse: [libraryFiles remove: each]]].	newList		do:			[:lib | 			libraryFiles				add:					(ExternalLibraryHolder named: lib directories: libraryDirectories owner:							self)]</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private</category><body package="BOSS" selector="ownExternalAssociations">ownExternalAssociations	"Answer an Array of the associations contained in the receiver's externals dictionary.  Only answer those actually contained in the receiver's external dictionary and not any in its superclass."	"We add a copy of the association so BOSS readers don't map the original association to the values answered by this method."	| associations |	associations := OrderedCollection new.	self externals ownAssociationsDo: [:anAssoc |		associations add: anAssoc copyOld].	^associations asArray</body></methods><methods><class-id>External.CStructureLayout</class-id> <category>enumerating</category><body package="External-Types" selector="doStruct:">doStruct: aType	"Align the argument within the receiver's current layout."	| layout align |	layout := self copyOld initialize.	aType keysAndValuesDo: [:key :alt |		aType align: key on: (alt value typeDo: layout)].	align := layout alignment.	aType alignment: align.	layout allocate: 0 aligned: align.	aType dataSize: layout numBytes.	aType beStructure.	^structAlignBlock value: self value: aType</body></methods><methods><class-id>External.CStructureLayout</class-id> <category>enumerating</category><body package="External-Types" selector="doUnion:">doUnion: aType	"Align the argument within the receiver's current layout."	| size align |	size := 0.	align := 1.	aType do: [:alt | | layout layoutAlign |		layout := self copyOld initialize.		alt value typeDo: layout.		layoutAlign := layout alignment.		layout allocate: 0 aligned: layoutAlign.		size := size max: layout numBytes.		align := align max: layoutAlign].	aType alignment: align.	aType dataSize: size.	aType beUnion.	^unionAlignBlock value: self value: aType</body></methods><methods><class-id>External.CStructureLayout class</class-id> <category>layouts</category><body package="External-Types" selector="defaultLayout">defaultLayout	"Answer the current platform's default layout."	^DefaultLayout copyOld</body></methods><methods><class-id>External.CProcedureType</class-id> <category>accessing-compilation</category><body package="External-Types" selector="typesKindsAndSizesDo:">typesKindsAndSizesDo: aBlock	| types kinds sizes |	types := Array new: self basicSize.	kinds := types copyOld.	sizes := types copyOld.	1 to: self basicSize do:		[:i| | type |		type := types at: i put: (self basicAt: i).		kinds at: i put: type kind.		sizes at: i put: (type isVoid ifTrue: [0] ifFalse: [type dataSize])].	^aBlock value: types value: kinds value: sizes</body></methods><methods><class-id>External.CPointer</class-id> <category>primitives</category><body package="External-Data" selector="primCopyCStringFromHeap:pointerKind:">primCopyCStringFromHeap: address pointerKind: pointerKind	"Answer an instance of a String by copying the null terminated string pointed to by the receiver from the external heap.  The terminating null is not part of the answered String.  This method does not directly check to see if the receiver's type is appropriate for a String copy operation.  If the receiver's referent type is incorrect, a signal will eventually be raised as the receiver's contents will fail to store into a Smalltalk String object.  The second argument is used to distinguish between segmented and linear pointers."	&lt;primitive: 335 errorCode: error&gt;	| cPointer aChar theString |	self referentAddress == 0 ifTrue: [^self error: (#errDereferenceNullPointer &lt;&lt; #external &gt;&gt; 'Attempt to dereference a NULL pointer.')].	(error isError	and: [error name == #'allocation failed'	and: [thisContext sender sender method ~~ thisContext method]])		ifTrue:			[error handleErrorFor: #largeSpace.			^self primCopyCStringFromHeap: address pointerKind: pointerKind].	theString := (String primitiveArgumentClass new: 16) writeStream.	cPointer := self copyOld.	[(aChar := cPointer contents) == 0]		whileFalse:			[theString nextPut: aChar.			cPointer += 1].	^theString contents</body></methods><methods><class-id>External.CPointer</class-id> <category>copying</category><body package="External-Data" selector="copyCStringSequenceFromHeap:">copyCStringSequenceFromHeap: encoding	"Answer a sequence of Strings by copying strings pointed to by the receiver from the heap.  Each string is null-terminated, with the last string followed by two null bytes.  The terminating null is not part of the answered Strings.  This method does not directly check to see if the receiver's type is appropriate for a String copy operation.  If the receiver's referent type is incorrect, a signal will eventually be raised as the receiver's contents will fail to store into a Smalltalk String object."	| cPointer result wide nullCount next |	self referentAddress == 0 ifTrue: [^self error: (#errDereferenceNullPointer &lt;&lt; #external &gt;&gt; 'Attempt to dereference a NULL pointer.')].	result := OrderedCollection new.	wide := StreamEncoder encodingUsesWideChars: encoding.	nullCount := wide ifTrue: [2] ifFalse: [1].	cPointer := self copyOld type: CIntegerType char pointerType.	[next := wide		ifTrue: [cPointer primCopyDoubleByteStringFromHeap: 0 pointerKind: type kind]		ifFalse: [cPointer primCopyCStringFromHeap: 0 pointerKind: type kind].	next isEmpty] whileFalse:		[result add: (next asStringEncoding: encoding).		cPointer += (next size + nullCount)].	^result</body></methods><methods><class-id>External.CPointer</class-id> <category>pointer arithmetic</category><body package="External-Data" selector="+">+ offset	"Answer a pointer whose address is incremented by offset elements.  The answered pointer is a copy of the receiver with the referent address properly adjusted.  The pointer value will be adjusted by (offset * size of the receiver's referent type).  Please see the class comments for more details."	^self copyOld += offset</body></methods><methods><class-id>External.ExternalMethod</class-id> <category>copying</category><body package="External-Interface" selector="postCopy">postCopy	"Answer the receiver with all internal state properly reset after a copy operation."	super postCopy.	virtuals := virtuals copyOld.	^self</body></methods><methods><class-id>External.LinkedOrderedCollection</class-id> <category>accessing</category><body package="External-Collections" selector="removeAll">removeAll	self copyOld ownDo: [:el | self remove: el]</body></methods><methods><class-id>Refactory.CodeHighlighter.CodeHighlightingParser</class-id> <category>initialize-release</category><body package="RBCodeHighlighting" selector="text:">text: aText 	text := aText.	string := text string copyOld.	text addEmphasis: #() removeEmphasis: StyleDescription stylesToRemove allowDuplicates: false</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper class</class-id> <category>instance creation</category><body package="Method Wrapper Base" selector="on:inClass:">on: aSelector inClass: aClass 	| wrapper |	(self canWrap: aSelector inClass: aClass) ifFalse: [^nil].	wrapper := (self methods at: aSelector numArgs				ifAbsentPut: [self createMethodFor: aSelector numArgs]) copyOld.	wrapper class: aClass selector: aSelector.	^wrapper</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>matching</category><body package="SmaCC Runtime" selector="copyInContext:">copyInContext: aDictionary	| copy |	copy := self copyOld.	self tokenVariables		do:			[:selector | copy perform: (self convertToSetter: selector) with: ((self perform: selector) copyInContext: aDictionary)].	self nodeVariables		do:			[:selector | copy perform: (self convertToSetter: selector) with: ((self perform: selector) copyInContext: aDictionary)].	self compositeTokenVariables		do:			[:selector | 			copy				perform: (self convertToSetter: selector)				with: ((self perform: selector) collect: [:each | each copyInContext: aDictionary])].	self compositeNodeVariables		do:			[:selector | 			copy				perform: (self convertToSetter: selector)				with: ((self perform: selector) collect: [:each | each copyInContext: aDictionary])].	^copy</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>matching</category><body package="SmaCC Runtime" selector="matchCollection:index:to:index:inContext:">matchCollection: matchNodes index: matchIndex to: programNodes index: programIndex inContext: aDictionary	| node currentIndex currentDictionary nodes |	matchNodes size &lt; matchIndex ifTrue: [^programNodes size &lt; programIndex].	node := matchNodes at: matchIndex.	node isListMatch		ifTrue:			[currentIndex := programIndex - 1.			[currentDictionary := aDictionary copyOld.			programNodes size &lt; currentIndex				or:					[(self						matchCollection: matchNodes						index: matchIndex + 1						to: programNodes						index: currentIndex + 1						inContext: currentDictionary)						and:							[nodes := programNodes copyFrom: programIndex to: currentIndex.							(currentDictionary at: node ifAbsentPut: [nodes]) = nodes								ifTrue:									[currentDictionary keysAndValuesDo: [:key :value | aDictionary at: key put: value].									^true].							false]]] whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size &lt; programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) ifFalse: [^false].	^self		matchCollection: matchNodes		index: matchIndex + 1		to: programNodes		index: programIndex + 1		inContext: aDictionary</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>copying</category><body package="SmaCC Runtime" selector="postCopy">postCopy	super postCopy.	self		allGettersDo:			[:each | 			self				perform: (self convertToSetter: each)				with:					((self compositeVariableSelectors includes: each)						ifTrue: [(self perform: each) collect: [:item | item copyOld]]						ifFalse: [(self perform: each) copyOld])]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternNode</class-id> <category>matching</category><body package="SmaCC Runtime" selector="copyInContext:">copyInContext: aDictionary	^(aDictionary at: self ifAbsent: [nil]) copyOld</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	^(self copyOld)		protocol: self newProtocol;		newProtocol: self protocol;		toggleUndoState;		yourself</body></methods><methods><class-id>Refactory.Browser.AbstractCodeModel</class-id> <category>navigator accessing</category><body package="Browser-BrowserUI" selector="setSelector:">setSelector: aSelector 	navigator updateWithState: ((state copyOld)				selector: aSelector;				yourself)</body></methods><methods><class-id>Refactory.Browser.PackageChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	| oldPackage |	oldPackage := self currentPackage.	oldPackage isNil ifTrue: [^nil].	^(self copyOld)		package: oldPackage;		toggleUndoState;		yourself</body></methods><methods><class-id>Refactory.Browser.MoveObjectChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	^(self copyOld)		move: targetNamespace , '.' , self simpleObjectName			to: self originalNamespaceName;		yourself</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>matching</category><body package="Browser-Parser" selector="matchList:index:against:index:inContext:">matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 	| node currentIndex currentDictionary nodes |	matchNodes size &lt; matchIndex ifTrue: [^programNodes size &lt; programIndex].	node := matchNodes at: matchIndex.	node isList 		ifTrue: 			[currentIndex := programIndex - 1.						[currentDictionary := aDictionary copyOld.			programNodes size &lt; currentIndex or: 					[nodes := programNodes copyFrom: programIndex to: currentIndex.					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 							[(self 								matchList: matchNodes								index: matchIndex + 1								against: programNodes								index: currentIndex + 1								inContext: currentDictionary) 									ifTrue: 										[currentDictionary 											keysAndValuesDo: [:key :value | aDictionary at: key put: value].										^true].							false]]] 					whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size &lt; programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) 		ifFalse: [^false].	^self 		matchList: matchNodes		index: matchIndex + 1		against: programNodes		index: programIndex + 1		inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary	^self copyOld</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="buildParseTree">buildParseTree	parseTree := (class parseTreeFor: selector) copyOld.	parseTree isNil ifTrue: [self refactoringError: (#CouldNotParseMethod &lt;&lt; #browser &gt;&gt; 'Could not parse method')]</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>initialize-release</category><body package="Browser-BaseUI" selector="initialize">initialize	super initialize.	self actionList list: (List 				withAll: ((RBCommand actions values collect: [:each | each copyOld]) 						asSortedCollection: [:a :b | a name asString &lt; b name asString])).	self typeList list: (List withAll: RBCommand withAllSubclasses).	self nameHolder onChangeSend: #changedName to: self.	self descriptionHolder onChangeSend: #changedDescription to: self.	self actionHolder onChangeSend: #changedAction to: self.	self enabledHolder onChangeSend: #changedEnabled to: self.	self receiverHolder onChangeSend: #changedReceiver to: self.	self typeList selectionIndexHolder onChangeSend: #changedType to: self</body></methods><methods><class-id>Refactory.Browser.BrowserDefinitionTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseRe_ferencesDots 					#defaultString: 'Browse Re&amp;ferences...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable References' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseRea_dersDots 					#defaultString: 'Browse Rea&amp;ders...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable Readers' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_WritersDots 					#defaultString: '&amp;Browse Writers...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable Writers' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_AddVariableDots 					#defaultString: '&amp;Add Variable...' 					#catalogID: #browser ) 				#nameKey: #'Add Instance Variable' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RemoveVariableDots 					#defaultString: '&amp;Remove Variable...' 					#catalogID: #browser ) 				#nameKey: #'Remove Selected Instance Variable' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Refactor 					#defaultString: 'Refactor' 					#catalogID: #browser ) 				#nameKey: #refactorMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Push_Up 								#defaultString: 'Push &amp;Up' 								#catalogID: #browser ) 							#nameKey: #'Push Up Selected Instance Variable' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Push_Down 								#defaultString: 'Push &amp;Down' 								#catalogID: #browser ) 							#nameKey: #'Push Down Selected Instance Variable' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CreateAccessors 								#defaultString: 'Create Accessors' 								#catalogID: #browser ) 							#nameKey: #'Create Selected Instance Variable Accessors' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #A_bstract 								#defaultString: 'A&amp;bstract' 								#catalogID: #browser ) 							#nameKey: #'Abstract Selected Instance Variable' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Protect 								#defaultString: '&amp;Protect' 								#catalogID: #browser ) 							#nameKey: #'Protect Selected Instance Variable' 							#value: 							#action: ) ) #(2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#command: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#command: #printIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#command: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#command: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Explain 					#defaultString: 'Explain' 					#catalogID: #browser ) 				#nameKey: #'Explain Code' 				#value: 				#action: 				#command: #explain ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copyOld 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(1 3 3 4 1 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self temporaries: (self temporaries collect: [:each | each copyOld]).	self statements: (self statements collect: [:each | each copyOld])</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self contents: (self contents collect: [:each | each copyOld])</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	| newDict |	newDict := classSelectors copyOld.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copyOld].	classSelectors := newDict.	newDict := metaClassSelectors copyOld.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copyOld].	metaClassSelectors := newDict.	initializers := initializers copyOld.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="implementorsOf:in:">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector.	anEnvironment classesDo: 			[:class | 			((class includesSelector: aSelector) 				and: [anEnvironment includesSelector: aSelector in: class]) 					ifTrue: 						[class isMeta 							ifTrue: [metaDict at: class soleInstance fullRootName put: selectors copyOld]							ifFalse: [classDict at: class fullRootName put: selectors copyOld]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body></methods><methods><class-id>Refactory.Browser.MethodNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI" selector="defaultMenu">defaultMenu	"Ugly method to add the spawn hierarchy after the spawn in the method list 	(assuming that our navigator has the spawn hierarchy action)."	| newMenu menuItem spawnMenuItem |	newMenu := super defaultMenu copyOld.	menuItem := (navigator menuNamed: #classMenu) 				atNameKey: #'Spawn Class Hierarchy'.	spawnMenuItem := newMenu atNameKey: #'Spawn Method'.	menuItem isNil | spawnMenuItem isNil ifTrue: [^newMenu].	newMenu addItem: menuItem copyOld atPosition: spawnMenuItem position + 0.00001.	^newMenu</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private-store</category><body package="Browser-BrowserUI" selector="pundlesWithoutCurrentObjectOverrides">pundlesWithoutCurrentObjectOverrides		| withoutPundles |	withoutPundles := self pundles copyOld asSet.	self classesAndNameSpaces do:		[:each | 		(Override overridesForClassOrNameSpace: each) ifNotNil: 			[:overridesForMethod | 			overridesForMethod do: 				[:eachOverride | 				withoutPundles addAll: (eachOverride sources select: [:eachSource | eachSource isPackage])]]].	^withoutPundles</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>removal-scopes</category><body package="Browser-BrowserUI" selector="validateObjectRemovalChange:">validateObjectRemovalChange: aCompositeChange	"Determine if any of the object removals have references from else where in the system. We need to consider not only the objects themselves, but any contained objects (or subclasses) as well. If they do, have a dialog with the user about what to do about it (cancel, proceed, or browse them), return true/false based on whether the change should be allowed to proceed.First step is to extract the removals (there may be override adjustments in there too)."	| ws selectedRemovals classesWithChild notEmptyNamespaces references warningChunks allRemovals |	selectedRemovals := ((aCompositeChange changes select: [:each | each isKindOf: RemoveObjectChange]) collect: #changeObject)				asSet.	classesWithChild := Set new.	notEmptyNamespaces := Set new.	allRemovals := selectedRemovals copyOld.	selectedRemovals do: 			[:eachSelection |			eachSelection isNameSpace				ifTrue: 					[| victims |					victims := eachSelection withAllNameSpacesAndAllClasses.					selectedRemovals do: [:eachRemoval | victims remove: eachRemoval ifAbsent: []].					victims isEmpty						ifFalse: 							[notEmptyNamespaces add: eachSelection.							allRemovals addAll: victims]]				ifFalse: 					[eachSelection allSubclasses do: 							[:eachSubclass |							(selectedRemovals includes: eachSubclass)								ifFalse: 									[allRemovals add: eachSubclass.									classesWithChild add: eachSelection]]]].	references := Dictionary new.	self showWaitCursorWhile: 			[allRemovals do: [:each | references at: each put: (BrowserEnvironment new referencesTo: each fullyQualifiedReference binding)]].	references do: [:eachEnvironment | eachEnvironment removeScopes: allRemovals].	references := references reject: #isEmpty.	(references isEmpty and: [classesWithChild isEmpty and: [notEmptyNamespaces isEmpty]]) ifTrue: [^true].	warningChunks := OrderedCollection new.	references isEmpty		ifFalse: 			[ws := String new writeStream.			ws				nextPutAll: (#ObjectRemovalsReferencedElsewhereC &lt;&lt; #browser						&gt;&gt; 'Some of the objects to be removed are referenced elsewhere in the system:') asString.			(references keys asSortedCollection: [:a :b | a name &lt; b name]) do: 					[:each |					ws nextPutAll: ('&lt;n&gt;&lt;t&gt;&lt;1s&gt; -- &lt;2s&gt;' expandMacrosWith: each toolListDisplayString								with: ((references at: each) dispositionToObjectRemoval: each))].			warningChunks add: ws contents].	classesWithChild isEmpty		ifFalse: 			[ws := String new writeStream.			ws nextPutAll: (#ClassesToRemoveHaveChildrenC &lt;&lt; #browser &gt;&gt; 'Some of the classes to be removed have unselected subclasses:')						asString.			(classesWithChild asSortedCollection: [:a :b | a name &lt; b name]) do: 					[:each |					ws nextPutAll: ('&lt;n&gt;&lt;t&gt;&lt;1s&gt; -- &lt;2s&gt;' expandMacrosWith: each toolListDisplayString								with: (self explainClassRemoval: each subclassVictims: each allSubclasses asSet - selectedRemovals))].			warningChunks add: ws contents].	notEmptyNamespaces isEmpty		ifFalse: 			[ws := String new writeStream.			ws				nextPutAll: (#NamespacesToRemoveAreNotEmpty &lt;&lt; #browser &gt;&gt; 'Some of the namespaces to be removed contain unselected items:')						asString.			(notEmptyNamespaces asSortedCollection: [:a :b | a name &lt; b name]) do: 					[:each |					ws nextPutAll: ('&lt;n&gt;&lt;t&gt;&lt;1s&gt; -- &lt;2s&gt;' expandMacrosWith: each toolListDisplayString								with: (self explainScopeRemoval: each containedVictims: each withAllNameSpacesAndAllClasses asSet - selectedRemovals))].			warningChunks add: ws contents].	^self confirmRemoval: (warningChunks fold: [:a :b | '&lt;1s&gt;&lt;n&gt;&lt;n&gt;&lt;2s&gt;' expandMacrosWith: a with: b]) references: references</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>store-packages</category><body package="Browser-BrowserUI" selector="storeInspectChangeSet:">storeInspectChangeSet: dbid 	| hasChanges |	hasChanges := false.	self packages do: 			[:each | 			| changeSet |			changeSet := each changeSetFor: dbid.			(changeSet notNil and: [changeSet notEmpty]) 				ifTrue: 					[hasChanges := true.					changeSet copyOld inspect]].	hasChanges ifFalse: [self warn: (#NoChanges &lt;&lt; #browser &gt;&gt; 'No changes')]</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private-code components</category><body package="Browser-BrowserUI" selector="codeIn:codeComponents:sharedVariablesDo:nameSpacesDo:definedClassesDo:methodsDo:">codeIn: aNameCollection codeComponents: parcelPackageCollection sharedVariablesDo: svBlock nameSpacesDo: nsBlock definedClassesDo: cBlock methodsDo: mBlock 	aNameCollection do: 			[:each | 			| binding ref |			ref := each asQualifiedReference.			binding := ref bindingOrNil.			parcelPackageCollection do: 					[:codeComponent | 					binding isForNameSpace 						ifTrue: 							[(codeComponent definesObject: binding value) 								ifTrue: [nsBlock value: binding value]]						ifFalse: 							[(codeComponent definesClass: binding value) 								ifTrue: [cBlock value: binding value].							(codeComponent definedSelectorsFor: binding value) copyOld 								do: [:sel | mBlock value: binding value value: sel].							(codeComponent definedSelectorsFor: binding value class) copyOld 								do: [:sel | mBlock value: binding value class value: sel]].					(codeComponent definedBindingsFor: binding value) copyOld do: 							[:sv | 							sv isForGeneral 								ifTrue: 									[svBlock 										value: (binding value fullName , '.' , sv key) asQualifiedReference]]]]</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>copying</category><body package="Browser-ChangeObjects" selector="postCopy">postCopy	super postCopy.	changes := changes collect: [:each | each copyOld]</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="executeNotifying:">executeNotifying: aBlock 	| undos undo |	undos := changes collect: 					[:each | 					[each executeNotifying: aBlock] on: RefactoryChangeFailureNotification						do: [:ex | each == changes first ifTrue: [ex pass] ifFalse: [ex resume]]].	(undos anySatisfy: [:each | each isNil]) ifTrue: [^nil].	undo := self copyOld.	undo changes: undos reverse.	^undo</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects" selector="renameChangesForObject:to:">renameChangesForObject: aClassName to: newClassName 	^(self copyOld)		changes: (self changes 					collect: [:each | each renameChangesForObject: aClassName to: newClassName]);		yourself</body></methods><methods><class-id>Refactory.Browser.BundleStructureView</class-id> <category>displaying</category><body package="Browser-BrowserUI" selector="displayOn:">displayOn: aGC	"In addition to drawing the subparts, we show which is being drug, and in the event we're scanning, we actually forgo drawing the subparts, drawing a progress label instead."	state = #idle ifFalse: [self displayDragOn: aGC copyOld].	super displayOn: aGC</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self value: self value copyOld</body></methods><methods><class-id>Refactory.Browser.PrerequisitesExplorerView</class-id> <category>displaying</category><body package="Browser-Prerequisites" selector="displayOn:">displayOn: aGC	"In addition to drawing the subparts, we show which is being drug, and in the event we're scanning, we actually forgo drawing the subparts, drawing a progress label instead."	self isScanning ifTrue: [^self displayScanningOn: aGC].	state = #idle ifFalse: [self displaySelectedOn: aGC copyOld].	super displayOn: aGC</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self body: self body copyOld.	self arguments: (self arguments collect: [:each | each copyOld]).	self tags: (self tags collect: [:each | each copyOld])</body></methods><methods><class-id>Refactory.Browser.MoveMethodToOverrideInPackageChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	| originalPackage |	originalPackage := self currentPackage.	originalPackage isNil ifTrue: [^nil].	^(self copyOld)		oldPackageName: packageName;		package: originalPackage;		toggleUndoState;		yourself</body></methods><methods><class-id>Refactory.Browser.CommentChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	^(self copyOld)		comment: self commentObject comment;		toggleUndoState;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoryObjectChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects" selector="renameChangesForObject:to:">renameChangesForObject: aClassName to: newClassName 	| newString |	newString := self 				changeVariable: self objectName				thatBeginsWith: aClassName				toBeginWith: newClassName.	self objectName = newString 		ifFalse: 			[^(self copyOld)				objectName: newString;				yourself].	^self</body></methods><methods><class-id>Refactory.Browser.BundleStructureTool</class-id> <category>actions</category><body package="Browser-BrowserUI" selector="addToSubcomponents">addToSubcomponents	| currentItems |	currentItems := self bundle containedItems.	(self promptForAddWithout: (currentItems copyWith: self bundle))		ifNotNil: 			[:toAdd |			toAdd isEmpty				ifFalse: 					[self bundle containedItems: ((currentItems copyOld)								addAll: toAdd;								yourself).					(self widgetAt: #bundleStructureView) addSubcomponentRows: toAdd]]</body></methods><methods><class-id>Refactory.Browser.CodeComponentSummaryTool</class-id> <category>updating</category><body package="Browser-BrowserUI" selector="updateContents">updateContents	"What a pain, TextEditorView makes this (where this equals messing with the tabs via the style) kind of hard, so we have to get down and dirty with its guts."		| newText view paragraph newStyle widths left tabs |	newText := self summaryText addHyperlinkEmphases.	self textController ifNil: [^self].	view := self textController view.	paragraph := view displayContents.	newStyle := paragraph textStyle copyOld.	widths := newText computeMinimumTabWidthsUsing: view graphicsContext.	left := 0.	tabs := widths collect: [:each | left := left + each + 45].	newStyle useTabs: #(1) , tabs.	paragraph		compositionWidth: view wrappingBox width		text: newText		style: newStyle		fitWidth: true.	view		displayContents: paragraph;		invalidate</body></methods><methods><class-id>Refactory.Browser.CodeComponentSummaryTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copyOld 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) ) #(1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation		| undo |	undo := self copyOld.	undo propertyValue: self installedPropertyValue.	^undo</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>menu accessing</category><body package="Browser-BaseUI" selector="createActionMenuItemFrom:">createActionMenuItemFrom: aMenuItem	| newItem commandName |	newItem := aMenuItem copyOld.	newItem rawLabel: (self menuLabelFor: aMenuItem).	newItem nameKey: aMenuItem nameKey.	commandName := aMenuItem nameKey.	(commandName notNil and: [aMenuItem value ~= #rbItem])		ifTrue:			[newItem value: [self action: newItem].			newItem				helpText: (self actionNamed: aMenuItem nameKey asString) description]		ifFalse: [newItem value: nil].	newItem enablementSelector: #isMenuItemEnabled:.	aMenuItem enablementSelector notNil		ifTrue: [newItem hidden: [self isMenuItemHidden: aMenuItem]].	^newItem</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>menu accessing</category><body package="Browser-BaseUI" selector="buildMenuFrom:">buildMenuFrom: aMenu	| newMenu |	newMenu := Menu new.	aMenu allMenuItemGroups do: 			[:group |			| items index newIndex |			items := OrderedCollection new.			group do: 					[:each |					((#(#action: #rbItem) includes: each value)						or: [each value isSymbol and: [each value keywords size &gt; 1]])							ifTrue: [items add: (self createActionMenuItemFrom: each)]							ifFalse: 								[each value = #dynamicMenu									ifTrue: [items addAll: (self dynamicMenuItemsFrom: each)]									ifFalse: 										[| newItem symbol |										newItem := each copyOld.										newItem truePerformerBlock: [:ignore | self].										"Force all messages that we understand to be dispatched to us, 										no matter if they are used in the menu bar or elsewhere."										((symbol := newItem value) isSymbol and: [self respondsTo: newItem value])											ifTrue: [newItem value: [self perform: symbol]].										items add: newItem]]].			items do: [:each | each notNil ifTrue: [self createSubMenuItemFor: each]].			index := 0.			[index &lt; items size] whileTrue: 					[newIndex := items								nextIndexOf: nil								from: index + 1								to: items size.					newIndex isNil ifTrue: [newIndex := items size + 1].					newMenu addItemGroup: (items copyFrom: index + 1 to: newIndex - 1).					index := newIndex]].	^newMenu</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>menu accessing</category><body package="Browser-BaseUI" selector="buildTopLevelMenuFrom:">buildTopLevelMenuFrom: aMenuName	| menu |		[menu := (self class menuNamed: aMenuName) copyOld				augmentFrom: self class				to: self menuAugmentationRoot				menuName: aMenuName				for: self]			on: MenuAugmentationError			do: [:ex | ex isResumable ifTrue: [ex resume]].	^(self doesMenuNeedToBeRebuilt: menu)		ifTrue: [[self buildMenuFrom: menu]]		ifFalse: [self buildMenuFrom: menu]</body></methods><methods><class-id>Refactory.Browser.CopyrightNoticeTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copyOld 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(1 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.AddClassChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects" selector="renameChangesForObject:to:">renameChangesForObject: aClassName to: newClassName 	| newChange tree newSuperclass superclass |	newChange := super renameChangesForObject: aClassName to: newClassName.	tree := RBParser parseExpression: newChange definition				onError: [:s :e | ^newChange].	tree isMessage ifFalse: [^newChange].	tree arguments size &lt; 2 ifTrue: [^newChange].	superclass := tree arguments at: 2.	(superclass isLiteralNode and: [superclass value isBindingReference]) 		ifFalse: [^newChange].	newSuperclass := self 				changeVariable: superclass value asString				thatBeginsWith: aClassName				toBeginWith: newClassName.	newSuperclass = superclass value asString ifTrue: [^newChange].	tree arguments at: 2		put: (RBLiteralNode 				value: (LiteralBindingReference pathString: newSuperclass)).	^(newChange copyOld)		definition: tree formattedCode;		fillOutDefinition;		yourself</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule</class-id> <category>copying</category><body package="Browser-Smalllint" selector="postCopy">postCopy	super postCopy.	rules := rules collect: #copyOld</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule class</class-id> <category>instance creation</category><body package="Browser-Smalllint" selector="ruleFor:protocol:">ruleFor: aClass protocol: aProtocol 	| allRules prot label |	aProtocol isString		ifTrue:			[prot := aProtocol.			label := aProtocol asString copyOld.			label at: 1 put: label first asUppercase]		ifFalse:			[prot := aProtocol value.			label := aProtocol key].	allRules := aClass withAllSubclasses inject: OrderedCollection new				into: 					[:sum :each | 					sum						addAll: ((BrowserEnvironment new selectorsFor: prot asSymbol									in: each class) collect: [:selector | each perform: selector]);						yourself].	^self rules: (allRules asSortedCollection: [:a :b | a name &lt; b name])		name: label</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self arguments: (self arguments collect: [:each | each copyOld]).	self body: self body copyOld</body></methods><methods><class-id>Refactory.Browser.ExtractMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="checkAssignments:">checkAssignments: variableNames 	| node outsideVars removeAssigned |	removeAssigned := variableNames copyOld.	node := self placeholderNode.	outsideVars := variableNames 				select: [:each | (node whoDefines: each) references: each].	outsideVars size == 1 		ifTrue: [self checkSingleAssignment: outsideVars asArray first].	outsideVars size &gt; 1 		ifTrue: 			[self refactoringError: (#CannotExtractAssignmentWithoutAllRefs &lt;&lt; #browser &gt;&gt; 'Cannot extract assignment without all references.')].	removeAssigned removeAll: outsideVars.	(RBReadBeforeWrittenTester readBeforeWritten: removeAssigned		in: extractedParseTree) notEmpty 		ifTrue: 			[self refactoringError: (#CannotExtractAssignmentIfReadBeforeWritten &lt;&lt; #browser &gt;&gt; 'Cannot extract assignment if read before written.')].	removeAssigned 		do: [:each | (node whoDefines: each) removeTemporaryNamed: each].	self createTemporariesInExtractedMethodFor: variableNames</body></methods><methods><class-id>Refactory.Browser.RBActionDispatcher</class-id> <category>copying</category><body package="Browser-BaseUI" selector="postCopy">postCopy	super postCopy.	objects := objects copyOld</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing-pundles</category><body package="Browser-BaseUI" selector="selectPundle:">selectPundle: aPundleModel 	| newState |	newState := state copyOld.	newState		definitions: #();		protocols: #();		objectNames: #();		pundle: aPundleModel.	self updateWithState: newState</body></methods><methods><class-id>Refactory.Browser.RenameObjectChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="executeNotifying:">executeNotifying: aBlock 		[| undos |	self changeObjectReference renameTo: newName.	undos := changes collect: 					[:each | 					(each renameChangesForObject: oldName asString to: self newUnambiguousName) 						executeNotifying: aBlock].	(undos anySatisfy: [:each | each isNil]) ifTrue: [^nil].	^(self copyOld)		changes: undos reverse;		rename: self newUnambiguousName to: oldName asQualifiedReference simpleName;		yourself] 			on: RefactoryChangeFailureNotification			do: [:ex | ex resume]</body></methods><methods><class-id>Refactory.Browser.BundleStructureMergeChange</class-id> <category>converting</category><body package="Store-Merge Management" selector="asUndoOperation">asUndoOperation	^(self copyOld)		structure: self bundle structure;		yourself</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>utilities</category><body package="Browser-Refactorings" selector="safeMethodNameFor:basedOn:">safeMethodNameFor: aClass basedOn: aString 	"Creates an unused method name containing aString"	| baseString newString hasParam i |	baseString := aString copyOld.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	hasParam := newString last = $:.	hasParam 		ifTrue: [baseString := newString copyFrom: 1 to: newString size - 1].	i := 0.	[aClass hierarchyDefinesMethod: newString asSymbol] whileTrue: 			[i := i + 1.			newString := baseString , i printString 						, (hasParam ifTrue: [':'] ifFalse: [''])].	^newString asSymbol</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="setOption:toUse:">setOption: aSymbol toUse: aBlock	| dict |	dict := self options.	dict == self class refactoringOptions ifTrue: [self options: dict copyOld].	^self options at: aSymbol put: aBlock</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>transforming-class/namespace names</category><body package="Browser-Refactorings" selector="replaceReferenceTo:inPath:toBe:">replaceReferenceTo: aRBProgramItem inPath: path toBe: aString 	| newPath index nameStream |	newPath := path copyOld.	index := path size + 1.		[index := path 				prevIndexOf: aRBProgramItem name				from: index - 1				to: 1.	index notNil] 			whileTrue: 				[nameStream := WriteStream on: String new.				(1 to: index) do: [:i | nameStream nextPutAll: (path at: i)]					separatedBy: [nameStream nextPut: $.].				(self methodClass referencedItem: nameStream contents) == aRBProgramItem 					ifTrue: [newPath at: index put: aString]].	^newPath</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="copyOptionsFrom:">copyOptionsFrom: aDictionary 	| dict |	dict := self options.	dict == self class refactoringOptions 		ifTrue: [^self options: aDictionary copyOld].	dict keysAndValuesDo: 			[:key :value | 			value == (self class refactoringOptions at: key) 				ifTrue: [dict at: key put: (aDictionary at: key)]].	self options: dict</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(aDictionary at: self) copyOld</body></methods><methods><class-id>Refactory.Browser.MenuViewer</class-id> <category>private</category><body package="Browser-BrowserUI" selector="initializeMenu:">initializeMenu: aMenu	| simplifiedCopy |	simplifiedCopy := aMenu copyOld.	simplifiedCopy menuItems do: 			[:each |			each value: [self selection value: each value].			each enablementSelector: nil.			each indicationSelector: nil.			each submenu				ifNotNil: [:submenu | each submenu: (self initializeMenu: submenu)]].	^simplifiedCopy</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule class</class-id> <category>private</category><body package="Browser-Smalllint" selector="modifiesTree:in:">modifiesTree: aCollectionTree in: aParseTree 	| notifier args |	notifier := ParseTreeSearcher new.	args := Array with: (RBPatternVariableNode named: '`@object').	notifier 		matchesAnyTreeOf: (#(#add: #addAll: #remove: #removeAll:) collect: 					[:each | 					RBMessageNode 						receiver: aCollectionTree copyOld						selector: each						arguments: args])		do: [:aNode :answer | true].	^notifier executeTree: aParseTree initialAnswer: false</body></methods><methods><class-id>Refactory.Browser.BrowserCommentTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_GenerateDefaultComment 					#defaultString: '&amp;Generate Default Comment' 					#catalogID: #browser ) 				#nameKey: #'Generate Default Class Comment' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#command: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#command: #printIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#command: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#command: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copyOld 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(1 1 4 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>private</category><body package="Browser-BrowserUI" selector="updateTextWidget">updateTextWidget	| widget prefs |	builder isNil ifTrue: [^self].	widget := builder componentAt: #textEditor.	widget isNil ifTrue: [^self].	modified 		= (widget lookPreferences foregroundColor = self modifiedTextColor) 			ifTrue: [^self].	prefs := modified 				ifTrue: [initialLookPrefs copyOld foregroundColor: self modifiedTextColor]				ifFalse: [initialLookPrefs].	widget lookPreferences: prefs</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>probes</category><body package="Debugger-Browser Extensions" selector="basicReinsertProbesAndIndices:into:">basicReinsertProbesAndIndices: probesAndIndices into: probedMethod	| probesInError |	probesInError := OrderedCollection new.	probesAndIndices do:		[:ac | | probe index newRecord |		probe := ac key baseParent copyOld.		index := ac value.		newRecord := probedMethod probeRecordFor: (index to: index).		probe record: newRecord.		(probe updateTempVarIndexForMethod: probedMethod)			ifTrue: [probedMethod addProbe: probe]			ifFalse:				[newRecord updateMethod: probedMethod.		"update mclass and selector for reporting"				probesInError add: probe]].	probesInError addAll: probedMethod recompileProbes.	ProbedCompiledMethod reportOnFailedProbes: probesInError.</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #F_ormat 					#defaultString: 'F&amp;ormat' 					#catalogID: #browser ) 				#nameKey: #'Format Code' 				#value: 				#action: 				#command: #format ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #GoToClass 					#defaultString: 'Go to Class' 					#catalogID: #browser ) 				#nameKey: #'Navigate to Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseClassInNewWindow 					#defaultString: 'Browse Class in New Window' 					#catalogID: #browser ) 				#nameKey: #'Open Browser on Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseReferencesToClass 					#defaultString: 'Browse References to Class' 					#catalogID: #browser ) 				#nameKey: #'Browse References to Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVariableRe_ferencesDots 					#defaultString: 'Browse Variable Re&amp;ferences...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable References' 				#value: 				#action: 				#enablementSelector: #hasInstanceVariableSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVariableRea_dersDots 					#defaultString: 'Browse Variable Rea&amp;ders...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable Readers' 				#value: 				#action: 				#enablementSelector: #hasInstanceVariableSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVariable_WritersDots 					#defaultString: 'Browse Variable &amp;Writers...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable Writers' 				#value: 				#action: 				#enablementSelector: #hasInstanceVariableSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_SendersOfSelector 					#defaultString: 'Browse &amp;Senders of Selector' 					#catalogID: #browser ) 				#nameKey: #'Selected Message References' 				#value: 				#action: 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_ImplementorsOfSelector 					#defaultString: 'Browse &amp;Implementors of Selector' 					#catalogID: #browser ) 				#nameKey: #'Selected Message Implementors' 				#value: 				#action: 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Refactor 					#defaultString: 'Refactor' 					#catalogID: #browser ) 				#nameKey: #refactorMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ExtractValueToTemporary 								#defaultString: '&amp;Extract Value to Temporary' 								#catalogID: #browser ) 							#nameKey: #'Extract to Temporary' 							#value: 							#action: 							#enablementSelector: #hasValueNodeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_nameVariableAsDots 								#defaultString: 'Re&amp;name Variable As...' 								#catalogID: #browser ) 							#nameKey: #'Rename Selected Temporary Variable' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MoveToInner_Scope 								#defaultString: 'Move to Inner &amp;Scope' 								#catalogID: #browser ) 							#nameKey: #'Move Selected Temporary to Innermost Scope' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Con_vertToInstanceVariable 								#defaultString: 'Con&amp;vert to Instance Variable' 								#catalogID: #browser ) 							#nameKey: #'Convert Temporary Variable to Instance Variable' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RemoveParameter 								#defaultString: '&amp;Remove Parameter' 								#catalogID: #browser ) 							#nameKey: #'Remove Selected Parameter' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #In_lineParameter 								#defaultString: 'In&amp;line Parameter' 								#catalogID: #browser ) 							#nameKey: #'Inline Selected Parameter' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #In_lineMethod 								#defaultString: 'In&amp;line Method' 								#catalogID: #browser ) 							#nameKey: #'Inline Method' 							#value: 							#action: 							#enablementSelector: #hasMessageNodeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ExtractToTemporary 								#defaultString: '&amp;Extract to Temporary' 								#catalogID: #browser ) 							#nameKey: #'Extract to Temporary' 							#value: 							#action: 							#enablementSelector: #hasMessageNodeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InlineAssignedTemporary 								#defaultString: '&amp;Inline Assigned Temporary' 								#catalogID: #browser ) 							#nameKey: #'Inline Temporary' 							#value: 							#action: 							#enablementSelector: #hasAssignmentSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PushVariable_Up 								#defaultString: 'Push Variable &amp;Up' 								#catalogID: #browser ) 							#nameKey: #'Push Up Selected Instance Variable' 							#value: 							#action: 							#enablementSelector: #hasInstanceVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CreateAccessors 								#defaultString: 'Create Accessors' 								#catalogID: #browser ) 							#nameKey: #'Create Selected Instance Variable Accessors' 							#value: 							#action: 							#enablementSelector: #hasInstanceVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MakeVariableA_bstract 								#defaultString: 'Make Variable A&amp;bstract' 								#catalogID: #browser ) 							#nameKey: #'Abstract Selected Instance Variable' 							#value: 							#action: 							#enablementSelector: #hasInstanceVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ProtectVariable 								#defaultString: '&amp;Protect Variable' 								#catalogID: #browser ) 							#nameKey: #'Protect Selected Instance Variable' 							#value: 							#action: 							#enablementSelector: #hasInstanceVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ExtractMethod 								#defaultString: '&amp;Extract Method' 								#catalogID: #browser ) 							#nameKey: #'Extract Method' 							#value: 							#action: 							#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #extractMethod ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExtractMethodToComponent 								#defaultString: 'Extract Method to Component' 								#catalogID: #browser ) 							#nameKey: #'Extract Method to Component' 							#value: 							#action: ) ) #(13 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#command: #doIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#command: #printIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#command: #inspectIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#command: #debugIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Explain 					#defaultString: 'Explain' 					#catalogID: #browser ) 				#nameKey: #'Explain Code' 				#value: 				#action: 				#command: #explain ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copyOld				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(2 9 4 1 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.AddProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	^(self protocolObject organization categories includes: self protocol) 		ifTrue: [self copyOld]		ifFalse: 			[self isData 				ifTrue: 					[RemoveProtocolChange nameSpace: self changeObject protocol: self protocol]				ifFalse: 					[RemoveProtocolChange class: self changeObject protocol: self protocol]]</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>copying</category><body package="Browser-BaseUI" selector="postCopy">postCopy	super postCopy.	properties := properties copyOld</body></methods><methods><class-id>Refactory.Browser.SmalllintCodeTool</class-id> <category>private</category><body package="Browser-SmalllintUI" selector="distinctRules">distinctRules	| components |	components := OrderedCollection withAll: self lintRuleList selections.	components isEmpty 		ifTrue: [components := OrderedCollection with: self allLintChecks].	components copyOld 		do: [:each | each allRules do: [:rule | components remove: rule ifAbsent: []]].	^components</body></methods><methods><class-id>Refactory.Browser.SmalllintCodeTool</class-id> <category>actions</category><body package="Browser-SmalllintUI" selector="run">run	| rule |	rule := self selectedRule.	rule rules isEmpty ifTrue: [^self].	self runRule: rule copyOld</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	definitions := definitions copyOld.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>private</category><body package="Browser-Refactorings" selector="itemsDo:">itemsDo: aBlock 	| seen |	seen := IdentitySet new.	self items copyOld do: 			[:each | 			aBlock value: each.			seen add: each name].	self isDefined ifFalse: [^self].	self realNameSpace bindingsDo: 			[:each | 			| variable item |			variable := each key.			((seen includes: variable) or: [(item := self itemFor: variable) isNil]) 				ifFalse: [aBlock value: item]]</body></methods><methods><class-id>Refactory.Browser.SelectionPackageStatus</class-id> <category>tooltips</category><body package="Browser-BrowserUI" selector="allConnectionsText">allConnectionsText	"Build a paragraph from the toolTexts of the selections repository connections. Build a style for the paragraph that makes the tabs look good."	| pundle ws paragraph style text columnWidths left |	codeModel state narrowestSelectionType == #codeComponent ifFalse: [^nil].	pundle := codeModel state codeComponent.	pundle databaseInformations isEmpty ifTrue: [^nil].	ws := TextStream on: String new.	((pundle databaseInformations reject: [:each | each dbIdentifier isEmpty])		sorted: [:a :b | a dbIdentifier &lt; b dbIdentifier])			do: [:each | ws nextPutAllText: each toolText]			separatedBy: [ws cr].	text := ws contents.	text isEmpty ifTrue: [^nil].	paragraph := ComposedText withText: text.	style := inputField widgetPolicy lookPolicyClass systemTextStyle copyOld.	columnWidths := text				computeMinimumTabWidthsUsing: inputField graphicsContext.	left := 0.	style		useTabs: #(1) , (columnWidths collect: [:each | left := left + each + 30]).	paragraph textStyle: style.	^paragraph</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager</class-id> <category>copying</category><body package="Store-Merge Management" selector="postCopy">postCopy	redo := redo copyOld.	undo := undo copyOld.</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self arguments: (self arguments collect: [:each | each copyOld])</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser" selector="acceptMessageNode:">acceptMessageNode: aMessageNode	| newFormatter code |	newFormatter := self copyOld.	code := newFormatter format: aMessageNode receiver.	codeStream nextPutAll: code.	codeStream space.	newFormatter isMultiLine		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])		while: [self formatMessage: aMessageNode cascade: false]</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>private-formatting</category><body package="Browser-Parser" selector="formatMessage:cascade:">formatMessage: aMessageNode cascade: cascadeBoolean	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length argLimit |	selectorParts := aMessageNode selectorParts.	arguments := aMessageNode arguments.	formattedArgs := OrderedCollection new.	argLimit := self maximumArgumentsPerLine.	(arguments allSatisfy: [:each | each children isEmpty])		ifTrue: [argLimit := argLimit + 1].	multiLine := aMessageNode selector numArgs &gt; argLimit.	length := aMessageNode selector size + arguments size + 1.	firstArgLength := 0.	self indentWhile: 			[1 to: arguments size				do: 					[:i |					| formatter string |					formatter := (self copyOld)								lineStart: (selectorParts at: i) length negated;								yourself.					string := formatter format: (arguments at: i).					formattedArgs add: string.					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].					length := length + string size.					multiLine := multiLine or: [formatter isMultiLine]]].	multiLine := multiLine				or: [length + self lineLength &gt; self lineLengthLimit].	indentFirst := cascadeBoolean not and: 					[multiLine and: 							[(self startMessageSendOnNewLine: aMessageNode) or: 									[self lineLength + selectorParts first length + 2 + firstArgLength										&gt; self lineLengthLimit]]].	indentFirst ifTrue: [self indent].	self		formatMessageSelector: selectorParts		withArguments: formattedArgs		multiline: multiLine</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>private-formatting</category><body package="Browser-Parser" selector="formatBlockNode:startBlockString:endBlockString:">formatBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString	| seqNode multiline formattedBody formatter |	seqNode := aBlockNode body.	formatter := (self copyOld)				lineStart: 0;				yourself.	formattedBody := formatter format: seqNode.	multiline := self lineLength + formattedBody size &gt; self lineLengthLimit				or: [formatter isMultiLine].	multiline ifTrue: [self indent].	codeStream nextPutAll: startBlockString.	self addModerateExtraSpace.	aBlockNode arguments do: 			[:each |			codeStream nextPut: $:.			self visitNode: each.			codeStream space].	aBlockNode arguments notEmpty		ifTrue: 			[codeStream nextPutAll: '| '.			multiline ifTrue: [self indent]].	codeStream nextPutAll: formattedBody.	self addModerateExtraSpace.	codeStream nextPutAll: endBlockString</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>private</category><body package="Browser-Refactorings" selector="prepareForRemoval">prepareForRemoval	super prepareForRemoval.	self superclass isNil ifTrue: [self rootNameSpace removeRootClass: self].	self subclasses copyOld do: 			[:each | 			each isMeta 				ifTrue: [each superclass: nil]				ifFalse: [each environment removeLocalObject: each]].	self superclass notNil ifTrue: [self superclass removeSubclass: self].	self metaclass superclass notNil 		ifTrue: [self metaclass superclass removeSubclass: self metaclass]</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="instanceVariableNames">instanceVariableNames	^self privateInstanceVariableNames copyOld</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>testing</category><body package="Browser-Refactorings" selector="referencedItem:in:">referencedItem: aString in: aNamespace	"Search for the named item, giving access to both our local names (e.g. shared variables) but searching aNamespace rather than our namespace and imports. The simplest thing that could possibly work seems to be to copy ourselves, tweak the namespace, and hope."	| copy |	aNamespace isNil ifTrue: [^self referencedItem: aString].	copy := self copyOld.	copy parent: aNamespace.	^copy referencedItem: aString</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self messages: (self messages collect: [:each | each copyOld])</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	instanceBehaviorNames := instanceBehaviorNames copyOld.	classBehaviorNames := classBehaviorNames copyOld.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="safeVariableNameBasedOn:">safeVariableNameBasedOn: aString 	"Creates an unused variable name containing aString"	| baseString newString i allTempVars |	allTempVars := inlineParseTree allTemporaryVariables.	baseString := aString copyOld.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	i := 0.		[(allTempVars includes: newString) 		or: [class definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="addSelfReferenceToSourceMessage">addSelfReferenceToSourceMessage	| newArguments |	newArguments := OrderedCollection withAll: sourceMessage arguments.	newArguments addFirst: sourceMessage receiver copyOld.	sourceMessage 		renameSelector: (self addArgumentToSelector: sourceMessage selector)		andArguments: newArguments</body></methods><methods><class-id>Refactory.Browser.SelectorProtocolNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI" selector="iconFor:">iconFor: aMethodCategory	"Return a graphic that shows the count of methods in this category. It's back coloring is based on whether all, none, or some of the methods are currently visible in the browser. As is the number count text color."	"The back 'shape' is actually a series of rectangles, we get a cleaner looking ovoid this way since it stays balanced, whereas arc/wedge drawings aliases really bad."	"The bit with style gridding, pure dart throwing until I found an algorithm that positioned it correctly on all 3 display systems."		| totalCount hereCount countStyle listView label countTextColor |	navigator selectedClass ifNil: [^nil].	totalCount := self totalMethodCountIn: aMethodCategory.	hereCount := self visibleMethodCountIn: aMethodCategory.	listView := self widgetAt: #objectList.	countStyle := listView textStyle copyOld.	countStyle gridForFont: #small withTopLead: 0 bottomLead: 0.	countTextColor := (hereCount		between: 1		and: totalCount - 1)		ifTrue: [ColorValue black]		ifFalse: [ColorValue white].	label := Label		with:			(totalCount printString asText				emphasizeAllWith:					(Array						with: #small						with: #color -&gt; countTextColor))		attributes: countStyle.	^VisualStack		with:			((totalCount isZero not and: [hereCount = totalCount])				ifTrue: [GeneralIcons darkMethodCountBackground]				ifFalse: [GeneralIcons lightMethodCountBackground])		with: label</body></methods><methods><class-id>Refactory.Browser.SmalllintResultEditor</class-id> <category>private</category><body package="Browser-SmalllintUI" selector="removeCurrentResultFrom:">removeCurrentResultFrom: displayedResults 	| currentResult last newList |	currentResult := self selectedResult.	displayedResults remove: currentResult ifAbsent: [].	newList := displayedResults copyOld.	last := nil.	displayedResults reverseDo: 			[:each | 			(each isComposite and: [(each rules includes: last) not])				ifTrue: [newList remove: each ifAbsent: []]				ifFalse: [last := each]].	^newList</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	| compositeChange category |	compositeChange := CompositeRefactoryChange named: self name.	category := self protocolObject organization 				categoryOfElement: self symbol.	compositeChange addChange: ((self copyOld)				protocol: category;				yourself).	self includesProtocol 		ifFalse: 			[compositeChange addChange: (self isData 						ifTrue: 							[RemoveProtocolChange nameSpace: self changeObject protocol: self protocol]						ifFalse: 							[RemoveProtocolChange class: self changeObject protocol: self protocol])].	compositeChange toggleUndoState.	^compositeChange</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self receiver: self receiver copyOld.	self arguments: (self arguments collect: [:each | each copyOld])</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI" selector="windowSpec">windowSpec	"Some very hackish code that adds the horizontal scrollbar to the list. 	If you know of a better way to do this, please feel free to clean it up :)."	| spec allSpecs index listSpec flagsIndex |	ShowHorizontalScrollbar ifFalse: [^self basicWindowSpec].	spec := self basicWindowSpec copyOld.	spec at: spec size put: spec last copyOld.	allSpecs := spec last last copyOld.	index := (1 to: allSpecs size) 				detect: [:each | (allSpecs at: each) includes: #objectList]				ifNone: [nil].	index isNil ifTrue: [^spec].	listSpec := allSpecs at: index.	flagsIndex := listSpec indexOf: #flags:.	flagsIndex odd 		ifTrue: 			[listSpec at: flagsIndex + 1 put: ((listSpec at: flagsIndex + 1) bitOr: 2)]		ifFalse: [allSpecs at: index put: (allSpecs at: index) , #(#flags: 15)].	spec last at: spec last size put: allSpecs.	^spec</body></methods><methods><class-id>Refactory.Browser.CodeComponentBlockTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#command: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#command:  #printIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#command: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#command: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copyOld 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(1 4 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.InlineParameterRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="modifyImplementorParseTree:in:">modifyImplementorParseTree: parseTree in: aClass 	| node assignment |	node := (parseTree arguments at: parameterIndex) copyOld.	parseTree body addTemporaryNamed: node name.	assignment := RBAssignmentNode variable: node copyOld value: expressions first.	parseTree body addNodeFirst: assignment.	super modifyImplementorParseTree: parseTree in: aClass</body></methods><methods><class-id>Refactory.Browser.BasicLintRule</class-id> <category>accessing</category><body package="Browser-Smalllint" selector="filteredResult">filteredResult	^(SmalllintFilterEnvironment onEnvironment: result		and: (self class filterDictionary at: self name ifAbsent: [result copyEmpty]) 				copyOld not)		label: result label;		lintRuleName: self name;		yourself</body></methods><methods><class-id>Refactory.Browser.BasicLintRule class</class-id> <category>accessing</category><body package="Browser-Smalllint" selector="addFilter:for:">addFilter: anEnvironment for: aString 	self filterDictionary at: aString put: anEnvironment copyOld</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	super postCopy.	bundleNames := bundleNames copyOld.	packageNames := packageNames copyOld</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects" selector="renameChangesForObject:to:">renameChangesForObject: aClassName to: newClassName 	| newChange tree newReceiver |	newChange := super renameChangesForObject: aClassName to: newClassName.	tree := RBParser parseExpression: newChange definition				onError: [:s :e | ^newChange].	tree isMessage ifFalse: [^newChange].	tree receiver isVariable ifFalse: [^newChange].	newReceiver := self 				changeVariable: tree receiver name				thatBeginsWith: aClassName				toBeginWith: newClassName.	newReceiver = tree receiver name ifTrue: [^newChange].	tree receiver: (RBVariableNode named: newReceiver).	^(newChange copyOld)		definition: tree formattedCode;		fillOutDefinition;		yourself</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self variable: self variable copyOld.	self value: self value copyOld</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	protocols := protocols copyOld.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="replaceBindingReference:">replaceBindingReference: aReference 	| path newPath |	path := aReference path.	newPath := self 				replaceReferenceTo: object				inPath: path				toBe: newName.	^(aReference copyOld)		path: newPath;		yourself</body></methods><methods><class-id>Refactory.Browser.RemoveObjectRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="reparentSubclasses">reparentSubclasses	objectNames do: 			[:each | 			| class |			class := self model classNamed: each.			class notNil 				ifTrue: 					[self model reparentClasses: class subclasses copyOld to: class superclass]]</body></methods><methods><class-id>Graphics.VariableCharacterAttributes</class-id> <category>private</category><body package="Internationalization" selector="updatedQueryFor:">updatedQueryFor: aFontPolicy	| locale pixels family encoding |	(aFontPolicy isNil or: [(policyCache first) == aFontPolicy])		ifFalse:			[self invalidateQueryCache.			policyCache at: 1 put: aFontPolicy].	updatedQuery notNil 		ifTrue: [^updatedQuery].	locale := Locale current.	updatedQuery := (self defaultQueryFor: aFontPolicy) copyOld.	pixels := locale preferredPixelSizeFor: aFontPolicy.	"Algorithm for following 4 lines from FontPolicy&gt;&gt;stringMatchFrom:to:test:value:weight:"	family := updatedQuery family.	family isNil		ifTrue: [ family := #()]		ifFalse: [ family isString ifTrue: [ family := Array with: family]].	family := Locale current preferredFontFamily, family.	doScaling		ifTrue: [updatedQuery  pixelSize: (pixels * self scalingFactor) rounded].	encoding := locale defaultStreamEncoder encodingType.	encoding isNil ifFalse: [encoding := encoding asString].	updatedQuery 		family: family;		encoding: encoding;		encodings: locale preferredEncodings.	^updatedQuery</body></methods><methods><class-id>Graphics.ScreenFont class</class-id> <category>private</category><body package="Graphics-Fonts" selector="filterEncoding:on:">filterEncoding: encName on: platform	| encoder i |	encoder := CharacterEncoder encoderNamed: encName platform: platform.	encoder := encoder copyOld.	(0 to: 31), (127 to: 160) do: [:c |		(i := encoder encode: (Character value: c)) == 65535			ifFalse: [encoder encode: Character illegalCode asCharacter as: i]].	^encoder</body></methods><methods><class-id>Graphics.ScreenFont class</class-id> <category>class initialization</category><body package="Graphics-Fonts" selector="iso8859Encoder">iso8859Encoder	| encoder |	encoder := ISO8859L1String encoder copyOld.	"Ignore unprintable characters"	0 to: 31 do: [:i | encoder encode: Character illegalCode asCharacter as: i].	127 to: 160 do: [:i | encoder encode: Character illegalCode asCharacter as: i].	^encoder</body></methods><methods><class-id>Graphics.VariableSizeTextAttributes</class-id> <category>system startup</category><body package="Graphics-Fonts" selector="updateLineGridding:">updateLineGridding: aFontPolicy	| font |	lastFontPolicy == aFontPolicy ifTrue: [^self].	lastFontPolicy := aFontPolicy.	characterAttributes scalingFactor == nil		ifTrue:			[| fontD |			fontD := (self defaultFontFor: lastFontPolicy) copyOld.			fontD pixelSize: (lastFontPolicy preferredFontSize * self scalingFactor) rounded.			characterAttributes setDefaultQuery: fontD for: lastFontPolicy]		ifFalse:			["The CharacterAttributes must have enough smarts to do this by itself."			characterAttributes invalidateQueryCache].	font := lastFontPolicy findFont: (self fontAt: fontAttributeForLeading for: lastFontPolicy).	baseline := font ascent + topLeading.	lineGrid := font height + bottomLeading + topLeading</body></methods><methods><class-id>Graphics.XFont class</class-id> <category>utilities</category><body package="Graphics-Fonts" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen 	| encoding fontName encodingName fd |	fd := concreteFontDescription copyOld.	encodingName := concreteFontDescription specifiesEncoding		ifTrue: [concreteFontDescription encoding]		ifFalse: [concreteFontDescription name].	encoding := self encoderNamed: encodingName.	(concreteFontDescription specifiesPixelSize and: [concreteFontDescription pixelSize = 0]) 		ifTrue: 			[fontName := self generateFontNameFor: concreteFontDescription name using: requestedFontDescription pixelSize.			fd pixelSize: requestedFontDescription pixelSize]		ifFalse: [fontName := concreteFontDescription name].	fd name: fontName.	^(aScreen		fontNamed: fontName		fromClass: self		encoding: encoding)		setDescription: fd</body></methods><methods><class-id>Graphics.Printer class</class-id> <category>examples</category><body package="Examples" selector="exampleFonts">exampleFonts	"Printer exampleFonts."	| text document font |	document := Document new.	document		doFooter: true		footerString: 'Printer exampleFonts'		doPageNumbers: true.	text := (#reallyLongText &lt;&lt; #examples &gt;&gt; 'The lazy brown dog jumped over the quick fox''s back, but since the fox was quick, he managed to catch up to the dog later and eat it.  The moral of this story is always to eat your Wheaties.') asText.	font := FontDescription new pixelSize: 10; boldness: 0.5.	#('times' 'helvetica' 'courier')		do: 			[:family |			| style |			font family: family; italic: false.			style := TextAttributes defaultFontQuery: font copyOld.			style baseline: 10.			style lineGrid: 10 * 12 // 10.			document startParagraph.			document addText: family under: (TextAttributes styleNamed: #default).			document startParagraph.			document addText: text under: style copyOld.			font italic: true.			style := TextAttributes defaultFontQuery: font copyOld.			style baseline: 10.			style lineGrid: 10 * 12 // 10.			document startParagraph.			document addText: family, '-italic' under: (TextAttributes styleNamed: #default).			document startParagraph.			document addText: text under: style copyOld].	document toPrinter</body></methods><methods><class-id>Graphics.Printer class</class-id> <category>examples</category><body package="Examples" selector="exampleFontSizes">exampleFontSizes	"Printer exampleFontSizes."	| text document font |	document := Document new.	document		doFooter: true		footerString: 'Printer exampleFontSizes'		doPageNumbers: true.	text := (#reallyLongText &lt;&lt; #examples &gt;&gt; 'The lazy brown dog jumped over the quick fox''s back, but since the fox was quick, he managed to catch up to the dog later and eat it.  The moral of this story is always to eat your Wheaties.') asText.	font := FontDescription new family: 'times'; boldness: 0.5; italic: false.	#(6 10 14 18 )		do: 			[:size |			| style |			font pixelSize: size.			style := TextAttributes defaultFontQuery: font copyOld.			style baseline: size.			style lineGrid: size * 12 // 10.			document startParagraph.			document addText: font pixelSize printString under: (TextAttributes styleNamed: #default).			document startParagraph.			document addText: text under: style copyOld].	document toPrinter</body></methods><methods><class-id>Graphics.CachedImage</class-id> <category>converting</category><body package="Graphics-Images" selector="renderDithered:">renderDithered: im	| medium gc |	medium := im paintBasis retainedMediumWithExtent: im extent.	gc := medium graphicsContext.	gc paintPolicy: gc paintPolicy copyOld.	gc paintPolicy imageRenderer: OrderedDither new.	gc copyImage: im to: Point zero.	^medium</body></methods><methods><class-id>Graphics.MacOSXFont class</class-id> <category>utilities</category><body package="Graphics-Fonts" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen 	"Answer an instance of the receiver that best represents the argument, 	 concreteFontDescription, given the font it is most closely to resemble, 	 requestedFontDescription.  The argument, aScreen, is the current Screen 	 object the font should be associated with.  PostScriptFonts are independent 	 of the Screen argument."	| size fontName encoding fontDescription boldValue isItalic screenFont |	encoding := self encoderNamed: self defaultEncodingName.	fontDescription := concreteFontDescription copyOld.	size := concreteFontDescription specifiesPixelSize 				ifTrue: [concreteFontDescription pixelSize]				ifFalse: [requestedFontDescription pixelSize].	fontName := concreteFontDescription family.	"'HelveticaNeue' matches 'helv*', which doesn't work here."	(fontName = 'Helvetica Neue' or: [fontName = 'HelveticaNeue']) 		ifTrue: [fontName := 'Helvetica'].	boldValue := requestedFontDescription specifiesBoldness 				ifTrue: [requestedFontDescription boldness]				ifFalse: 					[requestedFontDescription name isString 						ifTrue: 							[(self boldnessDescription: requestedFontDescription name) 								ifNil: [concreteFontDescription boldness]]						ifFalse: [concreteFontDescription boldness]].	isItalic := requestedFontDescription specifiesItalic 				ifTrue: [requestedFontDescription italic]				ifFalse: 					[requestedFontDescription name isString 						ifTrue: 							[(self italicDescription: requestedFontDescription name) 								ifNil: [concreteFontDescription italic]]						ifFalse: [concreteFontDescription italic]].	fontName := fontName , ' ' , size printString , ' ' 				, boldValue printString , ' ' 				, (isItalic ifTrue: ['1'] ifFalse: ['0']) , ' ' 				, requestedFontDescription setWidth printString.	screenFont := aScreen 		fontNamed: fontName		fromClass: self		encoding: encoding.	screenFont setDescription: fontDescription.	concreteFontDescription family = 'Lucida_Grande' ifTrue: [screenFont tuneWidthsOn: aScreen].	^screenFont.</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="copyOld">copyOld	"Prevent the baseTable and composeTable from being corrupted if	more than one DispatchTable are sharing them"	shared := true.	^super copyOld</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>private</category><body package="Graphics-Text Support" selector="forkCopy">forkCopy	"The receiver needs to be modified.  Copy the shared state"	shared		ifTrue:			[composeTable := composeTable copyOld.			baseTable := baseTable copyOld.			commandMapping := commandMapping copyOld.			shared := false].</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>accessing</category><body package="Graphics-Text Support" selector="bindValue:to:">bindValue: aValue to: aCharacter	"Arrange for aValue to be answered whenever aCharacter is passed in"	| array |	self forkCopy.	(composeTable includesKey: aCharacter)		ifTrue:	[self notify: (#errBindMetaCharacter &lt;&lt; #dialogs &gt;&gt; 'This character is a meta-character.  Proceed to rebind it').				composeTable removeKey: aCharacter].	array := baseTable at: aCharacter ifAbsent: nil.	array class == Array		ifTrue:	[array := array copyOld.				array replaceAll: (array at: 1) with: aValue]		ifFalse:	[array := aValue].	baseTable at: aCharacter put: array</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="copy">copy	"Prevent the baseTable and composeTable from being corrupted if	more than one DispatchTable are sharing them"	shared := true.	^super copyOld</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>accessing</category><body package="Graphics-Text Support" selector="bindValue:to:modifiers:">bindValue: aValue to: aCharacter modifiers: metaCollection	"Arrange for aValue to be answered whenever aCharacter is passed in	with the same set of meta state bits defined in metaCollection."	| array index |	self forkCopy.	(composeTable includesKey: aCharacter)		ifTrue:	[self notify: (#errBindMetaCharacter &lt;&lt; #dialogs &gt;&gt; 'This character is a meta-character.  Proceed to rebind it').				composeTable removeKey: aCharacter].	array := baseTable at: aCharacter ifAbsent: [nil].	array class == Array		ifTrue: [ array := array copyOld ]		ifFalse: [array := Array new: 32 withAll: array].	index := 0.	(metaCollection includes: #shift) ifTrue: [index := index bitOr: InputState shiftMask].	(metaCollection includes: #control) ifTrue: [index := index bitOr: InputState ctrlMask].	(metaCollection includes: #meta) ifTrue: [index := index bitOr: InputState metaMask].	(metaCollection includes: #alt) ifTrue: [index := index bitOr: InputState altMask].	(metaCollection includes: #command) ifTrue: [index := index bitOr: InputState commandMask].	array at: index+1 put: aValue.	baseTable at: aCharacter put: array</body></methods><methods><class-id>Graphics.MappedPalette</class-id> <category>accessing</category><body package="Graphics-Palettes" selector="mapResolution">mapResolution	"Answer the resolutions of my inverse map, in bits.  A resolution	is the number of bits used to represent a stimulus component	of a color, e.g. a red resolution of 4 means that 4 bits will be used	to store the red component.  The resolutions are returned as	a four-element array of the red, green, blue, and gray resolutions	in order."	^mapResolution copyOld</body></methods><methods><class-id>Graphics.MappedPalette class</class-id> <category>defaults</category><body package="Graphics-Palettes" selector="defaultMapResolution">defaultMapResolution	"Answer the default inverse map resolutions, in bits.  A resolution	is the number of bits used to represent a stimulus component	of a color, e.g. a red resolution of 4 means that 4 bits will be used	to store the red component.  The resolutions are returned as	a four-element array of the red, green, blue, and gray resolutions	in order."	^DefaultMapResolution copyOld</body></methods><methods><class-id>Graphics.FontPolicy</class-id> <category>private</category><body package="Graphics-Fonts" selector="bestFont:allowance:">bestFont: requestedFont allowance: allowance 	"Find a font that approximately or exactly matches the requested font"	| req limit best |	limit := allowance.	req := requestedFont copyOld.	req optimizeMatching.	best := nil.	1 to: availableFonts size		do: 			[:i | 			| concreteFont distance |			concreteFont := availableFonts at: i.			distance := self 						measureDistancesFrom: req						to: concreteFont						stopAt: limit.			distance &lt; limit 				ifTrue: 					[limit := distance.					best := concreteFont]].	best == nil ifFalse: [^best].	^noFontBlock 		ifNil: [self class noMatchingFontSignal raiseRequestWith: requestedFont]		ifNotNil: [noFontBlock value: requestedFont]</body></methods><methods><class-id>Graphics.FontPolicy</class-id> <category>utilities</category><body package="ExtraEmphases" selector="findFont:">findFont: aFontDescription 	"Answer the nearest font from those available on this device	to the requested FontDescription"	| font bestMatch |	fdCache = aFontDescription ifTrue: [^dfCache].	font := fontCache at: aFontDescription ifAbsent: [nil].	font == nil 		ifFalse: 			[fdCache := aFontDescription copyOld.			dfCache := font.			^font].	bestMatch := self findBestFont: aFontDescription.	aFontDescription isComposite 		ifTrue: 			[font := CompositeFont 						createFont: bestMatch						toResemble: aFontDescription						for: self]		ifFalse: 			[font := fontClass 						createFont: bestMatch						toResemble: aFontDescription						on: device].	font := self decorateFont: font with: aFontDescription.	fontCache at: aFontDescription copyOld put: font.	fdCache := aFontDescription.	dfCache := font.	^font</body></methods><methods><class-id>Graphics.FontPolicy</class-id> <category>private</category><body package="Graphics-Fonts" selector="matchFont:allowance:">matchFont: requestedFont allowance: allowance	"Find all fonts that approximately or exactly match the requested font"	| list req |	list := OrderedCollection new: 40.	req := requestedFont copyOld.	req optimizeMatching.	1 to: availableFonts size do:		[:i |		| concreteFont distance |		concreteFont := availableFonts at: i.		distance := self measureDistancesFrom: req to: concreteFont stopAt: allowance.		distance &lt;= allowance			ifTrue:	[list add: distance -&gt; concreteFont]].	list isEmpty		ifFalse:	[^list asSortedCollection: [:x :y | x key &lt; y key]].	^noFontBlock 		ifNil: [self class noMatchingFontSignal raiseRequestWith: requestedFont]		ifNotNil: [OrderedCollection with: allowance-&gt;(noFontBlock value: requestedFont)]</body></methods><methods><class-id>Graphics.Document</class-id> <category>initialize-release</category><body package="System-Printing" selector="initialize">initialize	"Set up defaults,  and create an ordered collection to hold the 	intermediate representation of the document."	entities 			:= OrderedCollection new: 255.	currentMargins := DefaultMargins copyOld.	self setTabs: DefaultTabStops copyOld.	self setMargins: currentMargins copyOld</body></methods><methods><class-id>Graphics.Document</class-id> <category>adding entities</category><body package="System-Printing" selector="startParagraph">startParagraph	"Set up to start a new paragraph of text.  In particular, reset margins."	self setMargins: self margins copyOld.	entities add: (Message selector: #startParagraph)</body></methods><methods><class-id>Graphics.ExtendedFontDescription</class-id> <category>copying</category><body package="ExtraEmphases" selector="postCopy">postCopy	super postCopy.	extensions := extensions copyOld.</body></methods><methods><class-id>Graphics.OrderedDither</class-id> <category>private</category><body package="Graphics-Color Rendering" selector="postCopy">postCopy	super postCopy.	array := array collect: [:row | row copyOld]</body></methods><methods><class-id>Graphics.OrderedDither</class-id> <category>private-tessellation</category><body package="Graphics-Color Rendering" selector="finishTessellation">finishTessellation	"Take final steps in calculating the threshold array, following tessellation stages."	"Rotate odd order arrays by 45 degrees."	| tempArray center offset |	tempArray := self copyOld.	center := self centerPoint.	offset := -1@1.	1 to: height do:		[:row |		| threshold baseOrigin |		threshold := array at: row.		baseOrigin := center + ((1@1) * (row - 1)).		1 to: width do:			[:col |			threshold at: col put: (tempArray atPoint: baseOrigin + (offset * (col - 1)))]]</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>displaying</category><body package="Graphics-Visual Objects" selector="displayOn:">displayOn: aGraphicsContext	"Display each of the receiver's components."	| clipBox |	clipBox := aGraphicsContext clippingBounds.	1 to: components size do:		[:i |		| component |		component := components at: i.		(component intersects: clipBox)			ifTrue: [component displayOn: aGraphicsContext copyOld]]</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>bounds accessing</category><body package="Graphics-Visual Objects" selector="computePreferredBounds">computePreferredBounds	"Compute the receiver's preferredBounds"	| size |	size := components size.	size = 0 ifTrue:		[^preferredBounds := 0 @ 0 corner: 0 @ 0].	preferredBounds := (components at: 1) bounds copyOld.	2 to: size do: [:i |		preferredBounds := preferredBounds merge: (components at: i) bounds].	^preferredBounds</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>rebuilding</category><body package="Graphics-Visual Objects" selector="client:components:">client: aSubCanvas components: compList	| theComponents |	theComponents := self components copyOld.	theComponents do: [:each | self removeComponent: each].	compList do: [:each | self addComponent: each].	self invalidate.	^theComponents</body></methods><methods><class-id>Graphics.LayoutOrigin</class-id> <category>converting</category><body package="Interface-Support" selector="reducedForm">reducedForm	"Answer the most reduced form for representing the receiver.  This	includes reducing floats to integers where possible."	| result |	(leftFraction = 0 and: [topFraction = 0]) ifTrue: [^Point x: left y: top].	result := self copyOld.	leftFraction = 0	ifTrue: [result leftFraction: 0].	topFraction = 0	ifTrue: [result topFraction: 0].	leftFraction = 1	ifTrue: [result leftFraction: 1].	topFraction = 1	ifTrue: [result topFraction: 1].	^result</body></methods><methods><class-id>Graphics.CharacterBlockScanner</class-id> <category>stop conditions</category><body package="Graphics-Text Scanning" selector="paddedSpace">paddedSpace	"When the line is justified, the spaces will not be the same as the 	font's space character.  A padding of extra space must be 	considered in trying to find which character the cursor is pointing at. 	Answer whether the scanning has crossed the cursor."	| pad |	spaceCount := spaceCount + 1.	pad := self justifiedPadFor: spaceCount.	lastSpaceOrTabExtent := lastCharacterExtent copyOld.	lastSpaceOrTabExtent x: spaceWidth + pad.	destX + lastSpaceOrTabExtent x &gt; characterPoint x ifTrue: [		lastCharacterExtent := lastSpaceOrTabExtent copyOld.		^self crossedX].	lastIndex := lastIndex + 1.	destX := destX + lastSpaceOrTabExtent x.	^false</body></methods><methods><class-id>Graphics.CharacterBlockScanner</class-id> <category>stop conditions</category><body package="Graphics-Text Scanning" selector="tab">tab	"Handle leading and internal tabs in a justified line.  Leading tabs are 	considered legal and should be reflected on the display gracefully.  	Internal tabs (when the line is justified) are considered at the very 		best a misguided use of the character, and are reflected on the display 	the best we can."		| currentX |	currentX := destX.	(textStyle alignment = Justified and: [spaceCount &gt; 0])		ifTrue:			[currentX := currentX				+ (textStyle tabWidth - (self justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[currentX := textStyle nextTabXFrom: currentX leftMargin: leftMargin				rightMargin: rightMargin spaceWidth: spaceWidth].	lastSpaceOrTabExtent := (currentX - destX max: 0) @ lastCharacterExtent y.	currentX &gt; characterPoint x		ifTrue:			[lastCharacterExtent := lastSpaceOrTabExtent copyOld.			^self crossedX].	destX := currentX.	lastIndex := lastIndex + 1.	^false</body></methods><methods><class-id>Graphics.CharacterBlockScanner</class-id> <category>stop conditions</category><body package="Graphics-Text Scanning" selector="space">space	"When the line is justified, the spaces will not be the same as the 	font's space character.  A padding of extra space must be 	considered in trying to find which character the cursor is pointing at. 	Answer whether the scanning has crossed the cursor."	spaceCount := spaceCount + 1.	lastSpaceOrTabExtent := lastCharacterExtent copyOld.	lastSpaceOrTabExtent x: spaceWidth.	destX + lastSpaceOrTabExtent x &gt; characterPoint x ifTrue: [		 lastCharacterExtent := lastSpaceOrTabExtent copyOld.		^self crossedX].	lastIndex := lastIndex + 1.	destX := destX + spaceWidth.	^false</body></methods><methods><class-id>Graphics.PostScriptPrinterFont class</class-id> <category>utilities</category><body package="Graphics-Printing-PostScript" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen	| fontName fd |	fd := concreteFontDescription copyOld.	fontName := concreteFontDescription name, '~', requestedFontDescription pixelSize printString.	fd pixelSize: requestedFontDescription pixelSize.	fd name: fontName.	^(aScreen			fontNamed: fontName			fromClass: self)		setDescription: fd</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>displaying</category><body package="Graphics-Text Support" selector="displayFromCharacter:to:startX:forTranslation:on:">displayFromCharacter: startIndex to: stopIndex startX: startX forTranslation: aPoint on: aGraphicsContext	"Display the characters between startIndex and stopIndex on 	aGraphicsContext. The x position of the first character is at startX. 	This is useful for displaying text selections.	It is important to start displaying at the character before startIndex 	if startIndex is not the start of a line and after stopIndex if the stop 	is not the end of a line because some hosts do kerning for us. This 	would result in some missing parts of characters that intruded into 	the bounding box of the characters. This is most noticable with italic 	text."	| stop lineIndex startForLine stopForLine  leftX rightX top scanner textSize lineRecord lineGrid left gc|	self fontPolicy: aGraphicsContext fontPolicy.	textSize := self text size.	startIndex &gt; textSize ifTrue: 		[^self].	stop := stopIndex.	stop &gt; textSize ifTrue: [stop := textSize].	scanner := self getDisplayScanner.	scanner textStyle: self textStyle.	lineIndex := self lineIndexOfCharacterIndex: startIndex.	lineRecord := self lineAt: lineIndex.	stopForLine := lineRecord last.	stopIndex &lt; stopForLine ifTrue: [stopForLine := stopIndex].	startForLine := startIndex.	rightX:= self rightMarginForDisplay + aPoint x.	top  := (self topAtLineIndex: lineIndex) + aPoint y.	lineGrid := self lineGridFor: aGraphicsContext fontPolicy.	left := (self leftMarginForDisplayForLine: lineIndex) + aPoint x.	gc := aGraphicsContext.	lineRecord first = startForLine		ifTrue: [leftX := left]		ifFalse: ["move the start index back by one if the previous character is				not white space.  Change the clipping box of the first line so it appears that				we started displaying at startX"				| line index char |				line := self textAt: lineIndex.				index := startForLine - 1.				(char := line at: index) isSeparator					ifTrue: [leftX := startX]					ifFalse: [| font r |							font := aGraphicsContext findFont:									(self textStyle fontAt: (line emphasisAt: index)												for: self fontPolicy).							gc := aGraphicsContext copyOld.							r := gc clippingBounds.							gc clippingRectangle: (r left: (startX max: r left)). 							leftX := startX -(font widthOf: char).							startForLine := index]].	[scanner 		displayLine: lineRecord		inText: (self textAt: lineIndex)		left: left		right: rightX		startX: leftX		top: top		startIndex: startForLine		stopIndex: stopForLine		on: gc.	stop &lt;= stopForLine 			ifTrue: [ | cRect cb|					stopForLine = lineRecord last ifTrue: [^self].					cb := gc clippingBounds.					leftX := scanner destX.					cRect := cb origin corner: (leftX min: cb right)@cb bottom.					gc clippingRectangle: cRect.					scanner 						displayLine: lineRecord						inText: (self textAt: lineIndex)						left: left						right: rightX						startX: leftX						top: top						startIndex: stopForLine+1						stopIndex: stopForLine+1						on: gc.						gc clippingRectangle: cb.						^self].	"Set the GraphicsContext back to the original since the clipping may have been changed	for the first line."	gc := aGraphicsContext.	lineIndex := lineIndex + 1.	lineRecord := self lineAt: lineIndex.	startForLine := lineRecord first.	stopForLine := lineRecord last.	stop &lt; stopForLine ifTrue: [stopForLine := stop].	leftX := (self leftMarginForDisplayForLine: lineIndex) + aPoint x.		left := leftX.	top := top + lineGrid] repeat</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="restIndent:">restIndent: anInteger 	"Set the indentation for all but the first line of the receiver to be	anInteger in the style of the receiver."	self setTextStyle: self textStyle copyOld.	self textStyle restIndent: ((anInteger max: 0)				min: compositionWidth - DefaultSpace - self rightIndent).	self composeAll</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>private</category><body package="Graphics-Text Support" selector="setAlignment:">setAlignment: anAlignment	"Set the receiver's alignment to be anAlignment."	| old |	self setTextStyle: self textStyle copyOld.	old := self textStyle alignment.	old = anAlignment ifTrue: [^self].	self textStyle alignment: anAlignment.	old = LeftFlush		ifTrue: [self composeAll]</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="firstIndent:">firstIndent: anInteger 	"Set the horizontal indentation of the first line to be	anInteger in the style of the receiver."	self setTextStyle: self textStyle copyOld.	self textStyle firstIndent: ((anInteger max: 0)				min: compositionWidth - DefaultSpace - self rightIndent).	self composeAll</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="clearIndents">clearIndents	"Reset all the indentation settings to be 0."	self setTextStyle: self textStyle copyOld.	self textStyle firstIndent: 0.	self textStyle restIndent: 0.	self textStyle rightIndent: 0.	self composeAll</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="gridWithLead:">gridWithLead: leadInteger 	"Set the line grid of the receiver's style for displaying text to the height	of the first font in the receiver's style + the argument, leadInteger."	self setTextStyle: self textStyle copyOld.	self textStyle 		gridForFont: (text emphasisAt: 1)		withLead: leadInteger.		"assumes only one font referred to by runs"	self updateCompositionHeight.</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="rightIndent:">rightIndent: anInteger 	"Set the right margin indentation for the lines of the receiver to be	anInteger in the style of the receiver."	| maxRightIndent |	self setTextStyle: self textStyle copyOld.	self firstIndent &gt; self restIndent		ifTrue: [maxRightIndent := compositionWidth - DefaultSpace - self firstIndent max: 1]		ifFalse: [maxRightIndent := compositionWidth - DefaultSpace - self restIndent max: 1].	self textStyle rightIndent: (anInteger min: maxRightIndent).	self composeAll</body></methods><methods><class-id>Graphics.ByteCharacterEncoder</class-id> <category>copying</category><body package="Graphics-Fonts" selector="postCopy">postCopy	super postCopy.	decoder := decoder copyOld.	encoder := encoder copyOld.</body></methods><methods><class-id>Graphics.LayoutFrame</class-id> <category>converting</category><body package="Interface-Support" selector="reducedForm">reducedForm	"Generate the most reduced form for representing the receiver.  This	includes reducing floats to integers where possible."	| result |	(leftFraction = 0 and:		[topFraction = 0 and:			[rightFraction = 0 and:				[bottomFraction = 0]]])		ifTrue:			[^Rectangle				left: left				right: right				top: top				bottom: bottom].	result := self copyOld.	leftFraction = 0		ifTrue: [result leftFraction: 0].	topFraction = 0		ifTrue: [result topFraction: 0].	rightFraction = 0		ifTrue: [result rightFraction: 0].	bottomFraction = 0		ifTrue: [result bottomFraction: 0].	leftFraction = 1		ifTrue: [result leftFraction: 1].	topFraction = 1		ifTrue: [result topFraction: 1].	rightFraction = 1		ifTrue: [result rightFraction: 1].	bottomFraction = 1		ifTrue: [result bottomFraction: 1].	^result</body></methods><methods><class-id>Graphics.LineInformationTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="postCopy">postCopy	"The receiver is a copy.  Copy the lines."	super postCopy.	lines := lines copyOld</body></methods><methods><class-id>Graphics.DocumentRenderer</class-id> <category>private</category><body package="System-Printing" selector="flushBuffer:">flushBuffer: aText		| ct ctt |	ctt := textStyle copyOld.	(ctt respondsTo: #fontPolicyBlock:)		ifTrue:			[ctt setCharacterAttributes: textStyle characterAttributes copyOld.			ctt				fontPolicyBlock: [output fontPolicy];				flushGridding].	tabsArePositions		ifTrue: [ctt useTabPositions: currentTabs]		ifFalse: [ctt useTabs: currentTabs].	ct := ComposedText		withText: aText		style: ctt		compositionWidth:			(output clippingBounds insetBy: self deviceMargins) width		fontPolicy: output fontPolicy.	self outputComposedText: ct</body></methods><methods><class-id>Graphics.CharacterAttributes</class-id> <category>accessing</category><body package="Graphics-Fonts" selector="fontAt:for:">fontAt: aStyle for: aFontPolicy	"Answer a FontDescription corresponding to the style"	| query |	aStyle == nil		ifTrue: [^self defaultFontFor: aFontPolicy].	(query := self queryCacheAt: aStyle for: aFontPolicy ifAbsent: [nil]) == nil		ifFalse: [^query].	query := (self defaultFontFor: aFontPolicy) copyOld.	self apply: aStyle to: query with: nil for: aFontPolicy.	self queryCacheAt: aStyle for: aFontPolicy put: query.	^query</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>class initialization</category><body package="Graphics-Fonts" selector="initializeDefaults">initializeDefaults	"CharacterAttributes initializeDefaults"	| pragmas |	DefaultAttributes == nil		ifTrue: [DefaultAttributes := IdentityDictionary new].	DefaultAttributes keys copyOld do: [:key | DefaultAttributes removeKey: key].	pragmas := Pragma allNamed: #stylesWithOrder: in: self class.	pragmas := pragmas asSortedCollection: [:p1 :p2 |			(p1 argumentAt: 1) &lt;= (p2 argumentAt: 1)].	pragmas do: [:p |		self perform: p selector with: DefaultAttributes].	CharacterAttributes allGeneralInstancesDo: [:ca |		ca invalidateQueryCache].</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>images</category><body package="Graphics-Printing-PostScript" selector="copyArea:fromGraphicsMedium:sourceOffset:destinationOffset:">copyArea: aShape fromGraphicsMedium: aGraphicsMediumOrImage sourceOffset: srcOffsetPoint destinationOffset: destOffsetPoint 	"Copy an area of anImage to my display medium. The source 	area is described by aShape translated by srcOffsetPoint; the 	destination area is described by aShape translated by 	destOffsetPoint in my coordinate system."	| maskExtent mask maskGC |	(aShape isKindOf: Rectangle)		ifTrue: [^self copyOld				intersectClip: (aShape translatedBy: destOffsetPoint);				displayImage: aGraphicsMediumOrImage at: destOffsetPoint-srcOffsetPoint].	((aShape isKindOf: Image) and: [aShape paintBasis = CoverageValue])		ifTrue: [^self				copyMaskedArea: aShape				fromImage: aGraphicsMediumOrImage asImage				sourceOffset: srcOffsetPoint				destinationOffset: destOffsetPoint].	"Render aShape onto a Mask, then perform the copy."	maskExtent := aGraphicsMediumOrImage extent.	mask := Mask extent: maskExtent.	maskGC := mask graphicsContext.	self installDIGraphicsStateOn: maskGC.	maskGC		clippingRectangle: nil;		paint: CoverageValue opaque.	maskGC display: aShape at: srcOffsetPoint.	self		copyMaskedArea: mask asImage		fromImage: aGraphicsMediumOrImage asImage		sourceOffset: 0@0		destinationOffset: destOffsetPoint-srcOffsetPoint.	mask close.</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>images</category><body package="Graphics-Printing-PostScript" selector="copyMaskedArea:fromImage:sourceOffset:destinationOffset:">copyMaskedArea: aShape fromImage: anImage sourceOffset: srcOffsetPoint destinationOffset: destOffsetPoint 	"Copy an area of aShape to my display medium. The source 	area is described by anImage translated by srcOffsetPoint; the 	destination area is described by anImage translated by 	destOffsetPoint in my coordinate system."	| shape |	shape := aShape asImage.	medium languageLevel = 3 		ifTrue: 			[self 				writeImage: anImage				maskedBy: shape				at: destOffsetPoint]		ifFalse: 			[| uniqueColorIndexes im2 |			uniqueColorIndexes := Set new.			anImage pixelsDo: 					[:x :y | 					(shape atX: x y: y) = 1 						ifTrue: [uniqueColorIndexes add: (anImage atX: x y: y)]].			uniqueColorIndexes do: 					[:p | 					im2 := anImage convertToCoverageWithOpaquePixel: p.					im2 						copy: im2 bounds						from: 0 @ 0						in: shape						rule: RasterOp and.					im2 bitsAreAllZero 						ifFalse: 							[(self copyOld)								paint: (anImage palette at: p);								displayMask: im2 at: destOffsetPoint]]]</body></methods><methods><class-id>Graphics.TextAttributes</class-id> <category>tabs and margins</category><body package="Graphics-Fonts" selector="useTabs:">useTabs: newTabsArray	"Change the tab stops used by this text style."	tabsArray := newTabsArray copyOld.	equalTabs := (tabsArray size &lt;= 2 or: [tabsArray = (tabsArray first to: tabsArray last by: tabsArray first)])	  ifTrue: [tabsArray first]	  ifFalse: [0].	tabsArePositions := false.</body></methods><methods><class-id>Graphics.TextAttributes class</class-id> <category>constants</category><body package="Graphics-Fonts" selector="styleNamed:ifAbsent:">styleNamed: aSymbol ifAbsent: aBlock	"Answer the style named aSymbol from the text style dictionary.	If the style is not in the dictionary, answer the result of	evaluating aBlock."	^(TextStyles at: aSymbol ifAbsent: aBlock) copyOld</body></methods><methods><class-id>Graphics.TextAttributes class</class-id> <category>class initialization</category><body package="Graphics-Fonts" selector="default">default	"TextAttributes default"	^DefaultTextStyle copyOld</body></methods><methods><class-id>Graphics.TextAttributes class</class-id> <category>constants</category><body package="Graphics-Fonts" selector="styleNamed:">styleNamed: aSymbol	"Answer the style named aSymbol from the text style dictionary."	^(TextStyles at: aSymbol) copyOld</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>displaying</category><body package="Graphics-Visual Objects" selector="displayOn:at:enabled:">displayOn: aGraphicsContext at: aPoint enabled: aBoolean 	aBoolean		ifFalse:  			[| copyGC |			copyGC := aGraphicsContext copyOld.			copyGC paint: SymbolicPaint hilite.			self displayOn: copyGC at: aPoint + (1 @ 1)].	self displayOn: aGraphicsContext at: aPoint</body></methods><methods><class-id>Graphics.EllipticalArc</class-id> <category>private</category><body package="Graphics-Geometry" selector="computeBounds">computeBounds	"Answer the Rectangle that minimally bounds the coordinate region used	by the receiver, independent of considerations such as line width."	(startAngle = 0 and: [sweepAngle = 360]) ifTrue: [^boundingBox copyOld].	^self class boundingRectangleForPoints: (self computePoints copyWith: boundingBox center).</body></methods><methods><class-id>Graphics.RasterOp</class-id> <category>copying</category><body package="Graphics-Support" selector="copyBits">copyBits	"Perform the movement of bits from one bitmap to another	described by the instance variables of the receiver."	| sx sy dx dy w h tempBitmap |	combinationRule = RasterOp paint		ifTrue: [^self paintBits].	dx := destX max: clipX.	dy := destY max: clipY.	sx := sourceX + dx - destX.	sy := sourceY + dy - destY.	w := width min: (clipX + clipWidth - dx).	h := height min: (clipY + clipHeight - dy).	halftone == nil ifTrue:		[^destination copyBitsStride: destStride width: destWidth atX: dx y: dy				from: source stride: sourceStride width: sourceWidth atX: sx y: sy				width: w height: h rule: combinationRule].	source == nil ifTrue:		[^destination tileBitsStride: destStride width: destWidth atX: dx y: dy				from: halftone stride: halftoneStride width: halftoneWidth				atX: dx - halftonePhaseX y: dy - halftonePhaseY				width: w height: h rule: combinationRule].	"Three-operand case."	(combinationRule = 0 or: [combinationRule = 10 or: [combinationRule = 15]]) ifTrue:		["no source necessary"		^destination copyBitsStride: destStride width: destWidth atX: dx y: dy				from: source stride: sourceStride width: sourceWidth atX: sx y: sy				width: w height: h rule: combinationRule].	combinationRule = 5 ifTrue: ["nop" ^self].	"If we can perform the raster operation in two stages without an intermediate	bitmap, do so."	(combinationRule = 1 or: [combinationRule = 2 or: [combinationRule = 3]]) ifTrue:		[^self copyBitsTwoStageRule1: combinationRule rule2: 1			destX: dx destY: dy sourceX: sx sourceY: sy			halftoneX: halftonePhaseX halftoneY: halftonePhaseY width: w height: h].	(combinationRule = 12 or: [combinationRule = 13 or: [combinationRule = 14]]) ifTrue:		[^self copyBitsTwoStageRule1: combinationRule rule2: 13			destX: dx destY: dy sourceX: sx sourceY: sy			halftoneX: halftonePhaseX halftoneY: halftonePhaseY width: w height: h].	"Use an intermediate bitmap for the AND of the source and halftone."	tempBitmap := source copyOld.	tempBitmap tileBitsStride: sourceStride width: sourceWidth atX: sx y: sy				from: halftone stride: halftoneStride width: halftoneWidth				atX: dx - halftonePhaseX y: dy - halftonePhaseY				width: w height: h rule: RasterOp and.	destination copyBitsStride: destStride width: destWidth atX: dx y: dy				from: tempBitmap stride: sourceStride width: sourceWidth atX: sx y: sy				width: w height: h rule: combinationRule</body></methods><methods><class-id>Graphics.SyntheticFont</class-id> <category>converting</category><body package="Graphics-Fonts" selector="withColor:">withColor: aColor	^self copyOld color: aColor</body></methods><methods><class-id>Graphics.SyntheticFont</class-id> <category>converting</category><body package="Graphics-Fonts" selector="withStrikeout">withStrikeout	^self copyOld strikeout: true</body></methods><methods><class-id>Graphics.SyntheticFont</class-id> <category>accessing</category><body package="Graphics-Fonts" selector="widthTable">widthTable	| widthTable w |	widths == nil		ifTrue:	[^baseFont widthTable].	widthTable := baseFont widthTable copyOld.	1 to: widthTable size do:		[ :i |		(w := widths at: i) == nil ifFalse: [widthTable at: i put: w]].	^widthTable</body></methods><methods><class-id>Graphics.SyntheticFont</class-id> <category>converting</category><body package="Graphics-Fonts" selector="withUnderline">withUnderline	^self copyOld underline: true</body></methods><methods><class-id>Graphics.DeviceFont</class-id> <category>displaying</category><body package="Graphics-Fonts" selector="displayCharacters:from:to:at:on:">displayCharacters: string from: start to: stop at: aPoint on: aGraphicsContext	"Render the string onto the graphicsContext"	| p char |	p := aPoint copyOld.	start to: stop do:		[:i |		char := string at: i.		char isInteger			ifTrue: [char := self decode: char].		self displayCharacter: char at: p on: aGraphicsContext.		p x: p x + (self widthOf: char)].</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>displaying</category><body package="Graphics-Support" selector="copyArea:fromImage:sourceOffset:destinationOffset:">copyArea: aShape fromImage: anImage sourceOffset: srcOffsetPoint destinationOffset: destOffsetPoint 	"Copy an area of anImage to my display medium. The source	area is described by aShape translated by srcOffsetPoint; the 	destination area is described by aShape translated by 	destOffsetPoint in my coordinate system."	| image gc |	image := paintPolicy representImage: anImage forMedium: medium.	(aShape isKindOf: Rectangle)		ifFalse: [^self copyCompleteArea: aShape					from: image asRetainedMedium graphicsContext					sourceOffset: srcOffsetPoint					destinationOffset: destOffsetPoint].	gc := self copyOld.	gc intersectClip: (aShape translatedBy: destOffsetPoint).	image bitsPerPixel = 1		ifTrue:			[gc				displayUninterpretedMonoImageBits: image				foreground: (medium palette indexOfPaintNearest: (image palette at: 1 ifAbsent: [self paint]))				background: (medium palette indexOfPaintNearest: (image palette at: 0 ifAbsent: [self paint]))				at: destOffsetPoint - srcOffsetPoint]		ifFalse: [gc displayUninterpretedImageBits: image at: destOffsetPoint - srcOffsetPoint]</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>accessing</category><body package="Graphics-Support" selector="clientData">clientData	"Answer a copy of the receiver's client-data dictionary. A copy, rather than 	the dictionary itself is returned because we take the position that clientData 	is immutable."	^clientData isNil		ifTrue: [IdentityDictionary new]		ifFalse: [clientData copyOld]</body></methods><methods><class-id>Graphics.CompositeFont</class-id> <category>displaying</category><body package="Internationalization" selector="displayCharacters:from:to:at:on:">displayCharacters: string from: start to: stop at: aPoint on: gc	"Render the string onto the graphicsContext."	| p |	p := aPoint copyOld.	start to: stop do:		[:index | | char |		char := string at: index.		self selectFontFor: char.		"Get aGraphicsContext to reinstall the currentFont."		gc font: self.		currentFont displayCharacter: char at: p on: gc.		p := (p x + (currentFont widthOf: char)) @ p y ]</body></methods><methods><class-id>Graphics.CompositeFont class</class-id> <category>utility</category><body package="Internationalization" selector="createFont:toResemble:for:">createFont: bestMatch toResemble: aFontDescription for: fontPolicy	"Return an instance of self with the font set described by aFontDescription."	| fonts encodings actualEncodings actualEncoders |	fonts := OrderedCollection new.	encodings := aFontDescription encodings.	actualEncodings := OrderedCollection new.	actualEncoders := OrderedCollection new.	encodings do:		[ :encoding | | font best fontDesc |			fontDesc := aFontDescription copyOld.			fontDesc encodings: nil.			fontDesc encoding: encoding.			(Locale current ignoreSerifEncodings includes: encoding) ifTrue: [fontDesc serif: nil].			best := fontPolicy findBestFont: fontDesc.			font := (fontPolicy fontClass				createFont: best				toResemble: fontDesc				on: fontPolicy graphicsDevice).			actualEncodings add: font encodingType.			actualEncoders add: font encoder.			fonts add: font].	^CompositeFont new 		with: fonts asArray		priorityTable: (self				getPriorityTableFor: actualEncodings asArray				from: actualEncoders asArray)</body></methods><methods><class-id>Graphics.OptimizedLineWidthInfoTable</class-id> <category>private</category><body package="Graphics-Text Support" selector="setLines:lastLine:">setLines: anArray lastLine: aNumber	"Set the lines and last line given by the arguments."	super setLines: anArray lastLine: aNumber.	widestLine := 0.	widths := anArray copyOld.</body></methods><methods><class-id>Graphics.OptimizedLineWidthInfoTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="postCopy">postCopy	"The receiver is a copy.  Copy the lines and widths."	super postCopy.	widths := widths copyOld</body></methods><methods><class-id>Graphics.TextMeasurer class</class-id> <category>class initialization</category><body package="Graphics-Text Scanning" selector="initialize">initialize	"Initialize the stop conditions."	"TextMeasurer initialize"	| array |	EndOfRun := -1.	CrossedX := -2.	NoStopConditions := StopsDictionary new.	StopConditions := StopsDictionary new.	StopConditions at: Character tab put: #tab.	StopConditions at: Character lf put: #cr.	"line feed"	StopConditions at: Character cr put: #cr.	"carriage return"	StopConditions at: Character newPage put: #cr.	"new page"	SpaceStopConditions := StopConditions copyOld.	SpaceStopConditions at: $  put: #space.	PaddedStopConditions := StopConditions copyOld.	PaddedStopConditions at: $  put: #paddedSpace.	CodeMaps := IdentityDictionary new.	array := WordArray new: 256.	array at: 1 put: 65535.	1 to: 255 do: [:i | array at: i+1 put: i].	CodeMaps at: #unmapped put: array.	FontEncodingTypeCache := nil.	StringEncodingTypeCache := nil.	StopsDictionaryCache := nil.	MapCache := nil.</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="reflectInXTo:">reflectInXTo: newImage	"Fill newImage with the result of reflecting the receiver	about the vertical axis.  Answer newImage. "	| rop |	(newImage isLike: self) ifFalse: [self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	newImage == self ifTrue: [^self copyOld reflectInXTo: newImage].  "can't do in place"	rop := RasterOp		destinationImage: newImage		sourceImage: self		halftoneImage: nil		combinationRule: RasterOp over		destOrigin: 0 @ 0		sourceOrigin: 0 @ 0		halftonePhase: 0 @ 0		extent: 1 @ height		clipRect: (0@0 extent: self extent).	0 to: width - 1 do: [:x |		rop destX: width - 1 - x; sourceX: x; copyBits].	^newImage</body></methods><methods><class-id>Graphics.Image</class-id> <category>accessing</category><body package="Graphics-Images" selector="bits">bits	"Answer a copy of my bitmap contents."	^bits copyOld</body></methods><methods><class-id>Graphics.Image</class-id> <category>copying</category><body package="Graphics-Images" selector="postCopy">postCopy	" Copy any necessary instance variable	values after doing a shallowCopy.	Subclasses may extend this. "	super postCopy.	bits := bits copyOld</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="fillConvexShapeTo:outlinedBy:">fillConvexShapeTo: newImage outlinedBy: pixelValue	"Fill the interior of the outermost outlined region in the	receiver with the given pixel value, storing the	result into newImage.  The outlined region is delimited by an	outline of pixels with the given pixel value.  The outlined	region must not be concave by more than 90 degrees.  The	receiver must have a depth of one, so pixelValue must be	0 or 1."	| temp skew all mergeRule intersectRule |	(newImage isLike: self) ifFalse: [self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	depth = 1 ifFalse: [self error: (#errRequiresDepth &lt;&lt; #dialogs &gt;&gt; 'Shape filling requires image depth=1')].	pixelValue = 0		ifTrue:			[mergeRule := RasterOp and.			intersectRule := RasterOp under]		ifFalse:			[pixelValue = 1				ifTrue:					[mergeRule := RasterOp under.					intersectRule := RasterOp and]				ifFalse: [self error: (#errShapeFilling &lt;&lt; #dialogs &gt;&gt; 'Shape filling requires pixelValue=0 or 1')]].	newImage == self ifTrue: [^self copyOld fillConvexShapeTo: newImage outlinedBy: pixelValue].  "can't do in place"	all := self bounds.	newImage copy: all from: 0@0 in: self rule: RasterOp over.	temp := self copyOld.	skew := 1.	[skew &lt; width] whileTrue:		[newImage copy: all from: skew@0 in: newImage rule: mergeRule.		skew := skew+skew].	skew := 1.	[skew &lt; width] whileTrue:		[temp copy: all from: skew negated@0 in: temp rule: mergeRule.		skew := skew+skew].	newImage copy: all from: 0@0 in: temp rule: intersectRule.	temp copy: all from: 0@0 in: self rule: RasterOp over.	skew := 1.	[skew &lt; height] whileTrue:		[temp copy: all from: 0@skew in: temp rule: mergeRule.		skew := skew+skew].	newImage copy: all from: 0@0 in: temp rule: intersectRule.	temp copy: all from: 0@0 in: self rule: RasterOp over.	skew := 1.	[skew &lt; height] whileTrue:		[temp copy: all from: 0@skew negated in: temp rule: mergeRule.		skew := skew+skew].	newImage copy: all from: 0@0 in: temp rule: intersectRule.	^newImage</body></methods><methods><class-id>Graphics.Image</class-id> <category>editing utilitys</category><body package="Graphics-Images" selector="minimalStorageString">minimalStorageString	self depth = 1 ifTrue: [^self storeString].	^(self copyOld convertToPalette: (MappedPalette withColors: self uniqueColorValues asArray)) storeString</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="rotateByQuadrants:to:">rotateByQuadrants: quads to: newImage	"Fill newImage with a copy of the receiver	rotated clockwise by quads * 90 degrees.	quads = 0 means unchanged, 1 means clockwise 90 degrees, and so on.	Answer newImage."	| angle rotSize rotImage all destPt sourcePt sourceDelta destDelta rotOrigin mask temp |	newImage == self ifTrue: [^self copyOld rotateByQuadrants: quads to: newImage].  "can't do in place"	angle := quads bitAnd: 3.  "take angle mod 360 degrees"	angle = 0		ifTrue: [^newImage copy: self bounds from: 0@0 in: self rule: RasterOp over].   "null rotation"	angle = 2		ifTrue:			[newImage copy: self bounds from: 0@0 in: self rule: RasterOp over.			newImage reflectInXTo: newImage.			newImage reflectInYTo: newImage.			^newImage].  "two reflections does 180 degrees"	"Break the problem up into squares of size 2^N, and rotate them"	rotSize := (width min: height)   "minimum rotation size"				max: (64 min: (width max: height)).  "but faster if we do larger chunks"	rotSize := 2 raisedTo: ((rotSize-1) asFloat floorLog: 2)+1.  "force up to a power of 2"	(newImage isLike: self withExtent: self extent transpose) ifFalse:		[self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	rotImage := self copyEmpty: rotSize asPoint.	all := rotImage bounds.	sourcePt := 0@0.	width &gt;= height		ifTrue:			[sourceDelta := rotSize@0.			angle=1				ifTrue:					[destPt := 0@0.					destDelta := sourceDelta transpose.					rotOrigin := (rotSize-height)@0]				ifFalse:					[destPt := 0@(width-rotSize).					destDelta := (0@0) - sourceDelta transpose.					rotOrigin := 0@0]]		ifFalse:			[sourceDelta := 0@rotSize.			angle=1				ifTrue:					[destPt := (height-rotSize)@0.					destDelta := (0@0) - sourceDelta transpose.					rotOrigin := 0@0]				ifFalse:					[destPt := 0@0.					destDelta := sourceDelta transpose.					rotOrigin := 0@(rotSize-width)]].	mask := rotImage copyEmpty.	temp := rotImage copyEmpty.	(width max: height) - 1 // rotSize + 1 timesRepeat:		[rotImage copy: all from: sourcePt in: self rule: RasterOp over.		rotImage rotate2: angle mask: mask temp: temp.		newImage copy: (all translatedBy: destPt) from: rotOrigin in: rotImage rule: RasterOp over.		sourcePt := sourcePt + sourceDelta.		destPt := destPt + destDelta].	^newImage</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="reflectInYTo:">reflectInYTo: newImage	"Fill newImage with the result of reflecting the receiver	about the horizontal axis.  Answer newImage."	| row |	(newImage isLike: self) ifFalse: [self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	newImage == self ifTrue: [^self copyOld reflectInYTo: newImage].  "can't do in place"	row := self pixelArraySpecies new: self packedRowSize.	0 to: height - 1 do:		[:y |		self packedRowAt: y into: row.		newImage packedRowAt: height - 1 - y putAll: row].	^newImage</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="fillShapeAround:to:outlinedBy:">fillShapeAround: interiorPoint to: newImage outlinedBy: pixelValue	"Fill the interior of some outlined region with the given	pixel value, storing the result into newImage.  The	outlined region is delimited by an outline of pixels with the	given pixel value.  InteriorPoint marks a location in the	interior or the region.  A mark is placed at this point as a	seed, then the seed is smeared into a blob until there is no	change in the blob when it fills the region.  The receiver	must have a depth of one, so pixelValue must be 0 or 1."	| dirs previousSmear all cycle noChange mergeRule eraseRule clearRule |	(newImage isLike: self) ifFalse: [self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	depth = 1 ifFalse: [self error: (#errRequiresDepth &lt;&lt; #dialogs &gt;&gt; 'Shape filling requires image depth=1')].	newImage == self ifTrue: [^self copyOld fillShapeAround: interiorPoint to: newImage outlinedBy: pixelValue].  "can't do in place"	pixelValue = 0		ifTrue:			[mergeRule := RasterOp and.			eraseRule := RasterOp reverseUnder.			clearRule := RasterOp writeOnes]		ifFalse:			[pixelValue = 1				ifTrue:					[mergeRule := RasterOp under.					eraseRule := RasterOp erase.					clearRule := RasterOp writeZeros]				ifFalse: [self error: (#errShapeFilling &lt;&lt; #dialogs &gt;&gt; 'Shape filling requires pixelValue=0 or 1')]].	newImage == self ifTrue: [^self copyOld fillShapeAround: interiorPoint to: newImage outlinedBy: pixelValue].  "can't do in place"	all := self bounds.	newImage copy: all from: 0@0 in: newImage rule: clearRule.	newImage atPoint: interiorPoint put: pixelValue.		"Place a seed in the interior"	previousSmear := newImage copyOld.	dirs := Array with: 1@0 with: -1@0 with: 0@1 with: 0 @ -1.	cycle := 0.	[(cycle := cycle+1) \\ 4 = 0 and:   "check for no change every 4 smears"		[previousSmear copy: all from: 0@0 in: newImage rule: RasterOp reverse.		noChange := previousSmear bitsAreAllZero.		previousSmear copy: all from: 0@0 in: newImage rule: RasterOp over.		noChange]]		whileFalse: 			[dirs do:				[:dir |    "smear in each of the four directions"				newImage copy: all from: dir in: newImage rule: mergeRule.				"After each smear, trim around the region border"				newImage copy: all from: 0@0 in: self rule: eraseRule]].	newImage copy: all from: 0@0 in: self rule: mergeRule.	^newImage</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>copying</category><body package="Graphics-Geometry" selector="postCopy">postCopy	super postCopy.	origin := origin copyOld.	corner := corner copyOld</body></methods><methods><class-id>Graphics.AlphaCompositedImage</class-id> <category>accessing</category><body package="Graphics-Images" selector="disabled">disabled	"Return a copy of the receiver that will fade into the background by taking 33% of all of the alpha values."		| washedOutImage bits |	washedOutImage := image copyOld.	bits := washedOutImage bitsInstVar.	1		to: bits size		by: 4		do:			[:n | 			bits				at: n				put: (bits at: n) // 3].	^self class image: washedOutImage</body></methods><methods><class-id>Graphics.AlphaCompositedImage</class-id> <category>copying</category><body package="Graphics-Images" selector="postCopy">postCopy	image := image copyOld</body></methods><methods><class-id>Graphics.AlphaCompositedImage</class-id> <category>utilities</category><body package="Graphics-Images" selector="masked:">masked: anotherAlphaCompositedImage	| copy newBits maskingBits |	copy := self copyOld.	newBits := copy image bitsInstVar.	maskingBits := anotherAlphaCompositedImage image bitsInstVar.	1 to: newBits size		by: 4		do: [:n | newBits at: n put: (newBits at: n) * (maskingBits at: n) // 255].	^copy</body></methods><methods><class-id>Graphics.MSWindowsFont class</class-id> <category>utilities</category><body package="Graphics-Fonts" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen	| encoder synthetic fName fd divider oneString zeroString |	encoder := OSSystemSupport concreteClass vmPreferredEncoding = #default				ifTrue: [self encoderNamed: concreteFontDescription encoding]				ifFalse: [UnicodeCharacterEncoder new].	divider := (#[16r7E] asStringEncoding: #default) first.	oneString := String with: $1 with: divider.	zeroString := String with: $0 with: divider.	fd := concreteFontDescription copyOld.	synthetic := concreteFontDescription pixelSize = 0.	synthetic := synthetic				or: [requestedFontDescription boldness &gt; 0.6						and: [concreteFontDescription boldness &lt; 0.6]].	synthetic := synthetic or: [requestedFontDescription italic].	synthetic := synthetic or: [requestedFontDescription underline].	synthetic := synthetic or: [requestedFontDescription strikeout].	synthetic		ifTrue: [| stream size boldValue isItalic |			size := concreteFontDescription pixelSize = 0						ifTrue: [requestedFontDescription pixelSize]						ifFalse: [concreteFontDescription pixelSize].			boldValue := requestedFontDescription specifiesBoldness						ifTrue: [requestedFontDescription boldness]						ifFalse: [requestedFontDescription name isString								ifTrue: [((requestedFontDescription name tokensBasedOn: $~) at: 3) asNumber										/ 1000.0]								ifFalse: [concreteFontDescription boldness]].			isItalic := requestedFontDescription specifiesItalic						ifTrue: [requestedFontDescription italic]						ifFalse: [requestedFontDescription name isString								ifTrue: [((requestedFontDescription name tokensBasedOn: $~) at: 4) asNumber &gt; 0]								ifFalse: [concreteFontDescription italic]].			stream := String new writeStream.			stream				nextPutAll: concreteFontDescription family;				nextPut: divider.			stream				print: size;				nextPut: divider.			stream				print: (boldValue &gt; 0.6 ifTrue: [700] ifFalse: [400]);				nextPut: divider.			stream nextPutAll: (isItalic ifTrue: [oneString] ifFalse: [zeroString]).			stream nextPutAll: (requestedFontDescription underline						ifTrue: [oneString]						ifFalse: [zeroString]).			stream nextPutAll: (requestedFontDescription strikeout						ifTrue: [oneString]						ifFalse: [zeroString]).			stream				nextPutAll: (self extractEncoding: concreteFontDescription name);				nextPut: divider.			stream nextPutAll: '0'.			fName := stream contents.			fd				boldness: (requestedFontDescription boldness &gt; 0.6							ifTrue: [0.7]							ifFalse: [0.5]);				italic: requestedFontDescription italic;				underline: requestedFontDescription underline;				strikeout: requestedFontDescription strikeout;				pixelSize: size;				name: fName]		ifFalse: [fName := concreteFontDescription name].	^(aScreen fontNamed: fName fromClass: self encoding: encoder)		setDescription: fd</body></methods><methods><class-id>Lens.LDMRelationsBody</class-id> <category>graph manipulation</category><body package="LDM-Framework" selector="closeAllFrom:side:">closeAllFrom: element side: side	"Close all the relationships from element for the given side. First get all the open relationships, then let the generator close those relationship. Then remove the relationships that are not connected to the focus (foa) and rebuild the graph view"	| clossable |	clossable := graph relationshipsFromElement: element side: side.	clossable keysAndValuesDo: [:rel :related | 		generator			userCloseRelationship: rel			from: element			to: related copyOld			side: side].	generator checkConnectivity: self foa. 	self rebuild</body></methods><methods><class-id>Lens.LDMBrowserModel</class-id> <category>private</category><body package="LDM-Framework" selector="updateAttributesFor:">updateAttributesFor: perspective 	"Arrange the attributes of the relationships in a dictionary so the access is faster. The attributes in the 	dictionary may be programatically changed, thus overriding the default defined in the perspective"	attributes := IdentityDictionary new.	perspective relDesc		do: 			[:rDesc | 			| rel |			rel := LDMRelationship at: (rDesc at: 1) asSymbol.			attributes at: rel put: rDesc copyOld]</body></methods><methods><class-id>Lens.LDMSelectionService</class-id> <category>accessing</category><body package="LDM-Framework" selector="selectedViews">selectedViews	"Answer the value for selectedViews"	^self getSelectedViews copyOld</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>displaying</category><body package="LDM-Framework" selector="displayOn:">displayOn: aGraphicsContext 	"Display each of the receiver's components. 	If the view is selected then use selection colors."	| clipBox aGC |	"aGraphicsContext class == CYPSGenerator ifTrue: [^self displayOnPs: aGraphicsContext]."	aGC := aGraphicsContext copyOld.	clipBox := aGC clippingBounds.	aGC paint: self foregroundColor.	1 to: components size		do: 			[:i | 			| component |			component := components at: i.			(component intersects: clipBox)				ifTrue: [component displayOn: aGC copyOld]]</body></methods><methods><class-id>Lens.LDMTransitiveClosureRel</class-id> <category>computing</category><body package="LDM-Framework" selector="relatedTo:">relatedTo: el 	"Starts with the set that results from applying one time the 	basicRelationship. Then applies it to all of the members in the set, 	as many times as required (it stops when the set doesn't grow any 	more elements ). Remember that here we are interested only in the 	relationship between the root and all the tree.	This computation can be quite expensive. The algorithm presented here is	completely general. A more specific solution for specific cases can be	implemented in the elements themselves"	| resultSet incrementSet |	resultSet := r1 relatedTo: el.	incrementSet := resultSet copyOld.	[incrementSet isEmpty]		whileFalse: 			[| newIncrementSet |			newIncrementSet := IdentitySet new.			incrementSet do: [:newEl | newIncrementSet addAll: (r1 relatedTo: newEl)].			incrementSet := IdentitySet new.			newIncrementSet do: [:newEl2 | (resultSet includes: newEl2)					ifFalse: 						[incrementSet add: newEl2.						resultSet add: newEl2]]].	^resultSet</body></methods><methods><class-id>Lens.LDMArrowView</class-id> <category>display box accessing</category><body package="LDM-Framework" selector="preferredBounds">preferredBounds	"Compute the preferredBounds for the receiver"	CachedBounds == nil		ifTrue: 			[| imageOff imageOn labelOff labelOn |			imageOff := offImage isNil						ifTrue: [0 @ 0]						ifFalse: [offImage preferredBounds extent].			imageOn := onImage isNil						ifTrue: [0 @ 0]						ifFalse: [onImage preferredBounds extent].			labelOff := (ComposedText withText: label style: LabelStyle) preferredBounds extent.			labelOn := (ComposedText withText: label asText copyOld allBold style: LabelStyle) preferredBounds extent.			CachedBounds := Rectangle origin: 0 @ 0 corner: (imageOff x + labelOff x max: imageOn x + labelOn x)							+ 0 @ ((imageOff y max: labelOff y)								max: (imageOn y max: labelOn y))].	^CachedBounds</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="translationsFromPostgres">translationsFromPostgres	"^an IdentityDictionary 	I return my session specific disctionary of translation blocks. Because different session may wish 	to translate thinfs differently, the blocks must be local to the session."	translationsFromPostgres isNil ifTrue: [translationsFromPostgres := self class translationsFromPostgres copyOld].	^translationsFromPostgres</body></methods><methods><class-id>Protocols.Struct</class-id> <category>copying</category><body package="Protocols-Common" selector="postCopy">postCopy	1 to: lastIndex do: [ :i | self basicAt: i put: (self basicAt: i) copyOld ]</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>overrides</category><body package="Store-Repository Access" selector="validateClassAndNameSpaceOverlaps:">validateClassAndNameSpaceOverlaps: queryBoolean	"Answer true if user validates class redefinitions."	| coll pname |	( coll := nameSpaces copyOld ) addAll: classes.     	coll do: 		[ :obj | |  action |		action := queryBoolean			ifTrue: 				[ | pkg message |				pkg := Registry containingPackageForSymbol: obj absoluteSymbol.				pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].				message := (#_1sIsAlreadyDefinedIn2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is already defined in &lt;2s&gt;')					expandMacrosWith: obj fullName with: pname.				Override overrideReplaceOrCancel: message 				]			ifFalse: 				[ pname = Registry nullPackageName 							ifTrue: [ #replace ] ifFalse: [ #override ].				].		action == #cancel  			ifTrue: [ ^false ].		action == #override			ifTrue: [ overrides add: ( obj -&gt; ( Override forClassOrNameSpace: obj ) ) ]		].	^true.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support" selector="removeDbs:">removeDbs: aCollectionOfDatabaseIdentifiers	"Removes anything associated with databases in aCollectionOfDatabaseIdentifiers	This is only reached through the switchDatabase operation, 	which is only available while logged in."		dbInfo copyOld keys do:		[:eachDatabaseInfoSymbol | 		(aCollectionOfDatabaseIdentifiers includes: eachDatabaseInfoSymbol) ifTrue:			[dbInfo size == 1 ifTrue: [self databaseInformationForOrCreate: DbRegistry dbIdentifier].			dbInfo removeKey: eachDatabaseInfoSymbol]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Tools-Blueprints" selector="propertyBlueprints">propertyBlueprints	| output propertiesWithoutVolitileKeys |	"AR #61875 this code was modified because it was pulling in a StoreBase prerequisite, which Tools-Blueprints is not allowed to do."	propertiesWithoutVolitileKeys := properties copyOld.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesWithoutVolitileKeys removeKey: each ifAbsent: [nil]].	output := Array new writeStream.	propertiesWithoutVolitileKeys keysAndValuesDo: 			[:propertyName :propertyValue |			| coercedValue |			propertyName = #version				ifFalse: 					[coercedValue := (propertyValue isKindOf: BlockClosure)								ifTrue: [propertyValue method getSource]								ifFalse: [propertyValue].					output nextPut: ((CodeComponentPropertyBlueprint new)								codeComponent: self;								key: propertyName;								value: coercedValue)]].	^output contents</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>resources</category><body package="Store-UI-Unloadables Support" selector="readOnlyCodeMenu">readOnlyCodeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyCodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copyOld ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#value: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#value: #selectEntireText ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>selector accessing</category><body package="PackageCategories" selector="classAndSelectorDo:">classAndSelectorDo: aBlock 	"For each pair of the class and its selectors and the meta class and its selectors	evaluate aBlock."	| actual |	actual := self actualClassMeta: false.	(self selectorsMeta: false) copyOld		do: [:selector | aBlock value: actual value: selector].	actual := self actualClassMeta: true.	(self selectorsMeta: true) copyOld		do: [:selector | aBlock value: actual value: selector]</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>data accessing</category><body package="PackageCategories" selector="classAndDataKeyDo:">classAndDataKeyDo: aBlock 	"For each pair of the class and its datakeys, evaluate aBlock."	| actual |	actual := self actualClass.	self dataKeys copyOld do: 		[ :dataKey | aBlock value: actual value: dataKey].</body></methods><methods><class-id>Store.PublishPundlesDialog</class-id> <category>private</category><body package="Store-UI" selector="culledPundles">culledPundles	| packages bundles |	packages := pundles select: #isPackage.	bundles := pundles select: #isBundle.	packages copyOld do:		[:eachPackage |		(bundles detect: [:eachBundle | eachPackage enclosingComponents includes: eachBundle] ifNone: [nil])			ifNotNil: [packages remove: eachPackage]].	bundles copyOld do:		[:each |		(bundles detect: [:eachBundle | each enclosingComponents includes: eachBundle] ifNone: [nil])			ifNotNil: [bundles remove: each]].	packages copyOld do:		[:each |		| count |		(count := packages occurrencesOf: each) &gt; 1 ifTrue: [count - 1 timesRepeat: [packages remove: each ifAbsent: [nil]]]].	bundles copyOld do:		[:each |		| count |		(count := bundles occurrencesOf: each) &gt; 1 ifTrue: [count - 1 timesRepeat: [bundles remove: each ifAbsent: [nil]]]].	^bundles, packages</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="PackageCategories" selector="classesNamed:">classesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassDescriptor or ClassExtensionDescriptors."		| names selected |	names := aSetOfNames copyOld.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self classesDefinedInPackage do: 		[ :cl | (names includes: cl absoluteName)				ifTrue: 				[ names remove: cl absoluteName.				selected add: cl				]		].	self metaclassesDefinedInPackage do: 		[ :cl | (names includes: cl absoluteName, ' class')			ifTrue: 				[names remove: cl absoluteName, ' class'.				selected add: cl]		].	names do: 		[ :nm|  selected add: ( ClassExtensionDescriptor fullName: nm meta: false ) ].	^selected</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="PackageCategories" selector="nameSpacesNamed:">nameSpacesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of NameSpaceDescriptor or NameSpacesExtensionDescriptors."		| names selected |	names := aSetOfNames copyOld.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self nameSpacesDefinedInPackage do: 		[ :ns | (names includes: ns absoluteName)				ifTrue: 				[ names remove: ns absoluteName.				selected add: ns				]		].	names do: [:nm|  selected add: ((NameSpaceExtensionDescriptor new) fullName: nm; yourself)].	^selected</body></methods><methods><class-id>Store.PackageModel</class-id> <category>change set conversion</category><body package="PackageCategories" selector="copyModels:">copyModels: modelDictionary	"Deep copy the modelDictionary into the receiver."	"Meant for internal use only."	models := IdentityDictionary new.	modelDictionary keysAndValuesDo:		[ :key :value | models at: key put: value copyOld ].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>overrides</category><body package="PackageCategories" selector="cleanUpOverrides">cleanUpOverrides	self overrides copyOld do:		[ :over | | obj |		( obj := over object ) == nil			ifFalse: 				[ ( ( over getSources: obj ) includes: self )					ifTrue: [ over silentlyRemove ]				].		].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="PackageCategories" selector="removeEmptyModels">removeEmptyModels	models copyOld do: 		[ :model | 		model isEmpty			ifTrue: [ self removeModel: model ]		]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="PackageCategories" selector="cleanse:">cleanse: warn	"Cleanse the component. Remove any class or method definitions	 that are no longer in the system, including the postLoadMethod."	| warnBlock |	warnBlock := [ :str | warn ifTrue: [ Transcript show: ((#nRemovingNonexistant1s &lt;&lt; #packages &gt;&gt; '&lt;n&gt;Removing non-existant &lt;1s&gt;') expandMacrosWith: str)  ] ].	models keys do:		[ :key |		 key asStrictReference isDefined			ifFalse: 				[ warnBlock value: key.				models removeKey: key. 				].		].	self extendedClassModels do:		[ :model | 		model classAndSelectorDo:			[ :cls :selector | 			cls compiledMethodAt: selector ifAbsent: 				[ warnBlock value: ((#x1s2s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt;')						expandMacrosWith: cls fullName						with: selector).				model removeSelector: selector meta: cls isMeta 				]			].		model classAndDataKeyDo:			[ :cls :key |			( cls includesDataKey: key )				ifFalse: [ warnBlock value: (cls fullName, '.', key).						model removeDataKey: key ]			]		].	self extendedNameSpaceModels do:		[ :model | 		model nameSpaceAndDataKeyDo:			[ :ns :key |			( ns includesDataKey: key )				ifFalse: [ warnBlock value: (ns fullName, '.', key).						model removeDataKey: key ]			]		].	models copyOld do:		[ :m | m isEmpty ifTrue: [ self removeModel: m ] ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing-browser</category><body package="PackageCategories" selector="allMethodsBut:">allMethodsBut: oldCollection 	"Answer an array. The first element has collection of methods that are 	defined in the backage but not in oldCollection. 	The second has method defined in oldColection but not in the package."	| coll newColl oldMethod |	coll := oldCollection copyOld.	newColl := List new.	self methods		do: 			[:method | 			oldMethod := coll detect: [:each | each sameAs: method]						ifNone: [nil].			oldMethod isNil				ifTrue: [newColl add: method]				ifFalse: [coll remove: oldMethod]].	^Array with: newColl with: coll</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-Component Support" selector="computeFullDiffsBetweenDBPackage:into:">computeFullDiffsBetweenDBPackage: aDBPackage into: diff 	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number2 since this method	is called with arguments reversed."	| coll1 coll2 |	"methods"	coll1 := aDBPackage methodsWithSource asSet.	coll2 := OrderedCollection new: coll1 size.	self methods 		do: [:method | coll1 remove: method ifAbsent: [coll2 add: method]].	"At this point coll1 contains methods that are only in aDBPackage	and coll2 methods that are only the receiver."	diff methodsSide: 2 put: coll2.	diff methodsSide: 1 put: coll1.	"data"	coll1 := aDBPackage data asSet.	coll2 := OrderedCollection new: coll1 size.	self data do: [:datum | coll1 remove: datum ifAbsent: [coll2 add: datum]].	"At this point coll1 contains data that are only in aDBPackage	and coll2 data that are only the receiver."	diff dataSide: 2 put: coll2.	diff dataSide: 1 put: coll1.	"namespaces"	coll1 := aDBPackage nameSpacesDefinedInPackage copyOld.	coll2 := OrderedCollection new: coll1 size.	self nameSpacesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff nameSpacesSide: 2 put: coll2.	diff nameSpacesSide: 1 put: coll1.	"classes"	coll1 := aDBPackage classesDefinedInPackage copyOld.	coll2 := OrderedCollection new: coll1 size.	self classesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff classesSide: 2 put: coll2.	diff classesSide: 1 put: coll1.	coll1 := aDBPackage metaclassesDefinedInPackage copyOld.	coll2 := OrderedCollection new: coll1 size.	self metaclassesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff metaSide: 2 put: coll2.	diff metaSide: 1 put: coll1.	self computeOverrideDiffsBetweenDBPackage: aDBPackage into: diff.	^diff</body></methods><methods><class-id>Store.PackageModel</class-id> <category>initialize-release</category><body package="PackageCategories" selector="release">release	models notNil 		ifTrue: [ models copyOld do: [ :model | self removeModel: model ] ].	models := IdentityDictionary new.	Registry removePackage: self</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>private</category><body package="Store-Merge Management" selector="asGeneralResolution">asGeneralResolution	| instance |	instance := self copyOld.	instance alternative: nil.	^instance</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>actions</category><body package="Store-UI" selector="updateFiles">updateFiles	| targetPundleModel fileDescriptions |	targetPundleModel := self specList first dbPundle.	fileDescriptions := targetPundleModel fileDescriptions.	self fileList do:		[:each |		each publish ifTrue:			[(fileDescriptions contains: [:eachFile | eachFile portableFilename asString = each name])				ifTrue:					[targetPundleModel removeFile: each name.					targetPundleModel addFile: each name]				ifFalse: [targetPundleModel addFile: each name]]].	fileDescriptions := targetPundleModel fileDescriptions copyOld.	fileDescriptions do:		[:each |		(self fileList anySatisfy: [:eachFile | eachFile name = each portableFilename asString]) ifFalse:			[targetPundleModel removeFile: each portableFilename asString]]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>utility</category><body package="Store-Component Support" selector="inspectChangeSet">inspectChangeSet		changeSet ifNil: [^Dialog warn: (#NoChangesFor1s &lt;&lt; #store &gt;&gt; 'No changes for &lt;1s&gt;' expandMacrosWith: dbIdentifier)].	changeSet inspectorClass		inspect: changeSet copyOld		label: (#ChangesFor1s &lt;&lt; #store &gt;&gt; 'Changes for &lt;1s&gt;' expandMacrosWith: dbIdentifier)</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-definition sorting</category><body package="Atomic Compiling and Loading" selector="sortedFullClasses">sortedFullClasses	| classes workingClasses names |	sortedFullClasses ifNotNil: [^sortedFullClasses].	(classes := self fullLoadClasses) isEmpty ifTrue: [^#()].	sortedFullClasses := OrderedCollection new: classes size.	workingClasses := classes copyOld.	[workingClasses isEmpty] whileFalse:		[names := workingClasses collect: [:each | each longName].		workingClasses copyOld do:			[:each |			(names contains: [:eachName | eachName = each superclassName]) ifFalse:				[sortedFullClasses add: each.				workingClasses remove: each]]].	^sortedFullClasses</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>installation</category><body package="Atomic Compiling and Loading" selector="initializeBindings">initializeBindings	"Keep trying until there are either none to do, or the number to do doesn't change"	| workingBindings workingSize copyBindings |	bindingsToInitialize isEmpty ifTrue: [^self].	workingBindings := bindingsToInitialize copyOld.	copyBindings := workingBindings copyOld.	workingSize := -1.	[workingSize ~= workingBindings size and: [workingBindings notEmpty]] whileTrue:		[workingSize := workingBindings size.		workingBindings do:			[:each |			[each recompile.			each initialize.			each ifNotNil: [copyBindings remove: each]]				on: MessageNotUnderstood				do: [:exception | exception resume]].			workingBindings := copyBindings copyOld]</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-definition sorting</category><body package="Atomic Compiling and Loading" selector="sortedClasses">sortedClasses	| classes orderedClasses workingClasses names |	(classes := self loadingDictionaryClasses) isEmpty ifTrue: [^#()].	(Gathering for: (classes first package name), ' - Classes') started.	orderedClasses := OrderedCollection new: classes size.	workingClasses := classes copyOld.	[workingClasses isEmpty] whileFalse:		[names := (workingClasses collect: [:each | each longName]) asSet.		workingClasses copyOld do:			[:each |			(names contains: [:eachName | eachName = each superclassName]) ifFalse:				[orderedClasses add: each.				workingClasses remove: each]]].	loadingDictionary at: #classes put: orderedClasses.	(Gathering for: (classes first package name), ' - Classes') finished.	^orderedClasses</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>installation</category><body package="Atomic Compiling and Loading" selector="initializeClasses">initializeClasses	"Keep trying until there are either none to do, or the number to do doesn't change.	If there are any still unable to be initialized, go and raise MNU on each after setting doNotMarkClean to true"		| sortedClasses workingClasses packageDictionary workingSize |	classesToInitialize isEmpty ifTrue: [^self].	sortedClasses := SystemUtils sortForLoading: (classesToInitialize collect: [:each | each key]).	workingClasses := sortedClasses copyOld.	workingSize := -1.	[workingSize ~= sortedClasses size and: [sortedClasses notEmpty]] whileTrue:		[workingSize := sortedClasses size.		packageDictionary := Dictionary new.		self putClasses: sortedClasses intoDictionary: packageDictionary.		self installFromPackagesIn: packageDictionary removingFrom: workingClasses.		sortedClasses := workingClasses copyOld].	(self loadingDictionaryExtensionMethods select: [:each | each isMeta and: [each selector = #initialize]])		do:			[:each | 			[(self realFromShadow: each mclass) instanceBehavior postLoad: each packageModel]				on: InitializerFailedError , MessageNotUnderstood				do: [:exception | exception return: nil]].	workingClasses notEmpty		ifTrue:			[pundlesNeedPostInstallReconcile := true.			workingClasses				do:					[:each | 					[each postLoad: (Registry containingPackageForClass: each)]						on: InitializerFailedError						do: [:exception | exception resignalAs: MessageNotUnderstood new]]]</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-definition sorting</category><body package="Atomic Compiling and Loading" selector="sortedNamespaces">sortedNamespaces	| namespaces orderedNamespaces workingNamespaces names |	(namespaces := self loadingDictionaryNamespaces) isEmpty ifTrue: [^#()].	orderedNamespaces := OrderedCollection new: namespaces size.	workingNamespaces := namespaces copyOld.	[workingNamespaces isEmpty] whileFalse:		[names := workingNamespaces collect: [:each | each longName].		workingNamespaces copyOld do:			[:each |			(names contains: [:eachName | eachName = each ownerName]) ifFalse:				[orderedNamespaces add: each.				workingNamespaces remove: each]]].	loadingDictionary at: #namespaces put: orderedNamespaces.	^orderedNamespaces</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-compiling</category><body package="Atomic Compiling and Loading" selector="compilerMethodInShadow:orRealClassDefinesCompiler:">compilerMethodInShadow: aShadowClassOrMetaClass orRealClassDefinesCompiler: aClassOrMetaClass	| compilerMethod |	aShadowClassOrMetaClass ifNotNil: 		[aShadowClassOrMetaClass instanceBehavior == Object ifFalse:			[compilerMethod := aShadowClassOrMetaClass isMeta				ifTrue: 					[(aShadowClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: 						[(aShadowClassOrMetaClass compiledMethodAt: #classCompilerClass) copyOld]]				ifFalse: 					[(aShadowClassOrMetaClass class selectors includes: #compilerClass) ifTrue: 						[(aShadowClassOrMetaClass class compiledMethodAt: #compilerClass) copyOld]]]].	compilerMethod ifNotNil: [^compilerMethod].	aClassOrMetaClass ifNil: [^nil].	^aClassOrMetaClass isMeta		ifTrue: [(aClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aClassOrMetaClass compiledMethodAt: #classCompilerClass) copyOld]]		ifFalse: [(aClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aClassOrMetaClass class compiledMethodAt: #compilerClass) copyOld]].</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>actions</category><body package="Store-UI" selector="cancelChanges">cancelChanges	self targetedPundles list copyOld do:		[:each |		each blessingLevelNumber = -54 ifFalse: [self targetedPundles list remove: each]].	self enableApply</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>initialization</category><body package="PackageCategories" selector="initializeContentsFrom:">initializeContentsFrom: aBundleConnectionInformation	"Set up the initial contents from  an existing dbconnection."		contentDescriptions := 		( aBundleConnectionInformation contentDescriptions collect:			[ :desc | 			desc copyOld 				id: nil; 				dbIdentifier: dbIdentifier;				yourself 			] ) asList.	#{Store.DbRegistry} ifDefinedDo:			[ :reg |			fileDescriptions := aBundleConnectionInformation fileDescriptions collect:				[ :desc | 				desc copyOld 					dbTrace: nil; 					yourself 				].			].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>initialization</category><body package="Store-Component Support" selector="resetContentsFrom:">resetContentsFrom: aBundleConnectionInformation	"Make this database information adopt the parameter information's view of what pundles the bundle contains and in what order.  Since addComponentDescription: is lazy (does nothing if it is already there), the first statement only adds pundles we do not already have.  The second removes pundles which we have but which the newly loaded version does not have.  If the two content description collections are still not equal (content description equality only checks names) then we resort our pundle orders to match that of the (about-to-be) loaded pundle."	(self copyOld initializeContentsFrom: aBundleConnectionInformation)		contentDescriptions do: [:each | self addComponentDescription: each].	(contentDescriptions reject:		[:each | aBundleConnectionInformation contentDescriptions includes: each])			do: [:each | self removeComponentDescription: each].	contentDescriptions = aBundleConnectionInformation contentDescriptions ifFalse:		[self shouldTrackChanges ifTrue: [self addOtherChange: pundle structureMark].		Registry changedBundleStructure: self pundle.		SequenceableCollectionSorter			sort: contentDescriptions			using: [:a :b | (aBundleConnectionInformation contentDescriptions indexOf: a)						&lt; (aBundleConnectionInformation contentDescriptions indexOf: b)]].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="PackageCategories" selector="removeNonexistentComponentsRecursive">removeNonexistentComponentsRecursive	contentDescriptions copyOld do:		[ :descr | | comp |		descr == nil			ifFalse: 				[ ( comp := descr component ) == nil					ifTrue: [ self removeComponentDescription: descr ]					ifFalse: 						[ comp isBundle 							ifTrue: [ comp removeNonexistentComponentsRecursive ]						]				]		].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="PackageCategories" selector="removeNonexistentComponents">removeNonexistentComponents	contentDescriptions copyOld do:		[ :descr |		descr == nil			ifFalse: 				[ descr component == nil					ifTrue: [ self removeComponentDescription: descr ]				]		].</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>utility</category><body package="Store-Broker-Obsolete" selector="smalltalkWildcardToSql:">smalltalkWildcardToSql: aString	"Translates a smalltalk wild card string to a sql wildcard string."	"* becomes % and ? becomes _"	| string index |	string := aString copyOld.	[ ( index := string indexOfSubCollection: '*' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $% ].	[ ( index := string indexOfSubCollection: '?' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $_ ].	^string</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="PackageCategories" selector="cleanseModels:">cleanseModels: warn	"Check that all models exist - remove non-existant models and display a warning if warn is true."	| real undeclaredModel |	modelDictionary values copyOld do: 		[:models |		models first isNil			ifTrue: 				[[real := (models at: 2) actual] 					on: UnloadedObjectError					do: [:exception | modelDictionary removeKey: models second absoluteSymbol].				real isNil ifFalse: 					[modelDictionary removeKey: (models at: 2) absoluteSymbol.					2 to: models size do: 						[:index |						| model |						model := models at: index.						model fullClassSymbol: real absoluteSymbol.						self addModel: model]]]				ifFalse: 					[[models first actual] 						on: UnloadedObjectError						do: 							[:exception |							warn ifTrue: 								[Dialog warn: (#RemovingNonexistentC1s &lt;&lt; #packages &gt;&gt; 'Removing non-existent: &lt;1s&gt;'										expandMacrosWith: models first absoluteName)].						modelDictionary removeKey: models first absoluteSymbol]]].	undeclaredModel := modelDictionary at: #'Root.Smalltalk.Kernel.Undeclared' ifAbsent: [^self].	((undeclaredModel allButFirst: 1) select: [:each | each package = self nullPackage]) do:		[:each |		each dataKeys copyOld do: [:eachData | (Undeclared includesKey: eachData) ifFalse: [each removeDataKey: eachData]].		each dataKeys isEmpty ifTrue: [self removeModel: each named: #'Root.Smalltalk.Kernel.Undeclared']]</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>package partitioning</category><body package="PackageCategories" selector="unloadEmptyPackages">unloadEmptyPackages	"DANGER unprotected unloads"	"self unloadEmptyPackages"  	Registry allPackages copyOld do: 		[:pkg | pkg isCompletelyEmpty  ifTrue: [pkg doUnloadFromImage]].	Registry allBundles copyOld do: 		[ :bundle | 		bundle removeNonexistentComponents.		bundle isCompletelyEmpty   ifTrue: [ bundle doUnloadFromImage ]		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>content management</category><body package="PackageCategories" selector="anyContentDescriptions">anyContentDescriptions	"Answer a collection of pundle descriptors for any database connection"	dbInfo isEmpty		ifTrue: [ ^#( ) ].	dbInfo size &gt; 1 		ifTrue: [ 	dbInfo removeKey: self noDbSymbol ifAbsent: nil ].	^dbInfo values first contentDescriptions collect:		[ :desc |		desc copyOld			id: nil; 			dbIdentifier: nil;			yourself		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-Component Support" selector="anyFileDescriptions">anyFileDescriptions	"Answer a collection of file descriptors for any database connection"	dbInfo isEmpty ifTrue: [^OrderedCollection new].	dbInfo size &gt; 1 ifTrue: [dbInfo removeKey: self noDbSymbol ifAbsent: nil].	^dbInfo values first fileDescriptions collect: [:each | each copyOld dbTrace: nil]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>content management</category><body package="PackageCategories" selector="addComponent:">addComponent: aComponentDescription	"Add a component to the receiver."	| changed |	changed := false.	self databaseInfomationOrCreate.	self databaseInformationsDo: 		[:eachDatabaseInformation |		changed := (eachDatabaseInformation addComponentDescription: aComponentDescription copyOld) or: [changed]].	(changed and: [self shouldTrackChanges]) ifTrue: 		[self addOtherChange: self structureMark.		Registry changedBundleStructure: self]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>unloading</category><body package="PackageCategories" selector="preUnloadChecksFromBundle:">preUnloadChecksFromBundle: aBundle 	| bundles bnames bundle components |	bundles := Registry enclosingComponentsFor: self.	aBundle notNil 		ifTrue: 			[ bundles remove: aBundle ifAbsent: nil.			components := aBundle allContainedItems				select: [ :c | c isBundle ].			bundles copyOld do: 				[ :b | ( components includes: b ) ifTrue: [ bundles remove: b ] ]			].	bnames := bundles collect: [ :b | b name ].	(self unloadProblemsQuery: bnames header: ((#UnloadingPackageWillModifySomeBundles &lt;&lt; #packages &gt;&gt; 'The package to be unloaded, "&lt;1s&gt;", is contained in the bundles&lt;2s&gt;listed below.  Proceeding will modify these bundles.')			expandMacrosWith: self name			with: (String with: Character cr)))		ifFalse: [^false].	bundle := aBundle == nil		ifTrue: [ self ]		ifFalse: [ aBundle ].	self contents reverseDo: 		[ :comp | 		comp notNil 			ifTrue: 				[ ( comp runPreUnloadFrom: bundle )					ifFalse: [ ^false ]				]		].	^true</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>notifications</category><body package="Store-Repository Access" selector="profileSelected">profileSelected	| profile name |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name] ifNone: [^self].	currentProfileHolder value: profile copyOld.	DbRegistry tablePrefix: profile tableOwner.	(StoreSettings preferenceModelFor: #tablePrefix) value: profile tableOwner</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>instantiating</category><body package="Store-Database Model" selector="instantiateAllOfPackage:requiredFor:">instantiateAllOfPackage: aPackage requiredFor: aPackageModel	"Trace everything that we will need in order to publish a new version, assuming the change set associated with aPackageModel is correct. aPackage should be the trace of aPackageModel and in the same database. Don't worry about getting rid of proxies, because we know this is being read from the current database"	| dbInfo methodList methodNames query parameters nonOptimizedQuery tempMethods batchOfMethodNames|	aPackageModel ifNil: [^self].	dbInfo := aPackageModel databaseInformationFor: aPackage session databaseIdentifier.	dbInfo isNil 		ifTrue: [methodList := #()]		ifFalse: [			dbInfo changeSet isEmpty ifTrue: [^self].			methodList := dbInfo changeSet modifiedMethodDescriptors].	(aPackage methods isGlorpProxy not or: [aPackage methods isInstantiated]) ifTrue: [		"We've already been read. Just go over the changed list of methods to make sure we haven't got any new ones"		self instantiateIndividualMethodsIn: aPackage requiredFor: aPackageModel.		^self].	parameters := aPackage methods parameters.	methodList isEmpty ifFalse: [		methodNames := methodList collect: [:eachMethodDescriptor | eachMethodDescriptor selector].		tempMethods := OrderedCollection new.		"Now we run a query to bring back methods with those names (this may bring back a few too many that haven't changed but have the same name, but that's OK). We really just want to bring these and their source into cache, but hold onto the collection against the off-chance it gets GCd"		1 to: methodNames size by: 100 do: [:i |			batchOfMethodNames := methodNames copyFrom: (i min: methodNames size) to: (i + 99 min: methodNames size).			query := ((aPackage session system descriptorFor: StorePackage) mappingForAttributeNamed: #methods) query copyOld.			query AND: [:each | each definition name in: batchOfMethodNames].			tempMethods add: (query executeWithParameters: parameters in: aPackage session)]].	"Now we force read the methods collection without any optimization as to what to bring back"	nonOptimizedQuery := ((aPackage session system descriptorFor: StorePackage) mappingForAttributeNamed: #methods) query copyOld.	nonOptimizedQuery tracing: nonOptimizedQuery defaultTracing.	nonOptimizedQuery alsoFetch: [:each | each definition].	aPackage privateSetMethods: (nonOptimizedQuery executeWithParameters: parameters in: aPackage session).	tempMethods yourself.	self instantiateEverythingButMethodsOf: aPackage.</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>merge support</category><body package="Store-Merge Management" selector="makeResolutionProposals">makeResolutionProposals	"if the alternatives without the one (if any) associated with the base leaves precisely 	one alternative, that single alternative is the one that becomes the proposed alternative."		resolutions do: [:packageResolutions | packageResolutions makeResolutionProposals].	resolutions do: [:packageResolutions | packageResolutions removeEmptyResolvers].	self resolutions copyOld do:		[:each |		each resolutions isEmpty ifTrue: [resolutions removeKey: each name]].	self detectMoves.</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>private</category><body package="Store-Merge Management" selector="applyUnapplied:">applyUnapplied: aCollection	| errors clone currentChanges |	errors := false.	Refactory.Browser.RefactoryChangeManager undoSize: Refactory.Browser.RefactoryChangeManager undoSize + 1.	clone := Refactory.Browser.RefactoryChangeManager instance copyOld.	aCollection do: 		[:each | 		each apply			ifTrue: 				[each markApplied.				each undoValue ifNotNil: [:value | currentUndos add: value]]			ifFalse: [errors := true]].	Refactory.Browser.RefactoryChangeManager instance resetFrom: clone.	currentChanges := Refactory.Browser.CompositeRefactoryChange named: 		(#MergeChangesApplied1p &lt;&lt; #store &gt;&gt; 'Merge Actions Applied : &lt;1p&gt;' expandMacrosWith: Timestamp now).	currentUndos reverseDo: [:each | currentChanges addChange: each].	Refactory.Browser.RefactoryChangeManager instance addUndo: currentChanges.	^errors</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>accessing</category><body package="Store-Merge Management" selector="affectedBundles">affectedBundles	"Answer a collection of image bundles that were affected by applying modifications.	Meaning, that they have modifications that will be lost.	Make sure these are in semi-Hierarchy order... parents before their children, but siblings in any order	as long as each of their children is 'after' each one somewhere... 	We build this using add: and not addFirst, so the order at the end is reversed.	Given	A		B			C			D		E	First the empty children/build dictionary pass give us E D C, with the dictionary having A and B.	This is a simple optimization to not ever bother to add it to the lookup dictionary used later 	since we know that those with no children are 'before' all others.	Now, we go over the Dictionary keys, and make sure that nothing IN each is also in the remaining targets.	On the first pass, that makes sure B does go in, but A does not (since A contains B)	Finally, A gets added."		| targetBundles sortedBundles previousSize bundleDictionary |	targetBundles := (self bundleModels select: #hasBeenModified) asOrderedCollection.	sortedBundles := OrderedCollection new.	bundleDictionary := Dictionary new.	targetBundles copyOld do: 		[:each | 		| children |		children := (each contentDescriptions select: #isBundle) collect: #component.		children isEmpty			ifTrue: 				[targetBundles remove: each. 				sortedBundles add: each]			ifFalse: [bundleDictionary at: each put: children]].	previousSize := -1.	[targetBundles size &gt; 0 and: [previousSize ~= targetBundles size]] whileTrue:		[previousSize := targetBundles size.		bundleDictionary copyOld keysAndValuesDo:			[:eachBundle :containedBundles |			((bundleDictionary at: eachBundle) contains: [:eachChild | targetBundles includes: eachChild]) ifFalse:				[sortedBundles add: eachBundle. 				targetBundles remove: eachBundle. 				bundleDictionary removeKey: eachBundle]]].	sortedBundles addAll: targetBundles.	^sortedBundles reverse</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>private</category><body package="Store-Merge Management" selector="environmentOrderFor:">environmentOrderFor: aCollectionOfChangeResolvers	| orderedResolvers workingResolvers names workingSize |	orderedResolvers := OrderedCollection new: aCollectionOfChangeResolvers size.	workingResolvers := aCollectionOfChangeResolvers asOrderedCollection.	workingSize := -1.	[workingSize ~= workingResolvers size and: [workingResolvers notEmpty]] whileTrue:		[names := workingResolvers collect: [:each | each definitionName].		workingSize := workingResolvers size.		workingResolvers copyOld do:			[:each |			(names contains: [:eachName | '*.', eachName match: each ownerNameForLoadOrdering ignoreCase: false]) ifFalse:				[orderedResolvers add: each.				workingResolvers remove: each]]].	orderedResolvers addAll: workingResolvers.	^orderedResolvers</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>database utility</category><body package="Store-Database Model" selector="allNamesMatching:inClassNamed:">allNamesMatching: aString inClassNamed: aClassName	"Wildcard search and select for methods that are in a class in the image"	| query session likeString |	likeString := aString copyOld replaceAll: $* with: $%.	session := StoreLoginFactory currentStoreSession.	query := Query		read: self		where: [:eachMethod | (eachMethod name like: likeString) AND: [eachMethod className = aClassName]].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query.</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>database utility</category><body package="Store-Database Model" selector="allNamesMatching:in:">allNamesMatching: aString in: aSessionOrNil		| session query likeString |	likeString := aString copyOld replaceAll: $* with: $%.	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name like: likeString].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	self resolutions do: [:each | each removeEmptyResolvers].	self resolutions copyOld do:		[:each |		each resolutions isEmpty ifTrue: [resolutions removeKey: each name ifAbsent: [nil]].		each isBundleStructureResolver and: [each alternatives isEmpty ifTrue: 			[resolutions size = 1 ifTrue: [resolutions := Dictionary new]]]]</body></methods><methods><class-id>Store.Glorp.PropertyResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	| newResolutions |	newResolutions := resolutions copyOld.	resolutions keysAndValuesDo:		[:key :value |		value alternatives isEmpty ifTrue: [newResolutions removeKey: key].		value applied ifTrue: [newResolutions removeKey: key]].	resolutions := newResolutions.</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopy">postCopy	super postCopy.	definition := definition copyOld.	comment := comment copyOld.</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="allNamesMatching:in:">allNamesMatching: aString in: aSessionOrNil		| session query likeString |	likeString := aString copyOld replaceAll: $* with: $%.	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name like: likeString].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>converting</category><body package="Store-Database Model" selector="classesNamed:">classesNamed: aSetOfNames	"Convert aSetOfnames into a collection of StoreClassesInPackage"		| names selected |	names := aSetOfNames copyOld.	selected := SortedCollection sortBlock: [:each :other | each name &lt; other name].	self classes do:		[:each | 		(names includes: each absoluteName) ifTrue:			[names remove: each absoluteName.			selected add: each]].	names do: [:each | selected add: (ClassDescriptor fullName: each meta: false)].	^selected</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>loading</category><body package="Store-Database Model" selector="loadFailedClasses:">loadFailedClasses: aCollection	aCollection copyOld do:		[:each |		each loadSourceDirect ifNotNil: [aCollection remove: each]]</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>private-utilities</category><body package="Store-Database Model" selector="superclassOrder:">superclassOrder: aCollectionOfStoreClasses	"Sort all of the classes in the list into a collection where no class is preceded by a subclass or 	by its metaclass. I cannot use method in SystemUtils since the classes are not in the image"		| workingCopy orderedClasses classNames |	workingCopy := aCollectionOfStoreClasses copyOld.	orderedClasses := OrderedCollection new.	[workingCopy isEmpty]		whileFalse:			[classNames := workingCopy collect: [:each | each absoluteName].			workingCopy copyOld do:				[:each | 				(each isPseudo not and: [classNames includes: each superclassName])					ifFalse:						[orderedClasses add: each.						workingCopy remove: each]]].	^orderedClasses</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	| newResolutions |	newResolutions := resolutions copyOld.	resolutions keysAndValuesDo:		[:key :value |		value alternatives isEmpty ifTrue: [newResolutions removeKey: key].		value applied ifTrue: [newResolutions removeKey: key]].	resolutions := newResolutions.</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="getState">getState	"Shadow browsers need to have their state initialized with the right environment 	(as do loaded ones until we provide a global access to loaded glorp store models).	Some environments are pundle environments, others are not. Only get pundles for those that are:"	| newState newEnvironment |	newState := super getState.	newEnvironment := environment.	environment isPundleEnvironemt ifTrue:		[newEnvironment := self environment copyOld.		newEnvironment setPundles: self pundles].	newState environment: newEnvironment.	^newState.</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>menus</category><body package="Store-UI" selector="openFilterDialog">openFilterDialog	&lt;menuItem: #(#FilterDots #store 'Filter...')		nameKey: #filterDialog		enablement: true		indication: nil		shortcutKeyCharacter: $F		shortcutModifiers: 8		menu: #(#Packages #Packages)		position: 30.1&gt;	(RepositoryFilterDialog openUsing: self pundleFilter) ifTrue: 		[pundleFilter := PundleFilter lastAppliedFilter copyOld.		self refreshListAndSelections]</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI" selector="implementorsOf:in:">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector asSymbol.	anEnvironment classesDo: 		[:class | 		| storeMetaClass |		((class includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: class]) 			ifTrue: [classDict at: class fullRootName put: selectors copyOld].		storeMetaClass := class isImageObject ifTrue: [class] ifFalse: [class storeMetaClass].		((storeMetaClass includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: storeMetaClass]) 			ifTrue: [metaDict at: storeMetaClass fullRootName put: selectors copyOld]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="recordForStructureTag:">recordForStructureTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there.	Unlike other 'records' for tag objects, we answer a tag with the package(pundle) being me"	^aTag copyOld		package: self; 		yourself</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>loading</category><body package="Store-Database Model" selector="downloadFilesUsing:">downloadFilesUsing: aBundleCompilationResult		| allFiles |	allFiles := self files copyOld.	(self leafItems collect: 		[:each | 		each isBundle			ifTrue: [each files]			ifFalse: [#()]]) do: 				[:each | allFiles addAll: each].	allFiles size &gt; 0 ifFalse: [^self].	Store.Policies filePolicy downloadFiles: allFiles using: aBundleCompilationResult</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>loading</category><body package="Store-Database Model" selector="downloadFiles">downloadFiles		| allFiles |	allFiles := self files copyOld.	(self leafItems collect: 		[:each | 		each isBundle			ifTrue: [each files]			ifFalse: [#()]]) do: 				[:each | allFiles addAll: each].	allFiles size &gt; 0 ifFalse: [^self].	(DownloadingFiles for: self) started.	Store.Policies filePolicy downloadFiles: allFiles.	(DownloadingFiles for: self) finished</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>store faking</category><body package="StoreForGlorpVWUI" selector="asPundleWithComponentDescriptions">asPundleWithComponentDescriptions	"Return a copy of ourselves that has actual store component descriptions instead of our entities. Used in e.g. initializeFromDB: to let Store put things back the way it thinks things ought to be, and not old onto any of our entities. This copy really won't work at all for most purposes. The bundles and packages aren't even going to be dictionaries"	| copy |	copy := self copyOld.	copy privateSetBundles: #().	copy privateSetPackages: (self pundles collect: [:each | each asComponentDescriptionForReal]).	copy privateSetFiles: (self files collect: [:each | each asComponentDescriptionForReal]).	^copy.</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>full classes</category><body package="Store-Database Model" selector="generateFullClasses">generateFullClasses	"We can't just gather up my sub component items, because there may be (multiple) extension methods	So what we do, is we we create our own dictionary and fill or combine as needed, careful to copy	things since each sub package keeps its own dictionary of items we don't want to munge"	| gatheredClasses |	gatheredClasses := Dictionary new.	self containedItems do: 		[:each |		each fullClasses keysAndValuesDo: 			[:key :value |			| currentClass |			currentClass := gatheredClasses at: key ifAbsent: [nil].			currentClass isNil				ifTrue: [gatheredClasses at: key put: value copyOld]				ifFalse: [currentClass addAllFrom: value]]].	^gatheredClasses</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="augmentTextFieldController:">augmentTextFieldController: aController	"Provide additional tuning of the text controller used in the '#text' widget (the widget where we display the selected object's printStrings)."		| menu copyItem |	aController		initializeMenuForCode;		autoAccept: false.	menu := aController menu copyOld.	copyItem := menu menuItemWithValue: #copySelection.	menu := Menu new.	menu addItem: copyItem.	aController menuHolder value: menu</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI" selector="fieldListMenu">fieldListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #fieldListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Inspect 					#defaultString: '&amp;Inspect' 					#catalogID: #menus ) 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Dive 					#defaultString: '&amp;Dive' 					#catalogID: #menus ) 				#nameKey: #dive 				#value: #dive ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Back 					#defaultString: '&amp;Back' 					#catalogID: #menus ) 				#nameKey: #back 				#value: #back 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #navigatePrevious ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#nameKey: #editSelectAll 				#value: #selectAllFields 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #selectFields ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#nameKey: #copyOld 				#value: #copySelection 				#enablementSelector: #canCopy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Refresh 					#defaultString: '&amp;Refresh' 					#catalogID: #menus ) 				#nameKey: #refresh 				#value: #refresh ) ) #(3 1 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>printing</category><body package="Store-Database Model" selector="fileOutMethodsOn:">fileOutMethodsOn: aSourceFileManager	| allMethods |	allMethods := self instanceMethods copyOld.	allMethods addAll: self classMethods.	allMethods do:		[:each | each fileOutSourceOn: aSourceFileManager]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="asPundleWithComponentDescriptions">asPundleWithComponentDescriptions	"I should never be sent!"	| copy |	copy := self copyOld.	^copy.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>reconciling</category><body package="Store-Database Model" selector="propertiesMatch">propertiesMatch	| previousProperties myProperties previousSize mySize |	self previous isNil ifTrue: [^false].	previousProperties := self previous properties copyOld.	Dialect volatilePropertyKeys do: [:each | previousProperties removeKey: each ifAbsent: []].	myProperties := self properties.	myProperties isNil ifTrue: [^previousProperties == myProperties].	myProperties keysAndValuesDo: [:eachKey :eachValue |		(self ignorableProperties includes: eachKey)			ifFalse: [				(previousProperties at: eachKey ifAbsent: [Object new]) = eachValue					ifFalse: [^false]]].	previousSize := 0.	previousProperties keysDo: [:eachKey | (self ignorableProperties includes: eachKey) ifFalse: [previousSize := previousSize + 1]].	mySize := 0.	myProperties keysDo: [:eachKey | (self ignorableProperties includes: eachKey) ifFalse: [mySize := mySize + 1]].	^mySize = previousSize.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="Store-Database Model" selector="propertiesForFileOut">propertiesForFileOut	^self properties copyOld.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="recordForPropertyTag:">recordForPropertyTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there.	Unlike other 'records' for tag objects, we answer a tag with the package(pundle) being me"		^(self properties includesKey: aTag property)		ifFalse: [nil]		ifTrue:			[(aTag copyOld)				package: self;				yourself]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="propertiesWithoutVolatileKeys">propertiesWithoutVolatileKeys	| propertiesCopy |	propertiesCopy := self properties copyOld.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesCopy removeKey: each ifAbsent: [nil]].	^propertiesCopy</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>query utility</category><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:usingPundleFilter:">allVersionsInitiallyNamed: aString in: aSession usingPundleFilter: aPundleFilter	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order	with optional range of blessing(s) and date(s)"	| session query sameNamed otherNames result oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	aPundleFilter applyFilterToQuery: query.	query orderBy: [:each | each timestamp descending].	(sameNamed := session execute: query) isEmpty ifTrue: [^#()].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed 		inject: OrderedCollection new		into: 			[:sum :each |			(each parent notNil and: 				[each parent name ~= aString and: 					[(sum includes: each parent name) not]])					ifTrue: [sum add: each parent name].			sum].	result := otherNames 		copyOld inject: sameNamed copyOld		into: 			[:sum :each |			sum , (self 				allVersionsInitiallyNamed: each				in: aSession				notIn: ((otherNames copyOld) add: aString; yourself)				olderThan: oldestTimestamp				usingPundleFilter: aPundleFilter)].	^result sorted: [:each :other | each timestamp &gt; other timestamp]</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>query utility</category><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:">allVersionsInitiallyNamed: aString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query sameNamed otherNames result oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	(sameNamed := session execute: query) isEmpty ifTrue: [^#()].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed inject: OrderedCollection new into:		[:sum :each |		(each parent notNil and: [each parent name ~= aString and: [(sum includes: each parent name) not]])			ifTrue: [sum add: each parent name].		sum].	result := otherNames copyOld inject: sameNamed copyOld into:		[:sum :each |		sum, (self allVersionsInitiallyNamed: each in: aSession notIn: (otherNames copyOld add: aString; yourself) olderThan: oldestTimestamp)].	^result sorted: [:each :other | each timestamp &gt; other timestamp]</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>private</category><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:notIn:olderThan:usingPundleFilter:">allVersionsInitiallyNamed: aString in: aSession notIn: aCollection olderThan: aTimeStamp usingPundleFilter: aPundleFilter	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order	with optional range of blessing(s) and date(s)"		| session query sameNamed otherNames oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString AND: each timestamp &lt;= aTimeStamp].	aPundleFilter applyFilterToQuery: query.	query orderBy: [:each | each timestamp descending].	sameNamed := session execute: query.	sameNamed isEmpty ifTrue: [^sameNamed].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed		inject: OrderedCollection new		into:			[:sum :each | 			(each parent notNil and: 				[each parent name ~= aString and: 				[(sum includes: each parent name) not and: 				[(aCollection includes: each parent name) not]]])					ifTrue: [sum add: each parent name].			sum].	^otherNames copyOld		inject: sameNamed copyOld		into:			[:sum :each | 			sum , (self 				allVersionsInitiallyNamed: each 				in: aSession 				notIn: aCollection , otherNames 				olderThan: oldestTimestamp 				usingPundleFilter: aPundleFilter)]</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>private</category><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:notIn:olderThan:">allVersionsInitiallyNamed: aString in: aSession notIn: aCollection olderThan: aTimeStamp	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"		| session query sameNamed otherNames oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString AND: each timestamp &lt;= aTimeStamp].	query orderBy: [:each | each timestamp descending].	sameNamed := session execute: query.	sameNamed isEmpty ifTrue: [^sameNamed].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed		inject: OrderedCollection new		into:			[:sum :each | 			(each parent notNil and: [each parent name ~= aString and: [(sum includes: each parent name) not and: [(aCollection includes: each parent name) not]]])				ifTrue: [sum add: each parent name].			sum].	^otherNames copyOld		inject: sameNamed copyOld		into:			[:sum :each | 			sum , (self allVersionsInitiallyNamed: each in: aSession notIn: aCollection , otherNames olderThan: oldestTimestamp)]</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI" selector="implementorsOf:in:">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector asSymbol.	anEnvironment classesDo: 		[:class | 		| storeMetaClass |		((class includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: class]) 			ifTrue: [classDict at: class fullRootName put: selectors copyOld].		storeMetaClass := class isImageObject ifTrue: [class] ifFalse: [class storeMetaClass].		((storeMetaClass includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: storeMetaClass]) 			ifTrue: [metaDict at: storeMetaClass fullRootName put: selectors copyOld]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopy">postCopy	super postCopy.	mainClass := mainClass copyOld.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource		| allMethods |	self classDefinition ifNotNil: [self classDefinition loadSource].	allMethods := self instanceMethods copyOld.	allMethods addAll: self classMethods.	allMethods do: [:each | each loadSource].	self sharedVariables do: [:each | each loadSource].</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopy">postCopy	super postCopy.	instanceMethods := instanceMethods copyOld.	classMethods := classMethods copyOld.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>adding</category><body package="Store-Database Model" selector="addAllFrom:">addAllFrom: aStoreClassExtension	"We don't just add them all, since the values might be held onto, so we make a copy of our values	Just to make sure new values don't bleed into other owners.	Because of the possible existance of overrides, we do this the hard way. Overriden (last) gets priority"	| newMethods |	newMethods := OrderedSet withAll: aStoreClassExtension classMethods.	newMethods addAll: classMethods.	classMethods := newMethods.	newMethods := OrderedSet withAll: aStoreClassExtension instanceMethods.	newMethods addAll: instanceMethods.	instanceMethods := newMethods.	sharedVariables := sharedVariables copyOld. 	sharedVariables addAll: aStoreClassExtension sharedVariables.	(classDefinition isNil and: [aStoreClassExtension classDefinition notNil])		ifTrue: [classDefinition := aStoreClassExtension classDefinition].	metaclass := StoreMetaclassExtension on: self</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private</category><body package="Store-Merge Management" selector="resolveToText">resolveToText	selectedResolution isNil 		ifTrue: [self packageSelectionChanged]		ifFalse: 			[| packageModel resolution textController parseSucceeded | 			selectedResolution isApplyable ifFalse: [^self packageSelectionChanged].			selectedResolution isResolver ifFalse: [^self packageSelectionChanged].			packageModel := self packageForAccept.			packageModel isNil ifTrue: [^self packageSelectionChanged].			textController := (self builder componentAt: #displayTextID) widget controller.			Policies packagePolicy 				forcePackage: packageModel 				while: [parseSucceeded := selectedResolution parseText: textController text].			parseSucceeded ifFalse: [^self packageSelectionChanged].			self text: textController text copyOld.			resolution := UserInputResolution				forPackage: packageModel				text: textController text copyOld.			selectedResolution isMethodResolver ifTrue:				[resolution protocol: (self protocolStringOfSelectedResolutionFrom: self currentResolutionPackageItem)].			selectedResolution addAlternative: resolution.			selectedResolution proposed: resolution.			selectedResolution applied: false.			selectedResolution isMove ifTrue: 				[selectedResolution movePair movePair: nil.				selectedResolution movePair: nil].			self updateResolutionsWithoutRebuild]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private</category><body package="Store-Merge Management" selector="environmentOrderFor:">environmentOrderFor: aCollectionOfChangeResolvers	| orderedResolvers workingResolvers names workingSize |	orderedResolvers := OrderedCollection new: aCollectionOfChangeResolvers size.	workingResolvers := aCollectionOfChangeResolvers asOrderedCollection.	workingSize := -1.	[workingSize ~= workingResolvers size and: [workingResolvers notEmpty]] whileTrue:		[names := workingResolvers collect: [:each | each definitionName].		workingSize := workingResolvers size.		workingResolvers copyOld do:			[:each |			(names contains: [:eachName | '*.', eachName match: each ownerNameForLoadOrdering ignoreCase: false]) ifFalse:				[orderedResolvers add: each.				workingResolvers remove: each]]].	orderedResolvers addAll: workingResolvers.	^orderedResolvers</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>accessing</category><body package="Store-Database Model" selector="newVersion">newVersion	| copy |	copy := self copyOld.	copy previous: self.	^copy</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	| newResolutions |	newResolutions := resolutions copyOld.	resolutions keysAndValuesDo:		[:key :value |		value isProposedRemovalNotInPackage ifTrue: [newResolutions removeKey: key ifAbsent: [nil]].		value alternatives isEmpty ifTrue: [newResolutions removeKey: key ifAbsent: [nil]].		value applied ifTrue: [newResolutions removeKey: key ifAbsent: [nil]]].	resolutions := newResolutions.</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>resources</category><body package="Store-UI" selector="textMenu">textMenu	"Tools.MenuEditor new openOnClass: self andSelector: #textMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#nameKey: #copySelection 				#value: #copySelection 				#enablementSelector: #atLeastOnePundleVersionSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copyOld ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #find 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #findNext 				#value: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAll 					#defaultString: 'Select All' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #selectEntireText 				#value: #selectEntireText ) ) #(1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>action</category><body package="Atomic Compiling and Loading" selector="retryUnloadablesFor:">retryUnloadablesFor: aCompilationResult	"A bit of recursion... If the result is for bundle, we recurse in until they are for individual packages"	aCompilationResult isForBundle ifTrue: [^aCompilationResult results do: [:each | self retryUnloadablesFor: each]].	aCompilationResult unloadableDefinitions copyOld do:		[:each | 		| packageModel |		packageModel := each parameter package			ifNil: [aCompilationResult package storeModel]			ifNotNil: [:value | value storeModel].		([each parameter loadSourceInto: packageModel]			on: Error			do: [:exception | exception return]) ifNotNil:				[:value | 				(each parameter isForMethod and: [each parameter isMeta and: [each parameter selector = #initialize]])					ifTrue: [each parameter correspondingImageClass instanceBehavior postLoad: packageModel].				aCompilationResult unloadableDefinitions remove: each]].	aCompilationResult unloadableDefinitions isEmpty ifTrue: [aCompilationResult pundle storeModel markNotModified]</body></methods><methods><class-id>XML.SAXBuilderDriver</class-id> <category>content handler</category><body package="XML" selector="startElement:localName:qName:attributes:">startElement: namespaceURI localName: localName qName: name attributes: attributes	| nm |	document == nil ifTrue: [self startDocument].	nm := NodeTag new		qualifier: ((name includes: $:)				ifTrue: [name copyUpTo: $:]				ifFalse: [''])		ns: namespaceURI		type: localName.	elementStack addLast: (SAXElementContext new tag: nm).	elementStack last		attributes: (attributes collect: [:att | att copyOld]);		nodes: OrderedCollection new;		namespaces: newNamespaces.	newNamespaces := nil.	builder pushTag: nm.</body></methods><methods><class-id>XML.ChoicePattern</class-id> <category>copying</category><body package="XML" selector="postCopy">postCopy	super postCopy.	items := items collect: [:i | i copyOld].</body></methods><methods><class-id>XML.ModifiedPattern</class-id> <category>copying</category><body package="XML" selector="postCopy">postCopy	super postCopy.	node := node copyOld</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>private</category><body package="XML-source" selector="selectorFor:">selectorFor: aTag	^selectors at: aTag ifAbsentPut:			[| t |			t := aTag type copyOld replaceAll: $: with: $_.			t replaceAll: $. with: $_.			t replaceAll: $- with: $_.			('compile_', t, ':') asSymbol]</body></methods><methods><class-id>XML.SequencePattern</class-id> <category>copying</category><body package="XML" selector="postCopy">postCopy	super postCopy.	items := items collect: [:i | i copyOld].</body></methods><methods><class-id>XML.MixedPattern</class-id> <category>copying</category><body package="XML" selector="postCopy">postCopy	super postCopy.	items := items collect: [:i | i copyOld].</body></methods><methods><class-id>XML.AttributeType</class-id> <category>validating</category><body package="XML" selector="simpleValidateValueOf:for:">simpleValidateValueOf: anAttribute for: aParser	| v |	v := anAttribute value copyOld.	v replaceAll: Character cr with: Character space.	v replaceAll: Character lf with: Character space.	v replaceAll: Character tab with: Character space.	anAttribute value: v</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>private</category><body package="XML-source" selector="selectorFor:">selectorFor: aTag	^selectors at: aTag ifAbsentPut:			[| t |			t := aTag type copyOld replaceAll: $: with: $_.			t replaceAll: $. with: $_.			t replaceAll: $- with: $_.			('scan_', t, ':') asSymbol]</body></methods><methods><class-id>XML.SAXCanonicalWriter</class-id> <category>private</category><body package="XML" selector="emitNotation:">emitNotation: array	| sysID frag |	sysID := array at: 3.	sysID == nil ifTrue: [^super emitNotation: array].	sysID size to: 2 by: -1 do: [:i |		frag := sysID copyFrom: i to: sysID size.		frag replaceAll: $: with: $/.		frag replaceAll: $\ with: $/.		([(baseURI resolvePath: frag) asString = sysID] on: Error do: [:x | x return: false])			ifTrue: [^super emitNotation: (array copyOld at: 3 put: frag; yourself)]].	super emitNotation: array</body></methods><methods><class-id>XML.DocumentType</class-id> <category>printing</category><body package="XML" selector="printCanonicalOn:">printCanonicalOn: aStream	"Jumping through hoops to get Notations printed	just as Sun desires--Are public IDs really supposed	to have their white space normalized? If so, we	should move normalization to the parser."	| s s1 |	notations isEmpty ifTrue: [^self].	aStream nextPutAll: '&lt;!DOCTYPE ';		nextPutAll: declaredRoot asString;		nextPutAll: ' ['; cr.	(notations asSortedCollection: [:n1 :n2 | n1 name &lt; n2 name])		do: [:n |			aStream nextPutAll: '&lt;!NOTATION ';				nextPutAll: n name; space.			n publicID == nil				ifTrue: [aStream nextPutAll: 'SYSTEM']				ifFalse:					[s := n publicID copyOld.					s replaceAll: Character cr with: Character space.					s replaceAll: Character lf with: Character space.					s replaceAll: Character tab with: Character space.					[s1 := s copyReplaceAll: '  ' with: ' '.					s1 = s] whileFalse: [s := s1].					aStream						nextPutAll: 'PUBLIC ''';						nextPutAll: s;						nextPut: $'].			n systemID == nil				ifFalse: [aStream						nextPutAll: ' ''';						nextPutAll: n systemID;						nextPut: $'].			aStream nextPutAll: '&gt;'; cr].	aStream nextPutAll: ']&gt;'; cr.</body></methods><methods><class-id>Core.StringParameterSubstitution</class-id> <category>accessing</category><body package="Collections-Text" selector="map:using:">map: descriptionCharacter using: aTwoArgBlock	"Store the mapping between a character and the block	that describes how to transform an argument into a substring.	The block takes two arguments--the transformer (i.e., the	reciever), and the index of the argument to be rendered.	We copy the mapping table before modifying it, so that	other instances that share the same table won't be side-	effected by the change."	argumentTypeMapping := argumentTypeMapping copyOld.	argumentTypeMapping at: descriptionCharacter put: aTwoArgBlock</body></methods><methods><class-id>Core.StringParameterSubstitution class</class-id> <category>defaults</category><body package="Collections-Text" selector="default">default	^Default copyOld</body></methods><methods><class-id>Core.IntegerArray</class-id> <category>external copying</category><body package="Collections-Arrayed" selector="copyToHeap:">copyToHeap: mallocSelector 	"Copy the receiver to the external heap. The argument is a method 	selector that accepts one argument and determines how to allocate 	data for the receiver -- it is typically one of #malloc: or #malloc16:. 	The selector's argument is the number of objects of the receiver's 	baseCType to allocate. Answer a pointer to the data. If the allocation 	fails a primitive failed signal is raised."	| aPointer currentPointer size |	aPointer := self baseCType referentType perform: mallocSelector with: self basicSize.	currentPointer := aPointer copyOld.	size := self size.	1 to: size		do: 			[:index | 			currentPointer contents: (self at: index).			currentPointer += 1].	^aPointer</body></methods><methods><class-id>Core.RunArray</class-id> <category>copying</category><body package="Collections-Arrayed" selector="postCopy">postCopy	super postCopy.	runs := runs copyOld.	values := values copyOld</body></methods><methods><class-id>Core.RunArray</class-id> <category>copying</category><body package="Collections-Arrayed" selector=",">, aRunArray	"Answer a new RunArray that is a concatenation of the receiver and	aRunArray. "	| new copySize newRuns newValues index |	(aRunArray isKindOf: RunArray)		ifFalse:			[new := self copyOld.			"attempt to be sociable"			aRunArray do: [:each | new addLast: each].			^new].	runs size = 0 ifTrue: [^aRunArray copyOld].	aRunArray runs size = 0 ifTrue: [^self copyOld].	"Compute size of runs/values in result."	copySize := runs size + aRunArray runs size.	(values last = aRunArray values first) ifTrue:		["runs at boundary will be merged"		copySize := copySize - 1].	newRuns := Array new: copySize.	newValues := Array new: copySize.	"copy self into result"	index := self				copyFromRun: 1				offset: 0				toRun: runs size				offset: runs last - 1				intoRuns: newRuns				values: newValues				startingAt: 1.	"copy argument into result"	aRunArray		copyFromRun: 1		offset: 0		toRun: aRunArray runs size		offset: aRunArray runs last - 1		intoRuns: newRuns		values: newValues		startingAt: index.	^self class runs: newRuns values: newValues</body></methods><methods><class-id>Core.RunArray</class-id> <category>enumerating</category><body package="ExternalWebBrowser-Text" selector="collect:">collect: aBlock	"Assume that the result is to have the same run layout as the reciever and visit the value for each span only once."	^self class		runs: runs copyOld		values: (values collect: aBlock)</body></methods><methods><class-id>Core.LaggedFibonacciRandom</class-id> <category>copying</category><body package="Magnitude-Numbers" selector="postCopy">postCopy	"The values need to be copied because if not copies	can affect the behavior of the original object after	sufficient values are answered"	super postCopy.	self values: self values copyOld</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>reading Locale</category><body package="Internationalization" selector="readLocaleDataOfType:for:">readLocaleDataOfType: aSymbol for: aStream	"Values expected for aSymbol are: 	#time 	#date 	#stamp"	"Depending upon the type of object request, 	this method answers either a Time, a Date, or a Timestamp."	| policy fieldNumber policyStream delimiterToken weekday month day year hour minute second millisecond ampm createdDate createdTime createdTimestamp aStreamPosition offsetFromUTC |	aStreamPosition := aStream position.	self propertyAt: #withoutAnomalies put: true.	#(#custom #full #long #medium #short #editing #timeEditing #iso8601 #iso8601Enhanced)		do: 			[:policyFormatNameSymbol |			| workStream |			weekday := month := day := year := hour := minute := second := millisecond := createdDate := createdTime := createdTimestamp := nil.			workStream := aStream copyOld.			workStream position: aStreamPosition.			policy := printPolicy policyNamed: policyFormatNameSymbol ifAbsent: [nil].			policy isNil				ifTrue: [self propertyAt: #withoutAnomalies put: false]				ifFalse: 					[self propertyAt: #withoutAnomalies put: true.					aSymbol == #stamp ifTrue: [fieldNumber := 1].					aSymbol == #date ifTrue: [fieldNumber := 2].					aSymbol == #time ifTrue: [fieldNumber := 3].					policy := printPolicy fieldFormat: fieldNumber for: policy.					policy notNil						ifTrue: 							[policy := self groomPolicy: policy.							"policy := policy copyWithoutWhitespace."							policyStream := policy readStream.							self propertyAt: #withoutAnomalies put: true.							second := 0.							millisecond := 0.							policyStream do: 									[:token |									| isAlphameric isNumeric outputPossibilities inputString |									inputString := nil.									(self propertyAt: #withoutAnomalies)										ifTrue: 											[delimiterToken := nil.											outputPossibilities := OrderedCollection new.											(token isKindOf: PrintFormatToken)												ifTrue: 													["First find out what kind of output this token generates."													isAlphameric := false.													isNumeric := false.													isNumeric := #($y $Y $b $w $f $d $j $G $a $i $h $k $l $m $s $n $c $u)																includes: token selectorCharacter.													isNumeric														ifFalse: [isAlphameric := #($B $A $p) includes: token selectorCharacter].													"If output is generated from a set of possibilities, look at that set for matching."													(printPolicy tokenInterpretationDispatchTable at: token selectorCharacter)														value: token														value: outputPossibilities.													outputPossibilities isEmpty														ifFalse: 															[(#($r) includes: token selectorCharacter)																ifFalse: 																	[inputString := self																				accessInputForToken: token																				usingLiteralPossibilities: outputPossibilities																				fromStream: workStream]																ifTrue: 																	[inputString := self																				accessInputForToken: token																				usingSymbolicPossibilities: outputPossibilities																				fromStream: workStream].	"Time zone offsets have multiple wildcarded formats."															(self propertyAt: #withoutAnomalies)																ifTrue: 																	["The days of the week and the months of the year may come from lists."																	(#($r) includes: token selectorCharacter)																		ifTrue: [offsetFromUTC := inputString copyOld].																	(#($A $a) includes: token selectorCharacter)																		ifTrue: [weekday := inputString copyOld].																	(#($b $B) includes: token selectorCharacter)																		ifTrue: [month := inputString copyOld].																	token selectorCharacter = $p ifTrue: [ampm := inputString copyOld]]]														ifTrue: 															["output possibilities is empty..."															"Then find out what delimits this token's output."															policyStream atEnd																ifFalse: 																	[delimiterToken := policyStream peek	"Read workStream up to this marker."]																ifTrue: [delimiterToken := nil	"End of stream"].															delimiterToken notNil																ifTrue: 																	[(delimiterToken isKindOf: PrintFormatToken)																		ifFalse: 																			["Then read workStream to see if current content matches our expectations."																			inputString := workStream upTo: delimiterToken.																			workStream position - 1 &gt; 0																				ifTrue: [workStream skip: -1]																				ifFalse: [self propertyAt: #withoutAnomalies put: false].																			"If the content type does not match that of the format, this is an 									anomaly."																			(isNumeric and: [(self isStringNumeric: inputString) not])																				ifTrue: [self propertyAt: #withoutAnomalies put: false].																			(self propertyAt: #withoutAnomalies)																				ifTrue: 																					[(#($d $j $f $G) includes: token selectorCharacter)																						ifTrue: [day := inputString copyOld].																					(#($y $Y $u) includes: token selectorCharacter)																						ifTrue: [year := inputString copyOld].																					(#($i $h $k $l) includes: token selectorCharacter)																						ifTrue: [hour := inputString copyOld].																					(#($m) includes: token selectorCharacter)																						ifTrue: [minute := inputString copyOld].																					(#($s) includes: token selectorCharacter)																						ifTrue: [second := inputString copyOld].																					(#($n $c) includes: token selectorCharacter)																						ifTrue: 																							[aSymbol = #stamp																								ifTrue: [millisecond := inputString copyOld]																								ifFalse: [workStream skip: (inputString size + 1) * -1]].																					month isNil																						ifTrue: 																							[(#($b $B) includes: token selectorCharacter)																								ifTrue: [month := inputString copyOld]]]]																		ifTrue: 																			[isNumeric ifTrue: [inputString := workStream next: token numericModifier].																			(isNumeric and: [(self isStringNumeric: inputString) not])																				ifTrue: [self propertyAt: #withoutAnomalies put: false].																			(self propertyAt: #withoutAnomalies)																				ifTrue: 																					[(#($d $j $f $G) includes: token selectorCharacter)																						ifTrue: [day := inputString copyOld].																					(#($y $Y $u) includes: token selectorCharacter)																						ifTrue: [year := inputString copyOld].																					(#($i $h $k $l) includes: token selectorCharacter)																						ifTrue: [hour := inputString copyOld].																					(#($m) includes: token selectorCharacter)																						ifTrue: [minute := inputString copyOld].																					(#($s) includes: token selectorCharacter)																						ifTrue: [second := inputString copyOld].																					(#($n $c) includes: token selectorCharacter)																						ifTrue: 																							[aSymbol = #stamp																								ifTrue: [millisecond := inputString copyOld]																								ifFalse: [workStream skip: (inputString size + 1) * -1]].																					month isNil																						ifTrue: 																							[(#($b $B) includes: token selectorCharacter)																								ifTrue: [month := inputString copyOld]]]]]																ifFalse: 																	["Delimiter token is nil, which means we have reached the end of the stream."																	"Then read aStream to see if current content matches our expectations."																	inputString := workStream upToEnd.																	"If the content type does not match that of the format, this is an 								anomaly."																	(isNumeric and: [(self isStringNumeric: inputString) not])																		ifTrue: [self propertyAt: #withoutAnomalies put: false].																	(self propertyAt: #withoutAnomalies)																		ifTrue: 																			[(#($d $j $f $G) includes: token selectorCharacter)																				ifTrue: [day := inputString copyOld].																			(#($y $Y $u) includes: token selectorCharacter)																				ifTrue: [year := inputString copyOld].																			(#($i $h $k $l) includes: token selectorCharacter)																				ifTrue: [hour := inputString copyOld].																			(#($m) includes: token selectorCharacter)																				ifTrue: [minute := inputString copyOld].																			(#($s) includes: token selectorCharacter)																				ifTrue: [second := inputString copyOld].																			(#($n $c) includes: token selectorCharacter)																				ifTrue: 																					[aSymbol = #stamp																						ifTrue: [millisecond := inputString copyOld]																						ifFalse: [workStream skip: (inputString size + 1) * -1]].																			month isNil																				ifTrue: 																					[(#($b $B) includes: token selectorCharacter)																						ifTrue: [month := inputString copyOld]]]]]]												ifFalse: 													["If not a PrintFormatToken, token must be a character."													token = workStream next														ifFalse: [self propertyAt: #withoutAnomalies put: false]]]	"Without anomalies"]	"Policystream processing."]	"Policy notNil - narrow"].	"Policy notNil - wide"			(self propertyAt: #withoutAnomalies)				ifTrue: 					["Create and answer the requested object here."					(aSymbol = #date or: [aSymbol = #stamp])						ifTrue: 							[(month respondsTo: #string)								ifTrue: 									[(self isStringNumeric: month string)										ifFalse: [month := self indexOfMonth: month string]										ifTrue: [month := month string asNumber]].							(day respondsTo: #string) ifTrue: [day := day string asNumber].							(year respondsTo: #string) ifTrue: [year := year string asNumber].							((day isInteger and: [month isInteger]) and: [year isInteger])								ifTrue: 									["Y2K check, in case they entered a two-digit year. This code used to live in Date&gt;&gt;newDay:monthNumber:year:"									year &lt; 100 ifTrue: [year := Date today year // 100 * 100 + year].									createdDate := Date newDay: day monthNumber: month year: year]								ifFalse: [createdDate := nil]].					(aSymbol = #time or: [aSymbol = #stamp])						ifTrue: 							[(hour respondsTo: #string) ifTrue: [hour := hour string asNumber].							(minute respondsTo: #string) ifTrue: [minute := minute string asNumber].							(second respondsTo: #string) ifTrue: [second := second string asNumber].							(millisecond respondsTo: #string)								ifTrue: [millisecond := millisecond string asNumber].							"Check for AM or PM. 		If hour = 12 and AM, change hour to 0.		if hour &lt; 12 and PM, add 12 to hour."							ampm notNil								ifTrue: 									[| matched |									matched := false.									((printPolicy shortAmPm at: 1) match: ampm)										ifTrue: 											[hour = 12 ifTrue: [hour := 0].											ampm := printPolicy shortAmPm at: 1.											matched := true].									matched										ifFalse: 											[((printPolicy shortAmPm at: 2) match: ampm)												ifTrue: 													[hour &lt; 12 ifTrue: [hour := hour + 12].													ampm := printPolicy shortAmPm at: 2.													matched := true]].									matched										ifFalse: 											[((printPolicy longAmPm at: 1) match: ampm)												ifTrue: 													[hour = 12 ifTrue: [hour := 0].													ampm := printPolicy longAmPm at: 1.													matched := true]].									matched										ifFalse: 											[((printPolicy longAmPm at: 2) match: ampm)												ifTrue: 													[hour &lt; 12 ifTrue: [hour := hour + 12].													ampm := printPolicy longAmPm at: 2]]].							(hour &gt;= 0 and: [hour &lt;= 23])								ifFalse: 									[self error: (#errNotValidHour &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is not a valid hour'												expandMacrosWith: hour)].							(minute &gt;= 0 and: [minute &lt;= 59])								ifFalse: 									[self										error: (#errNotValidMinute &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is not a valid minute'												expandMacrosWith: minute)].							(second &gt;= 0 and: [second &lt;= 59])								ifFalse: 									[self										error: (#errNotValidSecond &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is not a valid second'												expandMacrosWith: second)].							(millisecond &gt;= 0 and: [millisecond &lt;= 999])								ifFalse: 									[self										error: (#errNotValidMillisecond &lt;&lt; #dialogs												&gt;&gt; '&lt;1p&gt; is not a valid millisecond' expandMacrosWith: millisecond)].							createdTime := Time fromSeconds: 60 * (60 * hour + minute) + second].					aSymbol = #date						ifTrue: 							[createdDate notNil								ifTrue: 									[aStream position: workStream position.									^createdDate]].					aSymbol = #time						ifTrue: 							[createdTime notNil								ifTrue: 									[aStream position: workStream position.									^createdTime]].					aSymbol = #stamp						ifTrue: 							[createdTimestamp := Timestamp new fromDate: createdDate										andTime: createdTime.							createdTimestamp notNil								ifTrue: 									[createdTimestamp millisecond: millisecond.									aStream position: workStream position.									^createdTimestamp]]]	"withoutAnomalies true"].	"policyFormatNameSymbols do"	"Fallback: if using the policy format to parse the textual representation has failed, 	try the readLatin methods. If these cannot understand the textual representation,	they will fail with an error dialog as always."	aStream position: aStreamPosition.	aSymbol = #date ifTrue: [^self readLatinDateFrom: aStream].	aSymbol = #time ifTrue: [^self readLatinTimeFrom: aStream].	aSymbol = #stamp ifTrue: [^self readLatinTimestampFrom: aStream].	^nil	"Error - and we should not ever get here, because the fallback above should handle failures in the classic manner."</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>private</category><body package="Internationalization" selector="accessInputForToken:usingLiteralPossibilities:fromStream:">accessInputForToken: token usingLiteralPossibilities: outputPossibilities fromStream: workStream	"Answers the inputString derived, or nil if not possible to answer a value."	"If we have multiple match possibilities, we want to take the one closest to our location in the stream."	| matchDictionary lowestValue inputString match keepKey keyValue |	match := false.	matchDictionary := Dictionary new.	outputPossibilities do: 			[:eachValue |			| matchLocation aString |			aString := workStream copyOld contents.			matchLocation := aString indexOfSubCollection: eachValue						startingAt: workStream position + 1.			matchLocation &gt; 0				ifTrue: 					[(aString copyFrom: matchLocation to: matchLocation + eachValue size - 1)						= eachValue							ifTrue: 								[match := true.								matchDictionary at: eachValue copyOld put: matchLocation + 0]]].	match		ifFalse: [self propertyAt: #withoutAnomalies put: false]		ifTrue: 			[lowestValue := nil.			matchDictionary keysAndValuesDo: 					[:key :value |					lowestValue isNil						ifTrue: [lowestValue := value]						ifFalse: [value &lt; lowestValue ifTrue: [lowestValue := value]]].			"Exclude shorter matches at duplicated locations as substrings found in error."			matchDictionary copyOld keysAndValuesDo: 					[:key :value |					value = lowestValue						ifTrue: 							[keepKey isNil								ifTrue: [keepKey := key]								ifFalse: [key size &gt; keepKey size ifTrue: [keepKey := key]]]].			lowestValue = (workStream position + 1)				ifTrue: 					[keyValue := keepKey.					inputString := workStream next: keyValue size.					inputString = keyValue						ifFalse: 							[match := false.							self propertyAt: #withoutAnomalies put: false]]].	^inputString</body></methods><methods><class-id>Core.WeakDictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopy">postCopy	super postCopy.	valueArray addDependent: self.	executors := executors copyOld.	accessLock := RecursionLock new</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Collections-Arrayed" selector="literalArrayEncoding">literalArrayEncoding	"Return a literal suitable for reconstituting the receiver."	^self copyOld</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Collections-Arrayed" selector="asStringEncoding:">asStringEncoding: encoding	"Convert self encoded in encoding to Unicode string."	| map cache |	cache := LastDecodeMap.	cache key == encoding		ifTrue: [map := cache value]		ifFalse:			[map := Lock critical:					[Decodings at: encoding ifAbsent: [#createMap]].			map == #createMap				ifTrue: [map := self class createDecodeMapFor: encoding].			map == nil				ifFalse: [LastDecodeMap := encoding -&gt; map]].	map == #identityMap		ifTrue: [^self copyOld changeClassToThatOf: ''].	^map == nil		ifTrue: [String fromIntegerArray: self encoding: encoding]		ifFalse: [self asStringFromMap: map encoding: encoding]</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Collections-Arrayed" selector="asByteString">asByteString	"Answer an instance of ByteString which is = to self."	^self copyOld changeClassTo: ByteString</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>bit manipulation</category><body package="Magnitude-Numbers" selector="bitAt:put:">bitAt: i put: k	"Set the bit at the ith position.  Only k's first bit is considered"	| answer digitIndex bitIndex newDigit |	answer := self copyOld.	digitIndex := i - 1 // 8 + 1.	bitIndex := i - 1 \\ 8 + 1.	newDigit := (self digitAt: digitIndex) bitAt: bitIndex put: k.	answer digitAt: digitIndex put: newDigit.	^answer compressed</body></methods><methods><class-id>Core.UnicodeCollationAlgorithm</class-id> <category>initialize-release</category><body package="Collections-Collation" selector="atString:putKey:">atString: stringAsArray putKey: key	| dict cp keepMask setMask old string unit |	string := String fromIntegerArray: stringAsArray.	cp := string first codePoint.	string size ~= 1		ifTrue: [			dict := tailoredCollationContractions				at: string first				ifAbsent: [collationContractions					at: string first					ifAbsent: [CompactDictionary new]].			dict := dict copyOld.			dict at: string put: (self packArray: key as: collationAllLevels species).			tailoredCollationContractions at: string first put: dict.			keepMask := CollateContract bitInvert.			setMask := CollateContract]		ifFalse: [			keepMask := CollateContract.			key size &gt; 1				ifTrue:					[setMask := CollateExpanded.					tailoredCollationExpansions at: (Character value: cp) put: (self packArray: key as: collationAllLevels species)]				ifFalse:					[setMask := CollateSimple.					unit := CollateUnit new decodeFromLiteralArray: key first.					tailoredCollationAllLevels testMissing: cp copyFrom: collationAllLevels.					tailoredCollationAllLevels packIndex: cp k1: unit k1 k2: unit k2 k3: unit k3 ignorable: unit ignorable]].	tailoredCollationFlags testMissing: cp+1 copyFrom: collationFlags.	old := tailoredCollationFlags at: cp+1.	tailoredCollationFlags at: cp+1 put: ((old bitAnd: keepMask) bitOr: setMask).</body></methods><methods><class-id>Core.Object</class-id> <category>glorp</category><body package="Store-Database Model" selector="glorpCopyIn:">glorpCopyIn: aDictionary	"For non-storeForGlorp objects, just copy normally"	^self copyOld.</body></methods><methods><class-id>Core.BehaviorShell</class-id> <category>copying</category><body package="Kernel-Classes" selector="postCopy">postCopy	"Reset the list of subclasses,	and copy the method dictionary."	super postCopy.	self methodDictionary: self methodDict copyOld</body></methods><methods><class-id>Core.ByteEncodedString class</class-id> <category>system startup</category><body package="Collections-String Support" selector="install">install	| encoding className decodingMap stringClass nm |	encoding := self platformStringPreference.	nm := encoding at: 1.	nm changeClassTo: ByteString.	className := StringClasses at: nm.	stringClass := className asQualifiedReference value.	decodingMap := encoding at: 2."	stringClass encoder decodingMap = decodingMap		ifFalse:			[[Processor activeProcess priority: Processor userSchedulingPriority.			self error: 'The VI and VM have different ideas of the preferred encoding']					forkAt: Processor systemRockBottomPriority]."	self defaultPlatformClass: stringClass.	PrimitiveArgumentClass := ByteArray."	128 to: 256 do: [:i | decodingMap at: i put: Character illegalCode asCharacter]."	PrimitiveArgumentClass		bePreferredClassWithEncoding: stringClass encoder decodingMap copyOld</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>copying</category><body package="Collections-Sequenceable" selector="copyWith:">copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and 	includes the argument, newElement, at the end."	| newCollection |	newCollection := self copyOld.	newCollection add: newElement.	^newCollection</body></methods><methods><class-id>Core.CompositeLocale class</class-id> <category>accessing</category><body package="Internationalization" selector="named:">named: aLocaleName	"Strip off the encoding portion of the name if supplied"	| localeName index |	(index := aLocaleName string indexOfSubCollection: '.' startingAt: 1) &gt; 0		ifTrue: [localeName := aLocaleName string copyFrom: 1 to: index - 1]		ifFalse: [localeName := aLocaleName string copyOld].	^self locale: localeName asSymbol		encoding: (self platformLocaleAndEncoding at: 2)</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>copying</category><body package="Collections-Sequenceable" selector=",">, aSequenceableCollection 	"Answer a copy of the receiver concatenated with the argument,	a SequenceableCollection."		^self copyOld		addAll: aSequenceableCollection;		yourself</body></methods><methods><class-id>Core.InternalCodeWriterStream</class-id> <category>storage</category><body package="System-Code Storage" selector="storeString:">storeString: aString	(aString isString and: [aString isSymbol not]) ifFalse:		[self storeString: aString asString.		^aString].	aString class == ByteString		ifTrue:			[self storeByte: 1.			self storeLength: aString size.			self nextPutAll: aString asByteArray]		ifFalse: [aString class == TwoByteString			ifTrue:				[self storeByte: 2.				self storeLength: aString basicSize.				self nextPutAll: (aString copyOld changeClassTo: ByteArray)]			ifFalse: [aString class == FourByteString				ifTrue:					[self storeByte: 4.					self storeLength: aString basicSize.					self nextPutAll: (aString copyOld changeClassTo: ByteArray)]				ifFalse: [self storeString: aString asByteString]]].	^aString</body></methods><methods><class-id>Core.LocaleEncodingComponent class</class-id> <category>installation</category><body package="Internationalization" selector="install_ASCII_Encoding">install_ASCII_Encoding	| enc copy starter |	starter := (StreamEncoder new: #ASCII) encoding.	enc := self new.	enc		name: starter;		compoundTextEncodeOrder: #(#ascii #iso1);		cutPasteEncoding: #CompoundText;		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: starter);		ignoreSerifEncodings: #();		needsInputMethod: true;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	self addEncoding: enc platform: #unix.	copy := enc copyOld.	copy		needsInputMethod: false;		preferredPixelSize: nil;		cutPasteEncoding: #UTF16.	self addEncoding: copy platform: #win32</body></methods><methods><class-id>Core.LocaleEncodingComponent class</class-id> <category>installation</category><body package="Internationalization" selector="install_UTF8_Encoding">install_UTF8_Encoding	| enc copy starter |	starter := (StreamEncoder new: #UTF8) encoding.	enc := self new.	enc		name: starter;		compoundTextEncodeOrder: #(#ascii #iso1);		cutPasteEncoding: #CompoundText;		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: starter);		ignoreSerifEncodings: #();		needsInputMethod: true;		preferredEncodings: #('iso8859-1' 'iso10646-1');		preferredFontFamily: #();		preferredPixelSize: 12.	self addEncoding: enc platform: #unix.	copy := enc copyOld.	copy		needsInputMethod: false;		preferredPixelSize: nil;		cutPasteEncoding: #UTF16;		preferredEncodings: nil.	self addEncoding: copy platform: #win32</body></methods><methods><class-id>Core.LocaleEncodingComponent class</class-id> <category>class initialization</category><body package="Internationalization" selector="initialize">initialize	"LocaleEncodingComponent initialize"		EncodingDictionary == nil ifTrue: [EncodingDictionary := Dictionary new].	(EncodingDictionary includesKey: #unix) ifFalse: [			EncodingDictionary at: #unix put: IdentityDictionary new].	(EncodingDictionary includesKey: #win32) ifFalse: [			EncodingDictionary at: #win32 put: IdentityDictionary new].	EncodingDictionary do: [:dict |		dict keys copyOld do: [:eName | dict removeKey: eName]].	(self class selectors select: [:i | 'install*Encoding' match: i]) do: [:sel | self perform: sel].</body></methods><methods><class-id>Core.Collection</class-id> <category>removing</category><body package="Collections-Abstract" selector="removeAll">removeAll	"Remove every element in the receiver. Return a collection of the items removed."	^self removeAll: self copyOld</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="Collections-Abstract" selector="copyUpTo:">copyUpTo: anObject	"Answer a copy of the receiver from index 1 to the first occurrence of 	anObject, non-inclusive."	| index |	index := self indexOf: anObject ifAbsent: [^self copyOld].	^self copyFrom: 1 to: index-1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="Collections-Abstract" selector="sorted">sorted	"Return a sorted copy of the receiver."	| sortedVersion |	sortedVersion := self copyOld.	sortedVersion sort.	^sortedVersion.</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="Collections-Abstract" selector="copyReplaceAll:with:">copyReplaceAll: oldSubCollection with: newSubCollection 	"Answer a copy of the receiver in which all occurrences of 	oldSubCollection have been replaced by newSubCollection.  If there 	are no such occurrences, answer a copy of the receiver."	| matchIndex matchIndices newCollection oldIndex newIndex newPlace |	"If there are no matches, answer the receiver."	(matchIndex := self indexOfSubCollection: oldSubCollection startingAt: 1) &gt; 0		ifFalse: [^self copyOld].	matchIndices := OrderedCollection with: matchIndex.	[(matchIndex := self indexOfSubCollection: oldSubCollection startingAt: matchIndex + oldSubCollection size) &gt; 0]		whileTrue: [matchIndices addLast: matchIndex].	"Copy the collection, replacing all the occurrences."	newCollection := self species withSize: self size + ((newSubCollection size - oldSubCollection size) * matchIndices size).	oldIndex := 1.	newIndex := 1.	[matchIndices isEmpty]		whileFalse: 			[matchIndex := matchIndices removeFirst.			"Copy the subcollection up to the match."			newPlace := newIndex + matchIndex - oldIndex.			newCollection				replaceFrom: newIndex				to: newPlace - 1				with: self				startingAt: oldIndex.			oldIndex := matchIndex + oldSubCollection size.			"Insert the new subcollection."			newIndex := newPlace + newSubCollection size.			newCollection				replaceFrom: newPlace				to: newIndex - 1				with: newSubCollection				startingAt: 1].	"Copy the collection beyond the last match."	newCollection		replaceFrom: newIndex		to: newCollection size		with: self		startingAt: oldIndex.	^newCollection	"'How noww brown cowow?' copyReplaceAll: 'ow' with: 'ello'"</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="Collections-Abstract" selector="sorted:">sorted: aBlock	"Return a sorted copy of the receiver using aBlock as the sort criteria.	e.g. #(1 4 -5 -2 3) sorted: [:a :b | a abs &lt;= b abs]	returns a sorted copy of the receiver as	#(1 -2 3 4 -5)"	| sortedVersion |	sortedVersion := self copyOld.	sortedVersion sort: aBlock.	^sortedVersion.</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopy">postCopy	valueArray := valueArray copyOld</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopyWithCopiedValues">postCopyWithCopiedValues	self postCopy.	1 to: valueArray size do:		[:i| | value |		nil == (value := valueArray at: i) ifFalse: [valueArray at: i put: value copyOld]]</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories" selector="asClassNameOnly">asClassNameOnly	"Check if the string names meta class and strip 	the postfix class."	^self namesMetaClass		ifTrue: [self classNameOnly]		ifFalse: [self copyOld]</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="Collections-Streams" selector="policy">policy	^StreamPolicy default copyOld</body></methods><methods><class-id>Core.OrderedSet</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopy">postCopy	super postCopy.	values := values copyOld</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing class hierarchy</category><body package="Kernel-Classes" selector="subclasses">subclasses	"Answer the receiver's subclasses.  Return a copy so that callers who 	add or delete subclasses won't get confused."	^subclasses == nil		ifTrue: [Array new]		ifFalse: [subclasses copyOld]</body></methods><methods><class-id>Core.Behavior</class-id> <category>recompiling</category><body package="Kernel-Classes" selector="rebindAllMethods:">rebindAllMethods: varNames	"Regenerate all the methods in the receiver's method dictionary"	| newMethods |	newMethods := methodDict copyOld.	self selectorsAndMethodsDo:		[:sel :meth | | newMethod |		newMethod := self						rebindMethod: meth						oldVariableNames: varNames.		newMethods at: sel put: (self validateMethod: newMethod forSelector: sel)].	methodDict := newMethods.	self flushVMmethodCache</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing instances and variables</category><body package="Kernel-Classes" selector="allSharedPools">allSharedPools	"Answer a Set of the pools, dictionaries, that the receiver and the	receiver's ancestors share."	^(superclass == nil or: [SystemUtils isVW20LanguageCompatible not])		ifTrue:			[self sharedPools copyOld]		ifFalse: 			[| aSet |			aSet := superclass allSharedPools.			aSet addAll: self sharedPools.			aSet]</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="Kernel-Classes" selector="copyMethodDictionary">copyMethodDictionary	methodDict := methodDict copyOld</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating class hierarchy</category><body package="Kernel-Classes" selector="clearInstanceVariables">clearInstanceVariables	"After creating the copy, clear in the copy those instance variables that would be confusing"	superclass := nil.	methodDict := methodDict copyOld.	subclasses := nil</body></methods><methods><class-id>Core.Behavior</class-id> <category>copying</category><body package="Kernel-Classes" selector="postCopy">postCopy	"Reset the list of subclasses,	and copy the method dictionary."	super postCopy.	subclasses := nil. 			methodDict := methodDict copyOld</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>organization</category><body package="BOSS" selector="orderedCategories:">orderedCategories: aList	"Set the list of categories known by the class's organization.	If the organization knows categories not on this list, add them	at the end.  If the system does not support the development	environment (organization is nil), do nothing."	| list2 |	organization == nil ifTrue: [^self].	list2 := aList copyOld asOrderedCollection.	self organization categories do:		[:cat |		(list2 includes: cat)			ifFalse: [list2 add: cat]].	self organization categories: list2</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance variables</category><body package="Kernel-Classes" selector="changeInstVarName:to:">changeInstVarName: aString to: aReplacement 	"Replace the variable known as aString with aReplacement"	| newArray |	(self instVarNames includes: aString) 		ifFalse: 			[self 				error: (#InstVarNotFound &lt;&lt; #dialogs 						&gt;&gt; '&lt;1s&gt; is not one of my instance variables' expandMacrosWith: aString)].	newArray := self instVarNames copyOld replaceAll: aString with: aReplacement.	self instanceVariableNames: (newArray fold: [:a :b | a , ' ' , b])</body></methods><methods><class-id>Core.Class</class-id> <category>instance variables</category><body package="Kernel-Classes" selector="changeInstVarName:to:">changeInstVarName: aString to: aReplacement 	"Replace the variable known as aString with aReplacement"	(self instVarNames includes: aString) 		ifFalse: 			[self 				error: (#InstVarNotFound &lt;&lt; #dialogs 						&gt;&gt; '&lt;1s&gt; is not one of my instance variables' expandMacrosWith: aString)].	(self classBuilder)		currentClass: self;		superclass: superclass;		instanceVariables: (self instVarNames copyOld replaceAll: aString					with: aReplacement);		format: self format;		reviseSystem</body></methods><methods><class-id>Core.GapString</class-id> <category>copying</category><body package="Collections-String Support" selector="postCopy">postCopy	super postCopy.	string := string copyOld</body></methods><methods><class-id>Core.List</class-id> <category>copying</category><body package="UIBasics-Collections" selector="postCopy">postCopy	"Answer a copy of the receiver."	self breakDependents.	collection :=  collection copyOld.</body></methods><methods><class-id>Core.CompositeTimeZone</class-id> <category>copying</category><body package="Magnitude-General" selector="postCopy">postCopy	policies := policies copyOld</body></methods><methods><class-id>Core.ExceptionSet</class-id> <category>adding</category><body package="Kernel-Exception Handling" selector=",">, anExceptionSelector 	"Answer a copy of the receiver concatenated with the argument,	anExceptionSelector."	^(self copyOld)		add: anExceptionSelector;		yourself</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installPTLocale">installPTLocale	"Portuguese (Portugal)"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #ptCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_pt);		timePolicy: (TimestampPrintPolicy newFor: #_pt);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copyOld.	copy		name: #'pt_PT.CP1252';		preferredPixelSize: nil;		defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #ptg) put: #'pt_PT.CP1252';		at: #('win32 *' #PTG) put: #'pt_PT.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installSELocale">installSELocale	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #seCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_se);		timePolicy: (TimestampPrintPolicy newFor: #_se);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copyOld.	copy		name: #'sv_SE.CP1252';		preferredPixelSize: nil;		defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #sve) put: #'sv_SE.CP1252';		at: #('win32 *' #SVE) put: #'sv_SE.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installNOLocale">installNOLocale	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #noCurrency);		numberPolicy: (NumberPrintPolicy newFor: #no);		timePolicy: (TimestampPrintPolicy newFor: #no);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copyOld.	copy name: #'no_NO.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #nor) put: #'no_NO.CP1252';		at: #('win32 *' #NOR) put: #'no_NO.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installPTBLocale">installPTBLocale	"Portuguese (Brazil)"	| locale copy |	locale := self new.	locale		name: #'pt_BR.CP1252';		collationPolicy: nil;		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #brazilCurrency);		numberPolicy: (NumberPrintPolicy newFor: #brazil);		timePolicy: (TimestampPrintPolicy newFor: #brazil);		cutPasteEncoding: #CompoundText;		defaultStreamEncoder: ISO8859L1String encoder;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copyOld.	self addLocale: copy platform: #unix.	copy := locale copyOld.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #ptb) put: #'pt_BR.CP1252';		at: #('win32 *' #PTB) put: #'pt_BR.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installUALocale">installUALocale	"Ukrainian locale."	| locale copy |	locale := self new.	locale 		collationPolicy: (StringCollationPolicy newFor: #ukrainianCollate:to:); 		currencyPolicy: (NumberPrintPolicy newFor: #uaCurrency); 		numberPolicy: (NumberPrintPolicy newFor: #ua);		timePolicy: (TimestampPrintPolicy newFor: #ua);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929; "A4paper in inches"		ignoreSerifEncodings: #(); 		needsInputMethod: true; 		preferredEncodings: nil; 		preferredPixelSize: nil;		preferredFontFamily: #().		copy := locale copyOld.	copy name: #'ua_UA.CP1251';		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #ms_cp_1251).	self addLocale: copy platform: #win32.	copy := locale copyOld.	copy preferredEncodings: #('koi8-u' 'koi8-r').	copy name: #'ua_UA.KOI8-U';		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #'koi8-u').	self addLocale: copy platform: #unix.	LocaleMap		at: #('win32 *' #ukr) put: #'ua_UA.CP1251';		at: #('win32 *' #UKR) put: #'ua_UA.CP1251'.</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installDELocale">installDELocale	"German"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #germanCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #deCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_de);		timePolicy: (TimestampPrintPolicy newFor: #_de);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copyOld.	copy name: #'de_DE.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #deu) put: #'de_DE.CP1252';		at: #('win32 *' #DEU) put: #'de_DE.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installNLLocale">installNLLocale	"self installNLLocale."	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #dutchCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #nlCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_nl);		timePolicy: (TimestampPrintPolicy newFor: #_nl);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.27 @ 11.69;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"A4 paper size in inch"	copy := locale copyOld.	copy name: #'nl_D.HPRoman8'.	copy		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #HP_Roman8).	self addLocale: copy platform: #unix.	copy := locale copyOld.	copy name: #'nl_D.ISO8859-1'.	copy defaultStreamEncoder: ISO8859L1String encoder.	self addLocale: copy platform: #unix.	copy := locale copyOld.	copy name: #'nl_D.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #nld) put: #'nl_D.CP1252';		at: #('win32 *' #NLD) put: #'nl_D.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installFRLocale">installFRLocale	"French"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #frCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_fr);		timePolicy: (TimestampPrintPolicy newFor: #_fr);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copyOld.	copy name: #'fr_FR.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #fra) put: #'fr_FR.CP1252';		at: #('win32 *' #FRA) put: #'fr_FR.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installELLocale">installELLocale	"Greek"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #greekCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #elCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_el);		timePolicy: (TimestampPrintPolicy newFor: #_el);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copyOld.	copy name: #'el_EL.CP1253'.	copy preferredPixelSize: nil.	copy		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #ms_cp_1253).	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #el) put: #'el_EL.CP1253';		at: #('win32 *' #EL) put: #'el_EL.CP1253'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installESLocale">installESLocale	"Spanish"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #esCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_es);		timePolicy: (TimestampPrintPolicy newFor: #_es);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copyOld.	copy name: #'es_ES.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #esn) put: #'es_ES.CP1252';		at: #('win32 *' #ESN) put: #'es_ES.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installFILocale">installFILocale	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #fiCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_fi);		timePolicy: (TimestampPrintPolicy newFor: #_fi);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copyOld.	copy		name: #'fi_FI.CP1252';		preferredPixelSize: nil;		defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #fin) put: #'fi_FI.CP1252';		at: #('win32 *' #FIN) put: #'fi_FI.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>class initialization</category><body package="Internationalization" selector="ensureAllLocalesHaveUTF8Alternative">ensureAllLocalesHaveUTF8Alternative	"For each locale that we have with some other encoding, create a version that's the same but uses UTF-8 encoding. Ideally we'd have a complete set of locales, or a decoupling of language from encoding, but in the meantime this handles the most common case, where Linux distributions often have UTF-8 encodings for arbitrary system locales."	| unixLocales |	unixLocales := LocaleDictionary at: #unix.	unixLocales copyOld keysAndValuesDo: [:eachLocaleName :eachLocale | | utf8Name |		eachLocaleName = #C ifFalse: [			utf8Name := ((eachLocaleName readStream through: $.) , 'UTF-8') asSymbol.			unixLocales at: utf8Name ifAbsentPut: [				| newLocale |				LocaleMap at: (Array with: '* linux' with: utf8Name) put: utf8Name.				eachLocale copyOld					name: utf8Name;					defaultStreamEncoder: UTF8StreamEncoder;					yourself]]]</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installCLocale">installCLocale	| locale copy |	locale := self new.	locale		name: #C;		collationPolicy: nil;		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: nil;		numberPolicy: nil;		timePolicy: nil;		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.5 @ 11.0; "Letter paper size in inch"		defaultStreamEncoder: ISO8859L1String encoder;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copyOld.	self addLocale: copy platform: #unix.	copy := locale copyOld.	copy preferredPixelSize: nil;		  defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installUSLocale">installUSLocale 	| locale copy |	 locale := self new.	 locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #usCurrency);		numberPolicy: (NumberPrintPolicy newFor: #us);		timePolicy: (TimestampPrintPolicy newFor: #us);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.5 @ 11.0; "Letter paper size in inch"		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12. 	copy := locale copyOld.	copy name: #'en_US.HPRoman8'.	copy defaultStreamEncoder: 			(StreamEncoder lookupEncoderDirectory: #HP_Roman8).	self addLocale: copy platform: #unix.	copy := locale copyOld.	copy name: #'en_US.ISO8859-1'.	copy defaultStreamEncoder: ISO8859L1String encoder.	self addLocale: copy platform: #unix.	copy := locale copyOld.	copy name: #'en_GB.ISO8859-15'.	copy defaultStreamEncoder: CharacterEncoder iso8859_15Encoder.	self addLocale: copy platform: #unix.	copy := locale copyOld.	copy name: #'en_US.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: CharacterEncoder mscp1252.	self addLocale: copy platform: #win32.	LocaleMap		at: #('* hp *' #american) put: #'en_US.HPRoman8';		at: #('* hp *' #'american.iso88591') put: #'en_US.ISO8859-1';		at: #('* hp *' #'en_US.roman8') put: #'en_US.HPRoman8';		at: #('* hp *' #'en_US.iso88591') put: #'en_US.ISO8859-1';		at: #('* sun *' #en_GB) put: #'en_GB.ISO8859-15';		at: #('* sun *' #en_US) put: #'en_US.ISO8859-1';		at: #('* sun *' #En_US) put: #'en_US.ISO8859-1';		at: #('* ibm *' #en_US) put: #'en_US.ISO8859-1';		at: #('* ibm *' #en_GB) put: #'en_GB.IBM-1252@euro';		at: #('* sequent *' #en_US) put: #'en_US.ISO8859-1';		at: #('win32 *' #enu) put: #'en_US.CP1252';		at: #('win32 *' #ENU) put: #'en_US.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installRUSLocale">installRUSLocale	"Locale installRUSLocale"      | locale copy |      locale := self new.      locale		collationPolicy: (StringCollationPolicy newFor: #russianCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1); "?"		currencyPolicy: (NumberPrintPolicy newFor: #rusCurrency);		numberPolicy: (NumberPrintPolicy newFor: #rus);		timePolicy: (TimestampPrintPolicy newFor: #rus);		cutPasteEncoding: #CompoundText;		needsInputMethod: true;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12. "Letter paper size in inch"	copy := locale copyOld.	copy name: #'ru_RU.CP1251';		preferredPixelSize: nil; 		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #ms_cp_1251). 	self addLocale: copy platform: #win32.	copy := locale copyOld.	copy name: #'ru_RU.KOI8-R'.	copy defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #KOI8R).	self addLocale: copy platform: #unix.	LocaleMap		at: #('win32 *' #rus) put: #'ru_RU.CP1251';		at: #('win32 *' #RUS) put: #'ru_RU.CP1251'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installDKLocale">installDKLocale	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #dkCurrency);		numberPolicy: (NumberPrintPolicy newFor: #dk);		timePolicy: (TimestampPrintPolicy newFor: #dk);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copyOld.	copy		name: #'da_DK.CP1252';		preferredPixelSize: nil;		defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #dan) put: #'da_DK.CP1252';		at: #('win32 *' #DAN) put: #'da_DK.CP1252'</body></methods><methods><class-id>Core.SharedQueue</class-id> <category>copying</category><body package="Kernel-Processes" selector="postCopy">postCopy     " Finish doing whatever is required,     beyond a shallowCopy, to implement 'copy'.     Answer the receiver."     | dup |     [accessProtect critical: [dup := contents  copyOld]] valueUninterruptably.     self init: dup capacity.     contents := dup.     contents size timesRepeat: [readSynch  signal].     ^self</body></methods><methods><class-id>Core.SubscriptionRegistry</class-id> <category>removing</category><body package="System-Announcements" selector="removeSubscription:">removeSubscription: anAnnouncementSubscription	"Remove using copy-on-write to avoid any conflicts with iteration already in progress."	| newSubscriptions class |	class := anAnnouncementSubscription announcementClass.	newSubscriptions := (classesAndSubscriptions at: class ifAbsent: [^self])		copyWithout: anAnnouncementSubscription.	anAnnouncementSubscription deactivate.	newSubscriptions isEmpty 		ifTrue: 			[classesAndSubscriptions := classesAndSubscriptions copyOld.			classesAndSubscriptions removeKey: class]		ifFalse: 			[classesAndSubscriptions at: class put: newSubscriptions]</body></methods><methods><class-id>Core.SubscriptionRegistry</class-id> <category>adding</category><body package="System-Announcements" selector="addSubscription:">addSubscription: anAnnouncementSubscription	"Add a subscription with copy-on-write to avoid conflicts if there is iteration in progress."	| class originalSubscriptions |	class := anAnnouncementSubscription announcementClass.	originalSubscriptions := classesAndSubscriptions at: class ifAbsent: [nil].	originalSubscriptions isNil		ifTrue:			[classesAndSubscriptions := classesAndSubscriptions copyOld.			classesAndSubscriptions at: class put: (Array with: anAnnouncementSubscription)]		ifFalse:			[classesAndSubscriptions 				at: class				put: (originalSubscriptions copyWith: anAnnouncementSubscription)]</body></methods><methods><class-id>Core.ExtrapolatedSystemTimeZone</class-id> <category>converting</category><body package="OS-Support" selector="localToUniversal:">localToUniversal: localTimestamp	" Convert a timestamp in the current timezone to a universal timestamp. "	| yearAdjustment localTimestampAdjusted universalTimestamp |	(self system timestampWithinRange: localTimestamp)		ifTrue: [^super localToUniversal: localTimestamp].	yearAdjustment := self system timestampRangeYearAdjustment: localTimestamp.	localTimestampAdjusted := (localTimestamp copyOld)				year: localTimestamp year - yearAdjustment;				yourself.	universalTimestamp := self system localToUniversal: localTimestampAdjusted.	universalTimestamp year: universalTimestamp year + yearAdjustment.	^universalTimestamp		milliseconds: localTimestamp milliseconds;		partialNanosecond: localTimestamp partialNanosecond;		yourself</body></methods><methods><class-id>Core.ExtrapolatedSystemTimeZone</class-id> <category>converting</category><body package="OS-Support" selector="universalToLocal:">universalToLocal: universalTimestamp	" Convert a universal timestamp to equivalent timestamp in the current timezone. "	| yearAdjustment universalTimestampAdjusted localTimestamp |	(self system timestampWithinRange: universalTimestamp)		ifTrue: [^super universalToLocal: universalTimestamp].	yearAdjustment := self system				timestampRangeYearAdjustment: universalTimestamp.	universalTimestampAdjusted := (universalTimestamp copyOld)				year: universalTimestamp year - yearAdjustment;				yourself.	localTimestamp := self system universalToLocal: universalTimestampAdjusted.	localTimestamp year: localTimestamp year + yearAdjustment.	^localTimestamp		milliseconds: universalTimestamp milliseconds;		partialNanosecond: universalTimestamp partialNanosecond;		yourself</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>accessing</category><body package="Collections-Arrayed" selector="at:put:">at: anIndex put: anObject 	"We copy the segment each time in case someone has asked for 	sharing. This makes for low space, but works only if stores are quite 	infrequent."	| c i1 |	i1 := (anIndex - 1 bitShift: -8) + 1.	c := self basicAt: i1.	c == nil		ifTrue: [c := self newPage]		ifFalse: [compressed ifTrue: [c := c copyOld]].	c at: (anIndex - 1 bitAnd: 255) + 1 put: anObject.	self basicAt: i1 put: c.	^anObject</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>copying</category><body package="Collections-Collation" selector="testMissing:copyFrom:">testMissing: index copyFrom: otherCollection	| page |	(otherCollection class == self class			or: [otherCollection species == self species			or: [otherCollection pageSize == self pageSize]])		ifFalse: [self error: 'Incompatible collection implementations'].	page := index - 1 // 256 + 1.	page &gt; self basicSize		ifTrue: [self become: (self copyWithSize: page*256)].	(self basicAt: page) == nil		ifTrue: [self basicAt: page put: (otherCollection basicAt: page) copyOld].</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>growing</category><body package="Collections-Arrayed" selector="copyWithSize:">copyWithSize: newSize	"Answer a copy of me that can store at least newSize elements."	| new |	new := self class new: newSize.	1 to: (self basicSize min: new size) do:		[:i |		new basicAt: i put: (self basicAt: i) copyOld].	^new</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>compressing</category><body package="Collections-Arrayed" selector="uncompress">uncompress	"Make #at:put: go faster, by forcing similiar segments to be different objects."	compressed := false.	2 to: self basicSize do: [:i |		1 to: i-1 do: [:j |			(self basicAt: i) == (self basicAt: j)				ifTrue: [self basicAt: i put: (self basicAt: i) copyOld]]].</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>accessing</category><body package="Collections-Streams" selector="peekFor:">peekFor: anObject 	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	| nextObject savedSkipSize |	self atEnd ifTrue: [^false].	savedSkipSize := skipSize copyOld.	nextObject := self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	self skip: -1.	skipSize restore: savedSkipSize.	^false</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>accessing</category><body package="Collections-Streams" selector="peek">peek	"Answer what would be returned with a self next, without	changing position.  If the receiver is at the end, answer nil."	| nextObject savedSkipSize |	self atEnd ifTrue: [^nil].	savedSkipSize := skipSize copyOld.	nextObject := self next.	self skip: -1.	skipSize restore: savedSkipSize.	^nextObject</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>accessing</category><body package="Collections-Streams" selector="next">next	"Answer the next object in the Stream represented by the receiver."	| ch |	binary		ifTrue: [^stream next].	skipSize reset.	ch := encoder readFrom: stream.	ch == nil		ifTrue:			[skipSize clear.			^nil].	lineEndCharacter == ch				"no need to convert"		ifFalse: [^ch].	lineEndConvention == LineEndLF		"convert LF to CR"		ifTrue: [^CR].	lineEndConvention == LineEndCRLF	"convert CRLF to CR"		ifTrue: [ | char skip1 |			skip1 := skipSize copyOld.				"We need to nil this out in case we find a CR				not followed by an LF, and need to back up."			skipSize reset.			char := [encoder readFrom: stream]					on: Stream endOfStreamSignal					do: [:ex | ex return: nil].			char == nil ifTrue: [^CR].			char == LF				ifTrue: [skipSize mergeCount: skip1]				ifFalse:					[self skip: -1.					skipSize restore: skip1].			^CR]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopy">postCopy	super postCopy.	1 to: self capacity do:		[:i| | value |		nil == (value := self basicAt: i)			ifFalse:				[self basicAt: i put: value copyOld]]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopyWithCopiedValues">postCopyWithCopiedValues	self postCopy.	1 to: self capacity do:		[:i| | value |		nil == (value := self basicAt: i)			ifFalse:				[value := value copyOld.				value value: value value copyOld.				self basicAt: i put: value]]</body></methods><methods><class-id>Core.Text</class-id> <category>copying</category><body package="Collections-Text" selector="copyReplaceFrom:to:with:">copyReplaceFrom: start to: stop with: aText 	^self copyOld replaceFrom: start to: stop with: aText</body></methods><methods><class-id>Core.Text</class-id> <category>converting</category><body package="Collections-Text" selector="withCRs">withCRs	"Answer a Text with all instances of $\ replaced by CRs. Retain all emphases."	^self shallowCopy 		setString: (self string collect: [:char | char = $\ ifTrue: [Character cr] ifFalse: [char]])		setRuns: self runs copyOld</body></methods><methods><class-id>Core.Text</class-id> <category>copying</category><body package="Collections-Text" selector="postCopy">postCopy	super postCopy.	string := string copyOld.	runs := runs copyOld</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Collections-Text" selector="chopTo:">chopTo: num	"Answer a string chopped to num characters by combining the	initial and final substrings of sufficient size."	| first last result |	num &gt;= self size ifTrue: [^self copyOld].	num = 1 ifTrue: [^self species with: (self at: 1)].	first := (num + 1) // 2.	last := num // 2.	result := self species new: num.	result replaceFrom: 1 to: first with: self startingAt: 1.	result replaceFrom: first + 1 to: num with: self startingAt: self size - last + 1.	^result	"	'antidisestablishmentarianism' chopTo: 10 'antidanism'	"</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private</category><body package="Collections-Text" selector="rangeOfPattern:reverseFrom:ignoreCase:">rangeOfPattern: pattern reverseFrom: start ignoreCase: caseInsensitive	"Find the first occurrence of pattern within the receiver, in reverse direction beginning at start,	allowing one character in place of each #, and zero or more characters in place of each *.	Answer the range of the match, or (0 to: 0) if no match.  If caseInsensitive is true, ignore case differences."	| patternList nextIndex firstIndex p searchSelector startReversed result matchList |	searchSelector := caseInsensitive				ifTrue: [#findSameAs:startingAt:wildcard:]				ifFalse: [#findString:startingAt:wildcard:].	patternList := pattern tokensBasedOn: $*.	patternList removeAllSuchThat: [:i | i isEmpty].	patternList isEmpty		ifTrue: [^pattern isEmpty ifTrue: [0 to: 0] ifFalse: [start to: start - 1]].	startReversed := 1 max: 1 + self size - start.	[startReversed &lt; self size] whileTrue: 			[matchList := patternList copyOld.			firstIndex := self reverse						perform: searchSelector						with: (p := matchList removeFirst) reverse						with: startReversed						with: $#.			firstIndex = 0 ifTrue: [^0 to: 0].			result := 2 + self size - firstIndex - p size.			matchList isEmpty ifTrue: [^result to: result + p size - 1].			nextIndex := result + p size.			[matchList isEmpty or: [nextIndex = 0]] whileFalse: 					[nextIndex := self								perform: searchSelector								with: (p := matchList removeFirst)								with: nextIndex								with: $#.					nextIndex = 0						ifTrue: [startReversed := 1 max: 1 + self size - result]						ifFalse: [nextIndex := nextIndex + p size]].			matchList isEmpty ifTrue: [^result to: nextIndex - 1]].		^0 to: 0</body></methods><methods><class-id>OSkLogSwitch</class-id> <category>services</category><body package="OSkLogger" selector="close">close	"^selfI close and remove all my targets.  This means any further entries will simly be dropped."	self logTargets copyOld do: 			[:aTarget | 			aTarget close.			self logTargets remove: aTarget].	^self</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private</category><body package="Database" selector="updateDataset:columns:">updateDataset: list columns: descrs	"Update the dataset with the list of data records, and descrs database column descriptions."	| col width columnWidths |	self clearDataset.	dsvList list addAll: list copyOld.	columnWidths := self truncateColumnsStatusHolder value				ifTrue: [self truncatedWidthsOfColumns: descrs]				ifFalse: [self adequateWidthsOfColumns: descrs forRows: list].	1 to: descrs size		do: 			[:index |			col := descrs at: index.			width := columnWidths at: index.			index = 1				ifTrue: [self firstColumnLabel: col name width: width]				ifFalse: [self addColumnLabel: col name width: width]].	self datasetWidget invalidate.	self datasetWidget isVisible: true			"Ensure that the dataset gets displayed."</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	self queryModel onChangeSend: #changedQuery to: self.	self blockFactor: 1.	self connectedStatusHolder onChangeSend: #connectedStatusChanged to: self.	self executeStatusHolder onChangeSend: #executeStatusChanged to: self.	self moreAnswersStatusHolder onChangeSend: #moreAnswersStatusChanged to: self.	self truncateColumnsStatusHolder onChangeSend: #truncateColumnsStatusChanged to: self.	self dsvList list: List new.	dsvList list add: (Array with: '   ' with: '   ') copyOld.</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private-dataset</category><body package="Database" selector="addColumnLabel:width:">addColumnLabel: aString width: aNumber	"Add a column to the dataset view. To go into effect, send &gt;&gt;invalidate to the dataset."	| columnCollection newColumn dataset columnSpec newColumnNumber aspectSymbol |	dataset := self datasetWidget.	columnCollection := dataset columnDescriptors asOrderedCollection.	columnSpec := columnCollection first description copyOld.	newColumnNumber := columnCollection size + 1.	aspectSymbol := ('selectedRow ', newColumnNumber printString) asSymbol.	columnSpec				label: aString;				model: aspectSymbol;				width: aNumber.	newColumn := columnSpec columnWithBuilder: self builder.	columnCollection add: newColumn.	dataset columnDescriptors: columnCollection.</body></methods><methods><class-id>Database.AdHocQueryTool class</class-id> <category>resources</category><body package="Database" selector="errorTextMenu">errorTextMenu	"MenuEditor new openOnClass: self andSelector: #errorTextMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #copyOld #catalogID: #database #defaultString: 'copy' )				#value: #copySelection ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>accessing</category><body package="Database" selector="upToEnd">upToEnd	"Answer the current contents of the receiver's input stream. All rows of the answer	set are fetched. Since there must be a unique object for every entry of the set, the	allocateForEachRow control in the session is ignored and  a copy of the bindOutput	object is always made."	| cont getRow |	( session == nil ) "No more answers."		ifTrue: [ self class endOfStreamSignal raiseSignal. ^#().].	cont := WriteStream on: (self contentsSpecies new: 512).	session allocateForEachRow		ifTrue:	[ getRow :=  [ self next ]		"next made the copy" ]		ifFalse:	[ getRow := [ self next copyOld ] 	"next didn't make the copy" ].	[ self atEnd ]		whileFalse: [ cont nextPut: getRow value ].	^cont contents</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>accessing</category><body package="Database" selector="next:into:startingAt:">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection.	Since there must be a unique object for every entry of the set, the allocateForEachRow	control in the session is ignored and  a copy of the bindOutput object is always made."	| index stopIndex getRow |	index := startIndex.	stopIndex := index + anInteger.	session allocateForEachRow		ifTrue:	[ getRow :=  [ self next ]		"next made the copy" ]		ifFalse:	[ getRow := [ self next copyOld ] 	"next didn't make the copy" ].	[ self atEnd not and: [ index &lt; stopIndex ] ]		whileTrue:		[ "Collect the next row by executing the getRow block from			above and then insert into the collection."			aSequenceableCollection at: index put: getRow value.			index := index + 1 ].	^aSequenceableCollection</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-answer set</category><body package="Database" selector="nextRowExternal">nextRowExternal	"Answer with the next row of data.  Answer nil at end"	| currentRowCopy |	( self advanceExternal == nil ) ifTrue:		[ "We've exhausted the answer set.  No DBMS cancel is necessary."		self state: #validResults.		^nil ].	"If we have a resultTemplate, use it to provide the answer."	( resultTemplate == nil ) ifFalse:		[ bufferIndex := 1.		^self nextViaTemplate: resultTemplate ].	currentRowCopy := allocateForEachRow		ifTrue:			[ currentRow copyOld ]		ifFalse:			[ currentRow ].	1 to: numColumns		do: [ :index |			(rowAdaptors at: index)				value: currentRowCopy				value: (self getFieldExternal: index) ].	^currentRowCopy</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-answer set</category><body package="Database" selector="getRowExternal:offset:">getRowExternal: fetchOrientation offset: fetchOffset	"Answer with the next row of data.  Answer nil at end"	| currentRowCopy |	( (self advanceExternal: fetchOrientation offset: fetchOffset) == nil ) ifTrue:		[ "We've exhausted the answer set.  No DBMS cancel is necessary."		self state: #validResults.		^nil ].	"If we have a resultTemplate, use it to provide the answer."	( resultTemplate == nil ) ifFalse:		[ bufferIndex := 1.		^self nextViaTemplate: resultTemplate ].	currentRowCopy := allocateForEachRow		ifTrue:			[ currentRow copyOld ]		ifFalse:			[ currentRow ].	1 to: numColumns		do: [ :index |			(rowAdaptors at: index)				value: currentRowCopy				value: (self getFieldExternal: index) ].	^currentRowCopy</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	super initialize.	self initializeAspects.	self 		updateProfileList;		currentProfile: self lastUsedProfile copyOld.	self databaseListHolder value: self knownDatabases.	self environmentListHolder value: 		self knownEnvironmentStrings asSortedCollection.	self userNameListHolder value:		self knownUserNames asSortedCollection.	self connectionProfileHolder onChangeSend: #profileSelected to: self.	currentProfileHolder onChangeSend: #profileChanged to: self</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>notifications</category><body package="Database" selector="profileSelected">profileSelected	| name profile |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name].	currentProfileHolder value: profile copyOld</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>actions</category><body package="Database" selector="saveProfile">saveProfile	| name savedProfile |	name := Dialog request: (#ProfileName &lt;&lt; #database &gt;&gt; 'Profile name:') initialAnswer: self currentProfile originalName.	name isEmpty ifTrue: [^self].	self currentProfile name: name.	savedProfile := self currentProfile copyOld.	self 		addOrReplaceProfile: savedProfile;		currentProfile: self currentProfile;		updateProfileList</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>store</category><body package="Store-Repository Access" selector="openProfile:">openProfile: aProfileOrNil	^self chooseProfileInitially: aProfileOrNil copyOld</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-participation</category><body package="Database" selector="participantsDetect:ifNone:">participantsDetect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	^participantsSemaphore critical:		[ (self participants copyOld)			detect:				[ :each |				(each == 0 or: [ each isExecutor ])					ifTrue: [ false ]					ifFalse: [ aBlock value: each ] ]			ifNone: exceptionBlock ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-participation</category><body package="Database" selector="participantsDo:">participantsDo: aBlock	"Invoke aBlock for each participant."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	participantsSemaphore critical:		[ (self participants copyOld) do:			[ :each |			(each == 0 or: [ each isExecutor ]) ifFalse:				[ aBlock value: each ] ] ]</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>sql generation</category><body package="GlorpQueries" selector="rewriteSetOperationUsing:">rewriteSetOperationUsing: aSelector	"Rewrite any INTERSECT OR EXCEPT operation we have into a correlated EXISTS or NOT EXISTS test, respectively. We take the sub-query, and AND into it a constraint that its base expression is equal to the first queries base expression, and then do either an exists: or a notExists:, depending on aSelector."		| newQuery |	newQuery := queries first copyOld.	2 to: queries size do: [:i | | q expression mainExpression |		q := (queries at: i) copyOld.		expression := RelationExpression new outerJoin: false; relation: #=; leftChild: newQuery baseExpression; rightChild: q baseExpression.		mainExpression := RelationExpression new outerJoin: false; relation: #AND; leftChild: q whereClause; rightChild: expression.		q whereClause: mainExpression.		newQuery AND: [:each | each perform: aSelector with: q]].	^newQuery.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	super postCopy.	queries := queries collect: [:each | each copyOld].	primaryQuery := queries first.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="removeNestedParensFromString:">removeNestedParensFromString: aString	"Return a Smalltalk instance of the type indicated by aGlorpType.  SQL-Server wraps aString in parentheses, so uwrap it first.  If aString is nil, ensure we return nil."	| debracket |	aString size &lt; 2 ifTrue: [^aString].	"relies on nil size = 0"	debracket := aString copyOld.	[debracket first = $( and: [debracket last = $)]]		whileTrue: [debracket := debracket copyFrom: 2 to: debracket size - 1].	^debracket</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>enumerating</category><body package="GlorpQueries" selector="reject:">reject: aBlock	^self copyOld AND: [:each | (aBlock value: each) not].</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	query := query copyOld.	realObjects := nil.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>enumerating</category><body package="GlorpQueries" selector="select:">select: aBlock	^self isInstantiated ifTrue: [self realObjects select: aBlock] ifFalse: [self copyOld AND: aBlock].</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	allTracings := allTracings copyOld.	retrievalExpressions := retrievalExpressions copyOld.	alsoFetchExpressions := alsoFetchExpressions copyOld.</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>converting</category><body package="GlorpQueries" selector="asSimpleQueryFor:">asSimpleQueryFor: aClass	| newQuery newCriteria newBase |	"Rebuild the expression, because this means a full query is being split into multiple sub-queries, e.g. for an inheritance read. The expression may get prepared differently in each case (e.g. table aliases), so we can't share"	newBase := BaseExpression new.	newBase descriptor: (session system descriptorFor: aClass).	newCriteria := whereClause rebuildOn: newBase startingFrom: newBase withOuterScopeBase: newBase.	newQuery := SimpleQuery new		initResultClass: aClass		whereClause: newCriteria		singleObject: readsOneObject.	self copyAttributesTo: newQuery.	newQuery session: session.	newQuery setOrdering: ordering.	newQuery setGrouping: grouping.	newQuery setUpExpressions.	newQuery tracing: tracing copyOld.	^newQuery.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>table creation</category><body package="GlorpCore" selector="migrateFromSystem:toSystem:">migrateFromSystem: from toSystem: to	| fromTables toTables toDelete toAdd toModify newVersion |	fromTables := from allTables copyOld.	toTables := to allTables copyOld.	toDelete := fromTables reject: [:each | 		toTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toAdd := toTables reject: [:each | 		fromTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toModify := fromTables reject: [:each | (toDelete includes: each) or: [toAdd includes: each]].	self doDDLOperation: [		self createTables: toAdd.		self dropTables: toDelete.		toModify do: [:each | 			newVersion := to tableNamed: each sqlString.			self updateTableFrom: each to: newVersion]].</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>copying</category><body package="GlorpCore" selector="postCopy">postCopy	super postCopy.	self initializeCache.	currentUnitOfWork := nil.	accessor := accessor copyOld.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>converting</category><body package="GlorpExpressions" selector="asGlorpExpressionOn:">asGlorpExpressionOn: aBaseExpression	| copy |	copy := self copyOld.	copy joins: (copy joins collect: [:each | each asGlorpExpressionOn: aBaseExpression]).	^copy.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="asGeneralGlorpExpression">asGeneralGlorpExpression	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	| result |	result := self copyOld.	result leftChild: leftChild asGeneralGlorpExpression.	result rightChild: rightChild asGeneralGlorpExpression.	^result.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="asGeneralGlorpExpressionWithFields">asGeneralGlorpExpressionWithFields	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	| result |	result := self copyOld.	result leftChild: leftChild asGeneralGlorpExpressionWithFields.	result rightChild: rightChild asGeneralGlorpExpressionWithFields.	^result.</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="mappedFields">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	| fields |	fields := super mappedFields copyOld.	fields addAll: keyMapping mappedFields.	valueMapping isNil ifFalse: [		fields addAll: valueMapping mappedFields].	^fields.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="typeWithDatabaseName:characterWidth:">typeWithDatabaseName: aString characterWidth: aNumber	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now."	| baseType matchingTypes simpleTypes |	matchingTypes := self typesWithValues values asArray select: [:each | each typeName asLowercase = aString asLowercase].	matchingTypes isEmpty ifTrue: [		Transcript cr; show: 'Cannot find type ', aString, ' using integer instead.'. matchingTypes := Array with: self integer].	"We may get generated and non-generated both matching, e.g. inMemorySequence and int. Prefer the non-generated."	simpleTypes := matchingTypes reject: [:each | each isGenerated].	baseType := simpleTypes isEmpty ifTrue: [matchingTypes first] ifFalse: [simpleTypes first].	^baseType hasWidth ifTrue: [baseType copyOld width: aNumber] ifFalse: [baseType].</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="typeNamed:ifAbsentPut:">typeNamed: aSymbol ifAbsentPut: aBlock	| type |	type := self types at: aSymbol ifAbsentPut: [		| newType |		newType := aBlock value.		newType platform: self.		newType selector: aSymbol].	type hasParameters ifTrue: [type := type copyOld].	^type.</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>copying</category><body package="GlorpDatabase" selector="withTable:">withTable: aTable	"Return a copy of ourselves, with the table set to aTable. Presumably aTable is an aliased version of our table"	^self copyOld table: aTable.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions" selector="copy">copy	| new |	new := super copyOld.	"We need to make sure we copy these before the base gets set. This is horribly ugly."	new selectListVersion: selectListVersion copyOld.	new whereClauseVersion: whereClauseVersion copyOld.	^new.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions" selector="copyOld">copyOld	| new |	new := super copyOld.	"We need to make sure we copy these before the base gets set. This is horribly ugly."	new selectListVersion: selectListVersion copyOld.	new whereClauseVersion: whereClauseVersion copyOld.	^new.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions" selector="createFor:withBase:symbol:">createFor: argumentList withBase: anExpression symbol: aSymbol	| new newBase newArgument newFunction |	new := super createFor: argumentList withBase: anExpression symbol: aSymbol.	"For the where clause version, we've got a dualRoleFunction. We can't just rebuild the whole thing, so rebuild the children, and then re-assemble it recreating from the template."	newBase := new whereClauseVersion base isNil ifTrue: [anExpression] ifFalse: [new whereClauseVersion base rebuildOn: anExpression].	newArgument := new whereClauseVersion argument rebuildOn: anExpression.	newFunction := self whereClauseVersion copyOld.	newFunction symbol: aSymbol.	newFunction base: newBase.	newFunction argument: newArgument.	new whereClauseVersion: newFunction.	"Don't try to rebuild the selectListVersion at all, because at least for the motivating case we have, it's just a shell, not a full blown expression, and it will already have been copied."	^new.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuiltBase rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	rebuiltBase := base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	rebuilt := self copyOld.	rebuilt base: rebuiltBase.	rebuilt query: (query rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression).	^rebuilt."	^query asGlorpExpressionOn: aBaseExpression."</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	super postCopy.	queries := queries collect: [:each | each copyOld].</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>class lookup</category><body package="GlorpExtensions" selector="removeObsolete">removeObsolete	| workingNames |	self isVisualWorks ifFalse: [^self].	(workingNames := self lookedUpNames) copyOld keysAndValuesDo: 		[:key :value |		value isObsolete ifTrue: [workingNames removeKey: key ifAbsent: nil]]</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="reverseAdjustIn:">reverseAdjustIn: aRowMapForMementos	"Adjust ourselves to refer to the originals rather than the copies"	| adjusted |	adjusted := self copyOld.	adjusted keys: (keys collect: [:each | 		aRowMapForMementos reversedCorrespondenceMap at: each ifAbsent: [each]]).	^adjusted.</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="adjustIn:">adjustIn: aCorrespondenceMap	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copyOld.	adjusted keys: (keys collect: [:each | aCorrespondenceMap at: each ifAbsent: [each]]).	^adjusted.</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>printing</category><body package="GlorpQueries" selector="printLeftoverTablesOn:">printLeftoverTablesOn: aCommand	"Now there might be leftover tables whose joins were implied directly by the where clause"	| leftOverTables |	leftOverTables := self allTables asSet copyOld.	availableTables do: [:each | leftOverTables remove: each ifAbsent: []].	leftOverTables isEmpty ifFalse: [aCommand nextPutAll: ', '].	GlorpHelper		print: [:each | each sqlTableName]		on: aCommand		for: leftOverTables		separatedBy: ', '.</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>printing</category><body package="GlorpQueries" selector="printJoinsOn:">printJoinsOn: aCommand	"This is pretty hideous. Figure out an order in which to print these stupid joins. As a bonus, they may be circular, so we may have to collapse joins together. And if we collapse, we can't print as we go because we don't know how many parentheses to add, so store them up and print them all at the end"	| allJoins |	joinsToProcess := query joins copyOld.	availableTables := Set with: self rootTable.	allJoins := OrderedCollection new.	[joinsToProcess isEmpty] whileFalse: [		| next nextTable allRelatedJoins fullJoin|		next := self nextJoin.		joinsToProcess remove: next.		nextTable := next tableToJoinFrom: availableTables.		allRelatedJoins := joinsToProcess select: [:each | (each tableToJoinFrom: availableTables) = nextTable].		fullJoin := allRelatedJoins inject: next into: [:sum :each | sum AND: each].		joinsToProcess removeAll: allRelatedJoins.		allJoins add: (fullJoin-&gt;nextTable).		availableTables addAll: (next tablesForANSIJoin)].	allJoins size timesRepeat: [aCommand platform parenthesizeCommandsInCompoundQuery ifTrue: [aCommand nextPut: $(]].	aCommand nextPutAll: self rootTable sqlTableName.	allJoins do: [:each | 		each key printForANSIJoinTo: each value on: aCommand.		aCommand platform parenthesizeCommandsInCompoundQuery ifTrue: [aCommand nextPut: $)]].	self printLeftoverTablesOn: aCommand.</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="reverseAdjustIn:">reverseAdjustIn: aRowMapForMementos	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copyOld.	adjusted key1: (aRowMapForMementos reversedCorrespondenceMap at: key1 ifAbsent: [key1]).	adjusted key2: (aRowMapForMementos reversedCorrespondenceMap at: key2 ifAbsent: [key2]).	^adjusted.</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="adjustIn:">adjustIn: aCorrespondenceMap	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copyOld.	adjusted key1: (aCorrespondenceMap at: key1 ifAbsent: [key1]).	adjusted key2: (aCorrespondenceMap at: key2 ifAbsent: [key2]).	^adjusted.</body></methods><methods><class-id>Glorp.SQLite3PragmaQuery</class-id> <category>sql generation</category><body package="GlorpQueries" selector="sqlWith:">sqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copyOld.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^SQLite3PragmaCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>copying</category><body package="GlorpExpressions" selector="createFor:">createFor: arguments	| new |	new := self copyOld.	new arguments: arguments.	new type: type.	^new.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>copying</category><body package="GlorpExpressions" selector="createFor:withBase:symbol:">createFor: arguments withBase: anExpression symbol: aSymbol	| new |	new := self copyOld.	new base: anExpression.	new symbol: aSymbol.	new type: type.	new arguments: arguments.	^new.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| newBase |	newBase := base asExpressionJoiningSource: source toTarget: target.	^self copyOld function: function; base: newBase.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| copy |	self == anExpression ifTrue: [^aBaseExpression].	self base == ultimateBaseExpression ifTrue: [^self].	copy := self copyOld.	copy base: aBaseExpression.	^copy.</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>registering</category><body package="GlorpUnitOfWork" selector="registerTransientInternalsOfCollection:">registerTransientInternalsOfCollection: aCollection	"If this is a collection, then we may need to register any internal structures it has, e.g. an internal array. This is implementation dependent for the collection. We will also explicitly exclude strings"	aCollection glorpIsCollection ifFalse: [^self].	aCollection class isBits ifTrue: [^self].	(self needsCollectionMementoFor: aCollection)		ifTrue: [collectionMementos at: aCollection put: aCollection copyOld].	aCollection glorpRegisterCollectionInternalsIn: self."For this to work, the dialect must not copy collections so shallowly that internals are reused identically.In VW, Dictionary copy calls postCopy, which copies the associations or value collection (but not thekeys).  Without this, mementos added to the original would also be added to the copy.  In VA, sendingcopy to a Dictionary does a shallow copy.  In VA, inline the call of copy to shallowCopy and send thepostCopy call to it explicitly to get the behaviour we need without changing Dictionary copy behaviourin VA, which might have side-effects.  This feature's tests have been altered to check this copy safety."</body></methods><methods><class-id>Glorp.Join</class-id> <category>api</category><body package="GlorpExpressions" selector="asGlorpExpressionOn:">asGlorpExpressionOn: aBaseExpression	| copy |	copy := self copyOld.	copy base: aBaseExpression.	copy outerJoin: outerJoin.	^copy.</body></methods><methods><class-id>Glorp.Join</class-id> <category>api</category><body package="GlorpExpressions" selector="asOuterJoin">asOuterJoin	^self copyOld beOuterJoin.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>bound values</category><body package="GlorpDatabase" selector="rowAtATimeBindings">rowAtATimeBindings	"Return multiple sets of bindings in a form suitable for iterating over"	| allBindings fields rowTemplate |	fields := self arrayBoundFields.	rowTemplate := Array new: fields size.	allBindings := Array new: allRows size.	1 to: allBindings size do: [:i | | currentRow input |		currentRow := rowTemplate copyOld.		input := allRows at: i.		allBindings at: i put: currentRow.		1 to: fields size do: [:j |			currentRow at: j put: (input at: (fields at: j) ifAbsent: [nil])]].	^allBindings asArray.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>As yet unclassified</category><body package="GlorpCore" selector="deleteSqlWith:">deleteSqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copyOld.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^QueryDeleteCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>As yet unclassified</category><body package="GlorpCore" selector="sqlWith:">sqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copyOld.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^QuerySelectCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>preparing</category><body package="GlorpQueries" selector="copyOfBuilders">copyOfBuilders 	"Copy the builders, but make sure that subBuilders also get matched up"	| newBuilders |	newBuilders := builders collect: [:each | each copyOld].	newBuilders do: [:each | each reconcileWithBuilders: builders andCopy: newBuilders].	^newBuilders.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>fields</category><body package="GlorpExpressions" selector="aliasTable:to:">aliasTable: aDatabaseTable to: aString 	| newTable |	newTable := aDatabaseTable copyOld.	newTable name: aString.	newTable parent: aDatabaseTable.	newTable schema: ''.	self tableAliases at: aDatabaseTable put: newTable</body></methods><methods><class-id>Text2.FlowLine</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayParagraphLinesOn:">displayParagraphLinesOn: aGraphicsContext	"Draw the paragraph guide lines, a debugging tool."	| gc |	(aGraphicsContext clientDataAt: #showParagraphMarkers ifAbsent: [false]) ifFalse: [^self].	gc := aGraphicsContext copyOld.	ColorValue orange installOn: gc.	self isParagraphStart ifTrue: [		gc displayRectangle: ((bounds left - 2 @ 0) corner: ((bounds left @ 0) + (0 @ bounds height))).		gc displayRectangle: ((bounds left - 2 @ 0) corner: (bounds left + 6 @ 2))].	self isParagraphStop ifTrue: [		gc displayRectangle: ((bounds right @ 0) corner: (bounds right + 2 @ bounds height)).		gc displayRectangle: ((bounds right - 4 @ (bounds height - 2)) corner: (bounds right + 2 @ bounds height))].</body></methods><methods><class-id>Text2.FlowParagraph</class-id> <category>copying</category><body package="Graphics-Text2-Flow" selector="postCopy">postCopy	bounds := bounds copyOld</body></methods><methods><class-id>Text2.TreapNode</class-id> <category>private</category><body package="Graphics-Text2-Support" selector="rotateRight">rotateRight	"Re-balance the tree by rotating the nodes to the right"	| temp |	temp := left copyOld.	temp previous == nil ifFalse: [temp previous next: temp].	temp next == nil ifFalse: [temp next previous: temp].	left := left right.	temp right: self.	^temp</body></methods><methods><class-id>Text2.TreapNode</class-id> <category>private</category><body package="Graphics-Text2-Support" selector="rotateLeft">rotateLeft	"Re-balance the tree by rotating the nodes to the left"	| temp |	temp := right copyOld.	temp previous == nil ifFalse: [temp previous next: temp].	temp next == nil ifFalse: [temp next previous: temp].	right := right left.	temp left: self.	^temp</body></methods><methods><class-id>Text2.DocumentSpan</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitTo:">splitTo: anOffset	anOffset = size ifTrue: [^self copyOld].	^self class fromString: string style: style offset: offset size: anOffset</body></methods><methods><class-id>Text2.DocumentSpan</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:">splitFrom: anOffset	anOffset = 0 ifTrue: [^self copyOld].	^self class fromString: string style: style offset: offset + anOffset size: size - anOffset</body></methods><methods><class-id>Text2.DocumentSpan</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:to:">splitFrom: start to: stop	(start = 0 and: [stop = size]) ifTrue: [^self copyOld].	^self class fromString: string style: style offset: offset + start size: (stop - start)</body></methods><methods><class-id>Text2.DocumentListItem</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitTo:">splitTo: anOffset	anOffset = 1 ifTrue: [^self copyOld].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.DocumentListItem</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:">splitFrom: anOffset	anOffset = 0 ifTrue: [^self copyOld].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.DocumentListItem</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:to:">splitFrom: start to: stop	(start = 0 and: [stop = 1]) ifTrue: [^self copyOld].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.Document</class-id> <category>copying</category><body package="Graphics-Text2-Document" selector="copyBetween:and:apply:">copyBetween: start and: stop apply: aBlockClosure	"Make a copy of the receiver between positions start and stop while applying a change to each intersecting segments styling using aBlockClosure. The positions are between characters with the position range of 0..size."	| startNode stopNode node copy segment offset |	stop &lt; start ifTrue: [^self error: 'position contiguity error'].	start &lt; 0 ifTrue: [^self error: 'position out of bounds'].	stop &gt; size ifTrue: [^self error: 'position out of bounds'].	copy := self class new.	copy unicodeProperties: unicodeProperties.	copy size: stop - start.	startNode := self nodeAtPositionAfter: start.	stopNode := start = stop		ifTrue: [startNode]		ifFalse: [self nodeAtPositionBefore: stop].	startNode == stopNode ifTrue: [		segment := startNode value splitFrom: start - startNode key to: stop - startNode key.		segment style: (aBlockClosure cull: segment style).		copy insertAt: 0 segment: segment.		^copy].	segment := startNode value splitFrom: start - startNode key.	segment style: (aBlockClosure cull: segment style).	copy insertAt: 0 segment: segment.	offset := segment size.		node := startNode next.	[node == stopNode] whileFalse: [		segment := node value copyOld.		segment style: (aBlockClosure cull: segment style).		copy insertAt: offset segment: segment.		offset := offset + segment size.		node := node next].	segment := stopNode value splitTo: stop - stopNode key.	segment style: (aBlockClosure cull: segment style).	copy insertAt: offset segment: segment.	^copy</body></methods><methods><class-id>Text2.Document</class-id> <category>copying</category><body package="Graphics-Text2-Document" selector="copyBetween:and:">copyBetween: start and: stop	"Make a copy of the receiver between positions start and stop. The positions are between characters with the position range of 0..size."	| startNode stopNode node copy offset |	stop &lt; start ifTrue: [^self error: 'position contiguity error'].	start &lt; 0 ifTrue: [^self error: 'position out of bounds'].	stop &gt; size ifTrue: [^self error: 'position out of bounds'].	copy := self class new.	copy unicodeProperties: unicodeProperties.	copy size: stop - start.	startNode := self nodeAtPositionAfter: start.	stopNode := start = stop		ifTrue: [startNode]		ifFalse: [self nodeAtPositionBefore: stop].	startNode == stopNode ifTrue: [		copy insertAt: 0 segment: (startNode value splitFrom: start - startNode key to: stop - startNode key).		^copy].	copy insertAt: 0 segment: (startNode value splitFrom: start - startNode key).	offset := startNode value size - (start - startNode key).	node := startNode next.	[node == stopNode] whileFalse: [		copy insertAt: offset segment: node value copyOld.		offset := offset + node value size.		node := node next].	copy insertAt: offset segment: (stopNode value splitTo: stop - stopNode key).	^copy</body></methods><methods><class-id>Text2.Document</class-id> <category>modifying</category><body package="Graphics-Text2-Document" selector="replaceBetween:and:with:">replaceBetween: start and: stop with: replacement	"Replace between positions start..stop with replacement, which can be a Document or a String. The positions are between characters in the document, with a range of 0..size. This one method can be used to perform an insert, delete or a replace all in one:		insert example: 'Hello World' asDocument replaceBetween: 0 and: 0 with: 'X'.		delete example: 'Hello World' asDocument replaceBetween: 0 and: 1 with: ''		replace example: 'Hello World' asDocument replaceBetween: 0 and: 1 with: 'X'.	"	| startNode stopNode replacementDocument replacementStart replacementStop node delta replacedOffsets |	stop &lt; start ifTrue: [^self error: 'position contiguity error'].	start &lt; 0 ifTrue: [^self error: 'position out of bounds'].	stop &gt; size ifTrue: [^self error: 'position out of bounds'].	replacementDocument := replacement asDocument.	"If we're empty, copy the contents of the other document"	self isEmpty ifTrue: [		replacementDocument offsetsAndSegmentsDo: [:offset :segment | self insertAt: offset segment: segment copyOld].		cache := nil.		size := replacementDocument size.		^self].	startNode := self nodeAtPositionAfter: start.	stopNode := start = stop		ifTrue: [startNode]		ifFalse: [self nodeAtPositionAfter: stop].	"Remove startNode .. stopNode. We must first copy the nodes because as we remove nodes, the previous/next chain will change as nodes rotate in the treap."	node := startNode.	replacedOffsets := OrderedCollection new.	[replacedOffsets add: node key.	node == stopNode] whileFalse: [node := node next].	replacedOffsets do: [:each | offsets removeKey: each].	"Move stopNode .. lastNode by (replacementDocument size - size removed)."	delta := replacementDocument size - (stop - start).	delta = 0 ifFalse: [		node := stopNode next isNil			ifTrue: [nil]			ifFalse: [self nodeAtPositionAfter: stopNode next key].		[node isNil] whileFalse: [			node key: node key + delta.			node := node next]].	"Create replacement start/stop"	replacementStart := replacementStop := nil.	(start - startNode key) &gt; 0 ifTrue: [		replacementStart := (start - startNode key) = startNode value size			ifTrue: [startNode value]			ifFalse: [startNode value splitTo: start - startNode key]].	(stop - stopNode key) &lt; stopNode value size ifTrue: [		replacementStop := (stop - stopNode key) = 0			ifTrue: [stopNode value]			ifFalse: [stopNode value splitFrom: stop - stopNode key]].	"Insert replacement start + document + stop"	replacementStart isNil ifFalse: [self insertAt: startNode key segment: replacementStart].	replacementDocument offsetsAndSegmentsDo: [:offset :segment | self insertAt: start + offset segment: segment copyOld].	replacementStop isNil ifFalse: [self insertAt: start + replacementDocument size segment: replacementStop].	"Update our size"	size := size + delta.	cache := nil</body></methods><methods><class-id>Text2.FlowSegment</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayAdornmentOn:y:">displayAdornmentOn: aGraphicsContext y: y	"Render the adornment on aGraphicsContext."	| gc |	gc := aGraphicsContext copyOld.	self style adornmentColor installOn: gc.	self perform: (self style adornment, 'DisplayOn:y:') asSymbol with: gc with: y</body></methods><methods><class-id>Text2.FlowSegment</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayOn:y:selectingBetween:and:">displayOn: aGraphicsContext y: y selectingBetween: selectionStartPosition and: selectionStopPosition	"Subclasses should implement, display the content of the segment on aGraphicsContext at x@y."	| containedInSelection containsStart containsStop gc clip1 clip2 start stop lineHeight selectionForegroundColor |	selectionForegroundColor := aGraphicsContext		clientDataAt: #selectionForegroundColor		ifAbsent: [^self displayOn: aGraphicsContext y: y].	containedInSelection := self start between: selectionStartPosition and: selectionStopPosition.	containsStart := selectionStartPosition between: self start and: self stop.	containsStop := selectionStopPosition between: self start and: self stop.	"The fast path, when there's no selection on this line or the foreground selection color is black."	(containsStart or: [containsStop]) ifFalse: [		gc := aGraphicsContext.		containedInSelection ifTrue: [			gc := aGraphicsContext copyOld.			gc paint: selectionForegroundColor].		^self displayOn: gc y: y].	start := (selectionStartPosition - self start) max: 0.	stop := (selectionStopPosition - self start) min: self size.	self isRightToLeft ifTrue: [		start := self size - start.		stop := self size - stop].	lineHeight := paragraph bounds height + 1.	clip1 := self isLeftToRight ifTrue: [0] ifFalse: [paragraph width].	clip2 := self isLeftToRight ifTrue: [paragraph width] ifFalse: [0].	containsStart ifTrue: [clip1 := self pixelXAtCoordinate: start device: aGraphicsContext medium graphicsDevice].	containsStop ifTrue: [clip2 := self pixelXAtCoordinate: stop device: aGraphicsContext medium graphicsDevice].	self isRightToLeft ifTrue: [		| swap |		swap := clip1.		clip1 := clip2.		clip2 := swap].	gc := aGraphicsContext copyOld.	gc intersectClip: ((0 @ 0) corner: (clip1 @ lineHeight)).	self displayOn: gc y: y.	gc := aGraphicsContext copyOld.	gc intersectClip: ((clip1 @ 0) corner: (clip2 @ lineHeight)).	gc paint: selectionForegroundColor.	self displayOn: gc y: y.	gc := aGraphicsContext copyOld.	gc intersectClip: ((clip2 @ 0) corner: (paragraph width @ lineHeight)).	self displayOn: gc y: y</body></methods><methods><class-id>Text2.DocumentImage</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:">splitFrom: anOffset	anOffset = 0 ifTrue: [^self copyOld].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.DocumentImage</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:to:">splitFrom: start to: stop	(start = 0 and: [stop = 1]) ifTrue: [^self copyOld].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.DocumentImage</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitTo:">splitTo: anOffset	anOffset = 1 ifTrue: [^self copyOld].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.FlowImage</class-id> <category>private - layout</category><body package="Graphics-Text2-Flow" selector="fit:into:device:">fit: maxWidth into: paragraphSegments device: device	(left = 0 and: [((1 - segment wrappingPercentage) * segment image width) &lt;= maxWidth]) ifFalse: [^super fit: maxWidth into: paragraphSegments device: device].	right := maxWidth.		paragraphSegments addFirst:		(self copyOld			left: right right: segment image width;			yourself).	paragraphSegments addFirst: self</body></methods><methods><class-id>Text2.FlowImage</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayOn:y:">displayOn: aGraphicsContext y: y	| gc |	gc := aGraphicsContext copyOld.	gc intersectClip: ((x @ (y - segment image height + 1)) extent: (right @ segment image height)).	segment image displayOn: gc at: (x - left) @ (y - segment image height + 1)</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private updating</category><body package="System-Code Storage" selector="installChangedNamespaces:">installChangedNamespaces: aCodeComponent	"A more complex implementation would substitute the physical NameSpace,	moving bindings across, etc, but this is potentially very complex.  We will use	the simple approach above until it proves inadequate.	Simply evaluate the definition message substituting the system version of the environment."	| changedNameSpaces |	changedNameSpaces := (updates at: #changed) select: [:each | each isNameSpace].	changedNameSpaces isEmpty ifTrue: [^self].	changedNameSpaces copyOld do:		[:each |		| overrides target |		overrides := Override overridesForClassOrNameSpace: each strictReference value.		overrides ifNotNil: [target := overrides detect: [:eachOverride | eachOverride sources includes: aCodeComponent relatedPundle] ifNone: [nil]].		target ifNotNil: 			[target setOverriddenDefinition: each definitionMessage.			(updates at: #changed) remove: each ifAbsent: [nil].			changedNameSpaces remove: each]].	changedNameSpaces do:		[:eachNameSpace|		eachNameSpace definitionMessage			receiver: eachNameSpace environment strictReference value;			value]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private updating</category><body package="System-Code Storage" selector="installChangedStatics:">installChangedStatics: aCodeComponent	| changedShareds |	changedShareds := (updates at: #changed) select: [:thing | thing isVariableBinding].	changedShareds isEmpty ifTrue: [^self].	changedShareds copyOld do:		[:each |		| overrides target |		each environment strictReference bindingOrNil ifNotNil:			[overrides := Override overridesForStatic: each in: each environment strictReference value.			overrides ifNotNil:[target := overrides detect: [:eachOverride | eachOverride sources includes: aCodeComponent relatedPundle] ifNone: [nil]].			target ifNotNil: 				[target setOverriddenDefinition: (target owner asNameSpace definitionMessageOfStatic: each).				(updates at: #changed) remove: each ifAbsent: [nil].				changedShareds remove: each]]].	definedBindings keysAndValuesDo:		[:env :keySet| | shadowEnv systemEnv | 		"env is class or namespace"		systemEnv := env strictReference value.		shadowEnv := self shadowOf: env.		keySet do:			[:key | 			| loadedBinding systemVersion |			loadedBinding := self bindingFor: key within: shadowEnv inSet: changedShareds.			loadedBinding notNil ifTrue:				[systemVersion := systemEnv asNameSpace localBindingFor: key.				loadedBinding environment: systemEnv.				loadedBinding initializer ~~ nil ifTrue:					[loadedBinding initializer method fixEnvironmentTo: systemEnv].				#(isPrivate isConstant category initializer)					with: #(bePrivate: beConstant: category: initializer:) 					do: 						[:getter :setter|						[systemVersion perform: setter with: (loadedBinding perform: getter)]							on: ConstantBindingModificationError							do: [:ex| ex resume]]]]]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private updating</category><body package="System-Code Storage" selector="installChangedClasses:within:">installChangedClasses: aCodeComponent within: aBundleOrNil	"We did not compare the methods of changed classes compareDefinedClassesIn:.	 We need to do that now (at the bottom) after the new class(s) have been installed"	| changedClasses loadOrderedClasses classBuilder overriddenClasses |	changedClasses := (updates at: #changed) select: [:each | each isBehavior].	changedClasses isEmpty ifTrue: [^self].	loadOrderedClasses := properties at: #loadOrderedClasses ifAbsent: [nil].	loadOrderedClasses := loadOrderedClasses isNil		ifTrue: [changedClasses]		ifFalse: [loadOrderedClasses select: [:each | changedClasses includes: each]].	overriddenClasses := OrderedCollection new.	loadOrderedClasses copyOld do:		[:each |		(Override isOverriddenClassOrNameSpace: each strictReference value in: aCodeComponent relatedPundle) ifTrue:			[loadOrderedClasses remove: each.			overriddenClasses add: each]].	classBuilder := ClassBuilder new.	loadOrderedClasses do:		[:eachClass| 		| classBuilderRecord methodBuilderRecord messageSend |		classBuilderRecord := BehaviorBuilderRecord forClass: eachClass strictReference value.		methodBuilderRecord := MetaclassBuilderRecord forInstance: classBuilderRecord.		messageSend := eachClass definitionMessage.		messageSend selector keywords			with: messageSend arguments			do: 				[:keyword :arg|				keyword ~= 'defineClass:' ifTrue:					[keyword = 'classInstanceVariableNames:'						ifTrue: [methodBuilderRecord instVarString: arg]						ifFalse:							[classBuilderRecord								perform: keyword asSymbol								with: (keyword = 'superclass:' ifTrue: [arg value] ifFalse: [arg])]]].		classBuilder			addRecord: classBuilderRecord;			addRecord: methodBuilderRecord].	loadOrderedClasses notEmpty ifTrue: [classBuilder reviseSystemSilently].	"Here we take overridden things and put the (possibly new) definition in the override object"	overriddenClasses do:		[:each |		| overrides target |		overrides := Override overridesForClassOrNameSpace: each strictReference value.		overrides ifNotNil: 			[target := overrides detect: [:eachOverride | eachOverride sources includes: aCodeComponent relatedPundle] ifNone: [nil]].		target ifNotNil: 			[target setOverriddenDefinition: each definitionMessage.			(updates at: #changed) remove: each ifAbsent: [nil]]].	"Since Bundle structure may have causes us to consider additions	 to be changes we still need to make sure the CodeComponent includes the class."	aCodeComponent addClasses: loadOrderedClasses.	changedClasses do: 		[:each | 		each strictReference ifDefinedDo:			[:systemVersion|			self 				compareMethodsIn: each				withSystemVersion: systemVersion				for: aCodeComponent				within: aBundleOrNil.			self 				compareMethodsIn: each class				withSystemVersion: systemVersion class				for: aCodeComponent				within: aBundleOrNil]].</body></methods><methods><class-id>Kernel.TimerSystem</class-id> <category>default actions</category><body package="Kernel-Processes" selector="setUp">setUp	| overdue restartPeriod resumption elapsed |	super setUp.	"Configure the native timer system and fallback timer system."	Callback := nil.	self configureTimerSystem.	"We are about to reschedule the timers themselves and any timers that would have expired while the image was	 suspended may be waiting on the TimerLock if their callback happened while the snapshot was being taken.	 We terminate the processes waiting on the TimerLock because we are about to reschedule those timers below	 and they will fire their callbacks then. This ensures the callback will not fire twice."	[TimerLock isEmpty] whileFalse: [TimerLock terminateProcess].	"Some timers are configured to specifically use the native interface. If we have no native interface available, we have to throw those timers away. We do at least put out a warning on the transcript."	NativeInterface ifNil:		[remainingSnapshot keys copyOld do: [:aTimer |			aTimer usesNativeInterface ifTrue:				[Transcript cr; nextPutAll: ((#UnableToRestartNativeTimer1p &lt;&lt; #dialogs &gt;&gt; 'Unable to restart native Timer: &lt;1p&gt;') expandMacrosWith: aTimer identityHash).				remainingSnapshot removeKey: aTimer]]].	"Reschedule the timers that were active at snapshot."	overdue := OrderedCollection new.	remainingSnapshot keysAndValuesDo: [:aTimer :remaining |		"Invalidate aTimer, as its OS resource no longer exists."		aTimer privateInvalidate.		"We offset each timer by the amount of elapsed time that has passed since the image was saved and resume each timer with the difference. If the clock has traveled back in time, then we do not count any elapsed time as having passed."		resumption := Timestamp nowUTC.		elapsed := resumption - microsecondSnapshot.		elapsed negative ifTrue: [elapsed := Duration zero].		restartPeriod := remaining - elapsed.		[	(restartPeriod isZero not and: [restartPeriod positive])				ifTrue:	[aTimer privateStartAfter: restartPeriod]				ifFalse:					[overdue add: aTimer.					(aTimer period isZero not and: [aTimer period positive]) ifTrue:						[restartPeriod := (restartPeriod asNanoseconds \\ aTimer period asNanoseconds) nanoseconds.						aTimer privateStartAfter: restartPeriod]]		] on: Error do: [ :ex |			"If the timer fails to reschedule (maybe because the default interface has changed and the new one can't handle the timer),			there's nothing else to do. The timer will not be activated."			aTimer flagInvalidTimer: 'Failed to reschedule in TimerSystem&gt;&gt;setUp - ', ex description ]].	remainingSnapshot := nil.	"Allow timers to fire and fire the overdue timers."	overdue do: #privateFire.	TimerLock signal</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>accessing</category><body package="System-Name Spaces" selector="duplicateBinding:under:">duplicateBinding: existingName under: newName	"Duplicate a binding in the receiver under a new name for purposes of variable renaming.	 This is tricky because we want to arrange both that the existing binding changes its name	 and a new binding gets the old name, and that a lookup of either name will succeed at any	 time during the duplication."	| existingTemp newTemp oldBindings tempBindings existingBinding duplicate |	(self includesKey: newName) ifTrue:		[self error: #errNewNameExists &lt;&lt; #dialogs &gt;&gt; 'new name already exists'].	existingBinding := self localBindingFor: existingName.	"First create a temporary set of bindings that contain new bindings for	 existingName and newName to serve while we're changing things."	existingTemp := existingBinding copyOld.	newTemp := existingBinding copyOld.	newTemp key: newName.	tempBindings := bindings copyEmpty: bindings basicSize.	bindings do:		[:binding|		binding key == existingName			ifTrue:				[tempBindings add: existingTemp; add: newTemp]			ifFalse:				[tempBindings add: binding]].	oldBindings := bindings.	bindings := tempBindings.	"Now rename the existingBinding, which requires removing it and adding it from	 bindings to ensure it gets hashed correctly, and add a duplicate with the old name."	oldBindings remove: existingBinding.	duplicate := existingBinding copyOld.	duplicate key: existingName.	existingBinding key: newName.	oldBindings add: existingBinding; add: duplicate.	bindings := oldBindings</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>initialize-release</category><body package="System-Compiler-Names and Scopes" selector="receiverName:withSuper:">receiverName: name withSuper: superFlag	"For the method scope, or block scopes that	can name their receiver (not in the language right now)."		| var |	variables == nil ifTrue: [self initVariables].	var := ReceiverVariable new scope: nesting.	variables at: name put: var.	superFlag		ifTrue:			[variables				at: 'super'				put: (var copyOld isSuper: true)]</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>accessing-debugger</category><body package="System-Compiler-Names and Scopes" selector="localTemps">localTemps	"Answer the local variable names	in this scope."	^(self isClonedFromOuter or: [variableList == nil])		ifTrue: [#()]		ifFalse: [variableList collect: [:var | var copyOld]]</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>initialize-release</category><body package="System-Compiler-Names and Scopes" selector="newOptimizedBlockScope">newOptimizedBlockScope	"Make an appropriate scope for an inner block."	"WARNING -- the system depends on the fact that the	copy and the original scope share the same collection	as their 'variableList'.  The variableList must be added	to rather than copied when new elements are added."	| inner |	variables == nil ifTrue: [self initVariables].	inner := self copyOld.	inner outerScope: self.	inner resetVars.	^inner</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>initialize-release</category><body package="System-Compiler-Names and Scopes" selector="disallowReceiverName:withSuper:">disallowReceiverName: name withSuper: superFlag	"For the method scope, or block scopes that	can name their receiver (not in the language right now)."		| var |	variables == nil ifTrue: [self initVariables].	var := ReceiverVariable new scope: nesting.	var markIllegal.	variables at: name put: var.	superFlag		ifTrue:			[variables				at: 'super'				put: (var copyOld isSuper: true)]</body></methods><methods><class-id>Kernel.DeferredBinding</class-id> <category>converting</category><body package="Collections-Support" selector="asDeferred">asDeferred	^self copyOld</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private</category><body package="BOSS" selector="cyclicShortBody:to:">cyclicShortBody: aBody to: bodies	"Add a forwarding reference to an object.  This will be resolved later"	| max bits |	bits := aBody at: 3.	swapBytes ifTrue:		[			bits := bits copyOld.			self swapShortOopsIn: bits		].	max := 0.	1 to: bits size by: self bytesPerShortOop do:		[:eachIndex | | oop |		oop := self shortOops: bits at: eachIndex.		"Ignore immediate values."		(oop bitAnd: 1) = 1 ifTrue: [oop := 0].		max := max max: oop].	bodies add: (aBody copyWith: max)</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private</category><body package="BOSS" selector="cyclicLongBody:to:">cyclicLongBody: aBody to: bodies	"Add a forwarding reference to an object.  This will be resolved later"	| max bits |	bits := aBody at: 3.	swapBytes ifTrue:		[			bits := bits copyOld.			self swapLongOopsIn: bits		].	max := 0.	1 to: bits size by: self bytesPerLongOop do:		[:eachIndex | | oop |		oop := self longOops: bits unsignedAt: eachIndex.		"Ignore immediate values."		(oop bitAnd: 1) = 1 ifTrue: [oop := 0].		max := max max: oop].	bodies add: (aBody copyWith: max)</body></methods><methods><class-id>Kernel.StrictBindingReference</class-id> <category>private</category><body package="System-Name Spaces" selector="duplicateWithPath:">duplicateWithPath: aPath	^self copyOld path: aPath</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>copying</category><body package="System-Code Components" selector="postCopy">postCopy	"Ensure that all relevant sub-structure is copied."	properties := properties copyOld.	properties keysAndValuesDo:		[ :k :v | properties at: k put: v copyOld ]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>accessing</category><body package="System-Code Components" selector="properties">properties	"Answer a copy of the component's properties"	^properties copyOld</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>private-load/unload</category><body package="System-Code Components" selector="purgeUndeclaredIfRequired:">purgeUndeclaredIfRequired: aCodeReader	"If there are any undeclared variables in the package that are also in Undeclared	 then purge unused bindings in Undeclared to try and remove them.  To successfully	 purge we have to discard the bindings from our properties and the codeReader's	 packageUndeclared.  We can just hang on to the keys and rely on Undeclared to hold	 onto the actual bindings."	| undeclaredKeys |	aCodeReader purgeUndeclared.	undeclaredKeys := (properties at: #packageUndeclared) keys.	(undeclaredKeys anySatisfy: [:key | Undeclared includesKey: key]) ifTrue:		[undeclaredKeys do: [:each | Undeclared removeKey: each].		Undeclared purgeUnusedBindings.		undeclaredKeys copyOld do: [:each | (Undeclared includesKey: each) ifFalse: [undeclaredKeys remove: each]]].	properties at: #packageUndeclared put: undeclaredKeys.</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="propertiesWithoutVolatileKeys">propertiesWithoutVolatileKeys	"Answer a copy of the component's properties"	| propertiesCopy |	propertiesCopy := properties copyOld.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesCopy removeKey: each ifAbsent: [nil]].	^propertiesCopy</body></methods><methods><class-id>Kernel.InteractiveCompilerErrorHandler</class-id> <category>private-undeclared variables</category><body package="System-Compiler-Support" selector="importContainer:from:">importContainer: varBinding from: codeStream 	| which binding |	binding := varBinding path.	binding := binding copyFrom: 1 to: binding size - 1.	binding size = 0 ifTrue: [binding := #(#Smalltalk) copyOld].	binding := BindingReference path: binding.	which := Dialog 				choose: (#OKToAddImportQ &lt;&lt; #dialogs 						&gt;&gt; 'Do you want to add "&lt;1s&gt;.*" as&lt;n&gt;an import of the class imports or of the NameSpace?' 							expandMacrosWith: binding asString)				labels: (Array 						with: #toTheClass &lt;&lt; #dialogs &gt;&gt; 'to the class'						with: #toTheNameSpace &lt;&lt; #dialogs &gt;&gt; 'to the name space'						with: #cancel &lt;&lt; #dialogs &gt;&gt; 'cancel')				values: #(#class #nameSpace nil)				default: #proceed				for: editor view.	which == nil ifTrue: [^self abort].	self replaceEditSelectionWith: varBinding simpleName.	which == #class 		ifTrue: 			[RedefinitionNotification redefinedClass: class attributes: nil.			SystemUtils modifySystem: 					[(class asNameSpace)						checkInstalled;						addImport: ((GeneralNameSpaceImport path: binding path) private: true)].			ChangeSet changeClass: class].	which == #nameSpace 		ifTrue: 			[RedefinitionNotification redefinedNameSpace: environment attributes: nil.			SystemUtils modifySystem: 					[environment 						addImport: ((GeneralNameSpaceImport path: binding path) private: true)].			ChangeSet changeNameSpace: environment].	^true</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>copying</category><body package="Kernel-Support" selector="postCopy">postCopy	files := files copyOld.	names := names copyOld.	sourceFormatters := sourceFormatters copyOld.	writableIndices := writableIndices copyOld.	openIndices := openIndices copyOld.</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>accessing</category><body package="Kernel-Support" selector="allFiles">allFiles	^names copyOld</body></methods><methods><class-id>Kernel.InstanceVariableSearch</class-id> <category>opcodes-control</category><body package="Tools-Misc" selector="jump:">jump: delta	delta &gt; 0		ifTrue: [self saveStacks at: self input pc+delta put: stack copyOld].	^false</body></methods><methods><class-id>Kernel.InstanceVariableSearch</class-id> <category>opcodes-control</category><body package="Tools-Misc" selector="jump:if:">jump: delta if: condition	self pop.	delta &gt; 0		ifTrue: [self saveStacks at: self input pc+delta put: stack copyOld].	^false</body></methods><methods><class-id>Kernel.InstanceVariableSearch</class-id> <category>searching</category><body package="Tools-Misc" selector="searchFor:type:">searchFor: instVar type: type	"Append to the stream, aStream, a description of each bytecode in the instruction	stream."		| end |	slotIndex := instVar.	searchType := type.	input := InstructionStream on: method.	stack := OrderedCollection new.	method numTemps timesRepeat: [stack add: #temp].	initialStack := stack copyOld.	end := method bytes size.	[input pc &lt;= end]		whileTrue:			[self reloadStack.			(input interpretNextInstructionFor: self) ifTrue: [^true]].	^false</body></methods><methods><class-id>Kernel.InstanceVariableSearch</class-id> <category>private</category><body package="Tools-Misc" selector="reloadStack">reloadStack	stack == nil		ifTrue: [stack :=  self saveStacks at: self input pc ifAbsent: [initialStack copyOld]].</body></methods><methods><class-id>Kernel.DecompilerAnalyzer</class-id> <category>opcodes-control</category><body package="System-Compiler-Support" selector="jump:">jump: delta	saved at: pc+delta put: stack copyOld.	stack := (saved at: pc) copyOld.</body></methods><methods><class-id>Kernel.DecompilerAnalyzer</class-id> <category>opcodes-control</category><body package="System-Compiler-Support" selector="loopHead">loopHead	saved at: pc-1 put: stack copyOld</body></methods><methods><class-id>Kernel.DecompilerAnalyzer</class-id> <category>opcodes-control</category><body package="System-Compiler-Support" selector="jump:if:">jump: delta if: condition	stack removeLast.	saved at: pc+delta put: stack copyOld.</body></methods><methods><class-id>Kernel.DecompilerAnalyzer</class-id> <category>opcodes-control</category><body package="System-Compiler-Support" selector="returnTop">returnTop	pc &gt; method endPC ifTrue: [^self].	stack := (saved at: pc) copyOld</body></methods><methods><class-id>Kernel.CompiledCodeSegment</class-id> <category>editing</category><body package="System-Compiler-Assembler" selector="insertBytesAt:bytes:for:segments:">insertBytesAt: pc bytes: newBytes for: aClient segments: segmentList	| visited |	modificationIndex := pc.	numBytesAdded := newBytes size.	bytes := bytes copyReplaceFrom: pc to: pc-1 with: newBytes.	self registry do: [:client |		client == aClient			ifFalse: [client updatePCs: [:oldPC || newPC |						newPC := oldPC.						(oldPC class == Array and: [oldPC first = index and: [oldPC last &gt;= pc]])							ifTrue: [(newPC := newPC copyOld) at: oldPC size put: oldPC last+newBytes size].						newPC]]].	visited := IdentitySet new.	segmentList do: [:seg || def adjust |		def := seg target.		def == nil			ifFalse:				[def := def definition.				(visited includes: seg target)					ifTrue: [def := nil]		"We don't want to do this twice"					ifFalse: [visited add: seg target]].		adjust := def notNil and: [def first = index].		adjust := adjust and: [def first &lt;= seg index				ifTrue: ["backward jump"  def last &gt;= pc]				ifFalse: ["forward jump"  def last &gt; pc]].		adjust			ifTrue: [seg target definition: (def copyOld at: def size put: def last + newBytes size; yourself)]].</body></methods><methods><class-id>Kernel.CompiledCodeSegment</class-id> <category>editing</category><body package="System-Compiler-Assembler" selector="removeBytesAt:size:segments:">removeBytesAt: pc size: bytesInBytecodes segments: segmentList	| visited |	modificationIndex := pc.	numBytesAdded := bytesInBytecodes negated.	bytes := bytes copyReplaceFrom: pc to: pc+bytesInBytecodes-1 with: #[].	registry do: [:client |		client updatePCs: [:oldPC || newPC |				newPC := oldPC.				(oldPC first = index and: [oldPC last &gt;= pc])					ifTrue: [(newPC := newPC copyOld) at: oldPC size put: oldPC last - bytesInBytecodes].				newPC]].	visited := IdentitySet new.	segmentList do: [:seg || def |		def := seg target.		def == nil			ifFalse:				[def := def definition.				(visited includes: seg target)					ifTrue: [def := nil]		"We don't want to do this twice"					ifFalse: [visited add: seg target]].		(def notNil and: [def first = index and: [def last &gt; pc]])			ifTrue: [seg target definition: (def copyOld at: def size put: def last - bytesInBytecodes; yourself)]].</body></methods><methods><class-id>Kernel.CompiledCodeSegment class</class-id> <category>resolving</category><body package="System-Compiler-Assembler" selector="composeSegments:">composeSegments: segments	| unresolved changed output |	unresolved := IdentitySet new.	1 to: segments size do: [:i | | seg |		seg := segments at: i.		seg index: i.		seg target == nil			ifFalse:				[seg initOptions.				unresolved add: seg]].	[changed := false.	unresolved copyOld do: [:ref |		| jumpInterval min max minOpt maxOpt opt |		jumpInterval := ref targetIndex &gt; ref index			ifTrue: [ref computeForwardJumpIn: segments]			ifFalse: [ref computeBackwardJumpIn: segments].		min := jumpInterval key.		max := jumpInterval value.		minOpt := ref jumpOptionForDelta: min.		maxOpt := ref jumpOptionForDelta: max.			"Assuming that minOpt and maxOpt are both integers			with a single bit set, set opt to be the integer that has			both the minOpt and maxOpt bits set, plus all bits between."		opt := maxOpt + maxOpt - minOpt.		opt = ref jumpOptions ifFalse: [changed := true].		ref jumpOptions: opt.		minOpt = maxOpt ifTrue: [unresolved remove: ref]].	changed] whileTrue.	output := ReadWriteStream on: (ByteArray new: 40).	segments do: [:s |		s basePC: output position+1; updateRegistry.		output nextPutAll: s bytes.		s putJumpOn: output fromSegments: segments].	^output contents</body></methods><methods><class-id>Kernel.BOSSCompiledCodeHolder</class-id> <category>accessing</category><body package="BOSS" selector="computeCodeForStorage:">computeCodeForStorage: storage	| list1 list2 map list1CodeOnly list2CodeOnly |	codeContents class == codeClass ifFalse:		[| aBlockOrNil vars newMeth |		aBlockOrNil := storage readerBlockFor: codeClass.		aBlockOrNil == nil			ifTrue:	[codeContents changeClassToThatOf: (codeClass basicNew: 0)]			ifFalse:	[aBlockOrNil value: codeContents.					class == nil ifFalse: [codeContents mclass: class]].		vars := storage variablesForClass: codeContents mclass.		vars == nil			ifFalse:				[newMeth := codeContents mclass							rebindMethod: codeContents							oldVariableNames: vars.				list1 := self enumerate: codeContents into: OrderedCollection new.				list2 := self enumerate: newMeth into: OrderedCollection new.				list1CodeOnly := self filterOutBlocksFrom: list1 copyOld.				list2CodeOnly := self filterOutBlocksFrom: list2 copyOld.				list1CodeOnly size = list2CodeOnly size					ifFalse: [self error: 'Unexplained mismatch between source and translated methods'].				map := IdentityDictionary new.				1 to: list1CodeOnly size do: [:i |					(list1CodeOnly at: i) become: (list2CodeOnly at: i).					map at: (list1CodeOnly at: i) put: (list2CodeOnly at: i).					map at: (list2CodeOnly at: i) put: (list1CodeOnly at: i)].				map at: newMeth put: self.				list1 do: [:obj | self map: obj using: map].					"Not strictly necessary, but for safety...."				list2 do: [:obj | self map: obj using: map].				]].	^codeContents</body></methods><methods><class-id>Kernel.CollationTable</class-id> <category>copying</category><body package="Collections-Collation" selector="testMissing:copyFrom:">testMissing: codePoint copyFrom: otherCollection	"Unlike SegmentedCollection, we're using zero-based indices--keep in mind when computing offsets."	| page |	(otherCollection class == self class			or: [otherCollection species == self species			or: [otherCollection pageSize == self pageSize]])		ifFalse: [self error: 'Incompatible collection implementations'].	page := codePoint // self pageSize + 1.	page &gt; self basicSize		ifTrue: [self become: (self copyWithSize: page*self pageSize)].	(self basicAt: page) == nil		ifTrue: [self basicAt: page put: (otherCollection basicAt: page) copyOld].</body></methods><methods><class-id>Kernel.CollationTable</class-id> <category>copying</category><body package="Collections-Collation" selector="copyWithSize:">copyWithSize: newSize	"Answer a copy of me that can store at least newSize elements."	| new |	new := self copyEmpty: newSize.	1 to: (self basicSize min: new size) do:		[:i |		new basicAt: i put: (self basicAt: i) copyOld].	^new</body></methods><methods><class-id>Kernel.CollationTable class</class-id> <category>utilities</category><body package="Collections-Collation" selector="convert:">convert: aLargeWordArray	| pageClass new page |	pageClass := OriginalCollationUnits.	new := self new: aLargeWordArray size/2 pageType: pageClass pageSize: 128.	new basicSize = aLargeWordArray basicSize ifFalse: [self error: 'Size was calculated wrong'].	1 to: new basicSize do: [:index |		page := aLargeWordArray basicAt: index.		page == nil ifFalse: [page := page copyOld changeClassTo: pageClass].		new basicAt: index put: page].	^new compress</body></methods><methods><class-id>Kernel.AssemblerCodeStream</class-id> <category>private</category><body package="System-Compiler-Assembler" selector="noteScrunch:at:">noteScrunch: amount at: pos	"Note that some code has been removed	just after pos, by decrementing all subsequent	PCs in the source map (if any).  pos is an Array,	with the first element being a 1-based segment	index, and the second element being a 1-based	pc offset within the segment."	self isMappingSource		ifTrue: [sourceMap do: [:m |			m updatePCs: [:oldPC || newPC |				newPC := oldPC.				(oldPC first = pos first and: [oldPC last &gt; pos last])					ifTrue: [(newPC := newPC copyOld) at: oldPC size put: oldPC last-amount].				newPC]]]</body></methods><methods><class-id>Kernel.IndexedFileMessageCatalog class</class-id> <category>accessing</category><body package="UIBasics-Internationalization" selector="directories">directories	^Directories copyOld</body></methods><methods><class-id>Kernel.ComponentChange</class-id> <category>accessing</category><body package="System-Code Component Changes" selector="componentClassName">componentClassName	^( self componentType copyOld asString )		at: 1 put: ( self componentType first asUppercase );		yourself</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>variable names</category><body package="System-Support" selector="validateStaticVariableName:confirm:warn:">validateStaticVariableName: varName confirm: confirmBlock warn: warnBlock	| cleanString parserClass newVarName firstChar msg |	newVarName := varName asString copyOld.	newVarName isEmpty		ifTrue:			[warnBlock value: (#invalidVariableName &lt;&lt; #dialogs &gt;&gt; 'An empty variable name is invalid').			^nil].	parserClass := self preferredParserClass.	cleanString := newVarName select: [:char | (parserClass isLetter: char) or: [char isDigit]].	cleanString = newVarName		ifFalse:			[cleanString isEmpty				ifTrue:					[warnBlock value: (#noValidCharsInVariable &lt;&lt; #dialogs &gt;&gt; 'No valid characters in variable name').					^nil].			newVarName := cleanString.			msg := (#invalidVariableCharacters &lt;&lt; #dialogs &gt;&gt; 'Invalid characters in variable name. Use "&lt;1s&gt;"?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [^nil]].	(firstChar := newVarName first) isLowercase		ifTrue:			[newVarName at: 1 put: firstChar asUppercase.			msg := (#capitalizeSharedNames &lt;&lt; #dialogs &gt;&gt; 'Shared variable names should be capitalized.&lt;n&gt;Change the name to "&lt;1s&gt;"?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [newVarName at: 1 put: firstChar]].	^newVarName asSymbol.</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>variable names</category><body package="System-Support" selector="validateInstanceVariableName:confirm:warn:">validateInstanceVariableName: varName confirm: confirmBlock warn: warnBlock	| cleanString parserClass newVarName msg firstChar |	newVarName := varName asString copyOld.	newVarName isEmpty		ifTrue:			[warnBlock value: (#invalidVariableName &lt;&lt; #dialogs &gt;&gt; 'An empty variable name is invalid').			^nil].	parserClass := self preferredParserClass.	cleanString := newVarName select: [:char | (parserClass isLetter: char) or: [char isDigit]].	cleanString = newVarName		ifFalse:			[cleanString isEmpty				ifTrue:					[warnBlock value: (#noValidCharsInVariable &lt;&lt; #dialogs &gt;&gt; 'No valid characters in variable name').					^nil].			newVarName := cleanString.			msg := (#invalidVariableCharacters &lt;&lt; #dialogs &gt;&gt; 'Invalid characters in variable name. Use "&lt;1s&gt;"?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [^nil]].	(firstChar := newVarName first) isUppercase		ifTrue:			[newVarName at: 1 put: firstChar asLowercase.			msg := (#doNotCapitalizeInstanceNames &lt;&lt; #dialogs &gt;&gt; 'Instance variable names should not be capitalized.&lt;n&gt;Change the name to "&lt;1s&gt;"?')					expandMacrosWith: newVarName.			(confirmBlock value: msg value: newVarName)				ifFalse: [newVarName at: 1 put: firstChar]].	^newVarName asSymbol.</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>variable names</category><body package="System-Support" selector="validateClassName:confirm:warn:">validateClassName: varName confirm: confirmBlock warn: warnBlock	| cleanString parserClass newVarName firstChar msg |	newVarName := varName asString copyOld.	newVarName isEmpty		ifTrue:			[warnBlock value: (#emptyClassName &lt;&lt; #dialogs &gt;&gt; 'An empty class name is invalid').			^nil].	parserClass := self preferredParserClass.	cleanString := newVarName select:		[:char | (parserClass isLetter: char) or: [char isDigit or: [char = $. and: [self isVW20LanguageCompatible]]]].	cleanString = newVarName		ifFalse:			[cleanString isEmpty				ifTrue:					[warnBlock value: (#noValidCharsInClass &lt;&lt; #dialogs &gt;&gt; 'No valid characters in class name').					^nil].			newVarName := cleanString.			msg := (#invalidClassCharacters &lt;&lt; #dialogs &gt;&gt; 'Invalid characters in class name.  Should I use &lt;1s&gt;?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [^nil]].	(firstChar := newVarName first) isLowercase		ifTrue:			[newVarName at: 1 put: (newVarName at: 1) asUppercase.			msg := (#capitalizeClassName &lt;&lt; #dialogs &gt;&gt; 'Class names should be capitalized.&lt;n&gt;Should I use &lt;1s&gt;?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [newVarName at: 1 put: firstChar]].	^newVarName asSymbol.</body></methods><methods><class-id>Kernel.Override</class-id> <category>installation</category><body package="System-Overrides" selector="checkSources:">checkSources: newSources	"Check the receiver's sources against newSources. Answer false if the receiver contains no unique sources."	| sorcesCopy |	( sources == nil 	)  |  ( sources size &lt; 1 )		ifTrue: [ ^false ].		"An error- no sources at all."	sorcesCopy := sources copyOld.	newSources do:		[ :comp |   | match |		match := sorcesCopy detect: [ :cc | cc comparesTo: comp ] ifNone: [ nil ].		match == nil			ifFalse: [ sorcesCopy remove: match ].		].	^sorcesCopy size &gt; 0.</body></methods><methods><class-id>Kernel.Override class</class-id> <category>events</category><body package="System-Overrides" selector="removeSelector:class:">removeSelector: selector class: class 	"A method has been removed from the system.	Remove all traces and notify components"	| oclass ometh |	oclass := self overriddenMethods at: class ifAbsent: [ ^self ].	ometh := oclass at: selector ifAbsent: [ ^self ].		ometh copyOld do: [ :over | over sources do: [ :comp | over removeFrom: comp ] ].	oclass removeKey: selector ifAbsent: nil.	oclass isEmpty		ifTrue: [ self overriddenMethods removeKey: class ].</body></methods><methods><class-id>Kernel.Override class</class-id> <category>management</category><body package="System-Overrides" selector="allOverridesRemoveIf:">allOverridesRemoveIf: aBlock	"Evaluate a block for every override and remove any override that evaluates true."	| actionBlock |	actionBlock :=		[ :assoc :over |  		assoc value removeAllSuchThat: [:each | each == over].		over notifySourcesOverrideBeingReinstalled.		].						ClassesAndNameSpaces associations do:		[ :assoc | 		assoc value copyOld do:			[ :over | 			( aBlock value: over )				ifTrue: [ actionBlock value: assoc value: over ].			]		].	Methods do:		[ : dict |		dict associations do:			[ :assoc |			assoc value copyOld do:				[ :over | 	( aBlock value: over ) ifTrue: [ actionBlock value: assoc value: over ] ]			]		].	Statics do:		[ : dict |		dict associations do:			[ :assoc |			assoc value copyOld do:				[ :over | 	( aBlock value: over ) ifTrue: [ actionBlock value: assoc value: over ] ]			]		].</body></methods><methods><class-id>Kernel.Override class</class-id> <category>management</category><body package="System-Overrides" selector="cleanseLists">cleanseLists		"self cleanseLists"	ClassesAndNameSpaces associations copyOld do:		[ : assoc | 		( assoc value size == 0 )  |  ( assoc key isObsolete )			ifTrue: [ ClassesAndNameSpaces removeKey: assoc key ].		].	Methods associations copyOld do:		[ : assoc |  | cls |		cls := assoc key.		( assoc value size == 0 )  |  ( cls isObsolete )			ifTrue: [ Methods removeKey: cls ]			ifFalse:				[ assoc value associations copyOld do:					[ :sub |  | selector |					selector := sub key.					( sub value size == 0 )						ifTrue: [ ( Methods at: cls ) removeKey: selector ]						ifFalse:							[ ( cls includesSelector: selector )								ifFalse: [ ( Methods at: cls ) removeKey: selector ]							]					]			].		].	Statics associations copyOld do:		[ : assoc | | namespace |		namespace := assoc key.		( assoc value size == 0 )  |  ( namespace isObsolete )			ifTrue: [ Statics removeKey: namespace ]			ifFalse:				[ assoc value associations copyOld do:					[ :sub |  | key |					key := sub key.					( sub value size == 0 ) 						ifTrue: [ ( Statics at: namespace ) removeKey: key ]						ifFalse:							[ ( namespace asNameSpace includesKey: key )								ifFalse: [ ( Statics at: namespace ) removeKey: key ]							]					]			]		].</body></methods><methods><class-id>Kernel.Override class</class-id> <category>events</category><body package="System-Overrides" selector="removeClass:">removeClass: class 	"A class has been removed from the system. Propogate changes to about to be nuked selectors and shareds"	( self overriddenMethods at: class ifAbsent: [ #( ) ] ) do: 		[ :list | list copyOld do: 			[ :over | self removeSelector: over selector class: class ].		].	( self overriddenMethods at: class class ifAbsent: [ #( ) ] ) do: 		[ :list | list copyOld do: 			[ :over | self removeSelector: over selector class: class class ].		].	( self overriddenStatics at: class ifAbsent: [ #( ) ] ) do:		[ :list | list copyOld do: 			[ :over | self removeBinding: over binding in: class ].		].	( self overriddenClassesAndNameSpaces at: class ifAbsent: [ #( ) ] ) 		do: [ : over | over sources do: [ :comp | over removeFrom: comp.] ].	self overriddenClassesAndNameSpaces removeKey: class ifAbsent: nil.</body></methods><methods><class-id>Kernel.Override class</class-id> <category>management</category><body package="System-Overrides" selector="prepareMoveOfSelector:class:fromPackage:toPackage:">prepareMoveOfSelector: aSelector class: aClass fromPackage: oldPackage toPackage: newPackage	"This method performs pre-processing of moving the given method from &lt;oldPackage&gt; to &lt;newPackage&gt;.	We focus on changes to override structure.	This method supports the situation when moving an overridden method from one package to another.	If the definition in oldPackage is overridden, we expect the target package to take it over 	and to remove the now obsolete entry from the Override information registry.	IF the override is targeted to a package that is already an overridden package, then we answer false if there is no RB,	or we raise a RefactoryChangeFailureNotification if there is a RB.	This is because we do not EVER want to re-override into an existing overridden package.	Before we do anything rash, we check if the the old package has never been overridden, i.e. its method is installed in the image.	if so, there is nothing to do and we answer true"		| existingOverrides oldOverride currentContainingPackage |	((existingOverrides := Override overrideCollectionForSelector: aSelector class: aClass) isNil or: [existingOverrides isEmpty]) 		ifTrue: [^true].	existingOverrides copyOld do: 		[:each | 		(each sources includes: newPackage) ifTrue: 			[#{Refactory.Browser.RefactoryChangeFailureNotification} 				ifDefinedDo: [:value | value raiseSignal].			^false]].	oldOverride := existingOverrides detect: [:each | each sources includes: oldPackage] ifNone: [nil].	oldOverride ifNil: [^true].	currentContainingPackage := Store.Registry containingPackageForSelector: aSelector class: aClass.	^currentContainingPackage = newPackage		ifTrue:			[oldOverride				privateReinstall;				purge.			true]		ifFalse:			[(oldOverride sources)				remove: oldPackage;				add: newPackage.			false]</body></methods><methods><class-id>Kernel.Override class</class-id> <category>private</category><body package="System-Overrides" selector="install:list:for:">install: anOverride list: aCollection for: anObject	"Private- add anOverride to a list of overrides. Validate that this does not add the same source twice	to the list. Notify the sources. NOTE: what to do if sources match previous override?"	| newSources  |	newSources := anOverride sources.	aCollection copyOld do:		[ :over | 		( over comparesTo: anOverride )			ifTrue: [ "?? over addSources: anOverride sources" ].		"duplicate of one already installed"		( over checkSources: newSources )			ifFalse: [ aCollection remove: over ]		"remove the original"		].	aCollection addLast: anOverride.	anOverride notifySourcesOfOverride:  anObject</body></methods><methods><class-id>Kernel.ClassOrganizer</class-id> <category>copying</category><body package="Kernel-Support" selector="postCopy">postCopy	"Ensure that the receiver's sub-structure is also copied."	super postCopy.	self commentKey: self commentKey.	categoryArray := categoryArray copyOld.	categoryStops := categoryStops copyOld.	elementArray := elementArray copyOld.</body></methods><methods><class-id>Kernel.CodeRegenerator</class-id> <category>code generation-jumps</category><body package="System-Compiler-Public Access" selector="jump:if:">jump: delta if: condition 	| newPC label currentLabels |	self pushAll.	newPC := pc + delta.	(pcLabels at: newPC) == nil		ifTrue:	[pcLabels at: newPC put: pcStack copyOld].	delta &lt; 0		ifTrue: [self error: (#DidNotExpectBackwardBranch &lt;&lt; #dialogs &gt;&gt; 'Did not expect backward branch')]		ifFalse: 			["Target has not yet been defined.  When multiple jumps all			arrive at the same pc, they each have to have separate			CodeLabels assigned, or the code generator will screw up"			label := self code newLabel.			currentLabels := self labels at: newPC.			currentLabels == nil				ifTrue: [self labels at: newPC put: (Array with: label)]				ifFalse: [self labels at: newPC put: (currentLabels copyWith: label)].			self code putBranchTo: label if: condition]</body></methods><methods><class-id>Kernel.CodeRegenerator</class-id> <category>code generation-jumps</category><body package="System-Compiler-Public Access" selector="jump:">jump: delta 	| newPC label currentLabels |	self pushAll.	newPC := pc + delta.	(pcLabels at: newPC) == nil		ifTrue:	[pcLabels at: newPC put: pcStack copyOld].	self checkMerge.	delta &lt; 0		ifTrue: 			["Target (a loopHead instruction) has already been defined"			label := self labels at: newPC.			self code putBranchBack: label]		ifFalse: 			["Target has not yet been defined.  When multiple jumps all			arrive at the same pc, they each have to have separate			CodeLabels assigned, or the code generator will screw up"			label := self code newLabel.			currentLabels := self labels at: newPC.			currentLabels == nil				ifTrue: [self labels at: newPC put: (Array with: label)]				ifFalse: [self labels at: newPC put: (currentLabels copyWith: label)].			self code putBranch: label]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>copying</category><body package="System-Code Components" selector="postCopy">postCopy	"Ensure that all relevant sub-structure is copied."	super postCopy.	definedClasses := definedClasses copyOld.	definedObjects := definedObjects copyOld.	definedBindings := definedBindings copyOld.	classSelectors := classSelectors copyWithCopiedValues.	namedObjects := namedObjects copyOld.</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>queries</category><body package="System-Code Components" selector="classesAndSelectorsDo:">classesAndSelectorsDo: aBlock 	"Evaluate the argument with each behavior and its selectors	 defined by the receiver."	classSelectors copyOld keysAndValuesDo:		[:aBehavior :selectors |		aBlock value: aBehavior value: selectors copyOld]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>queries</category><body package="System-Code Components" selector="definedClasses">definedClasses	^definedClasses copyOld.</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>queries</category><body package="System-Code Components" selector="definedBindings">definedBindings	^definedBindings copyOld.</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>ui</category><body package="System-Code Components" selector="saveParcelDialogFor:preOpen:preSave:">saveParcelDialogFor: aVisualOrNil preOpen: aBlockForDialog preSave: aBlockForSave	"UI for writing out a parcel in fast-loading binary format."	"parcels first saveParcelDialogFor: nil"	| pfe pse parcelName baseName dialog error save hide overwrite republish backup parcelFile parcelExists sourceExists sourceFile sourceIsSystemSource pad |	pfe := self class fileExtension.	pse := self class sourceExtension.	(parcelName := self name) isNil ifTrue: [parcelName := (#parcelNameScratch &lt;&lt; #dialogs &gt;&gt; 'scratch') asString].	"properties at: #parcel) remembers the Parcel's save filename	 without extension as a sequence of filename components."	baseName := properties at: #parcel ifAbsent: [Filename filterFilename: parcelName].	baseName isString ifFalse:		[baseName := baseName copyOld.		(baseName isEmpty not and: ['#:' match: baseName first])			ifTrue: [baseName at: 1 put: baseName first, '\'].		baseName := (Filename fromComponents: baseName) asString].	baseName := ValueHolder with: baseName.	republish := (loaded and: [(self propertyAt: #sourceIndex) notNil]) asValue.	overwrite := false asValue.	backup := false asValue.	[dialog := SimpleDialog initializedFor: aVisualOrNil.	dialog setInitialGap.	error := nil.	error notNil ifTrue:		[dialog addMessage: error centered: true. 		dialog addGap: 8].	dialog		addMessage: ((#saveParcel &lt;&lt; #dialogs &gt;&gt; 'Save  &lt;1s&gt; on name&lt;2s&gt; (+ name&lt;3s&gt;)')  expandMacrosWith: parcelName with: pfe with: pse)		centered: true.	dialog addGap: 4.	dialog addTextLine: baseName.	dialog addGap: 8.	dialog		"Extra space in the second label to get both columns to line up."		addCheckLabels: ((Array new: 3) at: 1 put: (#saveSourceFile &lt;&lt; #labels &gt;&gt; 'save source file') asString;										at: 2 put: (#hideSouce &lt;&lt; #labels &gt;&gt; 'hide source on load    ') asString;										at: 3 put: (#padSource &lt;&lt; #labels &gt;&gt; 'pad source') asString;										yourself)		values: (Array					with: (save := (properties at: #saveSource ifAbsent: self name notNil) asValue)					with: (hide := (properties at: #hideSource ifAbsent: false) asValue)					with: (pad := (properties at: #padded ifAbsent: false) asValue))		equalize: true		columns: 1.	dialog addDivider.	dialog		addCheckLabels: ((Array new: 3) at: 1 put: (#parcelRepublish &lt;&lt; #labels &gt;&gt; 'republish') asString;										at: 2 put: (#parcelBackup &lt;&lt; #labels &gt;&gt; 'backup') asString;										at: 3 put: (#parcelOverwrite &lt;&lt; #labels &gt;&gt; 'overwrite existing files') asString;										yourself)		values: (Array with: republish with: backup with: overwrite)		equalize: true		columns: 1.	dialog addDivider.	dialog addOK: [true].	dialog addGap: 6.	aBlockForDialog value: dialog.	dialog openDialog.	dialog cancel value ifTrue: [^false].	"check file safety..."	parcelFile := baseName value, pfe.	parcelExists := overwrite value not and: [parcelFile asFilename exists].	sourceExists := false.	sourceIsSystemSource := false.	(properties at: #saveSource put: save value) ifTrue:		[sourceFile := baseName value, pse.		sourceIsSystemSource := SourceFileManager default isSourceFile: sourceFile asLogicalFileSpecification.		sourceExists := overwrite value not and: [sourceFile asLogicalFileSpecification exists]].	"Check for overwriting unless republishing to the same source file."	(republish value	and: [save value	and: [(self propertyAt: #sourceIndex) notNil	and: [(SourceFileManager default logicalNameAt: (self propertyAt: #sourceIndex)) = sourceFile asLogicalFileSpecification]]]) ifFalse:		[sourceIsSystemSource			ifTrue: [error := ((#systemSource &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; is a system source file.&lt;n&gt;Saving will corrupt the sources.&lt;n&gt;Choose a new name.' ) expandMacrosWith: sourceFile) ]			ifFalse:				[parcelExists					ifTrue:						[error := sourceExists									ifTrue: [((#parcelAndSourceExist &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;  &amp; &lt;2s&gt; already exist.') expandMacrosWith: parcelFile with: sourceFile)]									ifFalse: [((#fileExists &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; already exists.') expandMacrosWith: parcelFile)]]					ifFalse:						[sourceExists ifTrue:							[error := ((#fileExists &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; already exists.') expandMacrosWith: sourceFile)]].				error notNil ifTrue: [error := ((#errOverWriteCheck &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;&lt;n&gt;Check overwrite to overwrite.' ) expandMacrosWith: error)]]].	error notNil] whileTrue.	properties		at: #parcel		put: (Filename logicalComponents: baseName value) asArray.	pad value		ifTrue: [properties at: #padded put: true]		ifFalse: [properties removeKey: #padded ifAbsent: nil].	aBlockForSave value: self.	self		parcelOutOn: parcelFile		withSource: (save value ifTrue: [sourceFile])		hideOnLoad: (properties at: #hideSource put: hide value)		republish: republish value		backup: backup value.	republish value ifTrue:		[self markNotModified.		(Dialog confirm: ((#parcelSaveImageRecommendation2 &lt;&lt; #dialogs &gt;&gt; 'It is recommended to save the image now&lt;n&gt;to ensure it stays in sync with the new parcel source file.&lt;n&gt;Save the image?') expandMacros))			ifTrue: [ObjectMemory snapshot]]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>queries</category><body package="System-Code Components" selector="definedObjects">definedObjects	^definedObjects copyOld</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>dependents access</category><body package="System-Code Components" selector="removeDependent:">removeDependent: anObject	"Override to manage flushing the classParcelMap when all browsers have closed.	 Prune any old dependents to prevent dangling references."	super removeDependent: anObject.	#{ApplicationModel} isDefined ifTrue:		[| applicationModel scheduledControllers |		applicationModel := #{ApplicationModel} value.		scheduledControllers := #{ScheduledControllers} valueOrDo: nil.		self dependents copyOld do:			[:dep|			((dep isKindOf: applicationModel)			and: [scheduledControllers isNil				or: [dep builder isNil				or: [dep builder window isNil				or: [(scheduledControllers isScheduled: dep builder window controller) not]]]]) ifTrue:				[super removeDependent: dep]]].	self dependents isEmpty ifTrue: [self flushClassParcelMap].	^anObject</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>api</category><body package="System-Code Components" selector="parcels">parcels	"Answer a collection of parcels."	^self parcelList copyOld</body></methods><methods><class-id>Kernel.DefineOpcodePool class</class-id> <category>private-initialization</category><body package="System-Compiler-Support" selector="vw40ExtendedSpecialSelectors">vw40ExtendedSpecialSelectors	"These are the most common selectors	(with at least 20 occurrences)	in the current license image"	^#(		#do: #cr #on: #nextPut: #bounds #x #y #isEmpty		#copyOld #name #with: #at:ifAbsent: #-&gt; #error: #first #bitShift:		#includes: #contents #key #asString #last #extent #componentAt: #printString		#bitAnd: #scaledRed:scaledGreen:scaledBlue: #view #rounded #window #/ #next #paint:		#yourself #space #asSymbol #controller #sensor #max: #height #isKindOf:		#subclassResponsibility #default #with:with: #asValue #collect: #tab #addLast: #print:		#initialize #builder #extent: #width #handle:do: #top #copyFrom:to: #negated		#widget #close #errorSignal #left #displayRectangle: #current #origin #layout		#perform: #asInteger #min: #black #selection #asPointerParameter #bottom #model		#removeLast #list #component #externalAccessFailedWith: #environment #raise #select: #extent:depth:bitsPerPixel:palette:usingBits:		#peekForTypeNoPush: #asFilename #asText #adapt:forAspect:channel: #showWhile: #tab: #organization #displayOn:at:		#primitiveFailed #release #notifierString: #writeStream #menuItemLabeled: #monoMaskPalette #atEnd #selector		#show: #addAll: #aspectAt:put: #nameClass:message: #model: #right #preferredBounds #emphasis:		#bindValue:to: #indexOf: #expected: #keyboard #disable #white #matchAt:put: #invalidate		#scale #replaceFrom:to:with:startingAt: #on:do: #to: #value:value: #fullName #readStream #valueNowOrOnUnwindDo:		#removeDependent: #byteAt: #onChangeSend:to: #asArray #asFloat #changed: #corner: #text		#labeled: #detect:ifNone: #warn: #name: #center #decodeAsLiteralArray #isSymbol #isString		#changed:with: #label: #position #printOn: #wait #\\ #keysAndValuesDo: #asValueReference		#preferenceFor: #includesKey: #abs #return #shouldNotImplement #returnWith: #critical: #list:		#displayBox #species #withCRs #replaceStackTop: #components #foregroundColor #with:with:with: #selection:		#bitOr: #label #parameter #string #lineGrid #backgroundColor #type #withColors:		#separator #palette #hash #graphicsContext #layout: #sender #open #enable		#remove:ifAbsent: #skip: #textStyle #| #scanToken #insetBy: #targetClass #selectionIndexHolder		#changeRequest #byteAt:put: #memberAt:put: #htmlEntity #wrapper #isEnabled #raiseWith: #displayOn:		#addDependent: #bounds: #perform:with: #x: #containsPoint: #preferenceModelFor: #numArgs #keyboardProcessor		#component: #cursorPoint #externalAccessFailedSignal #intersects: #origin:extent: #store: #zero #widgetState		#remove: #extent:depth:palette:bits:pad: #topComponent #memberAt: #fromBytes:	)</body></methods><methods><class-id>Kernel.ChangeScanner class</class-id> <category>class initialization</category><body package="System-Changes" selector="initialize">initialize	"ChangeScanner initialize"	"change the type table to treat #-quoted symbols as a single unit	rather than a # followed by a symbol"	ChangeTypeTable := TypeTable copyOld.	ChangeTypeTable at: $# asInteger put: #xLitQuote</body></methods><methods><class-id>Kernel.Decompiler class</class-id> <category>class initialization</category><body package="System-Compiler-Public Access" selector="initialize">initialize	"Decompiler initialize"	CascadeFlag := 'cascade' copyOld.  "a unique object"	CascadeLastFlag := 'cascadeLast' copyOld  "ditto"</body></methods><methods><class-id>Kernel.CompiledMainBlock</class-id> <category>copying</category><body package="Kernel-Methods" selector="withAdditionalProperties:">withAdditionalProperties: anArrayOfMessages	"Return a copy of this method suitably modified to have the given attributes.	 These attributes currently include resource annotations, and marking for unwind, propagate &amp; handler."	|  method allMessages | 	anArrayOfMessages == nil ifTrue: [^self].	anArrayOfMessages isEmpty ifTrue: [^self].	allMessages := (self attributeMessages copyOld ifNil: [OrderedCollection new]) asOrderedCollection.	anArrayOfMessages do: [:each | 		(allMessages includes: each) ifFalse: [allMessages add: each]].	allMessages isEmpty ifTrue: [^self].	method := ((allMessages anySatisfy: [:msg | msg selector == #exception:])					ifTrue: [MarkedMethod]					ifFalse: [(allMessages anySatisfy:									[:msg |									 msg selector == #primitive:module:									 or: [msg selector == #primitive:module:errorCode:]])								ifTrue: [UserPrimitiveMethod]								ifFalse: [AnnotatedMethod]])						fromMethod: self.	method attributeMessages: allMessages.	^method</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>formatting</category><body package="XML-source" selector="putBodyOn:attributes:value:">putBodyOn: aStream attributes: attributes value: aValue	"Put the body of a method or of a class comment	on the stream. This means mapping all text emphases	to XML tags so that they aren't lost."	| emph stack start end oldEmph removed added |	emph := #().	stack := OrderedCollection new.	self on: aStream tag: 'body' attributes: attributes do:		[:ignored :stream |		| oldLineEnd |		oldLineEnd := stream lineEndConvention.		start := 1.		[stream lineEndTransparent.		[start &gt; aValue size] whileFalse:			[end := (aValue runLengthFor: start) + start - 1.			oldEmph := emph.			emph := self makeArrayFrom: (aValue emphasisAt: start).			removed := self subtractEmphasis: emph from: oldEmph.			added := self subtractEmphasis: oldEmph from: emph.			self closeTags: removed from: stack on: stream.			self addTags: added to: stack on: stream.			self on: stream value: (aValue copyFrom: start to: end).			start := end+1]		] ensure: [stream lineEndConvention: oldLineEnd].		self closeTags: stack copyOld from: stack on: stream].</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>formatting</category><body package="XML-source" selector="putBodyOn:value:">putBodyOn: aStream value: aValue	"Put the body of a method or of a class comment	on the stream. This means mapping all text emphases	to XML tags so that they aren't lost."	| emph stack start end oldEmph removed added |	emph := #().	stack := OrderedCollection new.	self on: aStream tag: 'body' do:		[:xml :str |		start := 1.		[start &gt; aValue size] whileFalse:			[end := (aValue runLengthFor: start) + start - 1.			oldEmph := emph.			emph := self makeArrayFrom: (aValue emphasisAt: start).			removed := self subtractEmphasis: emph from: oldEmph.			added := self subtractEmphasis: oldEmph from: emph.			self closeTags: removed from: stack on: str.			self addTags: added to: stack on: str.			self on: str value: (aValue copyFrom: start to: end).			start := end+1].		self closeTags: stack copyOld from: stack on: str].</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>copying</category><body package="Debugger-Support" selector="postCopy">postCopy	"Finish doing whatever is required, 	beyond a shallowCopy, to implement 'copy'. 	Answer the receiver. 	Subclasses may add functionality, 	but they should always do super postCopy first."	super postCopy.	1 to: self numLiterals do: 		[:i | | lit cl |		lit := self literalAt: i.		cl := lit class.		((lit isKindOf: CompiledBlock) or: [cl == BlockClosure])			ifTrue: 				[self literalAt: i put: (lit := lit copyOld).				cl = BlockClosure					ifTrue: [lit method outerMethod: self]					ifFalse: [lit outerMethod: self]]			ifFalse: [self literalAt: i put: lit]].	^self</body></methods><methods><class-id>Kernel.JumpDecomposer</class-id> <category>private</category><body package="System-Compiler-Assembler" selector="updateCurrentPC">updateCurrentPC	| altPC target |	altPC := self logicalPC.	target := registry at: pc.	target do: [:tgt |		tgt updatePCs: [:oldPC |			oldPC = pc ifTrue: [altPC copyOld] ifFalse: [oldPC]]].	segments last registry addAll: target</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="Assets" selector="becomeCached">becomeCached	"convert myself to my caching subclass with the result of my value loaded in the cache"	| withCache |	withCache := ((self copyOld changeClassTo: Array) copyWith: self value) 				changeClassTo: CachedBlockClosure.	self become: withCache</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>copying</category><body package="Kernel-Methods" selector="postCopy">postCopy	"Finish doing whatever is required, 	beyond a shallowCopy, to implement 'copy'. 	Answer the receiver. 	Subclasses may add functionality, 	but they should always do super postCopy first."	super postCopy.	method := method copyOld.	^self</body></methods><methods><class-id>Kernel.BindingReference</class-id> <category>private</category><body package="System-Name Spaces" selector="duplicateWithPath:">duplicateWithPath: aPath	^self copyOld path: aPath</body></methods><methods><class-id>Kernel.PrerequisiteDescription</class-id> <category>copying</category><body package="System-Code Components" selector="postCopy">postCopy	super postCopy.	properties := properties copyOld</body></methods><methods><class-id>Kernel.SpecialSelectorCounter class</class-id> <category>utilities</category><body package="System-Compiler-Support" selector="specialSelectors">specialSelectors	^#(#+ #- #&lt; #&gt; #&lt;= #&gt;= #= #~= #* #// #@ #, #not #isNil #notNil #basicAt: #at: #at:put: #size #~~ #basicNew #nextPutAll: #== #class #add: #value #value: #basicSize #new #new: #basicAt:put: #basicNew: #do: #cr #on: #nextPut: #bounds #x #y #isEmpty #copyOld #name #with: #at:ifAbsent: #-&gt; #error: #first #bitShift: #includes: #contents #key #asString #last #extent #componentAt: #printString #bitAnd: #scaledRed:scaledGreen:scaledBlue: #view #rounded #window #/ #next #paint: #yourself #space #asSymbol #controller #sensor #max: #height #isKindOf: #subclassResponsibility #default #with:with: #asValue #collect: #tab #addLast: #print: #initialize #builder #extent: #width #handle:do: #top #copyFrom:to: #negated #widget #close #errorSignal #left #displayRectangle: #current #origin #layout #perform: #asInteger #min: #black #selection #asPointerParameter #bottom #model #removeLast #list #component #externalAccessFailedWith: #environment #raise #select: #extent:depth:bitsPerPixel:palette:usingBits: #peekForTypeNoPush: #asFilename #asText #adapt:forAspect:channel: #showWhile: #tab: #organization #displayOn:at: #primitiveFailed #release #notifierString: #writeStream #menuItemLabeled: #monoMaskPalette #atEnd #selector #show: #addAll: #aspectAt:put: #nameClass:message: #model: #right #preferredBounds #emphasis: #bindValue:to: #indexOf: #expected: #keyboard #disable #white #matchAt:put: #invalidate #scale #replaceFrom:to:with:startingAt: #on:do: #to: #value:value: #fullName #readStream #valueNowOrOnUnwindDo: #removeDependent: #byteAt: #onChangeSend:to: #asArray #asFloat #changed: #corner: #text #labeled: #detect:ifNone: #warn: #name: #center #decodeAsLiteralArray #isSymbol #isString #changed:with: #label: #position #printOn: #wait #\\ #keysAndValuesDo: #asValueReference #preferenceFor: #includesKey: #abs #return #shouldNotImplement #returnWith: #critical: #list: #displayBox #species #withCRs #replaceStackTop: #components #foregroundColor #with:with:with: #selection: #bitOr: #label #parameter #string #lineGrid #backgroundColor #type #withColors: #separator #palette #hash #graphicsContext #layout: #sender #open #enable #remove:ifAbsent: #skip: #textStyle #| #scanToken #insetBy: #targetClass #selectionIndexHolder #changeRequest #byteAt:put: #memberAt:put: #htmlEntity #wrapper #isEnabled #raiseWith: #displayOn: #addDependent: #bounds: #perform:with: #x: #containsPoint: #preferenceModelFor: #numArgs #keyboardProcessor #component: #cursorPoint #externalAccessFailedSignal #intersects: #origin:extent: #store: #zero #widgetState #remove: #extent:depth:palette:bits:pad: #topComponent #memberAt: #fromBytes:)</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>system backup/exit file names</category><body package="System-Support" selector="promptForChangesFileLocation">promptForChangesFileLocation	| prompt choiceStrings choices result newChanges possibleOldFile |	prompt := ((#MissingChangesFileWarning &lt;&lt; #dialogs &gt;&gt; 'When this image was last saved, its name was &lt;n&gt;"&lt;1s&gt;&lt;2s&gt;"&lt;n&gt;The changes file is missing, perhaps because the image file was copied or renamed to &lt;n&gt;"&lt;3s&gt;"&lt;n&gt;What would you like to do?')			expandMacrosWith: ImagePrefix			with: Filename imageExtension			with: self imageName).	choiceStrings := OrderedCollection new.	choices := OrderedCollection new.	newChanges := self changesFilenameInImageDirectoryForPrefix: self imageFilePrefixWithoutPath.	"Is there an old change file we can copy over to the new location"	possibleOldFile := self changesFilenameInImageDirectoryForPrefix: self imagePrefix.	possibleOldFile exists 		ifTrue: 			[choiceStrings 				add: ((#Copy1sTo2s &lt;&lt; #dialogs &gt;&gt; 'Copy "&lt;1s&gt;" to "&lt;2s&gt;"')			expandMacrosWith: possibleOldFile asString			with: newChanges asString).			choices add: #copyOld].	choiceStrings add: ((#CreateEmptyChangesFileQ &lt;&lt; #dialogs &gt;&gt; 'Create "&lt;1s&gt;" as an empty changes file.')			expandMacrosWith: newChanges asString).	choices add: #continue.	choiceStrings add: (#ExitTheImage &lt;&lt; #dialogs &gt;&gt; 'Exit the Image').	choices add: #quit.	result := Dialog 				choose: prompt				fromVerticallyAlignedButtonsWithLabels: choiceStrings				values: choices				default: #new.	result = #quit ifTrue: [self quit].	result = #copyOld 		ifTrue:			[SourceFileManager default changesFileName: possibleOldFile.			SourceFileManager default copyChangesTo: newChanges asString].	result = #continue		ifTrue: [			Transcript cr; show: ((#CreatingEmptyChangeLog &lt;&lt; #dialogs &gt;&gt; 'Creating a new empty log file &lt;1s&gt;.') expandMacrosWith: newChanges).			SourceFileManager default changesFileName: newChanges].</body></methods><methods><class-id>Kernel.CachedBlockClosure</class-id> <category>private</category><body package="Assets" selector="becomeUncached">becomeUncached	"convert myself back to my uncaching superclass"	| withoutCache |	withoutCache := ((self copyOld changeClassTo: Array) allButLast: 1) 				changeClassTo: BlockClosure.	self become: withoutCache</body></methods><methods><class-id>Kernel.Snapshot</class-id> <category>private-saving</category><body package="System-Support" selector="logSnapshot">logSnapshot	| msg dateAndTime dateAndTime2 log |	SourceFileManager default logChange: '''----SNAPSHOT----'''.	dateAndTime := Time dateAndTimeNow.	dateAndTime2 := dateAndTime collect: [:t | | str |		str := '' copyOld writeStream.		(Locale named: #C) timePolicy printLong: t on: str.		str contents].	msg := (Array with: self imageFilename asString), dateAndTime2.	log := String new writeStream.	log nextPut: $";		store: msg;		nextPut: $";		cr;		nextPut: $";		nextPutAll: (#snapShotCreatedLong &lt;&lt; #dialogs &gt;&gt; 'An image file &lt;1s&gt; was created at &lt;3p&gt; on &lt;2p&gt;.'			expandMacrosWith: msg first			with: (dateAndTime at: 1)			with: (dateAndTime at: 2));		nextPut: $".	SourceFileManager default logChange: log contents.	Transcript		cr;		show: (#snapShotCreated &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; created at &lt;2p&gt; &lt;3p&gt;'			expandMacrosWith: msg first			with: (dateAndTime at: 1)			with: (dateAndTime at: 2)).</body></methods><methods><class-id>Security.MD5</class-id> <category>private-digest</category><body package="MD5" selector="backupRegisters">backupRegisters"This has to match with #restoreRegisters:"	^Array		with: a copyOld		with: b copyOld		with: c copyOld		with: d copyOld</body></methods><methods><class-id>Security.HMAC</class-id> <category>services-basic</category><body package="HashesBase" selector="copy">copy"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self class new		setIHash: ihash copyOld		oHash: ohash copyOld		iPad: ipad copyOld		oPad: opad copyOld;		yourself</body></methods><methods><class-id>Security.HMAC</class-id> <category>services-basic</category><body package="HashesBase" selector="copyOld">copyOld"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self class new		setIHash: ihash copyOld		oHash: ohash copyOld		iPad: ipad copyOld		oPad: opad copyOld;		yourself</body></methods><methods><class-id>Security.HMAC</class-id> <category>initialize-release</category><body package="HashesBase" selector="setHash:">setHash: aHash	ihash := aHash.	ohash := aHash copyOld</body></methods><methods><class-id>OSkSocketListenerService</class-id> <category>start/stop</category><body package="OSkSocketServices" selector="closeEverything">closeEverything	"^selfI close down all my socket activity.  First I shut down the existing accepted connections, then I shut down my accept loop and lastly I close the listener socket."	self acceptedConnections copyOld do: [:each | each close].	self acceptLoop notNil 		ifTrue: 			[self acceptLoop terminate.			acceptLoop := nil].	self socket notNil 		ifTrue: 			[self socket close.			socket := nil].	^self</body></methods><shared-variable><name>EventDispatchTable</name><environment>UI.InputState</environment><private>true</private><constant>true</constant><category>As yet unclassified</category><initializer>#(#send:noOp: #send:eventKeyPress: #send:eventKeyRelease: #send:eventButtonPress: #send:eventButtonRelease: #send:eventMouseMoved: #send:eventEnter: #send:eventExit: #send:eventDamage: #send:eventResize: #send:eventQuit: #send:eventCollapse: #send:eventExpand: #send:eventWidgetColorChange: #send:eventDestroy: nil nil #send:eventMouseWheel: #send:eventQuitSystem: #send:eventButtonDoubleClick: #send:eventInputManager:)	copyOld</initializer><attributes><package>OS-Window System</package></attributes></shared-variable><shared-variable><name>MoveOutIcon</name><environment>Store.Glorp.ChangeResolver</environment><private>false</private><constant>false</constant><category>MoveOutIcon</category><initializer>MergeIcons move copyOld image: MergeIcons move image copyOld reflectedInX</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><remove-selector><class-id>Glorp.Query</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Store.Glorp.StorePundleWriter</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>BST</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Protocols.Struct</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Glorp.GlorpSession</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Glorp.DualRoleFunction</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>UI.AssociationTree</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Tools.UIMaskEditor</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Core.Symbol</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Graphics.DispatchTable</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Graphics.CharacterBlock</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Glorp.ElementBuilder</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Text2.Document</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Store.Glorp.StoreObject</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Glorp.GlorpVirtualCollection</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Glorp.Tracing</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Glorp.DatabaseAccessor</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Security.HMAC</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Core.Object</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Security.MessageDigest</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>Security.Hash</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>BSTNode</class-id> <selector>copy</selector></remove-selector><remove-selector><class-id>BSTNode</class-id> <selector>copyOld</selector></remove-selector><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>postCopy</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>postCopy</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BST</class-id> <category>copying</category><body package="CS474" selector="postCopy">postCopy	root notNil ifTrue: [root := root copy].	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>nextPutAll</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>nextPutAll</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>aStream</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>aStream</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BSTNode</class-id> <category>printing</category><body package="CS474" selector="printOn:">printOn: aStream 	"Append to the argument, aStream, the elements of the Array 	enclosed by parentheses."	aStream nextPutAll: '{'.	left notNil ifTrue: [left printOn: aStream].      aStream nextPutAll: value asString.		right notNil ifTrue: [right printOn: aStream].	aStream nextPut: $}</body></methods><methods><class-id>Core.CompositeLocale</class-id> <category>printing</category><body package="Internationalization" selector="printStringOld">printStringOld	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	aStream nextPutAll: 'a CompositeLocale named: #''' , self name , ''''.	^aStream contents</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>printing</category><body package="Protocols-Common" selector="printStringOld">printStringOld	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Kernel-Objects" selector="printStringOld">printStringOld	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <category>accessing</category><body package="Debugger-Probes" selector="printStringOld">printStringOld	action == nil		ifTrue: [^self nameString].	^(#('r' 'rw' 'w') at: action) , ' ' , class shortName , '&gt;&gt;' , selector</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>printing</category><body package="GlorpQueries" selector="printStringOld">printStringOld	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>Core.String</class-id> <category>printing</category><body package="Collections-Text" selector="printStringOld">printStringOld	"Answer a String whose characters are a description of the receiver. Take advantage of knowing what these normally look like to optimize."	| ws result |	ws := WriteStream on: (result := String new: self expectedPrintStringSize).	self printOn: ws.	"Since we own the lifecycle of the write stream, we can further exploit this 	 by taking the collection directly most of the time."	^result size = ws position ifTrue: [result] ifFalse: [ws contents]</body></methods><methods><class-id>BSTNode</class-id> <category>printing</category><body package="CS474" selector="printStringOld">printStringOld	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t1 |	t1 := String new.	left isNil not ifTrue: [t1 := left printString].	t1 := t1 , value printString , ' '.	right isNil not ifTrue: [t1 := t1 , right printString].	^t1</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>debugging</category><body package="GlorpQueries" selector="printStringOld">printStringOld	"Hard-code this for maximum dialect portability"	^'a MessageArchiver'.</body></methods><methods><class-id>BST</class-id> <category>printing</category><body package="CS474" selector="printStringOld">printStringOld	root isNil ifTrue: [^''].	^root printString</body></methods><methods><class-id>PostgreSQLEXDIStringValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	I return a PostgreSQL friendly (single quoted) string representation of my &gt;&gt;object.  Note that I take special action for Symbols because I don't want the preceeding hash in the external form.  I also take special action to escape $/ characters, unless the database is configured to use standard_conforming_strings."	| rawString |	rawString := (self object isSymbol ifTrue: [self object asString] ifFalse: [self object]) printStringOld.	^self session connection serverConfigurationParameters useStandardConformingStrings		ifTrue: [rawString]		ifFalse: 			[| rawStream refinedStream |			rawStream := ReadStream on: rawString.			refinedStream := WriteStream on: String new.			[rawStream atEnd] whileFalse: 					[| character |					character := rawStream next.					character = $\ ifTrue: [refinedStream nextPut: $\].					refinedStream nextPut: character].			refinedStream contents]</body></methods><methods><class-id>BSTNode</class-id> <category>printing</category><body package="CS474" selector="printStringOld">printStringOld	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t1 |	t1 := String new.	left isNil not ifTrue: [t1 := left printStringOld].	t1 := t1 , value printStringOld , ' '.	right isNil not ifTrue: [t1 := t1 , right printStringOld].	^t1</body></methods><methods><class-id>BSTNode</class-id> <category>printing</category><body package="CS474" selector="printString">printString	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| t1 |	t1 := String new.	left isNil not ifTrue: [t1 := left printStringOld].	t1 := t1 , value printStringOld , ' '.	right isNil not ifTrue: [t1 := t1 , right printStringOld].	^t1</body></methods><methods><class-id>SpDate</class-id> <category>printing</category><body package="SpTimes" selector="asISO8610StringOn:">asISO8610StringOn: aStream 	aStream		nextPutAll: self underlyingDate year printStringOld;		nextPut: $-.	self underlyingDate monthIndex &lt; 10 ifTrue: [aStream nextPut: $0].	aStream		nextPutAll: self underlyingDate monthIndex printStringOld;		nextPut: $-.	self underlyingDate dayOfMonth &lt; 10 ifTrue: [aStream nextPut: $0].	aStream nextPutAll: self underlyingDate dayOfMonth printStringOld.	^self</body></methods><methods><class-id>UI.HotSlice</class-id> <category>printing</category><body package="UIPainter" selector="displayString">displayString	selector isNil ifTrue: [^(#none1 &lt;&lt; #UIPainter &gt;&gt; '[none]') asString].	^selector printStringOld</body></methods><methods><class-id>UI.MenuAutomaticGenerator</class-id> <category>private</category><body package="Interface-Menus" selector="decodeLabel:">decodeLabel: label	label isSymbol ifTrue:		[^[menuDefiner perform: label]].	label isString ifTrue: 		[^label].	^label class == Array		ifTrue: 			[[UserMessage fromPragmaArgument: label]				on: Error				do: [:ex | ex return: label printStringOld]]		ifFalse: [label printStringOld]</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>private</category><body package="Interface-Models" selector="convertToLiteral:">convertToLiteral: aString	| array s indx obj |	array := Scanner new scanTokens: aString.	array size = 0 ifTrue: [^nil].	obj := array first.	array size = 1 ifTrue: [obj == #true ifTrue: [^true].						obj == #false ifTrue: [^false].						obj == #'nil' ifTrue: [^nil].						^obj].	obj == #'#'		ifTrue: [indx := 2]		ifFalse: [indx := 1].	s := String new writeStream.	indx to: array size do:		[:i |		| e |		e := array at: i.		s			nextPutAll: (e isCharacters						ifTrue: [e]						ifFalse: [e printStringOld]);			space].	s skip: -1.	^s contents asSymbol</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForSymbol">initForSymbol	"Initialize the receiver to convert to and from	Symbol's print representations."	toPrint := 			[:m | 			| val |			(val := m) == nil ifTrue: [String new] ifFalse: [val printStringOld]].	toRead := 			[:v | 			| t |			v size &gt; 0 				ifTrue: 					[v first == $# 						ifTrue: 							[t := v copyFrom: 2 to: v size.							(t first == $' and: [t last == $']) 								ifTrue: 									[t := t copyFrom: 2 to: t size - 1.									(t includes: $') 										ifTrue: 											[t := (t copyFrom: 2 to: t size) inject: (String with: t first)														into: 															[:sofar :c | 															(c == $' and: [sofar last == $']) 																ifTrue: [sofar]																ifFalse: [sofar copyWith: c]]]]]						ifFalse: [t := v]]				ifFalse: [t := String new].			t isEmpty 				ifTrue: [nil]				ifFalse: [(self stripTrailingSeparators: t) asSymbol]]</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForAspect">initForAspect	"Initialize the receiver to convert to and from	Symbol's print representations."	toPrint :=			[:m |			| val |			(val := m ) == nil				ifTrue: [String new]				ifFalse:					[(val detect: [:c | c isSeparator] ifNone: []) notNil						ifTrue: ['#', val]						ifFalse: [val printStringOld]]].	toRead := 			[ :v | 			| t |			v size &gt; 0				ifTrue:					[v first == $#						ifTrue: [t := v copyFrom: 2 to: v size]						ifFalse: [t := v]]				ifFalse: [t := String new].			t isEmpty				ifTrue: [nil]				ifFalse: [(self stripTrailingSeparators: t) asSymbol]]</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForByteArray">initForByteArray	toPrint :=		[:m |		| val |		(val := m ) == nil			ifTrue: [String new]			ifFalse: [val printStringOld]].	toRead :=		[:v |		v isEmpty			ifTrue: [nil]			ifFalse: [self convertToByteArray: v]]</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForBoolean">initForBoolean	toPrint := 			[:m | 			| val |			(val := m ) == nil				ifTrue: [String new]				ifFalse: 					[val printStringOld]].	toRead := [:v | v isEmpty				ifTrue: [nil]				ifFalse:					[#('T' 'TRUE' 'Y' 'YES' '1') includes:						(v asString asUppercase)]].</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForI18NKey">initForI18NKey	"Initialize the receiver to convert to and from	a message catalog key's print representations."	toPrint := 			[:m | 			| val |			(val := m) == nil ifTrue: [String new] ifFalse: [val printStringOld]].	toRead := 			[:v | 			| t |			t := v size &gt; 0 ifTrue: [v] ifFalse: [String new].			t isEmpty 				ifTrue: [nil]				ifFalse: [(t select: [:c | c isAlphaNumeric or: [c = $_]]) asSymbol]]</body></methods><methods><class-id>UI.SlotAdaptor</class-id> <category>printing</category><body package="Interface-Models" selector="printOn:">printOn: aStream	aStream print: self class.	aStream nextPut: $(.	self target printOn: aStream.	aStream space.	self printPathOn: aStream.	aStream nextPutAll: 'instVarAt: '.	aStream nextPutAll: index printStringOld.	aStream nextPut: $).</body></methods><methods><class-id>UI.HoverHelpAssistant</class-id> <category>initialize-release</category><body package="Interface-Hoverhelp" selector="resetStateMachine">resetStateMachine	self lock critical: [		stateMachine ifNotNil: [			self log: (#resetStateMachine, ' deactivate: ', stateMachine currentState name printStringOld).			stateMachine reset]]</body></methods><methods><class-id>UI.HoverHelpAssistant</class-id> <category>private</category><body package="Interface-Hoverhelp" selector="shouldOpenTooltipSoon">shouldOpenTooltipSoon	self		log: #shouldOpenNow , '=' , self hoverHelpSystem isCloseRecent printStringOld.	^self hoverHelpSystem isCloseRecent</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="Interface-Support" selector="iconLabelLengthValue">iconLabelLengthValue	| iconLabelLength |	iconLabelLength := PluggableAdaptor on: Window.	iconLabelLength		getBlock: 			[:win | 			win maxIconLabelLength = 0				ifTrue: ['No label']				ifFalse: [win maxIconLabelLength &gt; Window unlimitedIconLabelLengthBoundary						ifTrue: ['Unlimited']						ifFalse: [win maxIconLabelLength printStringOld]]]		putBlock:			[:win :newValueString |				newValueString size &gt; 0 ifTrue: 					[win maxIconLabelLength: (newValueString = 'No label'							ifTrue: [0]							ifFalse: [newValueString first isDigit									ifTrue: [newValueString asNumber]									ifFalse: [Window unlimitedIconLabelLengthBoundary]])]]		updateBlock: [:m :a :p | true].	^iconLabelLength</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>menu messages</category><body package="UIBasics-Support" selector="printIt">printIt	"Evaluate the current selection as an expression.  If successful, insert and	select the printString of the result of evaluation after the current selection."	self maybeSelectCurrentLine.	self hasRangeSelection ifTrue:		[[self			insertAndSelect: (' ' , self evaluateSelection printStringOld) 			at: self selectionStopIndex]				on: self class compilationErrorSignal				do: [:ex | ex return]]</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>editing-functions</category><body package="UIBasics-Support" selector="displayDate">displayDate	self appendToSelection: Date today printStringOld</body></methods><methods><class-id>UI.WinXPProgressWidgetView</class-id> <category>displaying</category><body package="UILooks-WinXP" selector="displayOn:">displayOn: graphicsContext 	| string origin extent stringOrigin |	origin := self barOrigin.	extent := self barExtent.	graphicsContext paint: self bgColor.	graphicsContext displayRectangle: (self bounds insetBy: 3).	graphicsContext paint: self fgColor.	graphicsContext displayRectangle: ((origin extent: extent) insetBy: 2).	string := (lastValue printStringOld , '%') asText allBold asComposedText.	stringOrigin := ((self bounds extent + (-1 @ -1)) - string bounds extent / 2.0) rounded.	string displayOn: graphicsContext at: stringOrigin.	graphicsContext paint: self bgColor.	graphicsContext intersectClip: ((origin extent: extent) insetBy: 2).	string displayOn: graphicsContext at: stringOrigin.</body></methods><methods><class-id>UI.IndexedAdaptor</class-id> <category>printing</category><body package="Interface-Models" selector="printOn:">printOn: aStream	aStream print: self class.	aStream nextPut: $(.	self target printOn: aStream.	aStream space.	self printPathOn: aStream.	aStream nextPutAll: index printStringOld.	aStream nextPut: $).</body></methods><methods><class-id>UI.ProgressWidgetView</class-id> <category>displaying</category><body package="UIBasics-Components" selector="displayOn:">displayOn: graphicsContext 	| string origin extent stringOrigin |	origin := self barOrigin.	extent := self barExtent.	graphicsContext paint: self bgColor.	graphicsContext displayRectangle: self bounds.	graphicsContext paint: self fgColor.	graphicsContext displayRectangle: (origin extent: extent).	string := (lastValue printStringOld , '%') asText allBold asComposedText.	stringOrigin := (self bounds extent - string bounds extent / 2.0) rounded.	string displayOn: graphicsContext at: stringOrigin.	graphicsContext paint: self bgColor.	graphicsContext intersectClip: (origin extent: extent).	string displayOn: graphicsContext at: stringOrigin</body></methods><methods><class-id>UI.WindowsInputManager class</class-id> <category>private class initialization</category><body package="Internationalization" selector="charSet:">charSet: aNumber 	"WindowsInputManager charSet: 204"	| codepage newEncoder |	"If somehow we get this message on a Unicode VM, the event is not	useful since for all keyboard code pages we should still use the UTF16	encoding."	(aNumber = 0 or: [Win32SystemSupport vmPreferredEncoding = #UTF16])		ifTrue: [self initializeEncoder.  ^self].	#(		#(#RUSSIAN_CHARSET 204 1251)		#(#EE_CHARSET 238 1250)		#(#GREEK_CHARSET 161 1253)		#(#TURKISH_CHARSET 162 1254)		#(#BALTIC_CHARSET 186 1257)		#(#HEBREW_CHARSET 177 1255)		#(#ARABIC_CHARSET 178 1256)		#(#THAI_CHARSET 222 874))			do: [:map | (map at: 2) = aNumber ifTrue: [codepage := map at: 3]].	newEncoder := CharacterEncoderPool		at: ('MS_CP_', codepage printStringOld) asSymbol		ifAbsent: [nil].	newEncoder isNil		ifTrue: [self initializeEncoder]		ifFalse: [Encoder := newEncoder].	^Encoder</body></methods><methods><class-id>UI.MenuItem</class-id> <category>enabled/disabled</category><body package="Interface-Menus" selector="isEnabled">isEnabled	"Answer whether the menu item should be enabled on the menu.  If its not enabled it can't be selected."	| result im |	result := enabled evaluate.	(result isKindOf: Boolean) ifFalse: 		[Transcript			cr;			show: ((#MenuEnablementNotBoolean &lt;&lt; #dialogs &gt;&gt; 'Menu enablement for &lt;1s&gt; answers &lt;2s&gt; instead of a Boolean.')			expandMacrosWith: label printStringOld			with: result printStringOld);			cr;			show: (#AnsweringTrue &lt;&lt; #dialogs &gt;&gt; 'Answering true').		result := true].	im := self labelImage.	im isNil ifFalse: [im downcastEvent: #enablement with: result from: self].	^result</body></methods><methods><class-id>UI.MenuItem</class-id> <category>labeling</category><body package="Interface-Menus" selector="rawLabel">rawLabel	^[label evaluate] on: Error do: [:ex | ex return: label printStringOld]</body></methods><methods><class-id>UI.Notice</class-id> <category>aspects</category><body package="Interface-Support" selector="show:">show: aString	messages == nil ifTrue: [^self].	messages position == 0 ifFalse: [messages cr].	messages show: '[' , Time now printStringOld , '] ' , aString.</body></methods><methods><class-id>UI.Notice class</class-id> <category>instance creation</category><body package="Interface-Support" selector="showNotice:complete:while:title:">showNotice: aString complete: anInteger while: aBlock title: titleString	"Show a progress indicator window while executing a block of 	code. A mini-transcript is included in the notice window.	anInteger is the completeness count (ie = 100%). 	IncrementNotification is raised to denote progress. To reset the	progress bar, raise an IncrementNotification signal with the parameter 'reset'.	MessageNotification is raised to add a message in the window's transcript."	"Example:"	"self 		showNotice: 'In Progress' 		complete: 10 		while: 			[#(10 6 0 20) do:				[:count |				MessageNotification raiseSignal: 'a message ', count printString.				ResetIncrementNotification signalWith: count.  				count timesRepeat: 					[(Delay forMilliseconds: 400) wait.					IncrementNotification raiseSignal]]]		title: 'Testing'"	|  noticeModel int increment progress res title newValue |	title := ((titleString isNil or: [titleString asString isEmpty]) ifTrue: [(#PleaseWait &lt;&lt; #dialogs &gt;&gt; 'Please Wait') asString] ifFalse: [titleString asString]), (#NoticeDoneMacro &lt;&lt; #labels &gt;&gt; ' : &lt;1s&gt;%% done') asString.	noticeModel := self new. 	self openOn: noticeModel withSpec: #noticeWindowSpec.	noticeModel message: aString asText allBold. 	noticeModel postOpenWith: nil.	InputState default grabInputFor: noticeModel builder window.	noticeModel builder window windowManager processOutstandingEvents.	int := anInteger isZero				ifTrue: [1]				ifFalse: [anInteger].	increment := 1.0 / int.	progress := (noticeModel builder componentAt: #progressBar1) widget model.	progress value: 0.0.	[ [ [ [ Cursor wait showWhile: [ res := aBlock value ] ]			on: IncrementNotification do: 				[:not | 				[noticeModel builder window raise.				newValue := progress value + (not ticks * increment).				((progress value * 100.0) rounded min: 100) = ((newValue * 100.0) rounded min: 100) ifFalse: 					[noticeModel builder window label: (title expandMacrosWith: ((newValue * 100.0) rounded min: 100) printStringOld)].				progress value: newValue.				noticeModel builder window windowManager processOutstandingEvents] uiEventNowFor: noticeModel builder window.				not resume				]		 ] on: MessageNotification do:			[ :not | 			[noticeModel builder window raise.			noticeModel show: not messageText.			noticeModel builder window windowManager processOutstandingEvents] uiEventNowFor: noticeModel builder window.			not resume			]	  ] on: ResetIncrementNotification do:			[ :not | | count |			[noticeModel builder window raise.			not oldCount: (Array with: (1 / increment) rounded with: ((progress value)  * (1 / increment)) rounded).			count := not count isZero				ifTrue: [ 1 ]				ifFalse: [ not count ].			progress value: 0.0.			noticeModel builder window label: (title expandMacrosWith: '0').			increment := 1.0 / count.			noticeModel builder window windowManager processOutstandingEvents] uiEventNowFor: noticeModel builder window.			not resume.			]	] ensure: 		[InputState default ungrabInputFor: noticeModel builder window.		noticeModel closeAndUnschedule].	^res</body></methods><methods><class-id>UI.Notice class</class-id> <category>instance creation</category><body package="Interface-Support" selector="showProgress:complete:while:title:">showProgress: aString complete: anInteger while: aBlock title: titleString	"Show a progress indicator window while executing a block of 	code. anInteger is the completeness count (ie = 100%). 	IncrementNotification is raised to denote progress. To reset the	progress bar, raise an IncrementNotification signal with the parameter 'reset'.	MessageNotification is raised to add a message in the window's transcript."	"Example:"	"self 		showProgress: 'In Progress' 		complete: 100000 		while: [100000 timesRepeat: [IncrementNotification raiseSignal]]		title: 'Testing'"	|  noticeModel int increment progress res title newValue |	title := ((titleString isNil or: [titleString asString isEmpty]) ifTrue: [(#PleaseWait &lt;&lt; #dialogs &gt;&gt; 'Please Wait') asString] ifFalse: [titleString asString]), (#NoticeDoneMacro &lt;&lt; #labels &gt;&gt; ' : &lt;1s&gt;%% done') asString.	noticeModel := self new.	self openOn: noticeModel withSpec: #progressWindowSpec.	InputState default grabInputFor: noticeModel builder window.	noticeModel message: aString asText allBold.	noticeModel postOpenWith: nil.	noticeModel builder window refresh.	int := anInteger isZero				ifTrue: [1]				ifFalse: [anInteger].	increment := 1.0 / int.	progress := (noticeModel builder componentAt: #progressBar1) widget model.	progress value: 0.0.	[ [Cursor wait showWhile: [res := aBlock value]]			on: IncrementNotification			do: 				[:not | 				[noticeModel builder window raise.				not messageText = (#reset &lt;&lt; #dialogs &gt;&gt; 'reset') asString ifTrue: [progress value: 0.0].				newValue := progress value + (not ticks * increment).				((progress value * 100.0) rounded min: 100) = ((newValue * 100.0) rounded min: 100) ifFalse: 					[noticeModel builder window label: (title expandMacrosWith: ((newValue * 100.0) rounded min: 100) printStringOld)].				progress value: newValue .				noticeModel builder window windowManager processOutstandingEvents] uiEventNowFor: noticeModel builder window.				not resume] ]			ensure: 				[InputState default ungrabInputFor: noticeModel builder window.				noticeModel closeAndUnschedule].	^res</body></methods><methods><class-id>UI.RowVisualComposite</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="rowSelectorButtonVisual">rowSelectorButtonVisual	^VisualBlock block: 			[:graphicsContext :boundingBox |			| box lookPolicy borderedButton |			box := boundingBox insetBy: (0 @ 0								extent: (container showVerticalLines ifTrue: [1] ifFalse: [0])										@ (container showHorizontalLines ifTrue: [1] ifFalse: [0])).			lookPolicy := container widgetPolicy lookPolicyClass.			borderedButton := self borderedButtonFor: lookPolicy.			((container isSelected: index) not and: [container showLineNumbers])				ifTrue: 					[| label textStyle |					textStyle := lookPolicy useSystemFontsOnWidgets								ifTrue: [lookPolicy systemWidgetTextStyle]								ifFalse: [lookPolicy systemTextStyle].					label := Label with: index printStringOld attributes: textStyle.					borderedButton component label: label].			(container isSelected: index)				ifTrue: 					[| label |					label := self selectionIconLabel.					borderedButton component label: label].			borderedButton bounds: box.			borderedButton container: container.			borderedButton displayOn: graphicsContext at: 0 @ 0]</body></methods><methods><class-id>UI.RowVisualComposite</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="rowSelectorVisual">rowSelectorVisual		container rowLabelsAsButtons		ifTrue: [^self rowSelectorButtonVisual].	^VisualBlock		block:			[:graphicsContext :boundingBox | 			| box offset |			(container isSelected: index)				ifTrue:					[box := DefaultSelectionMask bounds.					offset := boundingBox center - box extent half.					graphicsContext paint: self foregroundColor.					DefaultSelectionMask displayOn: graphicsContext at: offset].			((container isSelected: index) not and: [container showLineNumbers])				ifTrue:					[| label textStyle lookPolicy |					lookPolicy := container widgetPolicy lookPolicyClass.					textStyle := lookPolicy useSystemFontsOnWidgets						ifTrue: [lookPolicy systemWidgetTextStyle]						ifFalse: [lookPolicy systemTextStyle].					label := Label						with: index printStringOld						attributes: textStyle.					offset := boundingBox center - label bounds extent half.					label displayOn: graphicsContext at: offset]]		"bounds: self elementBox"</body></methods><methods><class-id>UI.InputSensor</class-id> <category>private</category><body package="Interface-Support" selector="forkEmergencyEvaluatorAt:">forkEmergencyEvaluatorAt: priority	"Fork a process running a simple Smalltalk evaluator using as little of the system as possible.  Used for desperate debugging.  May be invoked by control-shift-C."	[ | eWindow event |		eWindow := ScheduledWindow 			openNewIn: (Screen default bounds origin + (20@20) extent: Screen default bounds extent // 2).		eWindow controller.		EmergencyWindows add: eWindow.		[ | stream char gc lineSpacing leftMargin string bottom ct newbottom textStyle |			eWindow label: (#emergencyEvaluator &lt;&lt; #labels &gt;&gt; 'EMERGENCY EVALUATOR').			[eWindow sensor hasDamage] whileFalse.			eWindow checkForEvents.			textStyle := TextAttributes default.			gc := eWindow graphicsContext.			lineSpacing := textStyle lineGridFor: gc fontPolicy.			gc paint: ColorValue black.			leftMargin := 20.			((#emergencyEvaluatorExpression &lt;&lt; #dialogs &gt;&gt; 				'Emergency Evaluator (priority &lt;1p&gt;) -- type an expression terminated by ESC') 				expandMacrosWith: priority) asComposedText					displayOn: gc 					at: leftMargin@0.			stream := WriteStream on: String new.			bottom := lineSpacing.			ct := String new asComposedText.			[(char := (event := eWindow sensor nextKeyboardEvent) keyCharacter) = Character esc] whileFalse:				[event isKeyPress ifTrue: 					[(char = Character backspace or: [char = Character del]) 						ifTrue: 							[stream position &gt; 0 ifTrue: 								[stream skip: -1.								gc paint: ColorValue white.								gc displayRectangle: (0 @ (bottom-lineSpacing) corner: gc medium width @ bottom).								gc paint: ColorValue black]]						ifFalse: [(event isKeyboard and: [char isNil not]) ifTrue: [stream nextPut: char]].					ct := stream contents asComposedText.					newbottom := ct height + lineSpacing.					newbottom &gt; bottom ifTrue: 						[gc paint: ColorValue white.						gc displayRectangle: (0 @ lineSpacing corner: gc medium width @ newbottom).						gc paint: ColorValue black].					newbottom &lt; bottom ifTrue: 						[gc paint: ColorValue white.						gc displayRectangle: (0 @ newbottom corner: gc medium width @ bottom).						gc paint: ColorValue black].					bottom := newbottom.					ct  displayOn: gc at: leftMargin@lineSpacing.					gc flush]].			string := nil.			[string := Cursor execute showWhile: [(self class evaluatorClass evaluate: stream contents) printStringOld]]				on: Object errorSignal				do: 				[:ex |				(ex errorString , (String with: Character cr with: Character cr) , 				ex initialContext printStringOld) asComposedText					displayOn: gc					at: leftMargin@(lineSpacing+ ct height ).				ex return].			[string notNil ifTrue:				[('------', (String with: Character cr ) ,string) asComposedText					displayOn: gc					at: leftMargin@(lineSpacing*2+ ct height).				gc flush]]				on: Object errorSignal				do: [:ex | ex return].			(Delay forSeconds: 2) wait.			eWindow close]			ensure:				[EmergencyWindows remove: eWindow ifAbsent: [].				EmergencyWindows removeAllSuchThat: [:w | w isOpen not]]]					forkAt: priority</body></methods><methods><class-id>UI.InputState class</class-id> <category>class initialization</category><body package="OS-Window System" selector="initKeys">initKeys	"InputState initKeys"	FunctionKeyNames := #(		Compose Home Left Right Up Down PageUp PageDown End Begin		PF1 PF2 PF3 PF4 Insert ShiftL ShiftR Control CapsLock MetaL MetaR		AltL AltR Help Enter Clear FwdDelete NumLock BackTab nil nil nil		F1 F2 F3 F4 F5 F6 F7 F8 F9 F10		F11 F12 F13 F14 F15 F16 F17 F18 F19 F20		F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 F32 F33 F34 F35).	FunctionKeyValues := IdentityDictionary new: FunctionKeyNames size * 2.	FunctionKeyNames with: (1 to: FunctionKeyNames size) do:		[:keyName :index|		 keyName notNil ifTrue:			[FunctionKeyValues at: keyName put: index]].	"Now add L and R function key homonyms for F16 through F25 (L1 through L10)	 and F26 through F35 (R1 through R10)"	1 to: 10 do:		[:fKeyIndex|		FunctionKeyValues			at: ('L', fKeyIndex printStringOld) asSymbol put: fKeyIndex + 42;			at: ('R', fKeyIndex printStringOld) asSymbol put: fKeyIndex + 52].	MetaFunctionKeyMap := 0.	#(ShiftL ShiftR Control CapsLock MetaL MetaR AltL AltR) do: 			[:keyName | 			| index |			index := (FunctionKeyValues at: keyName) - 1.			MetaFunctionKeyMap := MetaFunctionKeyMap bitOr: (1 bitShift: index)]</body></methods><methods><class-id>UI.NamedSpec</class-id> <category>private</category><body package="UIPainter" selector="assignNameFrom:">assignNameFrom: aPainterController	| tempName wrappers specsLikeMe specNames index |	tempName := self componentName asString copyWithout: $ .	wrappers := self drilledWrappersFrom: aPainterController view components.	specsLikeMe := wrappers select: [:each | each spec isKindOf: self class].	specNames := specsLikeMe collect: [:each | each spec name].	index := 0.	[index := index + 1.	(specNames includes: (tempName, index printStringOld) asSymbol)] whileTrue.	name := (tempName, index printStringOld) asSymbol.</body></methods><methods><class-id>UI.MacOSXProgressWidgetView</class-id> <category>displaying</category><body package="UILooks-MacOSX" selector="displayOn:">displayOn: gc	"Draw a gray border arround the bar and draw text in darkGray only."	"MacXProgressWidgetView slowExample"		| string origin extent stringOrigin originOffset outerRect |	self installProcessIfNeeded.	origin := self barOrigin.	extent := self barExtent.	"Progress bar is always 16 pixel high, so adjust things here"	originOffset := (extent y - 16) // 2.	origin y: origin y + originOffset.	gc paint: ColorValue lightGray.	gc		displayRectangularBorder:			(outerRect := origin extent: (self bounds insetBy: 1) extent x @ 15).	gc intersectClip: outerRect.	self		displayImage: self class bgImage		from: (origin x + 1) @ origin y		to: outerRect extent x - 2		on: gc.	gc intersectClip: (origin + 1 extent: (extent x - 3) @ 14).	mutex		critical:			[self				displayImage: self class fgImage				from: iterativeIndex negated @ origin y				to: extent x - 2				on: gc].	gc intersectClip: self bounds.	string := (lastValue printStringOld , '%') asText allBold asComposedText.	stringOrigin := (self bounds extent - string bounds extent) half rounded.	gc paint: ColorValue darkGray.	string displayOn: gc at: stringOrigin</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>private</category><body package="UIBuilder-Framework" selector="rebuildMenu:named:with:augmentTo:">rebuildMenu: oldMenu named: aSymbol with: newMenu augmentTo: aClass	"A menu action method may have been added or removed.  Regenerate the menu to reflect the change.  For robustness catch and ignore any errors."		[	[newMenu		augmentFrom: self class		to: aClass		menuName: aSymbol		for: self.	oldMenu menuItems do: [:item | oldMenu removeItem: item].	oldMenu addPart: newMenu.	"Now get the menu bar view to update itself from the menu. 	Getting to the menuBarView this way is a hack."	self builder keyboardProcessor menuBar == nil		ifFalse: [self builder keyboardProcessor menuBar updateMenu]]			on: MenuAugmentationError			do: 				[:ex |				| err param |								[Transcript					cr;					show: (#SomeMenuItemsNotUsed &lt;&lt; #dialogs								&gt;&gt; 'The following menu items were not added for &lt;1s&gt;'									expandMacrosWith: self class name)]						on: Error						do: 							[:ex2 |							Transcript beginEntry.							ex2 return].				((param := ex parameter) notNil and: [param isSequenceable])					ifTrue: 						[param do: 								[:association |																[Transcript									cr;									tab;									show: association key first value storeString;									show: ' -&gt; ';									show: (err := association value) printStringOld;									show: '(';									show: err messageText;									show: ')']										on: Error										do: 											[:ex2 |											Transcript beginEntry.											ex2 return]]].				ex isResumable ifTrue: [ex resume] ifFalse: [ex pass]]]			on: Error			do: [:ex | ex return]</body></methods><methods><class-id>UI.EmergencyWindow</class-id> <category>events</category><body package="OS-Window System" selector="processEscape">processEscape	| string graphicsContext method |	graphicsContext := self graphicsContext.	string := nil.	[string := Cursor execute showWhile:		[method := self compileExpression: commandStream contents.		(nil performMethod: method) printStringOld]]		on: Error		do: [:error |			(error errorString , (String with: Character cr with: Character cr) , error initialContext printStringOld) asComposedText				displayOn: graphicsContext				at: leftMargin @ lastBottom.			error return].	[string notNil		ifTrue:			[('------', (String with: Character cr ) , string) asComposedText				displayOn: graphicsContext				at: leftMargin @ lastBottom.			graphicsContext flush]]		on: Error		do: [:error | error return].	(Delay forSeconds: 3) wait.	self close.</body></methods><methods><class-id>UI.SourceCodeEditor</class-id> <category>actions - performing</category><body package="UIBasics-Text2" selector="displayDate">displayDate	&lt;state: #active modifiers: #(control shift) key: $D&gt;	self insert: Date today printStringOld</body></methods><methods><class-id>UI.TreeViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter" selector="addBindingsTo:for:channel:">addBindingsTo: env for: inst channel: aChannel 	super		addBindingsTo: env		for: inst		channel: aChannel.	env 		at: #minimumHeight 		put: (self adapt: inst forAspect: #minimumHeight channel: aChannel).	env at: #displayStringSelector put: (TypeConverter onSymbolValue: (self				adapt: inst				forAspect: #displayStringSelector				channel: aChannel)).	env at: #useIcons put: (self			adapt: inst			forAspect: #useIcons			channel: aChannel).	env at: #fullLineSelect put: (self			adapt: inst			forAspect: #fullLineSelect			channel: aChannel).	env at: #rootExpander put: ( self			adapt: inst			forAspect: #rootExpander			channel: aChannel).	env at: #iconSelectors put: ((TypeConverter on: (self				adapt: inst				forAspect: #iconSelectors				channel: aChannel))			getBlock: 				[:m | 				| val |				(val := m value) isNil					ifTrue: [String new]					ifFalse: 						[| str |						str := (String new: 80) writeStream.						val do: [:ea | str nextPutAll: ea printStringOld; space].						str contents]]			putBlock: 				[:m :v | 				| tokens t |				v isEmpty					ifTrue: [t := #()]					ifFalse: 						[tokens := (v tokensBasedOn: Character space) reject: [:s | s = ''].						t := Array new: tokens size.						1 to: tokens size							do: 								[:i | 								| s |								s := tokens at: i.								s first == $# ifTrue: [s := s copyFrom: 2 to: s size].								t at: i put: s asSymbol]].				t isEmpty					ifTrue: [m value: nil]					ifFalse: [m value: t]]			updateBlock: [:m :a :p | true]).	env at: #inPlaceEditedSelector put: (self			adapt: inst			forAspect: #inPlaceEditedSelector			channel: aChannel).	env at: #openedEmphasis put: (self			adapt: inst			forAspect: #openedEmphasis			channel: aChannel).	env at: #closedEmphasis put: (self			adapt: inst			forAspect: #closedEmphasis			channel: aChannel).	env at: #leafEmphasis put: (self			adapt: inst			forAspect: #leafEmphasis			channel: aChannel).	env at: #useChildImages put: (self			adapt: inst			forAspect: #useChildImages			channel: aChannel).	env at: #useLines put: (self			adapt: inst			forAspect: #useLines			channel: aChannel)</body></methods><methods><class-id>UI.ClickableGraphic class</class-id> <category>example</category><body package="Graphics-Visual Objects" selector="example">example	"self example"	| me window text |	window := ScheduledWindow new.	window component: CompositePart new.	0 to: 1		do: 			[:x |			0 to: 1				do: 					[:y |					me := self new.					text := (x @ y) printStringOld asText.					me idleGraphic: (Label with: text).					me						mouseOverGraphic: (Label with: (text copyOld emphasizeAllWith: #underline)).					me mouseDownGraphic: (Label with: (text copyOld emphasizeAllWith: #italic)).					me when: Clicked						do: 							[Transcript								show: 'Clicked: ' , (x @ y) printStringOld;								cr].					window component add: me in: (x @ y / 2 extent: 1 asPoint / 2)]].	window openWithExtent: 200 @ 200</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu messages</category><body package="UIBasics-Controllers" selector="printIt">printIt	"Evaluate the current selection as an expression.  If successful, insert and	select the printString of the result of evaluation after the current selection."	self maybeSelectCurrentLine.	self hasRangeSelection		ifTrue: 			[			[self insertAndSelect: ' ' , self evaluateSelection printStringOld				at: self selectionStopIndex]					on: self class compilationErrorSignal					do: [:ex | ex return]]</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>editing-functions</category><body package="UIBasics-Controllers" selector="displayDate">displayDate	self appendToSelection: Date today printStringOld</body></methods><methods><class-id>UI.TypeConverter</class-id> <category>private</category><body package="Interface-Models" selector="aspectToText">aspectToText	" Initialize the receiver to perform the action	when assigned a value "	self		getBlock:			[:m |			| val |			(val := m value) == nil				ifTrue: [String new]				ifFalse:					[(val detect: [:c | c isSeparator] ifNone: []) notNil						ifTrue: ['#', val]						ifFalse: [val printStringOld]]]		putBlock:			[:m :v | 			| t |			v size &gt; 0				ifTrue:					[v first == $#						ifTrue: [t := v copyFrom: 2 to: v size]						ifFalse: [t := v]]				ifFalse: [t := String new].			t isEmpty				ifTrue: [m value: nil]				ifFalse: [m value: (self stripTrailingSeparators: t) asSymbol]]		updateBlock: [:m :a :p | true]</body></methods><methods><class-id>UI.TypeConverter</class-id> <category>initialize algorithm</category><body package="Interface-Models" selector="objectToText">objectToText	" Initialize the receiver to perform the action	when assigned a value "	self		getBlock:			[:m |			| val |			(val := m value) == nil				ifTrue: [String new]				ifFalse: [val printStringOld]]		putBlock:			[:m :v | v isEmpty				ifTrue: [m value: nil]				ifFalse: [m value: (Object readFrom: v readStream)]]		updateBlock: [:m :a :p | true]</body></methods><methods><class-id>UI.TypeConverter</class-id> <category>private</category><body package="Interface-Models" selector="convertToLiteral:">convertToLiteral: aString	| array s indx obj |	array := Scanner new scanTokens: aString.	array size = 0 ifTrue: [^nil].	obj := array first.	array size = 1 ifTrue: [obj == #true ifTrue: [^true].						obj == #false ifTrue: [^false].						obj == #'nil' ifTrue: [^nil].						^obj].	obj == #'#'		ifTrue: [indx := 2]		ifFalse: [indx := 1].	s := String new writeStream.	indx to: array size do:		[:i |		| e |		e := array at: i.		s			nextPutAll: (e isCharacters						ifTrue: [e]						ifFalse: [e printStringOld]);			space].	s skip: -1.	^s contents asSymbol</body></methods><methods><class-id>PostgreSQLEXDITimestampValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"I return a PostgreSQL-friendly (single quoted) string representation of my timestamp object."	| timestamp |	timestamp := self object.	^((String new writeStream)		print: timestamp year;		nextPut: $-;		print: timestamp month;		nextPut: $-;		print: timestamp day;		space;		print: timestamp hour;		nextPut: $:;		print: timestamp minute;		nextPut: $:;		print: timestamp second;		nextPut: $.;		nextPutAll: ('000000', timestamp microsecond printStringOld last: 6);		contents) printStringOld</body></methods><methods><class-id>OS.SocketAddress</class-id> <category>printing</category><body package="OS-Sockets" selector="printOn:">printOn: aStream 	"Append to the argument, aStream, the printable representation of the	domain code and the remaining bytes."	| fn fc |	aStream print: self class.	aStream nextPut: $(.	self class = SocketAddress		ifTrue: 			[fc := self domainCode.			fn := [self class domainNameFromCode: fc]				on: KeyNotFoundError				do: [:ex | ex returnWith: 'af' , fc printStringOld].			aStream nextPutAll: fn asString.			aStream space].	self printBytesOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>OS.MC_FileBTree class</class-id> <category>testing</category><body package="UIBasics-Internationalization" selector="test">test	"FileBTree test."	| test |	test := self named: 'test1.ism'.	1 to: 100 do:		[:i |		test at: 'foo', i printStringOld put: i].	^test</body></methods><methods><class-id>OS.IPSocketAddress</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	&lt;inspectorFields&gt;	^Array		with:			(Tools.Trippy.TextAttribute				label: #hostName &lt;&lt; #dialogs &gt;&gt; 'host name'				textBlock: [self hostName])		with:			(Tools.Trippy.TextAttribute				label: #hostAddress &lt;&lt; #dialogs &gt;&gt; 'host address'				textBlock: [ | output |					output := String new writeStream.					self printAddressOn: output.					output contents ])		with:			(Tools.Trippy.TextAttribute				label: #port &lt;&lt; #dialogs &gt;&gt; 'port'				textBlock: [self port printStringOld])</body></methods><methods><class-id>OS.WinProcess</class-id> <category>initialize-release</category><body package="OS-ExternalProcess" selector="oemEncoding">oemEncoding	^OSSystemSupport concreteClass new GetOEMCP printStringOld asSymbol.</body></methods><methods><class-id>OS.WinProcess</class-id> <category>printing</category><body package="OS-ExternalProcess" selector="printOn:">printOn: aStream 	aStream nextPutAll: 'a WinProcess '.	self key notNil		ifTrue: [aStream nextPutAll: 'PID: ' , (self key memberAt: #dwProcessId) printStringOld]		ifFalse: [aStream nextPutAll: '(Inactive)']</body></methods><methods><class-id>OS.ObjectiveCRuntimeTypeEncoder</class-id> <category>api</category><body package="OS-MacOSX" selector="decode:">decode: rtti	| stream types type |	stream := rtti readStream.	types := OrderedCollection new.	[stream atEnd] whileFalse: [types add: (self decodeTypeFromStream: stream)].	type := CProcedureType		resultType: types first		argumentTypes: (types allButFirst: 1)		argumentNames: ((1 to: types size - 1) collect: [:each | 'arg', each printStringOld]).	^type</body></methods><methods><class-id>OS.ObjectiveCRuntimeTypeEncoder</class-id> <category>private</category><body package="OS-MacOSX" selector="decodeCompositeTypeFromStream:type:endingWith:">decodeCompositeTypeFromStream: stream type: compositeType endingWith: anEndingCharacter	| compositeName composite types existing |	types := OrderedCollection new.	compositeName := String new writeStream.	[stream atEnd or: [stream peek = $= or: [stream peek = anEndingCharacter]]] whileFalse: [compositeName nextPut: stream next].	compositeName := compositeName contents asSymbol.	existing := true.	composite := AbstractObjectiveCRuntime concreteClass externals at: compositeName ifAbsent:		[existing := false.		composite := CCompositeType new perform: compositeType; name: compositeName; yourself.		compositeName = #?			ifTrue:	[composite]			ifFalse:	[AbstractObjectiveCRuntime concreteClass externals at: compositeName put: composite]].	stream next = anEndingCharacter ifFalse:		[[stream atEnd or: [stream peek = anEndingCharacter]] whileFalse: [types add: (self decodeTypeFromStream: stream)].		stream next. "anEndingCharacter"].	existing ifTrue: [^composite].	types keysAndValuesDo: [:key :value | composite at: ('member', key printStringOld) asSymbol put: (key - 1) -&gt; value].	^composite</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>accessing-zlib constants</category><body package="Compression-ZLib" selector="errorStringFor:">errorStringFor: errorCode	^(errorCode between: self Z_VERSION_ERROR and: self Z_NEED_DICT)		ifTrue: [(self cZError: errorCode) copyCStringFromHeap]		ifFalse: ['unknown error ', errorCode printStringOld]	"| i |	 i := self new.	 (i Z_VERSION_ERROR to: i Z_NEED_DICT) collect: [:ec| i errorStringFor: ec]"</body></methods><methods><class-id>OS.Win32PrinterInterface class</class-id> <category>utils</category><body package="OS-PC" selector="printStringFor:">printStringFor: aCompositePointer 	| s |	s := (String new: 50) writeStream.	aCompositePointer type referentType		keysAndValuesDo: 			[:k :v | 			s nextPutAll: k printStringOld.			s nextPutAll: '-&gt;'.			s nextPutAll: (aCompositePointer memberAt: k) printStringOld; cr].	^s contents</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 isNil		ifFalse: [leftView value: s1 printStringOld]		ifTrue: [leftView value: ''].	s2 isNil		ifFalse: [rightView value: s2 printStringOld]		ifTrue: [rightView value: ''].	^self</body></methods><methods><class-id>PostgreSQLConnectionLog</class-id> <category>services</category><body package="PostgreSQLLogging" selector="logMessage:">logMessage: aMessage 	"^self 	I log aMessage to my target stream. I write out a timestamp, 	followed by a representation of aMessage. Lastly I flush the stream."	(self targetStream) cr; nextPutAll: Timestamp now printStringOld; cr.	aMessage printOn: self targetStream.	self targetStream flush.	^self</body></methods><methods><class-id>BST</class-id> <category>printing</category><body package="CS474" selector="printStringOld">printStringOld	root isNil ifTrue: [^''].	^root printStringOld</body></methods><methods><class-id>BST</class-id> <category>printing</category><body package="CS474" selector="printString">printString	root isNil ifTrue: [^''].	^root printStringOld</body></methods><methods><class-id>PasswordPacket</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Packet size: ' , self packetSize value printStringOld; cr.	aStream nextPutAll: 'Password: ' , self passwordBytes asString printStringOld; cr.	^self</body></methods><methods><class-id>ByteValue</class-id> <category>debugging</category><body package="PostgreSQLDriver" selector="asString">asString	"^a String 	*FOR DEBUGGING ONLY*	I return a String representation of myself."	^'&lt;a ByteValue&gt;:', self value printStringOld</body></methods><methods><class-id>BackendKeyDataMessage</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Process ID: ', self processID printStringOld; cr.	aStream nextPutAll: 'Secret Key: ', self secretKey printStringOld; cr.	^self</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbeEditor</class-id> <category>actions</category><body package="Debugger-Probes" selector="selectWindowID">selectWindowID	| entries list |	entries := OrderedCollection new.	list := OrderedCollection new.	PDPManager windowHolders associationsDo:		[:ac|		entries add: ac key.		list add: '&lt;' , ac key printStringOld , '&gt; ' , ac value label asString].	list isEmpty		ifTrue:			[Dialog warn: (#ThereAreNoWindowsAvailable &lt;&lt; #pdp &gt;&gt; 'There are no windows available.').			^nil].	^Dialog 		choose: (#SelectWindowIDWindow &lt;&lt; #pdp &gt;&gt; 'Select Window&lt;ID&gt;		Window') 		fromList: list		values: entries 		lines: 20		cancel: []</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>private</category><body package="Debugger-Probes" selector="nextWindowID">nextWindowID	| id |	lastID := lastID + 1.	id := lastID printStringOld asSymbol.	watchWindows at: id put: self newWatchWindow.	^id"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorRecord</class-id> <category>initialize-release</category><body package="Debugger-Process Monitor" selector="onWindow:withTag:">onWindow: aWindow withTag: aTag	windowLabel := aWindow label.	windowLabel := windowLabel isNil		ifTrue: [aWindow printStringOld]		ifFalse: [windowLabel asString].	self basicOn: aWindow windowProcess withTag: aTag</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorRecord</class-id> <category>initialize-release</category><body package="Debugger-Process Monitor" selector="basicOn:withTag:">basicOn: aProcess withTag: aTag	self initializeNameForProcess: aProcess.	priority := aProcess priority.	underDebug := aProcess isUnderDebug.	state := underDebug ifTrue: ['d ' ] ifFalse: ['  '].	state := state , aProcess processState asString.	topContext := aProcess suspendedContext.	(topContext notNil and: [topContext method == (Semaphore compiledMethodAt: #wait)])		ifTrue: [topContext := topContext sender].	topContext := topContext printStringOld.	type := aProcess isSystemProcess.	type isNil ifTrue: [type := false].	processHash := aProcess identityHash.	processTag := aTag</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id> <category>reporting</category><body package="Debugger-Probes" selector="report:">report: basicType		| reportStream |	reportStream := WriteStream on: (String new: 200).	reportStream nextPutAll: (self reportStringFor: basicType).	instrumentationRequest == #instrumentSimpleWatch		ifTrue:			[reportStream				nextPutAll: ' &lt;';				nextPutAll: iVarName;				nextPut: $&gt;].	reportStream		nextPutAll:				(#OnMessageReceivedForC &lt;&lt; #pdp &gt;&gt; ' on message received for:') asString;		cr.	instrumentationRecords		do:			[:rec | 			reportStream				cr;				nextPutAll: rec printStringOld].	ComposedTextView		open: reportStream contents asText asValue		label:			#ProbeOnMessageReceivedReport &lt;&lt; #pdp &gt;&gt; 'Probe on Message Received Report'		extent: 500 @ 300</body></methods><methods><class-id>CraftedSmalltalk.StackInspector</class-id> <category>field list</category><body package="Debugger-StackInspector" selector="fieldList">fieldList	| argumentCount size index tempNames |	object == nil ifTrue:		[properties at: #tempNames put: Array new.		^super fieldList].	size := object stackP - object method numLocals.	size &gt; 0		ifFalse:			[^properties at: #tempNames put: Array new].	tempNames := Array new: size.	index := 1.	(isTopContext and:		[object atEnd not and:			[object pdpWillSend and:				[argumentCount := object peekForSelector numArgs.				object sendsAdd1					ifTrue: [argumentCount := argumentCount - 1].				argumentCount &lt; 100]]])		ifTrue:			[[argumentCount &gt; 0]				whileTrue:					[tempNames at: index put: 'a', argumentCount printStringOld, ': ', (self stackStringAt: index).					argumentCount := argumentCount - 1.					index := index + 1].			object hasReceiverOnStackForSend				ifTrue: [tempNames at: index put: 'r: ', (self stackStringAt: index)]				ifFalse: [index := index - 1]]		ifFalse: [tempNames at: index put: (self stackStringAt: index)].	index := index + 1.	index to: size do:		[:j | tempNames at: j put:  (self stackStringAt: j)].	^properties at: #tempNames put: tempNames</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorClient</class-id> <category>actions</category><body package="Debugger-Process Monitor" selector="changeProcessPriority">changeProcessPriority	| answer |	self hasSelection		ifFalse: [^self].	answer := Dialog request: (#EnterNewPriority &lt;&lt; #pdp &gt;&gt; 'Enter new priority') initialAnswer: self selectedProcessRecord priority printStringOld.	answer isEmpty		ifTrue: [^self].	answer := answer asNumber rounded.	(answer &lt; 1 or: [answer &gt; (Processor highestPriority - 1)])		ifTrue: [^self].	displayList selections do: [:rec | service changeProcessTagged: rec processTag priorityTo: answer]</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorClient</class-id> <category>private</category><body package="Debugger-Process Monitor" selector="numOfSystemProcesses">numOfSystemProcesses	^(processRecords inject: 0 into: [:s :p | s + (p isSystemProcess ifTrue: [1] ifFalse: [0])]) printStringOld</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorClient</class-id> <category>private</category><body package="Debugger-Process Monitor" selector="numOfUserProcesses">numOfUserProcesses	^(processRecords inject: 0 into: [:s :p | s + (p isSystemProcess ifTrue: [0] ifFalse: [1])]) printStringOld</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarRefInstrumenterGUIModel</class-id> <category>operation</category><body package="Debugger-Probes" selector="updateList">updateList		| classes iVarIndex |	iVarIndex := instrumenter iVarIndex.	classes := subclassModel value		ifTrue: [classUnderTest withAllSubclasses]		ifFalse: [Array with: classUnderTest].	methods := SortedCollection		sortBlock: [:aa :b | aa nameString &lt; b nameString].	classes		do:			[:cl | 			cl				selectorsAndMethodsDo:					[:sel :meth | 					| activity |					activity := 0.					(readModel value and: [meth readsField: iVarIndex])						ifTrue: [activity := 1].					(writeModel value and: [meth writesField: iVarIndex])						ifTrue: [activity := 3 - activity].					meth isProbeable ifFalse: [activity := 0].					activity ~= 0						ifTrue:							[methods add: (MethodActionRecord action: activity class: cl selector: sel)]]].	panelList list: (methods collect: [:aRecord | aRecord printStringOld])</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="createLabelString">createLabelString	labelString value: ((#BreakIn1sAt2s &lt;&lt; #pdp &gt;&gt; 'Break in &lt;1s&gt; at &lt;2s&gt;')			expandMacrosWith: self methodString			with: self characterIndex printStringOld).</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>doIt/accept/explain</category><body package="Debugger-UI" selector="printItCompleted:on:">printItCompleted: result on: aTextController	aTextController		insertAndSelect: (' ' , result printStringOld) 		at: aTextController selectionStopIndex</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicy</class-id> <category>list management</category><body package="Debugger-UI" selector="outputPackageOrParcelStringOn:for:selector:">outputPackageOrParcelStringOn: stream for: aMethod selector: selector	| packages |	#{Store.Registry} ifDefinedDo: 			[:registry |			^selector				ifNil: 					[(aMethod definition ifNotNil: #package)						ifNotNil: 							[:package |							stream								nextPutAll: '$P$';								nextPutAll: package printStringOld]]				ifNotNil: 					[packages := registry allContainingPackagesForSelector: selector								class: aMethod mclass.					packages isEmpty						ifFalse: 							[stream								nextPutAll: '$P$';								nextPutAll: packages last printStringOld]]]</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicy</class-id> <category>list management</category><body package="Debugger-UI" selector="filterStack">filterStack	filteredStack := OrderedCollection new.	patterns isEmpty		ifTrue:			[1 to: stack size do: 				[:i | filteredStack add: (Array with: (stack at: i) printStringOld with: i with: nil).].			^filteredStack].	1 to: stack size do:		[:i | | context componentString match id |		context := stack at: i.		componentString := self componentStringFor: context method homeMethod.		context isBlockContext ifTrue:			[componentString := '$B$', componentString].		match := patterns detect: [:pat | pat pattern perform: matchSymbol with: componentString] ifNone: [nil].		id := match notNil			ifTrue: [match name]			ifFalse: [nil].		(id notNil or: [i &lt;= displayAllLimit])			ifTrue: [filteredStack add: (Array with: context printStringOld with: i with: id)]].	^filteredStack</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id> <category>reporting</category><body package="Debugger-Probes" selector="report:">report: basicType		| reportStream |	reportStream := WriteStream on: (String new: 200).	reportStream		nextPutAll: (self reportStringFor: basicType);		nextPutAll:				(#OnInstanceVariable &lt;&lt; #pdp &gt;&gt; ' on instance variable &lt;') asString;		nextPutAll: iVarName;		nextPutAll: (#ReferencesForC &lt;&lt; #pdp &gt;&gt; '&gt; references for:') asString;		cr.	instrumentationRecords		do:			[:rec | 			reportStream				cr;				nextPutAll: rec printStringOld].	ComposedTextView		open: reportStream contents asText asValue		label:			#ProbeOnIVarRefsReport &lt;&lt; #pdp &gt;&gt;					'Probe on Instance Variable References Report'		extent: 500 @ 300</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>tags</category><body package="Debugger-Support" selector="selectTag:">selectTag: aString	| ctx |	ctx := tags detect: [:c | c printStringOld = aString] ifNone: [^self].	self selectContext: ctx.	self scheduleContextListSelectionUpdate.	self processEvents.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>tags</category><body package="Debugger-Support" selector="isTagged:">isTagged: aString	tags detect: [:c | c printStringOld = aString] ifNone: [^false].	^true</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>tags</category><body package="Debugger-Support" selector="tagMenuList">tagMenuList	| col |	col := tags asSortedCollection: [:a :b | a hasSender: b].	col := col reject: [:ctx | ctx hasExited].	tags := PDPWeakCollection withAll: col.	^col collect: [:ctx | ctx printStringOld].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>accessing</category><body package="Debugger-Support" selector="text">text	| theText meth |	currentContext isNil		ifTrue: [^Text new].	^[theText := currentContext sourceCode asText.	currentContext method homeMethod usuallyHasSelector		ifTrue: [theText makeSelectorBoldIn: currentContext mclass].	(meth := self selectedMethod) isProbed		ifTrue: [meth highlightProbesIn: theText].	theText] 		on: MethodDictionary keyNotFoundSignal		do:  [:ex |			((#noSourceCodeFor1s &lt;&lt; #pdp &gt;&gt; 'no source code for &lt;1s&gt;')			expandMacrosWith: currentContext printStringOld) asText emphasizeAllWith: #italic;				yourself].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>utility</category><body package="Debugger-Support" selector="shortStackFor:ofSize:">shortStackFor: aContext ofSize: anInteger	"Answer a string with the simple descriptions of anInteger number of	non-nil stackframes starting with aContext"	| shortStackStream ctx |	shortStackStream := WriteStream on: (String new: 400).	ctx := aContext.	anInteger timesRepeat: 		[ctx isNil ifFalse:			[shortStackStream nextPutAll: (ctx printStringOld contractTo: 50); cr.			ctx := ctx sender]].	shortStackStream position &gt; 0 ifTrue: [shortStackStream skip: -1].	^shortStackStream contents</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>recompiling</category><body package="Debugger-Probes" selector="reportOnFailedProbes:">reportOnFailedProbes: probesInError	| writeStream |	probesInError isEmpty		ifTrue: [^self].	writeStream := WriteStream on: (String new: 200).	writeStream nextPutAll: (#TheFollowingProbesFailedToRecompile &lt;&lt; #pdp &gt;&gt; 'The following probes failed to recompile correctly.') asString.	probesInError do: [:aProbe |		writeStream nextPutAll: aProbe methodString;			nextPutAll: ((#SpProbeAt1pDash2s &lt;&lt; #pdp &gt;&gt; ' probe at &lt;1p&gt; - &lt;2s&gt;&lt;n&gt;') 				expandMacrosWith: aProbe characterIndex printStringOld				with: aProbe reportString)].	[ComposedTextView		open: writeStream contents asText asValue		label: (#FailedProbeRecompileReport &lt;&lt; #pdp &gt;&gt; 'Failed probe recompile report')] fork"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>Tools.ColorValueSetting</class-id> <category>accessing</category><body package="Tools-Settings" selector="toXML:">toXML: aColorValue	self validate: aColorValue.	^Element		tag: self xmlTag		attributes: (Array 			with: (Attribute name: 'red' value: aColorValue red printStringOld)			with: (Attribute name: 'green' value: aColorValue green printStringOld)			with: (Attribute name: 'blue' value: aColorValue blue printStringOld))		elements: nil</body></methods><methods><class-id>Tools.AbstractPropertyComparisonRollupView</class-id> <category>private</category><body package="Store-Code Comparison" selector="printProperty:">printProperty: aPropertyObject	"The default is to use printString (unless it is already a string). But before we use the default, we check to see if we have any tagged methods whose tag is #printProperty: and paramter matches my propertyKey. If we do, we defer to that method to produce a stringified representation of the argument."	(Pragma		allNamed: #printProperty:		from: self class		to: AbstractComparisonRollupView) do: 				[:each |				(each argumentAt: 1) == self propertyKey					ifTrue: [^self perform: each selector with: aPropertyObject]].	^aPropertyObject isCharacters		ifTrue: [aPropertyObject]		ifFalse: [aPropertyObject printStringOld]</body></methods><methods><class-id>Tools.BooleanSetting</class-id> <category>accessing</category><body package="Tools-Settings" selector="toXML:">toXML: anObject	self validate: anObject.	^Element		tag: self xmlTag		elements: (Array with: (XML.Text text: anObject printStringOld))</body></methods><methods><class-id>Tools.PoolDictionaryInspector</class-id> <category>initialize-release</category><body package="Tools-Inspector" selector="viewLabel">viewLabel	"Answer an appropriate label for a view of the receiver.	 This is the name of the receiver's object appended by PoolDictionary."	^self object allowsSelfDefinition		ifTrue: [((#x1sNameSpace &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; NameSpace')			expandMacrosWith: self object printStringOld)]		ifFalse: [((#x1sPoolDictionary &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; PoolDictionary')			expandMacrosWith: (Smalltalk keyAtIdentityValue: self object ifAbsent: [^super viewLabel]))]</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>private</category><body package="Tools-Parcel Manager" selector="descriptionOfParcels:">descriptionOfParcels: parcelCollection	parcelCollection size = 1 ifTrue: [^self descriptionOfParcel: parcelCollection first].	^((#x1sParcelsSelected &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; parcels selected')			expandMacrosWith: parcelCollection size printStringOld)</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>private</category><body package="Tools-Parcel Manager" selector="descriptionOfGroups:">descriptionOfGroups: groupCollection	groupCollection isEmpty ifTrue: [^(#NoSelection &lt;&lt; #dialogs &gt;&gt; 'No selection')].	groupCollection size = 1 ifTrue: [^groupCollection first description].	^((#x1sGroupsSelected &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; groups selected')			expandMacrosWith: groupCollection size printStringOld)</body></methods><methods><class-id>Tools.SettingsDomain class</class-id> <category>notifications</category><body package="Tools-Settings" selector="classMethodsChanged">classMethodsChanged	"Class methods containing pragmas--that is, methods defining settings and pages--	have changed. Do the necessary updates. For robustness, only allow exception	to happen if there is an outer handler; meaning someone intends to handle it.	Otherwise, report to the transcipt but muffle.	Run the following code to force a notifier to come up for debugging."	"[self classMethodsChanged] on: Error do: [:ex | ex pass]"	[self unsafeUpdatePragmaDependents]		on: Error		do:			[:ex | 			ex isNested				ifTrue: [ex pass]				ifFalse:					[Transcript						cr;						show:								(#ErrorUpdatingSettingsInClass &lt;&lt; #dialogs										&gt;&gt;											'Exception while updating &lt;1s&gt;: &lt;2p&gt; in &lt;3p&gt;. To debug, evaluate the following expression: "[&lt;4s&gt; classMethodsChanged] on: Error do: [:ex | ex pass]".'										expandMacrosWith: self class name										with: ex										with: ex initialContext sender										with: self printStringOld).					ex exit]]</body></methods><methods><class-id>Tools.CompiledCodeInspector</class-id> <category>private-text</category><body package="Tools-Inspector" selector="sourceCodeText">sourceCodeText	"Answer the source code text representing the inspected object's home method."	| aString |	aString := self sourceCode.	aString isNil		ifTrue: [aString := object printStringOld].	^aString asText</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>private</category><body package="Tools-Misc" selector="infoText">infoText	"Returns aText with proper emphasis information 	 from the file system information on fileName"	| fn dates stream mod acc |	fn := fileName asFilename.	dates := fn dates.	mod := dates at: #modified.	mod == nil		ifFalse: [mod := self formatTime: mod].	acc := dates at: #accessed.	acc == nil		ifFalse: [acc := self formatTime: acc].	stream := TextStream on: String new.	stream emphasis: #italic;		nextPutAll: (#isFile &lt;&lt; #dialogs &gt;&gt; '- file -  Select ''Get contents'' to view contents. ') asString;		cr; cr; emphasis: #bold;		nextPutAll: (#fileSize &lt;&lt; #dialogs &gt;&gt; 'Size:     ') asString;		emphasis: nil;		nextPutAll: fn fileSize printStringOld;		cr.	mod == nil		ifFalse:			[stream					emphasis: #bold;				nextPutAll: (#fileModifiedTime &lt;&lt; #dialogs &gt;&gt; 'Last modified:     ') asString;				emphasis: nil;				nextPutAll: mod;				cr].	acc == nil		ifFalse:			[stream					emphasis: #bold;				nextPutAll: (#fileAccessTime &lt;&lt; #dialogs &gt;&gt; 'Last accessed:     ') asString;				emphasis: nil;				nextPutAll: acc;				cr].	((fileName includes: $.)	and: [(fileName copyFrom: (fileName lastIndexOf: $.) to: fileName size) asLowercase = Parcel fileExtension]) ifTrue:		[| codeReader info timestamp prereqs |		stream cr.		codeReader := CodeReader new.		[info := codeReader readInfoFromFileNamed: fileName]			on: CodeReader fileFormatSignal			do:				[:ex|				info := Dictionary new.				codeReader fileFormat notNil ifTrue: [info at: #format put: codeReader fileFormat]].		stream			emphasis: #bold; nextPutAll: (#parcelName &lt;&lt; #dialogs &gt;&gt; 'Parcel:	') asString; emphasis: nil;			nextPutAll: (info at: #parcel ifAbsent: ['?']) asString; cr.		stream			emphasis: #bold; nextPutAll: (#parcelVersion1 &lt;&lt; #dialogs &gt;&gt; 'Version:	') asString; emphasis: nil;			nextPutAll: (info at: #version ifAbsent: ['?']) asString; cr.		(timestamp := info at: #timestamp ifAbsent: nil) notNil ifTrue:			[stream				emphasis: #bold; nextPutAll: (#parcelSavedDate &lt;&lt; #dialogs &gt;&gt; 'Written:	') asString; emphasis: nil;				nextPutAll: (self formatTime: (Array with: timestamp asDate with: timestamp asTime)); cr].		stream			emphasis: #bold; nextPutAll: (#parcelFormat &lt;&lt; #dialogs &gt;&gt; 'Format:	') asString; emphasis: nil;			nextPutAll: (info at: #format ifAbsent: ['?']) printStringOld asString;			tab; emphasis: #italic;			nextPutAll: ((#currentParcelFormat &lt;&lt; #dialogs &gt;&gt; '(current &lt;1p&gt;)') expandMacrosWith: CodeWriter fileFormat);			emphasis: nil; cr.		(info includesKey: #space) ifTrue:			[stream				emphasis: #bold; nextPutAll: (#parcelNumberObjects &lt;&lt; #dialogs &gt;&gt; 'Objects:	') asString; emphasis: nil;				nextPutAll: ((info at: #space) at: 1); cr;				emphasis: #bold; nextPutAll: (#parcelBytes &lt;&lt; #dialogs &gt;&gt; 'Bytes:	') asString; emphasis: nil;				nextPutAll: ((info at: #space) at: 2); cr].		stream			emphasis: #bold; nextPutAll: (#parcelPrereqs &lt;&lt; #dialogs &gt;&gt; 'Prerequisites:') asString; emphasis: nil.		prereqs := info at: #prerequisiteParcels ifAbsent: [Array with: (Array with: (#unknown &lt;&lt; #dialogs &gt;&gt; 'unknown') asString with: '')].		prereqs isEmpty			ifTrue: [stream emphasis: #italic; tab; nextPutAll: (#noParcelPrereqs &lt;&lt; #dialogs &gt;&gt; 'none') asString; emphasis: nil]			ifFalse:				[prereqs do:					[:prereq|					stream tab; nextPutAll: prereq first.					(prereq at: 2) size &gt; 0 ifTrue:						[stream							emphasis: #italic; space; nextPut: $V; space;							nextPutAll: (prereq at: 2); emphasis: nil]]].		stream cr.		(info includesKey: #comment) ifTrue:			[stream				emphasis: #bold; nextPutAll: (#parcelComment &lt;&lt; #dialogs &gt;&gt; 'Comment:	') asString; emphasis: nil;				nextPutAll: ((info at: #comment) at: 1); cr]].	^stream contents</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="storePrerequisitesBlessingLevel">storePrerequisitesBlessingLevel	&lt;setting: #(#store #prerequisites #blessingLevel ) position: 10  &gt;	| levels choices labels keys |	levels := Store.Policies blessingPolicy blessings asSortedCollection.	choices := levels collect: [:each | each level].	labels := levels collect: [:each | each name].	keys := levels collect: [:each | each level printStringOld asSymbol].	^((EnumerationSetting		keys: keys		choices: choices		labels: labels)		on: Store.Policies prerequisitePolicy aspect: #blessingLevel)		label: #WithBlessingLevelAtLeast &lt;&lt; #store &gt;&gt; '...with blessing level at least'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-look and feel</category><body package="Tools-Settings-VW" selector="lookAndFeel10lookSelection">lookAndFeel10lookSelection	&lt;setting: #(lookAndFeel defaultLook)&gt;	| choices names keys |	names := OrderedCollection new.	choices := OrderedCollection new.	names add: #AutoSelect &lt;&lt; #labels &gt;&gt; 'Auto Select'.	choices add: #AutoSelect.	UILookPolicy allSubclasses do: 		[:look | | lookName |		(lookName := look settingsMenuName) notNil ifTrue:			[names add: lookName.			choices add: look fullyQualifiedReference]].	keys := choices collect: [:each | each printStringOld asSymbol].	^((EnumerationSetting keys: keys choices: choices labels: names)			onUISetting: #defaultLookSelector)		default: #'#AutoSelect';		label: #UserInterfaceLook &lt;&lt; #labels &gt;&gt; 'User interface look';		helpText: #UserInterfaceLookHelpText &lt;&lt; #dialogs &gt;&gt; 'Selects the default appearance and behavior of buttons, scroll bars, etc.  The new look will apply to any canvas or tool window that you open subsequently.  Use "Auto Select" to let VisualWorks adopt the look that is most appropriate for your operating environment.  To affect the look of a single canvas while you''re editing it, use the "Look" menu of the GUI Painter Tool.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-look and feel</category><body package="Tools-Settings-VW" selector="lookAndFeel15feelSelection">lookAndFeel15feelSelection	&lt;setting: #(lookAndFeel defaultFeel)&gt;	| choices names keys |	names := OrderedCollection new.	choices := OrderedCollection new.	names add: #AutoSelect &lt;&lt; #labels &gt;&gt; 'Auto Select'.	choices add: #AutoSelect.	UIFeelPolicy allSubclasses do: 		[:look | | lookName |		(lookName := look settingsMenuName) notNil ifTrue:			[names add: lookName.			choices add: look fullyQualifiedReference]].	keys := choices collect: [:each | each printStringOld asSymbol].	^((EnumerationSetting keys: keys choices: choices labels: names)			 onUISetting: #feelSelection)		default: #'#AutoSelect';		label: #UserInterfaceFeel &lt;&lt; #labels &gt;&gt; 'User interface feel';		helpText: #UserInterfaceFeelHelpText &lt;&lt; #dialogs &gt;&gt; 'Select the platform feel that you want text editors (including browsers) to have. You may add your own Feels by subclassing from UIFeelPolicy and providing your own keyboard bindings in the class. On the class side of the custom UIFeelPolicy class, one must provide a method called "menuName" that returns a string that names the custom feel policy, e.g., ''Windows 4.0''.'</body></methods><methods><class-id>Tools.ChangeEditor</class-id> <category>private</category><body package="Tools-Changes" selector="textForChangeSet">textForChangeSet	| comment |	^(comment := source value comment) isNil		ifTrue: [			source value isEmpty				ifTrue: [source value printStringOld]				ifFalse: [(#ThisChangeSetHasNoComment &lt;&lt; #dialogs &gt;&gt; 'This ChangeSet has no comment') asString]]		ifFalse: [			(comment size &gt; 0 and: [comment first = $"])				ifTrue:					[comment := comment copyFrom: 2 to: comment size].			(comment size &gt; 0 and: [comment last = $"])				ifTrue:					[comment := comment copyFrom: 1 to: comment size - 1].			comment]</body></methods><methods><class-id>Tools.FileDialog</class-id> <category>private</category><body package="Tools-Dialogs" selector="styledTimestamp:">styledTimestamp: aFilename	| ts |	ts := [aFilename modificationTimestamp] on: OSErrorHolder errorSignal				do: [:ex | ex return: Timestamp zero].	^self text: ts printStringOld styledFor: aFilename</body></methods><methods><class-id>Tools.FileDialog</class-id> <category>private</category><body package="Tools-Dialogs" selector="styledFilesize:">styledFilesize: aFilename 	^self text: aFilename fileSize printStringOld styledFor: aFilename</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>private</category><body package="System-Changes" selector="commentAndTimeStamp">commentAndTimeStamp	"Return my comment and time stamp."	| stream stream2 |	stream := (String new: comment size + 100) writeStream.	changeSetName notNil ifTrue:		[stream			nextPutAll: (#ChangesInChangeSet &lt;&lt; #dialogs &gt;&gt; '"Changes in change set &lt;1s&gt;"'				expandMacrosWith: changeSetName);			cr].	comment notNil ifTrue:		[stream nextPutAll: comment; cr].	stream2 := WriteStream on: (String new: 16).	SystemUtils timeStamp: stream2.	stream nextPutAll: stream2 contents printStringOld.	^stream contents</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>private</category><body package="UIPainter" selector="removeClass:">removeClass: aClass 	(Dialog confirm: ((#GenKey94 &lt;&lt; #UIPainter &gt;&gt; 'Are you certain that you want to remove&lt;n&gt;class &lt;1s&gt; from the system?')			expandMacrosWith: aClass printStringOld) for: builder window)		ifFalse: [^self].	(aClass subclasses size == 0 or: [Dialog confirm: ((#GenKey93 &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; has subclasses&lt;n&gt;Proceed with removal?')			expandMacrosWith: aClass name) for: builder window])		ifTrue: 			[aClass removeFromSystem.			self removeClassAndAdjustSets: aClass fullyQualifiedReference.			UIFinderVW2 changed: #specBearers]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>private</category><body package="UIPainter" selector="referUserToSpecBearingParent">referUserToSpecBearingParent	| totalNumberOfSpecs specBearingParent soleSpec canvases cls |	totalNumberOfSpecs := 0.	canvases := Dictionary new.	(cls := self selectedClassOrDo: [^self classGone]) class allSuperclasses		do: 			[:sc | 			| specCount specs |			specCount := (specs := sc organization listAtCategoryNamed: #'interface specs') size.			specCount &gt; 0				ifTrue: 					[specBearingParent := sc instanceBehavior.					canvases at: specBearingParent put: specs].			totalNumberOfSpecs := totalNumberOfSpecs + specCount.			specs isEmpty not ifTrue: [soleSpec := specs first]].	totalNumberOfSpecs == 1		ifTrue: [(Dialog				choose: ((#GenKey92 &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; inherits a canvas from&lt;n&gt;&lt;2s&gt;.&lt;n&gt;Edit this canvas?')			expandMacrosWith: cls printStringOld asString			with: specBearingParent name)				labels: (Array with: (#Edit &lt;&lt; #UIPainter &gt;&gt; 'Edit') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))				values: #(true false )				default: true				for: builder window)				ifTrue: [UIPainter new openOnClass: specBearingParent andSelector: soleSpec]]		ifFalse: [totalNumberOfSpecs == 0				ifTrue: [Dialog warn: ((#x1sHasNoCanvases &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; has no canvases')			expandMacrosWith: cls printStringOld) for: builder window]				ifFalse: [self class openInheritedCanvasDialogOn: cls name with: canvases]]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>commands</category><body package="UIPainter" selector="newImageFromFile">newImageFromFile	|cl aFilename newSelector|	cl := self selectedClassOrDo: [^self classGone].	(aFilename := Dialog 		requestFileName: (#NameOfBitmapFile &lt;&lt; #UIPainter &gt;&gt; 'Name of bitmap file') asString		default: '*.bmp') isEmpty  ifTrue: [^self].	(newSelector := Dialog request: (#GenKey91 &lt;&lt; #UIPainter &gt;&gt; 'Supply the name of the new method to be created:')) isEmpty		ifTrue: [^self].	(cl class includesSelector: newSelector asSymbol) 		ifTrue: 			[(Dialog 				confirm: ((#GenKey90 &lt;&lt; #UIPainter &gt;&gt; '#&lt;1s&gt; already exists in class &lt;2s&gt;!Are you sure you want to replace it?') expandMacrosWith: newSelector with: cl printStringOld))				ifFalse: [^self]].	ImageReader 		imageFromFile: aFilename		toClass: cl  		selector: newSelector asSymbol.	"Force a refresh on the list we care about"	self changedClassName</body></methods><methods><class-id>Tools.FileTools.FileInformationViewer</class-id> <category>accessing</category><body package="Tools-File Browser" selector="timestampStringAt:in:">timestampStringAt: aSymbol in: aDictionary	| array |	array := aDictionary at: aSymbol.	^array first printStringOld, ' ', array last printStringOld</body></methods><methods><class-id>Tools.FileTools.FileInformationViewer</class-id> <category>accessing</category><body package="Tools-File Browser" selector="printBlurbFor:on:">printBlurbFor: aFilename on: stream	self		print: (#Path &lt;&lt; #labels &gt;&gt; 'Path') value: [aFilename asString] on: stream;		print: (#Size &lt;&lt; #labels &gt;&gt; 'Size') value: [aFilename fileSize printStringOld] on: stream;		print: (#Created &lt;&lt; #labels &gt;&gt; 'Created') value: [self timestampStringAt: #created in: aFilename dates] on: stream;		print: (#LastModified &lt;&lt; #labels &gt;&gt; 'Last modified') value: [self timestampStringAt: #modified in: aFilename dates] on: stream;		print: (#LastAccessed &lt;&lt; #labels &gt;&gt; 'Last accessed') value: [self timestampStringAt: #accessed in: aFilename dates] on: stream</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>miscellaneous</category><body package="Tools-File Browser" selector="updateStatusBarForFolderSelection">updateStatusBarForFolderSelection	| filename |	filename := self selectedDirectory asFilename.	self statusTextLeftHolder value: filename asString.	self statusTextRightHolder value: ((#x1sFiles &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; files')			expandMacrosWith: self fileListHolder list size printStringOld)</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>miscellaneous</category><body package="Tools-File Browser" selector="fileSizeString:">fileSizeString: anInteger	anInteger &lt; 1024 ifTrue:		[^((#x1sBytes &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; bytes')			expandMacrosWith: anInteger printStringOld)].	anInteger &lt; 1048576 ifTrue:		[^((#x1sKB &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; KB')			expandMacrosWith: (anInteger // 1024) printStringOld)].	^((#x1sMB &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; MB')			expandMacrosWith: (anInteger // 1048576) printStringOld)</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>system information</category><body package="Tools-Misc" selector="printBasicSystemInformationon:">printBasicSystemInformationon: aStream	&lt;systemInformation: 0&gt;	| patches |	aStream		emphasis: #bold; 		nextPutAll: (#versionID &lt;&lt; #dialogs &gt;&gt; 'Version Id:') asString; 		emphasis: nil;		crtab; 		nextPutAll: ObjectMemory versionId printStringOld;		cr; 		emphasis: #bold; 		nextPutAll: (#patches &lt;&lt; #dialogs &gt;&gt; 'Patches:') asString; 		emphasis: nil.	patches := ChangeSet patches asSortedStrings.	patches isEmpty		ifTrue: [aStream crtab; nextPutAll: (#none &lt;&lt; #dialogs &gt;&gt; '(none)') asString]		ifFalse: [patches do: [:str | aStream crtab; nextPutAll: str]].	aStream cr</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>private</category><body package="Tools-Misc" selector="createPage:">createPage: aSelector	^[self perform: aSelector]		on: Error		do: [:ex |			self new				label: aSelector printStringOld				text: ((#ErrorInPage &lt;&lt; #dialogs &gt;&gt; 'Error in page generation: &lt;1s&gt;')			expandMacrosWith: ex description)]</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison" selector="attributesSingularRow">attributesSingularRow	^self singularBlueprint attributes isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self						annotateIconWithDisposition: ComparisonIcons modifyClassAttributes)				name: 'Attributes'				text: self singularBlueprint attributes printStringOld]</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="detailHintGraphics">detailHintGraphics	| icons addedMethodCount changedMethodCount removedMethodCount changedCategoryCount changedPackageCount |	icons := super detailHintGraphics.	addedMethodCount := changedMethodCount := removedMethodCount := changedCategoryCount := changedPackageCount := 0.	self		enumerateOrderedMethodAdditions: [addedMethodCount := addedMethodCount + 1]		removals: [removedMethodCount := removedMethodCount + 1]		changes: 			[:a :b |			a source = b source				ifFalse: [changedMethodCount := changedMethodCount + 1].			a category = b category				ifFalse: [changedCategoryCount := changedCategoryCount + 1].			a packageName = b packageName				ifFalse: [changedPackageCount := changedPackageCount + 1]].	changedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons modify						with: (Label with: '' , changedMethodCount printStringOld))].	changedPackageCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons movePackage						with: (Label with: '' , changedPackageCount printStringOld))].	changedCategoryCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons moveCategory						with: (Label with: '' , changedCategoryCount printStringOld))].	addedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons add						with: (Label with: '' , addedMethodCount printStringOld))].	removedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons remove						with: (Label with: '' , removedMethodCount printStringOld))].	^icons</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison" selector="attributesComparisonRow">attributesComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyClassAttributes		name: 'Attributes'		leftText: leftBlueprint attributes printStringOld		rightText: rightBlueprint attributes printStringOld</body></methods><methods><class-id>Tools.PrimitiveObjectInspector</class-id> <category>field list</category><body package="Tools-Inspector" selector="fieldList">fieldList	"Answer an Array consisting of 'self' and the instance variable 	names of the inspected object. Up to 40 indices are given for 	variable length objects."	| max |	max := self _objectSize: object.	^((Array with: 'self') ,		(self _objectClass: object) allInstVarNames,		(((showAllFields or: [max &lt;= DefaultNumberOfFields])			ifTrue: [1 to: max]			ifFalse: [(1 to: 30) , (max - 10 to: max)])				collect: [:i | i printStringOld]))</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>grid actions</category><body package="UIPainter" selector="gridSizeDialog">gridSizeDialog	| sz szInt |	sz := SimpleDialog new		request: (#GridSize &lt;&lt; #UIPainter &gt;&gt; 'Grid Size?')		initialAnswer: controller gridStep value printStringOld		onCancel: [^self]		for: builder window.	szInt := Integer readFromString: sz.	szInt &lt; 1	ifTrue: [ Dialog warn: (#GenKey140 &lt;&lt; #UIPainter &gt;&gt; 'The grid size must be greater than 0.') for: builder window ]	ifFalse: [ controller gridStep value: szInt ]</body></methods><methods><class-id>Tools.CommandBindingsEditor.BindingEditor</class-id> <category>actions</category><body package="Tools-Settings-Commands" selector="temporaryFilenameWithPrefix:suffix:">temporaryFilenameWithPrefix: prefix suffix: suffix	"TODO: replace this with a core supported temporary filename facility"	"I copied this from WebVelocity. SUnit tools does something similar"	| dirname filename |	"Presume this is ok for all unices"	dirname := '/tmp'.	('*win*' match: OSHandle platformMoniker)		ifTrue: [ dirname := SystemUtils getEnvironmentVariable: 'TEMP' ifAbsent: [ SystemUtils getEnvironmentVariable: 'TMP' ifAbsent: [ 'c:\temp\' ] ] ].	('*mac*' match: OSHandle platformMoniker)		ifTrue: [ dirname := SystemUtils getEnvironmentVariable: 'TMPDIR' ifAbsent: [ '/tmp' ] ].	dirname := dirname asFilename.	(dirname definitelyExists and: [ dirname isDirectory ])		ifFalse: [ ^nil ].	filename := dirname / (prefix , '-' , Time microsecondClock printStringOld , '-' , suffix).	^filename asAbsoluteFilename</body></methods><methods><class-id>Tools.SequenceableCollectionInspector</class-id> <category>field list</category><body package="Tools-Inspector" selector="fieldList">fieldList	^(Array with: 'self') , ((1 to: object size) collect: [:i | i printStringOld])</body></methods><methods><class-id>Tools.SequenceableCollectionInspector class</class-id> <category>view creation</category><body package="Tools-Inspector" selector="openOn:">openOn: anObject	"If anObject size is very large, then ask the user whether to open	the inspector, or open a simple inspector (that only shows 'self')	or abort."	| whatToDo |	anObject size &gt; 500		ifFalse: [^self open: (self inspect: anObject)].	whatToDo :=  Dialog						choose: ((#InspectedObjectIsHuge &lt;&lt; #dialogs &gt;&gt; 'The object you want to inspect is large, &lt;1s&gt; elements.')			expandMacrosWith: anObject size printStringOld)						labels: (Array with: (#showAllFields &lt;&lt; #dialogs &gt;&gt; 'show all fields') with: (#showSomeFields &lt;&lt; #dialogs &gt;&gt; 'show some fields'))						values: #(#full #simple)						default: #simple.	whatToDo == #simple		ifTrue: [^Inspector openOn: anObject].	^self open: (self inspect: anObject)</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="finishFetchExpressionForTopDetail:on:">finishFetchExpressionForTopDetail: detailSlot on: aStream	| spec |	(spec := detailSlot value) sourceType == #query		ifTrue:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]']]		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printStringOld;						nextPutAll: ') value']				ifFalse:					[aStream nextPutAll: 'Array new']]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="writeAutoOpenMethod:on:">writeAutoOpenMethod: autoOpenSlots on: aStream		aStream		cr; cr;		nextPutAll: 'autoOpenChildren';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."'; cr.	autoOpenSlots isEmpty		ifFalse:			[autoOpenSlots				do:					[:assn |					| spec cnv |					aStream						cr; tab;						nextPutAll: 'self openChild: self ';						nextPutAll: (spec := assn value) clientKey;						nextPutAll: ' with: ';						nextPutAll:							((cnv := spec minorKey) isNil								ifTrue: ['#windowSpec']								ifFalse: [cnv printStringOld]);						nextPut: $.]].	aStream cr; tab; nextPutAll: 'super autoOpenChildren'.	aStream nextPut: $!</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="writeSynchronizeMethod:on:">writeSynchronizeMethod: synchroSlots on: aStream	aStream		cr; cr;		nextPutAll: 'synchronize: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."'; cr.	synchroSlots isEmpty		ifTrue:			[aStream cr; tab; nextPutAll: '^self']		ifFalse:			[synchroSlots do:				[:slt |				| spec |				aStream					cr; tab;					nextPutAll: 'aChild == self ';					nextPutAll: (spec := slt) clientKey;					cr; tab; tab;					nextPutAll: ' ifTrue:';					cr; tab; tab; tab;					nextPutAll: '[self row '.				spec fetchAction isNil					ifTrue:						[aStream							nextPutAll: 'compute:';							cr; tab; tab; tab; tab;							nextPutAll: '[:v |';							cr; tab; tab; tab; tab.						self fetchExpressionForClientDetail: slt on: aStream.						aStream							nextPut:$];							cr; tab;tab;tab;							nextPutAll: 'for: aChild']					ifFalse:						[aStream							nextPutAll: 'onChangeSend: ';							nextPutAll: spec fetchAction printStringOld;							nextPutAll: ' to: self for: aChild'].				aStream nextPutAll: '].']].	aStream nextPut: $!</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="initStringForClientDetail:on:">initStringForClientDetail: detailSlot on: aStream	| spec |	aStream		nextPutAll: (spec := detailSlot value) majorKey asString;		space;		nextPutAll: 'new'.	spec lockPolicy ~~ #current		ifTrue:			[aStream				cr; tab; tab; tab; tab;				nextPutAll: 'lockPolicy: ';				nextPutAll: spec lockPolicy printStringOld; nextPut: $;;				cr; tab; tab; tab; tab;				nextPutAll: 'yourself']</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="writeFontLoadingMethod:">writeFontLoadingMethod: aString	| codeStream |	codeStream := String new writeStream.	self writePrivateMethodHeaderOn: codeStream.	codeStream 		nextPutAll: 'loadNamedFonts';		cr; tab;		nextPutAll: '"This method is created by the UIDefiner';		cr; tab;		nextPutAll: 'Any edits made here may be lost whenever named fonts are re-saved"';		cr; cr; tab;		nextPutAll: 'self loadNamedFontsFromFile: ';		nextPutAll: aString printStringOld;		nextPut: $!.	codeStream contents readStream fileIn.</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="finishFetchExpressionForDataFormDetail:on:">finishFetchExpressionForDataFormDetail: detailSlot on: aStream	| spec |	(spec := detailSlot value) sourceType == #query		ifTrue:			[aStream				nextPutAll: '(self row value isNil';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifTrue: [Array new]';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifFalse: ['.			spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]'].				aStream nextPutAll: '])']		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printStringOld;						nextPutAll: ') value']				ifFalse:					[aStream nextPutAll: 'Array new']]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="writeOpenActions:on:">writeOpenActions: detailSlots on: aStream	"If there is any detailSlot with an openAction defined, add the 	definition of the method to aStream for each such detailSlot"	(detailSlots isEmpty or:			[(detailSlots detect: [:assn |  assn value openAction notNil] ifNone: []) isNil])		ifTrue: [^self].	detailSlots		do:			[:assn |			| cnv spec |			(spec := assn value) openAction notNil				ifTrue:					[aStream						cr; cr;						nextPutAll: spec openAction;						cr; tab;						nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."';						cr; cr; tab;						nextPutAll: 'self openChild: self ';						nextPutAll: spec clientKey;						nextPutAll: ' with: ';						nextPutAll:							((cnv := spec minorKey) isNil								ifTrue: ['#windowSpec']								ifFalse: [cnv printStringOld]);						nextPut: $!]]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="fetchMethodBodyForTopDetail:on:">fetchMethodBodyForTopDetail: detailSlot on: aStream	| spec |	aStream 		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll: ' isNil';		cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: spec clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']);		cr; tab; tab; tab; tab.	(spec := detailSlot value) sourceType == #query		ifTrue:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values])]']				ifFalse:					[aStream						nextPutAll: '(Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values])]']]		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printStringOld;						nextPutAll: ') value]']				ifFalse:					[aStream nextPutAll: 'Array new]']]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="fetchMethodBodyForDataFormDetail:on:">fetchMethodBodyForDataFormDetail: detailSlot on: aStream	| spec |	aStream 		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll: ' isNil';		cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: spec clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']);		cr; tab; tab; tab; tab.	(spec := detailSlot value) sourceType == #query		ifTrue:			[aStream				nextPutAll: '(self row value isNil';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifTrue: [Array new]';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifFalse: ['.			spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]'].				aStream nextPutAll: '])]']		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printStringOld;						nextPutAll: ') value]']				ifFalse:					[aStream nextPutAll: 'Array new]']]</body></methods><methods><class-id>Tools.StateMachineState</class-id> <category>printing</category><body package="Tools-State Machine" selector="printOn:">printOn: aStream	super printOn: aStream.	name ifNotNil: [ aStream nextPut: $(; nextPutAll: name printStringOld; nextPut: $) ].</body></methods><methods><class-id>Tools.Explainer</class-id> <category>private-explaining</category><body package="Tools-Programming" selector="explainNumber:">explainNumber: aString 	"Is the string a Number?"	| stream char number |	(char := aString at: 1) isDigit ifFalse: [(char = $- and: [aString size &gt; 1])			ifFalse: [^nil]].	stream := ReadStream on: aString.	number := Number readFrom: stream.	stream atEnd ifFalse: [^nil].	^self wrapMessage: (number printStringOld = aString		ifTrue: [#explainer1PisA2S &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is a &lt;2s&gt;.' 			expandMacrosWith: number with: number class name]		ifFalse: [#explainer1PequalTo2PIsA3S &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; (= &lt;2p&gt;) is a &lt;3s&gt;.' 			expandMacrosWith: aString with: number with: number class name])</body></methods><methods><class-id>Tools.Explainer</class-id> <category>browsing</category><body package="Tools-Programming" selector="browseBindingReference:">browseBindingReference: aReference	^'Tools.SmalltalkWorkbench browseBindingReference: ', aReference printStringOld</body></methods><methods><class-id>Tools.Explainer</class-id> <category>private-explaining</category><body package="Tools-Programming" selector="explainInstanceVariable:">explainInstanceVariable: aString 	"Is string an instance variable of this class?"	| classes definingClass |	class == nil ifTrue: [^nil].	"no class is selected"	classes := class withAllSuperclasses.	definingClass := classes detect: 					[:each | 					(each instVarNames detect: [:name | name = aString] ifNone: []) notNil]				ifNone: [^nil].	^Array with: 		(self explanationForInstanceVariable: aString definedIn: definingClass) 				-&gt; (self browseInstVar: aString in: definingClass printStringOld)</body></methods><methods><class-id>Tools.DictionaryInspector</class-id> <category>private-menu messages</category><body package="Tools-Inspector" selector="removeField">removeField	(Dialog confirm: ((#ConfirmRemovalOf1s &lt;&lt; #dialogs &gt;&gt; 'Confirm removal of &lt;1s&gt;')			expandMacrosWith: field printStringOld) for: self interfaceWindow) ifFalse: [^self].	object removeKey: field.	field := nil.	self resetFields</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>private</category><body package="Tools-Workspace" selector="makeVariableName:uniqueIn:">makeVariableName: aString uniqueIn: aDictionary	"Accept a string that can be anything and answer another string that can safely be used as a legal Smalltalk variable name. The answer can be the same as the argument if it was OK to begin with. Make sure there is no name clash with keys of aDictionary.  Append 2, 3, and so on to the original name until the clash if resolved. The dictionary keys may be strings or symbols."	| namesTaken baseName name suffix |	namesTaken := (aDictionary keys collect: [:each | each asString]) asSet.	baseName := self makeVariableName: aString.	name := baseName.	suffix := 2.	[namesTaken includes: name] whileTrue:		[name := baseName, suffix printStringOld.		suffix := suffix + 1].	^name</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>private</category><body package="Tools-Workspace" selector="importSummary">importSummary	^importAll		ifTrue: [(#All &lt;&lt; #labels &gt;&gt; 'All') asString]		ifFalse: [specificImports size printStringOld]</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private</category><body package="Tools-Inspector" selector="resetFields">resetFields		| list |	list := self fieldList.	self printItems ifTrue: [list := list collect: [:e | e printStringOld]].	fieldList list: list asList</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private</category><body package="Debugger-Tools-Modifications" selector="resetFieldsForDebugger">resetFieldsForDebugger	| list |	list := self fieldList.	self printItems ifTrue: [list := list collect: [:e | e printStringOld]].	list := list asList.	list = fieldList list		ifTrue: [^self resetText].	fieldList list: list asList</body></methods><methods><class-id>Tools.Inspector</class-id> <category>text</category><body package="Debugger-Tools-Modifications" selector="text">text	"Answer the text displayed by the receiver."	| string |	field == nil ifTrue: [^Text new].	string := [5 seconds				toFinish: [field = 'self'						ifTrue: [self fieldValue inspectString]						ifFalse: [self fieldValue printStringOld]]				orElse: [self basicObjectPrintString: self fieldValue]]				on: Error , BreakInterrupt				do: [:ex | self protectedBasicObjectPrintString: self fieldValue].	^string asText</body></methods><methods><class-id>Tools.Inspector</class-id> <category>field list</category><body package="Tools-Inspector" selector="fieldList">fieldList	"Answer an Array consisting of 'self' and the instance variable 	names of the inspected object. Up to 40 indices are given for 	variable length objects."	| max |	max := object basicSize.	^((Array with: 'self') ,		object class allInstVarNames,		(((showAllFields or: [max &lt;= DefaultNumberOfFields])			ifTrue: [1 to: max]			ifFalse: [(1 to: 30) , (max - 10 to: max)])				collect: [:i | i printStringOld]))</body></methods><methods><class-id>Tools.GeneralMethodDefinition</class-id> <category>comparing</category><body package="Tools-Programming" selector="&lt;">&lt; anObject	"Answer whether the receiver is less than the argument.	 Order GeneralMethodDefinitions by inheriting class name, nonMeta/meta and selector."	| n1 n2 sel |	n1 := self objectName.	n2 := anObject objectName.	^n1 = n2		ifTrue:			[(self selector isString					ifTrue: [self selector]					ifFalse: [self selector printStringOld])				&lt; ((sel := anObject selector) isString						ifTrue: [sel]						ifFalse: [sel printStringOld])]		ifFalse: [n1 &lt; n2]</body></methods><methods><class-id>Tools.Trippy.Part</class-id> <category>accessing</category><body package="Tools-Trippy" selector="text">text	^[self value printStringOld] toolSafeIn: 2 seconds		else: 			[:ex |			#ErrorPrintingObject &lt;&lt; #dialogs &gt;&gt; '[Error printing the object: &lt;1s&gt;]'				expandMacrosWith: ex description]</body></methods><methods><class-id>Tools.Trippy.KeyedElement</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^key isString		ifTrue: [key]		ifFalse: [key isSymbol			ifTrue: [key asString]			ifFalse: [key isInteger				ifTrue: ['at', key printStringOld]				ifFalse: [(Inspector safeDisplayStringOf: key) copyWithout: Character space]]]</body></methods><methods><class-id>Tools.Trippy.KeyedElement</class-id> <category>accessing</category><body package="Tools-Trippy" selector="partName">partName	^key printStringOld</body></methods><methods><class-id>Tools.Trippy.CStructureTypeInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="members">members	| type memberParts |	type := object type.	type isPointer ifTrue: 		[type := type referentType].	memberParts := OrderedCollection new. 	type baseType keysAndValuesDo: 		[:name :assoc |		memberParts add: (TextAttribute 			label: name 			text: ('Type: &lt;1s&gt; offset: &lt;2s&gt;'			expandMacrosWith: assoc value printStringOld			with: assoc key printStringOld))].	^memberParts</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>private</category><body package="Tools-Trippy" selector="formattedResultOf:">formattedResultOf: aBlock	| result |	result := aBlock		on: Error		do: [:ex | ^(#errorC1s &lt;&lt; #dialogs &gt;&gt; '[error: &lt;1s&gt;]') expandMacrosWith: ex description].	^result printStringOld asText allBold</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>private-menus</category><body package="Tools-Trippy" selector="buildHistorySubmenu">buildHistorySubmenu	| menu item |	menu := Menu new.	trail keysAndValuesDo:		[:index :navigator | | label |		label := index &lt; 10			ifTrue: ['&amp;', index printStringOld, '. ', navigator visit displayString]			ifFalse: [navigator visit displayString].		item := MenuItem labeled: label.		item value: [self goTo: index].		index = current ifTrue: [item beOn].		menu addItem: item].	^menu</body></methods><methods><class-id>Tools.Trippy.IndexedVariable</class-id> <category>accessing</category><body package="Tools-Trippy" selector="partName">partName	^index printStringOld</body></methods><methods><class-id>Tools.Trippy.IndexedVariable</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^'at', index printStringOld</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="sendAndDive">sendAndDive	"Send the message and dive into the result."	| selector result |	selector := self selectedMethod selector.	selector numArgs ~= 0 ifTrue: [^self].	result := self doItReceiver perform: selector.	self container diveInto: 		(DerivedAttribute 			label: ((#x1sCSent2s &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;: sent &lt;2s&gt;')				expandMacrosWith: Time now printStringOld				with: selector printStringOld)			value: result)</body></methods><methods><class-id>Tools.Trippy.Inspector class</class-id> <category>utilities-printing</category><body package="Tools-Trippy" selector="safePrintStringOf:">safePrintStringOf: anObject	^[anObject printStringOld]		on: self safePrintingErrors		do:			[:ex | 			ex				return:					(#ErrorPrintingObject &lt;&lt; #dialogs &gt;&gt; '[Error printing the object: &lt;1s&gt;]'						expandMacrosWith: ex description)]</body></methods><methods><class-id>Tools.Trippy.Inspector class</class-id> <category>utilities-printing</category><body package="Tools-Trippy" selector="safeLabelStringOf:">safeLabelStringOf: anObject	"Answer a string representation of anObject short enough and line break-free,	for use in contexts such as a list view. Unlike safeDisplayString, favor the	programmer perspective (that is, printString) and try hard to give a useful	answer by falling back to basic print string if printString fails."	^[ | string |	string := anObject printStringOld.	(string size &gt; 40 or: [string trimBlanks isEmpty or: [(string includes: Character cr) or: [string includes: Character lf]]])		ifTrue: [anObject basicPrintString]		ifFalse: [string]	]		on: Error, BreakInterrupt		do: [:ex | ex return: (self safeBasicPrintStringOf: anObject)]</body></methods><methods><class-id>Tools.NotifierView class</class-id> <category>private</category><body package="Tools-Programming" selector="shortStackFor:ofSize:">shortStackFor: aContext ofSize: anInteger	"Answer a string with the simple descriptions of anInteger number of	non-nil stackframes starting with aContext"	| shortStackStream ctx |	shortStackStream := WriteStream on: (String new: 400).	ctx := aContext.	anInteger timesRepeat: 		[ctx isNil ifFalse:			[shortStackStream nextPutAll: (ctx printStringOld contractTo: 50); cr.			ctx := ctx sender]].	shortStackStream position &gt; 0 ifTrue: [shortStackStream skip: -1].	^shortStackStream contents</body></methods><methods><class-id>Tools.NumberSetting</class-id> <category>accessing</category><body package="Tools-Settings" selector="toXML:">toXML: anObject	self validate: anObject.	^Element		tag: self xmlTag		elements: (Array with: (XML.Text text: anObject printStringOld))</body></methods><methods><class-id>Tools.Workbook</class-id> <category>private</category><body package="Tools-Workspace" selector="pickUniquePageLabel">pickUniquePageLabel	| labels suffix label |	labels := self pages collect: [:each | each displayString].	suffix := 1.	[label := ((#Page1s &lt;&lt; #dialogs &gt;&gt; 'Page &lt;1s&gt;')			expandMacrosWith: suffix printStringOld).	labels includes: label] 		whileTrue: [suffix := suffix + 1].	^label</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>private</category><body package="UIPainter" selector="edittedSelector">edittedSelector	| mi menuButton |	mi := ((self builder menuAt: #sliceMenu) value menuItemWithValue: currentSlice ifNone: nil).	mi isNil ifTrue: [^self].	mi label: currentSlice selector printStringOld.	menuButton := (self builder componentAt: #sliceMenu) widget.	menuButton setLabel: menuButton currentChoice.	menuButton invalidate.	hotRegions regionsSelectors at: currentSlice index put: currentSlice selector</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>private</category><body package="UIPainter" selector="menuFromSlicesList">menuFromSlicesList	| mb |	mb := MenuBuilder new.	slicesList do: [ :slice |		mb add: slice selector printStringOld -&gt; slice	]. 	^mb menu</body></methods><methods><class-id>Tools.MethodFilterReference</class-id> <category>printing</category><body package="Tools-Programming" selector="valueString">valueString	^value isSymbol		ifTrue: [value printStringOld]		ifFalse: [value displayString]</body></methods><methods><class-id>External.CScalarType</class-id> <category>printing</category><body package="External-Types" selector="printOn:forName:indent:">printOn: aStream forName: varName indent: numTabs	aStream nextPutAll:		(printName isString			ifTrue: [printName]			ifFalse: [self class printStringOld, '?']).	self printName: varName on: aStream wrap: false</body></methods><methods><class-id>External.ExternalInterface</class-id> <category>accessing</category><body package="External-Interface" selector="externalAccessFailedWith:">externalAccessFailedWith: errorCode	"Raise the signal that indicates something went wrong with an external access	 -- use the receiver as the signal's parameter."	| errorString |	errorCode isError		ifTrue:			[				errorCode name == #'io error' ifTrue: [^errorCode handleErrorFor: self].				errorString := errorCode parameter == nil					ifTrue: [errorCode name]					ifFalse: [errorCode name, ' ', errorCode parameter printStringOld]			].	^self externalAccessFailedSignal		raiseRequestWith: self		errorString: errorString</body></methods><methods><class-id>External.CMacroDefinition</class-id> <category>printing</category><body package="External-Types" selector="printOn:">printOn: aStream	"Print a representation of the receiver onto the argument."	super printOn: aStream.	aStream		space;		nextPutAll: (name isString ifTrue: [name] ifFalse: [name printStringOld]);		nextPutAll: ' &lt;'.	self printValueOn: aStream.	aStream nextPut: $&gt;</body></methods><methods><class-id>Refactory.CodeHighlighter.BlockVariables</class-id> <category>variables</category><body package="RBCodeHighlighting" selector="variable:argument:">variable: aVariable argument: formatCode	"Answer a suitable structure for the variable and format code."	^formatCode -&gt; (aVariable , '.arg.' , id printStringOld)</body></methods><methods><class-id>Refactory.CodeHighlighter.BlockVariables</class-id> <category>variables</category><body package="RBCodeHighlighting" selector="variable:temporary:">variable: aVariable temporary: formatCode	"Answer a suitable structure for the variable and format code."	^formatCode -&gt; (aVariable , '.tmp.' , id printStringOld)</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper class</class-id> <category>private</category><body package="Method Wrapper Base" selector="codeStringFor:">codeStringFor: numArgs 	| nameString tempsString |	nameString := 'value'.	tempsString := numArgs == 0 				ifTrue: ['t := #()']				ifFalse: ['(t := #Array new: ' , numArgs printStringOld , ') '].	1 to: numArgs		do: 			[:i | 			nameString := nameString , 'value: t' , i printStringOld , ' '.			tempsString := tempsString , (i == 1 ifTrue: [''] ifFalse: [';']) 						, ' at: ' , i printStringOld 						, ' put: t' , i printStringOld].	^nameString , '	| t |	' , tempsString , '.	^' 		, self methodWrapperSymbol printStringOld 			, ' valueWithReceiver: self arguments: t'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>printing</category><body package="SmaCC Runtime" selector="printOn:">printOn: aStream	aStream		nextPut: ${;		nextPutAll: self value;		nextPut: $(;		nextPutAll: self startPosition printStringOld;		nextPut: $,;		nextPutAll: self stopPosition printStringOld;		nextPut: $,;		nextPutAll: self ids printStringOld;		nextPutAll: ')}'</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#RenameProtocol1sTo2sIn3s &lt;&lt; #browser &gt;&gt; 'Rename protocol, &lt;1s&gt;, to &lt;2s&gt; in &lt;3s&gt;')			expandMacrosWith: self protocol			with: self newProtocol			with: self protocolObject printStringOld)</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="primitiveExecute">primitiveExecute	(self protocolObject renameCategory: self protocol		to: self newProtocol) 			ifTrue: 				[self 					logProtocolChange: self protocolObject printStringOld 							, ' organization renameCategory: ' , self protocol printStringOld 							, ' to: ' , self newProtocol printStringOld].	isUndo ifTrue: [self resetToPriorState]</body></methods><methods><class-id>Refactory.Browser.RBMethod</class-id> <category>testing</category><body package="Browser-Refactorings" selector="refersToSymbol:">refersToSymbol: aSymbol 	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: aSymbol printStringOld do: [:node :answer | true];		matches: '`#literal'			do: [:node :answer | answer or: [self literal: node value containsReferenceTo: aSymbol]].	(RBScanner isSelector: aSymbol) 		ifTrue: 			[searcher 				matches: '`@object ' , (ParseTreeSearcher buildSelectorString: aSymbol)				do: [:node :answer | true]].	^searcher executeTree: self parseTree initialAnswer: false</body></methods><methods><class-id>Refactory.Browser.InlineMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="renameConflictingTemporary:">renameConflictingTemporary: aName 	| allNames newName index seqNode |	allNames := (Set new)				addAll: inlineParseTree allDefinedVariables;				yourself.	allNames remove: aName ifAbsent: [].	seqNode := sourceMessage.	[seqNode isSequence] whileFalse: [seqNode := seqNode parent].	allNames addAll: seqNode allDefinedVariables.	"Add those variables defined in blocks. This might cause a few 													variables to be renamed that don't need to be, but this should be safe."	newName := aName.	index := 0.		[(sourceMessage whoDefines: newName) notNil or: 			[(class hierarchyDefinesVariable: newName) or: [allNames includes: newName]]] 			whileTrue: 				[index := index + 1.				newName := aName , index printStringOld].	newName = aName ifFalse: [self renameTemporary: aName to: newName].	^newName</body></methods><methods><class-id>Refactory.Browser.CodeComponentInspectorField</class-id> <category>accessing</category><body package="Browser-BrowserUI" selector="partName">partName	^key printStringOld</body></methods><methods><class-id>Refactory.Browser.PrimitiveIndexGlobCriterion</class-id> <category>testing</category><body package="RBPrimitivesBrowsing" selector="matches:">matches: aPrimitiveIndex	^self pattern match: aPrimitiveIndex printStringOld</body></methods><methods><class-id>Refactory.Browser.RBSharedVariable</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="definitionString">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineSharedVariable: #';		nextPutAll: self name;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: isPrivate printStringOld;		cr;		tab;		nextPutAll: 'constant: ';		nextPutAll: constant printStringOld;		cr;		tab;		nextPutAll: 'category: ';		nextPutAll: self category asString printStringOld;		cr;		tab;		nextPutAll: 'initializer: '.	initializer isNil 		ifTrue: [definitionStream nextPutAll: 'nil']		ifFalse: [definitionStream nextPutAll: initializer asString printStringOld].	^definitionStream contents</body></methods><methods><class-id>Refactory.Browser.RemoveProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#GenKey5 &lt;&lt; #browser &gt;&gt; 'Remove protocol, &lt;1s&gt;, from &lt;2s&gt;')			expandMacrosWith: self protocol			with: self protocolObject printStringOld)</body></methods><methods><class-id>Refactory.Browser.RemoveProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="primitiveExecute">primitiveExecute	self protocolObject organization removeCategory: self protocol.	self 		logProtocolChange: self protocolObject printStringOld 				, ' organization removeCategory: ' 					, self protocol storeString.	self protocolObject reorganize</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="referencesTo:in:">referencesTo: aLiteral in: anEnvironment 	| classDict literalPrintString specialIndex variables |	literalPrintString := aLiteral isVariableBinding 				ifTrue: [aLiteral key asString]				ifFalse: 					[aLiteral isString ifTrue: [aLiteral] ifFalse: [aLiteral printStringOld]].	specialIndex := CompiledCode specialSelectorIndexFor: aLiteral.	classDict := Dictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := (class whichSelectorsReferTo: aLiteral) 						select: [:aSelector | anEnvironment includesSelector: aSelector in: class].			selectors notEmpty ifTrue: [classDict at: class put: selectors]].	variables := OrderedCollection new.	anEnvironment sharedVariableReferencesDo: 			[:each | 			| binding init method |			binding := each bindingOrNil.			binding notNil 				ifTrue: 					[init := binding initializer.					init notNil 						ifTrue: 							[method := init method.							((method refersToLiteral: aLiteral) or: 									[(specialIndex &gt; 0 and: [method sendsSpecialSelector: specialIndex]) 										or: [method refersToSpecialLiteral: aLiteral]]) 								ifTrue: [variables add: each]]]].	^(self onEnvironment: anEnvironment)		on: classDict;		initializers: variables;		label: ((#ReferencesTo1s &lt;&lt; #browser &gt;&gt; 'References to: &lt;1s&gt;')			expandMacrosWith: literalPrintString);		searchStrings: (Array with: literalPrintString);		yourself</body></methods><methods><class-id>Refactory.Browser.AbstractRefactoringBrowser</class-id> <category>menu</category><body package="Browser-BrowserUI" selector="bufferMenuSpecifications">bufferMenuSpecifications	^(1 to: (self toolsets size min: 9))		collect:			[:i | 			(self currentToolset == (self toolsets at: i)				ifTrue: [RBCheckedCommand]				ifFalse: [RBCommand])				named:					(self						menuNameFor:							('&amp;&lt;1s&gt; &lt;2s&gt;'								expandMacrosWith: i printStringOld								with: (self toolsets at: i) printStringOld))				description: #SelectBuffer &lt;&lt; #browser &gt;&gt; 'Select Buffer'				action: [self switchToBuffer: i]				receiver: #yourself]</body></methods><methods><class-id>Refactory.Browser.MethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="safeVariableNameFor:temporaries:basedOn:">safeVariableNameFor: aClass temporaries: allTempVars basedOn: aString	| baseString i newString |	newString := baseString := aString.	i := 0.		[(allTempVars includes: newString) 		or: [aClass definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printStringOld].	^newString</body></methods><methods><class-id>Refactory.Browser.MethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="buildSelectorString:withPermuteMap:">buildSelectorString: aSelector withPermuteMap: anIntegerCollection 	| stream keywords |	aSelector numArgs == 0 ifTrue: [^aSelector asString].	stream := WriteStream on: String new.	keywords := aSelector keywords.	keywords with: anIntegerCollection		do: 			[:each :i | 			stream				nextPutAll: each;				nextPutAll: ' ``@arg';				nextPutAll: i printStringOld;				nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private-selector</category><body package="Browser-BrowserUI" selector="addParameterTo:in:">addParameterTo: aSelector in: aClass		| initializer newSelector newArgument tree args dialog newArgs map argRoot argSuffix candidateSelector |	tree := aClass parseTreeFor: aSelector.	tree		ifNil:			[^self				warn: #CouldNotParseTheMethod &lt;&lt; #IDE &gt;&gt; 'Could not parse the method'].	argRoot := 'anObject'.	argSuffix := 0.	[newArgument := argRoot		,			(argSuffix isZero				ifTrue: ['']				ifFalse: [argSuffix printStringOld]).	tree allDefinedVariables includes: newArgument]		whileTrue: [argSuffix := argSuffix + 1].	args := tree argumentNames copyWith: newArgument.	candidateSelector := (aSelector numArgs == 0		ifTrue: [aSelector , ':']		ifFalse: [aSelector]) asSymbol.	dialog := (MethodNameAndInitialValueDialog new)		arguments: args;		selector: candidateSelector;		initialValue: 'nil'.	dialog open ifFalse: [^nil].	initializer := dialog initialValue.	newSelector := dialog selector.	newArgs := dialog arguments asOrderedCollection.	map := (1 to: args size) collect: [:i | args indexOf: (newArgs at: i)].	^self		handleError:			[self				performRefactoring:					(AddParameterRefactoring addParameterToMethod: aSelector in: aClass						newSelector: newSelector initializer: initializer newArgName:							newArgument permutation: map).			newSelector]</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>removal-methods</category><body package="Browser-BrowserUI" selector="validateMethodRemovalChange:">validateMethodRemovalChange: aCompositeChange	"Determine if any of the method removals have senders else where in the system. If they do, have a dialog with the user about what to do about it (cancel, proceed, or browse them), return true/false based on whether the change should be allowed to proceed."	"First step is to extract the removals (there may be override adjustments in there too), and then build a map of removals to reference environments."	| ws definitionPrintSelector removals referenceEnvironments filteredDefinitions |	removals := aCompositeChange changes				select: [:each | each isKindOf: RemoveMethodChange].	referenceEnvironments := Dictionary new.	self showWaitCursorWhile: 			[removals do: 					[:each |					each methodDefinition hasSuperImplementor						ifFalse: 							[referenceEnvironments at: each selector								ifAbsentPut: [each referenceEnvironment]]]].	"Filter out any cases where the only reference is self referential (i.e. a recursive method)"	referenceEnvironments := referenceEnvironments reject: 					[:each |					each isEmpty or: 							[each numberSelectors = 1 and: 									[each methodDefinitions any selector										= (referenceEnvironments keyAtIdentityValue: each)]]].	referenceEnvironments isEmpty ifTrue: [^true].	ws := String new writeStream.	ws		nextPutAll: (#MethodRemovalsReferencedElsewhereC &lt;&lt; #browser					&gt;&gt; 'Some of the methods to be removed are referenced elsewhere in the system:')						asString;		cr.	"Determine how rich to print the method definitions of the removal. If they're all in the same class (usually the case), then contextually, just printing the selector is enough."	filteredDefinitions := (removals collect: #methodDefinition)				select: [:each | referenceEnvironments includesKey: each selector].	definitionPrintSelector := (filteredDefinitions				collect: #implementingClass) size				= 1 ifTrue: [#selector] ifFalse: [#printStringOld].	self showWaitCursorWhile: 			[filteredDefinitions asSortedCollection do: 					[:each |					ws						cr;						tab;						nextPutAll: (each perform: definitionPrintSelector);						nextPutAll: ' -- ';						nextPutAll: ((referenceEnvironments at: each selector)									dispositionToMethodRemoval: each) asString]].	^self confirmRemoval: ws contents references: referenceEnvironments</body></methods><methods><class-id>Refactory.Browser.BundleStructureView</class-id> <category>view construction</category><body package="Browser-BrowserUI" selector="addSubcomponentRows:">addSubcomponentRows: aCodeComponentSequence	| clicker maxWidth sampleLabels labelHeight index |	aCodeComponentSequence isEmpty ifTrue: [^self].	sampleLabels := (0 to: 9) collect: [:n | Label with: n printStringOld].	maxWidth := ((sampleLabels collect: #width) fold: [:a :b | a max: b])				* (self bundleItems size log truncated + 1).	labelHeight := sampleLabels first height.	aCodeComponentSequence do: 			[:eachSubcomponent |			| row indexGraphic |			index := self nextListIndex.			row := Panel new beRow: 0.5 gap: 5.			row propertyAt: #subcomponent put: eachSubcomponent.			row propertyAt: #index put: index.			row add: (PixelSpace width: 3).			indexGraphic := VisualBlock block: 							[:gc :box |							| label |							label := Label with: (row propertyAt: #index) printStringOld.							label displayOn: gc at: (box width - label width) @ 0]						extent: maxWidth @ labelHeight.			row add: indexGraphic.			row add: eachSubcomponent toolListIcon.			row add: (Label with: eachSubcomponent name).			clicker := self clickerToRemove: eachSubcomponent.			row add: clicker.			row add: (PixelSpace width: 3).			self add: row].	self scrollBy: self children size * self lineGrid</body></methods><methods><class-id>Refactory.Browser.RemoveOverrideChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#RemoveOverrideFor1s &lt;&lt; #browser &gt;&gt; 'Remove Override for &lt;1s&gt;')			expandMacrosWith: override printStringOld)</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher class</class-id> <category>private</category><body package="Browser-Parser" selector="buildSelectorString:">buildSelectorString: aSelector 	| stream keywords |	aSelector numArgs = 0 ifTrue: [^aSelector].	stream := WriteStream on: String new.	keywords := aSelector keywords.	1 to: keywords size		do: 			[:i | 			stream				nextPutAll: (keywords at: i);				nextPutAll: ' ``@arg';				nextPutAll: i printStringOld;				nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.MethodCallAnalysis</class-id> <category>private</category><body package="RBDynamicRefactorings" selector="warnOfUnwrappables:">warnOfUnwrappables: classes	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'It is forbidden to install a wrapper on method #';		nextPutAll: selector;		nextPutAll: ' in the following classes:';		cr.	classes do: [:each | stream tab; nextPutAll: each printStringOld; cr].	stream		nextPutAll: 'If none of the above are called by code that also calls the #' , selector , ' implementor(s) that you intend'; cr;		nextPutAll: 'to rename, then it is safe to proceed.  Otherwise abort, or check the result of applying the refactorings.'.	self refactoringWarning: stream contents.</body></methods><methods><class-id>Refactory.Browser.MethodCallAnalysis</class-id> <category>private</category><body package="RBDynamicRefactorings" selector="warnOfPolymorphs:">warnOfPolymorphs: classes	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'I must also rename implementors of #';		nextPutAll: selector;		nextPutAll: ' in the following classes:'; cr.	classes do: [:each | stream tab; nextPutAll: each printStringOld; cr].	stream		nextPutAll: 'since they share call sites with the one(s) you wish to rename.'.	self refactoringWarning: stream contents.</body></methods><methods><class-id>Refactory.Browser.AddOverrideChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#AddOverrideFor1s &lt;&lt; #browser &gt;&gt; 'Add Override for &lt;1s&gt;')			expandMacrosWith: override printStringOld)</body></methods><methods><class-id>Refactory.Browser.BrowserTextTool</class-id> <category>compiling methods</category><body package="Browser-BrowserUI" selector="compileMethodText:from:">compileMethodText: aText from: aController	| basicChange targetClass adjustedChange textToCompile |	(targetClass := self compileIntoClass) ifNil: [^self].	textToCompile := aText.	basicChange := AddMethodChange				compile: textToCompile				in: targetClass				classified: self protocol				for: aController.	basicChange inheritProtocol.	adjustedChange := self changeWithPackageAndParcelInformation: basicChange.	adjustedChange ifNil: [^self].	_.BrowserCodeTool.SaveAutoFormat == true		ifTrue: ["If we go down this path, we have to compile it up front to give the interactive handler a chance to change the text in the controller, and then use the editor's latest text"			targetClass compilerClass new				compile: textToCompile				in: nil				allowReceiver: true				class: targetClass				environment: basicChange environment				noPattern: false				notifying: aController				ifFail: [^self].			[basicChange				source: (RBParser parseMethod: aController text) printStringOld]				on: Error				do: [:ex | ]].	self performChange: adjustedChange.	basicChange definedSelector		ifNotNil: [:selector | codeModel setSelector: selector]</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="pushUp:">pushUp: aSelector 	| refactoring source |	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: (class parseTreeFor: aSelector)				fromClass: class				toClasses: (Array with: class superclass).	self performComponentRefactoring: refactoring.	source := refactoring parseTree = (class parseTreeFor: aSelector) 				ifTrue: [class sourceCodeFor: aSelector]				ifFalse: [refactoring parseTree printStringOld].	class superclass compile: source		withAttributesFrom: (class methodFor: aSelector)</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="copyDownMethod:">copyDownMethod: aSelector 	| oldSource superclassDefiner subclasses refactoring |	superclassDefiner := class superclass whoDefinesMethod: aSelector.	superclassDefiner isNil ifTrue: [^self].	oldSource := superclassDefiner sourceCodeFor: aSelector.	oldSource isNil 		ifTrue: 			[self 				refactoringError: ((#SourceFor1sSuperNA &lt;&lt; #browser &gt;&gt; 'Source code for &lt;1s&gt; superclass method not available') 						expandMacrosWith: aSelector)].	subclasses := class superclass subclasses 				reject: [:each | each directlyDefinesMethod: aSelector].	subclasses isEmpty ifTrue: [^self].	((superclassDefiner parseTreeFor: aSelector) superMessages 		anySatisfy: [:each | superclassDefiner directlyDefinesMethod: each]) 			ifTrue: 				[self 					refactoringError: ((#CannotPushUp1sMustCopyDownAndSuperOverridden &lt;&lt; #browser &gt;&gt; 'Cannot push up &lt;1s&gt; since we must copy down the superclass method in &lt;2p&gt;&lt;n&gt;to the other subclasses, and the superclass method sends a super message which is overridden.') 							expandMacrosWith: aSelector							with: superclassDefiner)].	self 		refactoringWarning: ((#CopyDownSuperMethod1s &lt;&lt; #browser &gt;&gt; 'Do you want to copy down the superclass method to the classes that don''t define &lt;1s&gt;')			expandMacrosWith: aSelector).	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: (superclassDefiner parseTreeFor: aSelector)				fromClass: superclassDefiner				toClasses: subclasses.	self performComponentRefactoring: refactoring.	subclasses do: 			[:each | 			each compile: refactoring parseTree printStringOld				withAttributesFrom: (superclassDefiner methodFor: aSelector)]</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChangeInspector</class-id> <category>changing</category><body package="Browser-RefactoringUI" selector="changedChange">changedChange	| selectedChange changeText originalText originalFragments changeFragments |	selectedChange := self changeTree selection.	self dialogEnable: #executeAllButton.	selectedChange isNil		ifTrue: 			[changeDescription value: '' asText.			originalCode value: '' asText.			self disableMenu: self changesMenu except: #('Execute All').			^self].	changeText := selectedChange printStringOld asText.	originalText := self originalCodeForChange asText.	originalFragments := originalText smalltalkOrWordAndWhitespaceFragments.	changeFragments := changeText smalltalkOrWordAndWhitespaceFragments.	(originalFragments differences: changeFragments)		do: #applyAnyDifferenceTextEmphases.	changeDescription value: changeText.	originalCode value: originalText.	self enableMenu: self changesMenu except: #('Accept' 'Cancel')</body></methods><methods><class-id>Refactory.Browser.RefactoringBrowser</class-id> <category>actions</category><body package="Browser-BrowserUI" selector="setUndoCount">setUndoCount	"Don't like the isKindOf:, but don't have a portable way to determine if something is a number."	| undoString undoTree |	undoString := self request: (#EnterUndoStackSizeC &lt;&lt; #browser &gt;&gt; 'Enter undo stack size:')				initialAnswer: RefactoryChangeManager undoSize printStringOld.	undoString isEmpty ifTrue: [^self].	undoTree := RBParser parseExpression: undoString				onError: [:str :pos | ^self].	(undoTree isLiteralNode and: [undoTree value respondsToArithmetic]) 		ifFalse: [^self].	RefactoryChangeManager undoSize: undoTree value asInteger</body></methods><methods><class-id>Refactory.Browser.CodeToolSelectionPolicy class</class-id> <category>conversion support</category><body package="Browser-BrowserUI" selector="generateTabNameMethodSource">generateTabNameMethodSource	^(RBParser parseMethod: (self compiledMethodAt: #name) getSource)		selector: #tabName;		printStringOld</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hasSuperclass:">hasSuperclass: aClass 	^self new 		type: (Array with: #hasSuperclass with: aClass)		block: [aClass superclass isNil not]		errorString: ((#x1sHasQnoQsuperclass &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; has %&lt;1?a:no%&gt; superclass')			expandMacrosWith: aClass printStringOld)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hierarchyOf:definesVariable:">hierarchyOf: aClass definesVariable: aString 	^self new 		type: (Array 				with: #hierarchyDefinesInstVar				with: aClass				with: aString)		block: [aClass hierarchyDefinesVariable: aString]		errorString: ((#x1sOrSubclassDoesNotDefineVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; or one of its subclasses %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; variable &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="definesSelector:in:">definesSelector: aSelector in: aClass 	^(self new)		type: (Array 					with: #definesSelector					with: aClass					with: aSelector)			block: [aClass directlyDefinesMethod: aSelector]			errorString: ((#x1sQdoesnotdefineQ2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aSelector printStringOld);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="definesInstanceVariable:in:">definesInstanceVariable: aString in: aClass 	^self new 		type: (Array 				with: #definesInstVar				with: aClass				with: aString)		block: [aClass definesInstanceVariable: aString]		errorString: ((#x1sQdefinesQInstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="directlyDefinesInstanceVariable:in:">directlyDefinesInstanceVariable: aString in: aClass 	^(self new)		type: (Array 					with: #directlyDefinesInstanceVariable					with: aClass					with: aString)			block: [aClass directlyDefinesInstanceVariable: aString]			errorString: ((#x1sQdoesnotdirectlydefineQinstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;directly define%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hierarchyOf:canUnderstand:">hierarchyOf: aClass canUnderstand: aSelector 	^(self new)		type: (Array 					with: #hierarchyUnderstandsSelector					with: aClass					with: aSelector)			block: [aClass hierarchyDefinesMethod: aSelector]			errorString: ((#x1sQorsubclassORallsubclassesQdoNotUnderstand2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?or a subclass:and all subclasses do not%&gt; understand%&lt;1?s:%&gt; &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aSelector printStringOld);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hierarchyOf:referencesInstanceVariable:">hierarchyOf: aClass referencesInstanceVariable: aString 	^self new 		type: (Array 				with: #hierarchyReferencesInstVar				with: aClass				with: aString)		block: 			[aClass withAllSubclasses 				anySatisfy: [:each | (each whichSelectorsReferToInstanceVariable: aString) notEmpty]]		errorString: ((#x1sOrSubclassQdoesnotQreferenceInstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; or subclass %&lt;1?:does not %&gt;reference%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="isMetaclass:">isMetaclass: anObject 	^(self new)		type: (Array with: #IsMetaclass with: anObject)			block: [anObject isMeta]			errorString: ((#x1sIsQnotQAMetaclass &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;a metaclass')			expandMacrosWith: anObject printStringOld);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="isImmediateSubclass:of:">isImmediateSubclass: subclass of: superClass 	^(self new)		type: (Array 					with: #immediateSubclass					with: superClass					with: subclass)			block: [subclass superclass = superClass]			errorString: ((#x1sIsQnotQimmediateSubclassOf2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;an immediate subclass of &lt;2s&gt;')			expandMacrosWith: subclass printStringOld			with: superClass printStringOld);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hierarchyOf:canAccessVariableNamed:">hierarchyOf: aClass canAccessVariableNamed: aString 	^self new 		type: (Array 				with: #hierarchyCanAccessVariable				with: aClass				with: aString)		block: [aClass hierarchyCanAccessVariableNamed: aString]		errorString: ((#x1sOrSubclassDoesNotDefineVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; or one of its subclasses %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; variable &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="referencesInstanceVariable:in:">referencesInstanceVariable: aString in: aClass 	^(self new)		type: (Array 					with: #referencesInstVar					with: aClass					with: aString)			block: [(aClass whichSelectorsReferToInstanceVariable: aString) notEmpty]			errorString: ((#x1s1doesNotReferenceInstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;reference%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="isValidMethodName:for:">isValidMethodName: aString for: aClass 	^(self new)		type: (Array 					with: #validMethodName					with: aString					with: aClass)			block: [self checkMethodName: aString in: aClass]			errorString: ((#x1sIsNotValidMethodName &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;a valid method name')			expandMacrosWith: aString printStringOld);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="subclassesOf:referToSelector:">subclassesOf: aClass referToSelector: aSelector 	^self new 		type: (Array 				with: #subclassReferences				with: aClass				with: aSelector)		block: 			[aClass subclasses anySatisfy: 					[:each | 					each selectors anySatisfy: 							[:sel | 							| tree |							tree := each parseTreeFor: sel.							tree notNil and: [tree superMessages includes: aSelector]]]]		errorString: ((#x1noORaSubclassRefersTo2s &lt;&lt; #browser &gt;&gt; '%&lt;1?:no:a%&gt; subclass of &lt;1s&gt; refers to &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aSelector printStringOld)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="canUnderstand:in:">canUnderstand: aSelector in: aClass 	^(self new)		type: (Array 					with: #understandsSelector					with: aClass					with: aSelector)			block: [aClass definesMethod: aSelector]			errorString: ((#x1sQundestandsQ2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;understand%&lt;1?s:%&gt; &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aSelector printStringOld);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="definesVariable:in:">definesVariable: aString in: aClass 	^(self new)		type: (Array 					with: #definesVar					with: aClass					with: aString)			block: [aClass definesVariable: aString]			errorString: ((#x1sQdoesnotdefineQVariable2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; variable &lt;2s&gt;')			expandMacrosWith: aClass printStringOld			with: aString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="isAbstractClass:">isAbstractClass: aClass 	^self new 		type: (Array with: #IsAbstractClass with: aClass)		block: [aClass isAbstract]		errorString: ((#x1sIsQnotQAbstract &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;an abstract class')			expandMacrosWith: aClass printStringOld)</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="uniqueMethodNameFor:">uniqueMethodNameFor: anInteger 	| before after index name |	before := 'a'.	after := ''.	anInteger timesRepeat: [after := after , 'z:'].	index := 0.		[name := before , index printStringOld , after.	(Symbol findInterned: name) notNil] 			whileTrue: [index := index + 1].	^name asSymbol</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="model">model	^model isNil 		ifTrue: 			[model := (RBRootNameSpace new)						description: self printStringOld;						yourself]		ifFalse: [model]</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>utilities</category><body package="Browser-Refactorings" selector="safeMethodNameFor:basedOn:">safeMethodNameFor: aClass basedOn: aString 	"Creates an unused method name containing aString"	| baseString newString hasParam i |	baseString := aString copyOld.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	hasParam := newString last = $:.	hasParam 		ifTrue: [baseString := newString copyFrom: 1 to: newString size - 1].	i := 0.	[aClass hierarchyDefinesMethod: newString asSymbol] whileTrue: 			[i := i + 1.			newString := baseString , i printStringOld 						, (hasParam ifTrue: [':'] ifFalse: [''])].	^newString asSymbol</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings" selector="refactorings:">refactorings: aCollection 	| oldName |	oldName := self printStringOld.	refactorings := aCollection.	(model notNil and: [model description = oldName]) 		ifTrue: [model description: self printStringOld]</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>changing</category><body package="Browser-BrowserUI" selector="updateWindowLabel">updateWindowLabel	| window |	self builder isNil ifTrue: [^self].	window := self builder window.	window isNil ifTrue: [^self].	(windowLabel = window label or: [window label asString isEmpty]) 		ifFalse: [self environment label: window label].	windowLabel := self state hasSelection 				ifTrue: 					[windowLabel := self environment label.					windowLabel asString notEmpty ifTrue: [windowLabel := windowLabel asString , ' - '].					windowLabel asString , self state printStringOld]				ifFalse: [self defaultWindowLabel].	window label: windowLabel</body></methods><methods><class-id>Refactory.Browser.AddClassRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings" selector="printOn:">printOn: aStream 	aStream		nextPutAll: 'Add class, ';		nextPutAll: className;		nextPutAll: ', as subclass of ';		nextPutAll: superclass printStringOld;		nextPutAll: ' refactoring'</body></methods><methods><class-id>Refactory.Browser.RestoreOverrideChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#RestoreOverrideFor1s &lt;&lt; #browser &gt;&gt; 'Restore Override for &lt;1s&gt;')			expandMacrosWith: override printStringOld)</body></methods><methods><class-id>Refactory.Browser.RenameMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings" selector="myConditions">myConditions	^Condition withBlock: [oldSelector numArgs = newSelector numArgs]		errorString: ((#x1sDoesNotHaveCorrectArgNum &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; doesn''t have the correct number of arguments.')			expandMacrosWith: newSelector printStringOld)</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>private</category><body package="Browser-BrowserUI" selector="newMethodPatternFrom:">newMethodPatternFrom: node	| argName ws |	ws := String new writeStream.	argName := 'anObject'.	node selectorPartsDo: [:selectorPart | ws nextPutAll: selectorPart value]		argumentsDo: [:argument |			ws space.			argument isVariable				ifTrue: [ws nextPutAll: argument name]				ifFalse: [ws nextPutAll: argName.					(argName anySatisfy: #isDigit)						ifTrue: [argName := (argName reject: #isDigit)										, ((argName select: #isDigit) asNumber + 1) printStringOld]						ifFalse: [argName := 'anObject2']].			ws space].	^self formattedText: ws contents</body></methods><methods><class-id>Refactory.Browser.AddProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#AddProtocol1sTo2s &lt;&lt; #browser &gt;&gt; 'Add protocol, &lt;1s&gt;, to &lt;2s&gt;')			expandMacrosWith: self protocol			with: self protocolObject printStringOld)</body></methods><methods><class-id>Refactory.Browser.AddProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="primitiveExecute">primitiveExecute	self protocolObject organization addCategory: self protocol.	self 		logProtocolChange: self protocolObject printStringOld 				, ' organization addCategory: ' , self protocol printStringOld.	self protocolObject reorganize</body></methods><methods><class-id>Refactory.Browser.RBNameSpace</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="definitionString">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineNameSpace: #';		nextPutAll: self name;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: isPrivate printStringOld;		cr;		tab;		nextPutAll: 'imports: '''.	self imports do: [:each | each printDefinitionOn: definitionStream]		separatedBy: 			[definitionStream				cr;				tab].	definitionStream		nextPutAll: '''';		cr;		tab;		nextPutAll: 'category: '''''.	^definitionStream contents</body></methods><methods><class-id>Refactory.Browser.ClassBlendChange</class-id> <category>private</category><body package="ClassCloning" selector="isLostSuper:">isLostSuper: aMethod		| selector behavior output |	selector := aMethod selector.	behavior := aMethod mclass isMeta		ifTrue: [originalSubclass classBehavior]		ifFalse: [originalSubclass].	output := String new writeStream.	output nextPutAll: 'super'.	selector last = $:		ifTrue:			[selector keywords				keysAndValuesDo:					[:index :word | 					output						space;						nextPutAll: word;						space;						nextPutAll: '``@arg' , index printStringOld]]		ifFalse:			[output				space;				nextPutAll: selector].	^(behavior includesSelector: selector)		and:			[(ParseTreeSearcher				treeMatching: output contents				in: (behavior parseTreeFor: selector)) notNil]</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="newNameForSelf">newNameForSelf	| variableName index originalName nonMetaClass |	nonMetaClass := inlineClass nonMetaclass.	variableName := originalName := 		((nonMetaClass name first isVowel 			ifTrue: [(#an &lt;&lt; #browser &gt;&gt; 'an')]			ifFalse: [(#a &lt;&lt; #browser &gt;&gt; 'a')])) asString, nonMetaClass name.	index := 1.		[variableName := self safeVariableNameBasedOn: variableName.	inlineParseTree allDefinedVariables includes: variableName] 			whileTrue: 				[variableName := originalName , index printStringOld.				index := index + 1].	^variableName</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="safeVariableNameBasedOn:">safeVariableNameBasedOn: aString 	"Creates an unused variable name containing aString"	| baseString newString i allTempVars |	allTempVars := inlineParseTree allTemporaryVariables.	baseString := aString copyOld.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	i := 0.		[(allTempVars includes: newString) 		or: [class definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printStringOld].	^newString</body></methods><methods><class-id>Refactory.Browser.CompareCodeTool</class-id> <category>menus</category><body package="Browser-BrowserUI" selector="makeDefinitionsList">makeDefinitionsList	^self definitions 		asSortedCollection: [:a :b | a printStringOld &lt;= b printStringOld]</body></methods><methods><class-id>Refactory.Browser.CompareCodeTool</class-id> <category>private</category><body package="Browser-BrowserUI" selector="definitionFromString:">definitionFromString: aString	^self definitions detect: [:x | x printStringOld = aString ] ifNone: [nil]</body></methods><methods><class-id>Refactory.Browser.CompareCodeTool</class-id> <category>private</category><body package="Browser-BrowserUI" selector="definitionToString:">definitionToString: aDefinition	^aDefinition printStringOld</body></methods><methods><class-id>Refactory.Browser.SelectorProtocolNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI" selector="iconFor:">iconFor: aMethodCategory	"Return a graphic that shows the count of methods in this category. It's back coloring is based on whether all, none, or some of the methods are currently visible in the browser. As is the number count text color."	"The back 'shape' is actually a series of rectangles, we get a cleaner looking ovoid this way since it stays balanced, whereas arc/wedge drawings aliases really bad."	"The bit with style gridding, pure dart throwing until I found an algorithm that positioned it correctly on all 3 display systems."		| totalCount hereCount countStyle listView label countTextColor |	navigator selectedClass ifNil: [^nil].	totalCount := self totalMethodCountIn: aMethodCategory.	hereCount := self visibleMethodCountIn: aMethodCategory.	listView := self widgetAt: #objectList.	countStyle := listView textStyle copyOld.	countStyle gridForFont: #small withTopLead: 0 bottomLead: 0.	countTextColor := (hereCount		between: 1		and: totalCount - 1)		ifTrue: [ColorValue black]		ifFalse: [ColorValue white].	label := Label		with:			(totalCount printStringOld asText				emphasizeAllWith:					(Array						with: #small						with: #color -&gt; countTextColor))		attributes: countStyle.	^VisualStack		with:			((totalCount isZero not and: [hereCount = totalCount])				ifTrue: [GeneralIcons darkMethodCountBackground]				ifFalse: [GeneralIcons lightMethodCountBackground])		with: label</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#Move1sTo2sIn3s &lt;&lt; #browser &gt;&gt; 'Move &lt;1s&gt;, to &lt;2s&gt; in &lt;3s&gt;')			expandMacrosWith: symbol			with: self protocol			with: self protocolObject printStringOld)</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="primitiveExecute">primitiveExecute	self includesProtocol ifTrue: [super primitiveExecute].	self protocolObject classifySymbol: symbol under: self protocol.	self 		logProtocolChange: self protocolObject printStringOld 				, ' classifySymbol: ' , symbol printStringOld 				, ' under: ' , self protocol printStringOld.	isUndo ifTrue: [self resetToPriorState]</body></methods><methods><class-id>Refactory.Browser.CodeComponentBlockTool</class-id> <category>accepting</category><body package="Browser-BrowserUI" selector="accept:from:">accept: aText from: aController 	| block codeComponent |	codeComponent := self codeComponent.	codeComponent isNil ifTrue: [^self].	block := self class compilerClass new 				evaluate: aText				in: nil				allowReceiver: false				receiver: nil				environment: Smalltalk				notifying: aController				ifFail: [^self].	(block isKindOf: BlockClosure) 		ifFalse: [^self warn: (#DidNotEvaluateToABlock &lt;&lt; #browser &gt;&gt; 'Did not evaluate to a block')].	block numArgs ~= argumentCount 		ifTrue: 			[^self 				warn: ((#BlockDoesNotHaveCorrectNumArgs1s &lt;&lt; #browser &gt;&gt; 'Block does not have the correct number of arguments (&lt;1s&gt;)')			expandMacrosWith: argumentCount printStringOld)].	codeComponent perform: ((#x1sC &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;:')			expandMacrosWith: property) asSymbol		with: (CodeComponent asActionBlock: aText).	self updateContents</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockNode</class-id> <category>matching</category><body package="Browser-Parser" selector="addArgumentWithNameBasedOn:to:">addArgumentWithNameBasedOn: aString to: aRBBlockNode 	| name index vars |	name := aString.	vars := aRBBlockNode allDefinedVariables.	index := 0.	[vars includes: name] whileTrue: 			[index := index + 1.			name := name , index printStringOld].	aRBBlockNode 		arguments: (aRBBlockNode arguments copyWith: (RBVariableNode named: name))</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="renameSourceCodeReferences">renameSourceCodeReferences	| replacer |	replacer := self parseTreeRewriter.	self model allReferencesToObject: object		do: 			[:method | 			(method modelClass isClassObject and: 					[(method modelClass hierarchyDefinesVariable: newName) and: 							[(object environment isClassObject 								and: [method modelClass nonMetaclass includesClass: object environment]) 									not]]) 				ifTrue: 					[self refactoringError: ((#x1sAlreadyDefinedInHierarchyOf2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is already defined in hierarchy of &lt;2s&gt;')			expandMacrosWith: newName			with: method modelClass printStringOld)].			self convertMethod: method using: replacer]</body></methods><methods><class-id>Refactory.Browser.PushDownMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="pushDown:">pushDown: aSelector 	| code refactoring |	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: (class parseTreeFor: aSelector)				fromClass: class				toClasses: class subclasses.	self performComponentRefactoring: refactoring.	code := refactoring parseTree printStringOld.	class subclasses do: 			[:each | 			(each directlyDefinesMethod: aSelector) 				ifFalse: [each compile: code withAttributesFrom: (class methodFor: aSelector)]]</body></methods><methods><class-id>Refactory.Browser.AddParameterRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="newSelectorString">newSelectorString	| stream keywords |	stream := WriteStream on: String new.	keywords := newSelector keywords.	1 to: keywords size		do: 			[:i | 			stream nextPutAll: (keywords at: i).			(permutation at: i) == keywords size				ifTrue: 					[stream						nextPut: $(;						nextPutAll: initializer;						nextPut: $)]				ifFalse: 					[stream						nextPutAll: ' ``@arg';						nextPutAll: (permutation at: i) printStringOld].			stream nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.AddParameterRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings" selector="myConditions">myConditions	^Condition withBlock: 			[oldSelector numArgs + 1 = newSelector numArgs 				ifFalse: 					[self refactoringError: ((#x1sDoesNotHaveProperArgNum &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; doesn''t have the proper number of arguments.')			expandMacrosWith: newSelector printStringOld)].			self verifyInitializationExpression.			true]</body></methods><methods><class-id>Refactory.Browser.RBClass</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="definitionString">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineClass: #';		nextPutAll: self name;		cr;		tab;		nextPutAll: 'superclass: ';		print: (self superclass isNil 					ifTrue: [nil]					ifFalse: [self superclass asReference makeUnambiguous]);		cr;		tab;		nextPutAll: 'indexedType: #';		nextPutAll: indexedType;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: isPrivate printStringOld;		cr;		tab;		nextPutAll: 'instanceVariableNames: '''.	self instanceVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream		nextPutAll: '''';		cr;		tab;		nextPutAll: 'classInstanceVariableNames: '''.	self metaclass instanceVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream		nextPutAll: '''';		cr;		tab;		nextPutAll: 'imports: '''.	self imports do: 			[:each | 			definitionStream				cr;				next: 3 put: Character tab.			each printDefinitionOn: definitionStream].	definitionStream		cr;		next: 3 put: Character tab;		nextPutAll: '''';		cr;		tab;		nextPutAll: 'category: '''''.	^definitionStream contents</body></methods><methods><class-id>RowDescriptionMessage</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. In addition to information printed by my superclass, I print 	out the number of fields and the field descriptions."	super printOn: aStream.	aStream nextPutAll: 'Number of fields: ' , self numberOfFields printStringOld; cr.	fieldDescriptions		do: 			[:aFieldDescription | 			aFieldDescription printOn: aStream.			aStream cr].	^self</body></methods><methods><class-id>PostgreSQLRuntimeParameter</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream	aStream		nextPutAll: self name printStringOld;		nextPutAll: ' set to: ';		nextPutAll: self setting printStringOld;		nextPutAll: ' (';		nextPutAll: self description;		nextPutAll: ')';		yourself.	^self</body></methods><methods><class-id>SpIPAddress</class-id> <category>printing</category><body package="SpSockets" selector="hostAddressString">hostAddressString	| targetStream |	targetStream := String new writeStream.	targetStream		nextPutAll: (self hostAddress at: 1) printStringOld;		nextPut: $.;		nextPutAll: (self hostAddress at: 2) printStringOld;		nextPut: $.;		nextPutAll: (self hostAddress at: 3) printStringOld;		nextPut: $.;		nextPutAll: (self hostAddress at: 4) printStringOld.	^targetStream contents</body></methods><methods><class-id>Graphics.Printer class</class-id> <category>examples</category><body package="Examples" selector="exampleFontSizes">exampleFontSizes	"Printer exampleFontSizes."	| text document font |	document := Document new.	document		doFooter: true		footerString: 'Printer exampleFontSizes'		doPageNumbers: true.	text := (#reallyLongText &lt;&lt; #examples &gt;&gt; 'The lazy brown dog jumped over the quick fox''s back, but since the fox was quick, he managed to catch up to the dog later and eat it.  The moral of this story is always to eat your Wheaties.') asText.	font := FontDescription new family: 'times'; boldness: 0.5; italic: false.	#(6 10 14 18 )		do: 			[:size |			| style |			font pixelSize: size.			style := TextAttributes defaultFontQuery: font copyOld.			style baseline: size.			style lineGrid: size * 12 // 10.			document startParagraph.			document addText: font pixelSize printStringOld under: (TextAttributes styleNamed: #default).			document startParagraph.			document addText: text under: style copyOld].	document toPrinter</body></methods><methods><class-id>Graphics.MacOSXFont class</class-id> <category>utilities</category><body package="Graphics-Fonts" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen 	"Answer an instance of the receiver that best represents the argument, 	 concreteFontDescription, given the font it is most closely to resemble, 	 requestedFontDescription.  The argument, aScreen, is the current Screen 	 object the font should be associated with.  PostScriptFonts are independent 	 of the Screen argument."	| size fontName encoding fontDescription boldValue isItalic screenFont |	encoding := self encoderNamed: self defaultEncodingName.	fontDescription := concreteFontDescription copyOld.	size := concreteFontDescription specifiesPixelSize 				ifTrue: [concreteFontDescription pixelSize]				ifFalse: [requestedFontDescription pixelSize].	fontName := concreteFontDescription family.	"'HelveticaNeue' matches 'helv*', which doesn't work here."	(fontName = 'Helvetica Neue' or: [fontName = 'HelveticaNeue']) 		ifTrue: [fontName := 'Helvetica'].	boldValue := requestedFontDescription specifiesBoldness 				ifTrue: [requestedFontDescription boldness]				ifFalse: 					[requestedFontDescription name isString 						ifTrue: 							[(self boldnessDescription: requestedFontDescription name) 								ifNil: [concreteFontDescription boldness]]						ifFalse: [concreteFontDescription boldness]].	isItalic := requestedFontDescription specifiesItalic 				ifTrue: [requestedFontDescription italic]				ifFalse: 					[requestedFontDescription name isString 						ifTrue: 							[(self italicDescription: requestedFontDescription name) 								ifNil: [concreteFontDescription italic]]						ifFalse: [concreteFontDescription italic]].	fontName := fontName , ' ' , size printStringOld , ' ' 				, boldValue printStringOld , ' ' 				, (isItalic ifTrue: ['1'] ifFalse: ['0']) , ' ' 				, requestedFontDescription setWidth printStringOld.	screenFont := aScreen 		fontNamed: fontName		fromClass: self		encoding: encoding.	screenFont setDescription: fontDescription.	concreteFontDescription family = 'Lucida_Grande' ifTrue: [screenFont tuneWidthsOn: aScreen].	^screenFont.</body></methods><methods><class-id>Graphics.PostScriptPrinterFont</class-id> <category>initialize-release</category><body package="Graphics-Printing-PostScript" selector="name:size:">name: nm size: sz	fontBody := PostScriptFontBody named: nm.	size := sz.	ascent := fontBody ascent * size.	descent := fontBody descent * size.	name := nm,'~',size printStringOld.	encoder := fontBody encoder.	simpleWidthTable := nil.</body></methods><methods><class-id>Graphics.PostScriptPrinterFont class</class-id> <category>utilities</category><body package="Graphics-Printing-PostScript" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen	| fontName fd |	fd := concreteFontDescription copyOld.	fontName := concreteFontDescription name, '~', requestedFontDescription pixelSize printStringOld.	fd pixelSize: requestedFontDescription pixelSize.	fd name: fontName.	^(aScreen			fontNamed: fontName			fromClass: self)		setDescription: fd</body></methods><methods><class-id>Graphics.DocumentRenderer</class-id> <category>private</category><body package="System-Printing" selector="endPage">endPage	"Advance to the next page."	| footerY t ta ca |	page := page+1.	x := self deviceMargins left.	y := self deviceMargins top.	footerY := output clippingBounds height-(self deviceMargins bottom//2).	t := Text new.	(footer at: 3)   "pageNumber"		ifTrue:			[t := t, (Text string: (page printStringOld,'    ')					emphasis: (Array								with: #family-&gt;'times*'								with: #pixelSize-&gt;10))].	(footer at: 1)   "footer"		ifTrue:			[t := t, (Text string: (footer at: 2)					emphasis: (Array								with: #family-&gt;'times*'								with: #italic								with: #pixelSize-&gt;10))].	t isEmpty ifTrue: [^self].	ca := VariableCharacterAttributes newWithDefaultAttributes.	ca noScaling.	ca setDefaultQuery: (FontDescription new family: 'times*'; pixelSize: 10).	ta := TextAttributes characterAttributes: ca.	ta baseline: 10; lineGrid: 13.	t := ComposedText			withText: t			style: ta			compositionWidth: output clippingBounds width						- self deviceMargins left						- self deviceMargins right.	t displayOn: output at: x@(footerY-(t height/2)).	contentOnPage := false.</body></methods><methods><class-id>Graphics.JPEGImageReader</class-id> <category>marker parsing</category><body package="ImageReaders" selector="parseStartOfFile">parseStartOfFile	| length markerStart componentLength |	markerStart := ioStream position.	length := self nextWord.	dataPrecision := ioStream next.	dataPrecision = 8 		ifFalse: 			[self 				formatError: (#CannotHandle1sBits &lt;&lt; #dialogs 						&gt;&gt; 'Cannot handle &lt;1s&gt;-bit components' 							expandMacrosWith: dataPrecision printStringOld)].	height := self nextWord.	width := self nextWord.	componentLength := ioStream next.	height = 0 | (width = 0) | (componentLength = 0) 		ifTrue: 			[self formatError: #ImageIncompleteOrEmpty &lt;&lt; #dialogs 						&gt;&gt; 'Image incomplete or empty'].	length - (ioStream position - markerStart) = (componentLength * 3) 		ifFalse: 			[self formatError: #ImageCorruptComponentLength &lt;&lt; #dialogs 						&gt;&gt; 'Image incomplete or partially corrupted. Component length is incorrect'].	components := (1 to: componentLength) collect: 					[:each | |value|					(JPEGColorComponent new)						id: ioStream next;						widthInBlocks: (((value := ioStream next) bitShift: -4) bitAnd: 16r0F);						heightInBlocks: (value bitAnd: 16r0F);						qTableIndex: ioStream next + 1]</body></methods><methods><class-id>Graphics.JPEGImageReader</class-id> <category>marker parsing</category><body package="ImageReaders" selector="parseHuffmanTable">parseHuffmanTable	| length markerStart |	markerStart := ioStream position.	length := self nextWord.	[ioStream position - markerStart &lt; length] whileTrue: 			[| index isACTable bits count hTable |			index := ioStream next.			isACTable := (index bitAnd: 16r10) ~= 0.			index := (index bitAnd: 16rF) + 1.			index &gt; HuffmanTableSize 				ifTrue: 					[self 						formatError: (#ImageCorruptTableSize &lt;&lt; #dialogs 								&gt;&gt; 'Image incomplete or partially corrupted. Image has more than &lt;1s&gt; quantization tables' 									expandMacrosWith: HuffmanTableSize printStringOld)].			bits := ioStream next: 16.			count := bits inject: 0 into: [:sum :each | sum + each].			(count &gt; 256 or: [count &gt; (length - (ioStream position - markerStart))]) 				ifTrue: 					[self formatError: (#ImageCorruptHuffmanCount &lt;&lt; #dialogs 								&gt;&gt; 'Image incomplete or partially corrupted. Huffman Table count is incorrect')].			hTable := (JPEGHuffmanTable new)						bits: bits;						values: (ioStream next: count);						yourself.			(isACTable ifTrue: [self hACTable] ifFalse: [self hDCTable]) at: index				put: hTable]</body></methods><methods><class-id>Graphics.JPEGImageReader</class-id> <category>marker parsing</category><body package="ImageReaders" selector="parseQuantizationTable">parseQuantizationTable	| length markerStart |	markerStart := ioStream position.	length := self nextWord.	[ioStream position - markerStart &lt; length] whileTrue: 			[| qTablePosition prec value table |			value := ioStream next.			prec := (value bitShift: -4) &gt; 0.			qTablePosition := (value bitAnd: 16r0F) + 1.			qTablePosition &gt; QuantizationTableSize 				ifTrue: 					[self 						formatError: (#ImageCorruptTableSize &lt;&lt; #dialogs 								&gt;&gt; 'Image incomplete or partially corrupted. Image has more than &lt;1s&gt; quantization tables' 									expandMacrosWith: QuantizationTableSize printStringOld)].			table := Array new: DCTSize2.			1 to: DCTSize2				do: 					[:i | 					value := prec ifTrue: [self nextWord] ifFalse: [ioStream next].					table at: (JPEGNaturalOrder at: i) put: value].			self class useFloatingPoint ifTrue: [self scaleQuantizationTable: table].			self qTable at: qTablePosition put: table]</body></methods><methods><class-id>PostgreSQLEXDIByteArrayValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	ByteArrays can be stored in PostgreSQL fields of type bytea, but they must be Base 64 encoded 	first. This encoding makes the byte array about 30% longer but in return it means that the data can 	be stored on the target row rather than in a separate BLOB."	| writeStream |	writeStream := Base64EncodingWriteStream on: (String new: ((self object size) * (3 / 2)) rounded).	writeStream disableLineBreaks.	writeStream nextPutAll: self object.	writeStream close.	^writeStream contents printStringOld</body></methods><methods><class-id>FunctionCallPacket</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Function: '.	self function printOn: aStream.	aStream cr.	self arguments inject: 1		into: 			[:argumentNumber :anArgument | 			aStream nextPutAll: 'Field #' , argumentNumber printStringOld , ': '.			anArgument bytes printOn: aStream.			aStream cr.			argumentNumber + 1].	^self</body></methods><methods><class-id>ProtoObject</class-id> <category>overrides</category><body package="GlorpVWPort" selector="inspectorString">inspectorString	"For Object Studio compatibility"	^self printStringOld.</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>error handling</category><body package="Protocols-Common" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	^MessageNotUnderstood new		parameter: aMessage;		messageText: [| selectorString |			selectorString :=				[aMessage selector printStringOld]					on: Error					do: [:ex |						ex return:							(#errSelectorNotPrintable &lt;&lt; #dialogs &gt;&gt; '** unprintable selector **')							expandMacros asString].			(#errNotUnderstood &lt;&lt; #dialogs &gt;&gt; 'Message not understood: &lt;1s&gt;')				expandMacrosWith: selectorString];		raiseSignal.</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>printing</category><body package="Protocols-Common" selector="basicPrintOn:">basicPrintOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."        | title |        title := self class printStringOld.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>printing</category><body package="Protocols-Common" selector="printOn:">printOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."        | title |        title := self class printStringOld.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body></methods><methods><class-id>Protocols.CircularBuffer</class-id> <category>printing</category><body package="Protocols-Common" selector="printDetailsOn:">printDetailsOn: aStream	| stream show back forward |	show := 5. "how many elements around current position to show"	stream := (cache species new: 2*show) writeStream.	back := self skipBack: show.	forward := (self next: show + back into: stream) - show.	self skipBack: forward.	"Here we rely on pretty printing capability of internal streams, so that we don't need to reimplement it"	stream := stream printStringOld readStream.	stream skipThrough: $[.	aStream		nextPutAll: '[ ';		nextPutAll: (stream through: $[);		nextPut: $-;		print: self unread;		nextPut: $];		nextPutAll: (stream through: $]; upTo: $]);		nextPut: $]</body></methods><methods><class-id>PostgreSQLEXDINumberValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String	I return a PostgreSQL-friendly string representation of my numerical, non-integer object.  Print non-Fractions normally with intermediate $d mapped to $e and terminating non-digit discarded (a number will have either one or the other or neither, never both).  Convert Fractions to FixedPoints (more robust over the whole possible range than either asFloat or asDouble) with up to 6 digits of scale beyond their first or second significant digit (similar to Float)."	| obj vwPrintString |	obj := self object.	obj class == Fraction ifTrue:		[obj := obj reduced.		obj := obj asFixedPoint: (((obj denominator highBit - obj numerator highBit) max: 0) * 0.301) floor + 6].	^(vwPrintString := obj printStringOld) last isDigit		ifFalse: [vwPrintString allButLast: 1]		ifTrue: [vwPrintString collect: [:char | char = $d ifFalse: [char] ifTrue: [$e]]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printStringOld ]			].</body></methods><methods><class-id>Store.SQLAssistPostgreSQLServer</class-id> <category>special</category><body package="StoreForPostgreSQL" selector="recordsWithSourcesIn:butNotIn:">recordsWithSourcesIn:  aPrimaryKey butNotIn: bPrimaryKey 	"Postgresql likes it much better if we use an except clause rather than a primary key not in test"	self selectAll;		where;		column: #packageRef equalTo: aPrimaryKey printStringOld;		except;		beginClause;		addString:			( tableClass newSQL selectAll;			where;			column: #packageRef equalTo: bPrimaryKey printStringOld;			endClause			);		yourself.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-file out</category><body package="PackageCategories" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry packageNamedOrCreate: ', self name printStringOld, ' ) '.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="PackageCategories" selector="doUnloadFromImage">doUnloadFromImage	"Remove content of a package from the image.  Answer true if the operation has succeeded."	SystemUtils modifySystem: [		Transcript cr; show: ((#UnloadingPackageC1s &lt;&lt; #packages &gt;&gt; 'Unloading package: &lt;1s&gt;')				expandMacrosWith: self name printStringOld).		self doUnloadExtensionsFromImage.		self doUnloadDefinitionsFromImage.		self release.		Smalltalk organization removeEmptyCategories.		Override removeOverridesForComponent: self.		Override cleanseLists.		self runPostUnload.		self cleanseRelatedParcel.		self unloadSourceSafely.		ChangeSet unloadPundle: self].	^true</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>private</category><body package="Store-UI" selector="currentProgressIcon">currentProgressIcon	^SpinnerIcons perform: ('spin' , (progressIndex ) printStringOld) asSymbol</body></methods><methods><class-id>Store.PackageOwnerElement</class-id> <category>relationships</category><body package="Store-UI-Graphs" selector="elementRelatedBy:">elementRelatedBy: relToken 	"Answer a collection of related elements."	Transcript		cr;		show: ((#PackageElementToken1sElement2p &lt;&lt; #store &gt;&gt; 'PackageElement token: &lt;1s&gt; element: &lt;2p&gt;') 					expandMacrosWith: relToken					with: element).	Transcript		cr;		show: (element relatedBy: relToken) printStringOld.	^element relatedBy: relToken</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>private</category><body package="Store-UI" selector="validateSourcesIn:">validateSourcesIn: aCollection	"Validate that we're not publishing decompiled code from the image."	| invalid |	"If any of these aren't the image versions, then we're probably republishing or otherwise doing database operations where decompiled source isn't possible."	(aCollection anySatisfy: [:each | each getImagePundle ~~ each]) ifTrue: [^true].	aCollection		anySatisfy:			[:each | 			each changeSet modifiedMethodDescriptors				anySatisfy:					[:eachMethodDescriptor | 					| methodIsInvalid |					methodIsInvalid := eachMethodDescriptor compiledMethod getSource isNil.					methodIsInvalid ifTrue: [invalid := eachMethodDescriptor].					methodIsInvalid]].	invalid isNil		ifTrue: [^true]		ifFalse:			[^Dialog				confirm:					(#x1saboutToPublishDecompiled &lt;&lt; #store &gt;&gt;							'Some code, including &lt;1s&gt; is about to publish as decompiled (missing sources).&lt;n&gt;Proceed with publish?'						expandMacrosWith: invalid printStringOld)]</body></methods><methods><class-id>Store.BranchingVersionPolicy</class-id> <category>private</category><body package="Store-User Management" selector="increment:">increment: aString	"Given a string, increment the last digit sequence. If 'aString' does not end 	with a digit, returns 'aString'"		| lastNonDigit incrementedVersionNumber numberPortion newVersionString |	lastNonDigit := aString findLast: [:char | char isDigit not].	lastNonDigit = aString size ifTrue: [^aString].	numberPortion := aString copyFrom: lastNonDigit + 1 to: aString size.	incrementedVersionNumber :=  numberPortion asNumber + 1.	newVersionString := incrementedVersionNumber printStringOld.	[numberPortion size &gt; newVersionString size] whileTrue: [newVersionString := '0' , newVersionString].	^(aString copyFrom: 1 to: lastNonDigit) , newVersionString</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="name">name	^'&lt;1s&gt; propertyAt: &lt;2s&gt;' 		expandMacrosWith: symbol		with: self property printStringOld</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>converting</category><body package="Store-Change Management" selector="convertValue:">convertValue: value	^value isString		ifTrue: [ value ]		ifFalse: 			[ ( value isKindOf: BlockClosure )				ifTrue: [ CodeComponent stringFromAction: value ] 				ifFalse: [ value printStringOld ]			].</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>special</category><body package="Store-Broker-Obsolete" selector="classNamesInPackages:">classNamesInPackages: pkgIds	^self 	  selectDistinct: #( #className );	  where;	   column: #packageRef equalToArray: 		( pkgIds collect: [ :pkg | pkg primaryKey printStringOld ] );	sqlString</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="loadIntoPackage:from:">loadIntoPackage: imgPackage from: dbPackage	"Make sure that modification goes to the proper package."	( imgPackage == nil ) | ( dbPackage == nil )		ifTrue: 			[ Dialog warn: ( (#_1sCannotBeLoadedAckageIsNotLoaded &lt;&lt; #store &gt;&gt; '&lt;1s&gt; cannot be loaded since the package is not loaded.') 				expandMacrosWith: self printStringOld ).			^false 			].	self applyDefinitionFrom: dbPackage into: imgPackage.	^true</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"set new blessings and comments...."	self newGlobalState.	Announcements announce: (StorePrePublish for: self specifications: self specList).	self specList publishBlessing.	Announcements announce: (StorePostPublish for: self specifications: self specList).	self specList do:		[:each | each dbPundle blessingLevel: each blessing printStringOld].	self setDetailState.	dialog accept; closeRequest</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="PackageCategories" selector="checkForNameSpaceAndDataInZeroOrMultiplePackagesOn:">checkForNameSpaceAndDataInZeroOrMultiplePackagesOn: aStream 	Root allNameSpaces do: 		[ :ns | 		( self containingPackageForNameSpace: ns ) == nil			ifTrue: [ aStream nextPutAll: ((#x1sUnpackaged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; - Unpackaged')							expandMacrosWith: ns printStringOld); cr ]			ifFalse: 				[ | models |				models := self extensionModelsForSymbol: ns absoluteSymbol.				models size &gt;= 2 ifTrue: 					[ ns dataKeys do:						[ :key |  | pkgs |						pkgs := OrderedCollection new.						models do: 							[ :model | 							( model includesDataKey: key )								ifTrue: [ pkgs add: model package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1sDot2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: ns printStringOld								with: key asString								with: ns asArray printStringOld); cr ]						]					]				]		]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>utility</category><body package="PackageCategories" selector="repairForMethodsInZeroOrMultiplePackages">repairForMethodsInZeroOrMultiplePackages	"Registry repairForMethodsInZeroOrMultiplePackages"	Transcript cr; show: (#CheckingMultiplePackagesOrNone &lt;&lt; #packages &gt;&gt; 'Checking/repairing methods in multiple packages or no package').	Object allSubclassesDo: [:class | class selectors			do: 				[:selector | 				| pkgs cnt |				cnt := 0.				pkgs := self whatPackagesContainSelector: selector class: class.				pkgs size &gt; 1					ifTrue: [Transcript show: class printStringOld , '&gt;&gt;' , selector asString , ' --&gt; ' , pkgs asArray printStringOld; cr]					ifFalse: [(pkgs size &lt; 1 or: [pkgs first name = '(none)'])							ifTrue: 								[cnt := cnt + 1.								XChangeSet current									moveSelector: selector									class: class									toPackage: (self containingPackageForClass: class)]].				cnt &gt; 0 ifTrue: [Transcript cr; show: ((#MovingMethodsToNewPackage &lt;&lt; #packages &gt;&gt; 'Moved &lt;1s&gt; methods in class &lt;2s&gt; to &lt;3s&gt;')								expandMacrosWith: cnt printStringOld								with: class printStringOld								with: (self containingPackageForClass: class) name)]]].	Transcript cr; show: (#Done &lt;&lt; #packages &gt;&gt; 'Done.'); cr.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>parcel support</category><body package="PackageCategories" selector="parcel:added:to:">parcel: aParcel added: aThing to: aPackage	"aThing has been changed - reflect the update in aPackage."	aThing isNameSpace		ifTrue: [ ^XChangeSet current moveWholeNameSpace: aThing toPackage: aPackage ].	aThing isBehavior		ifTrue: [ ^XChangeSet current moveWholeClass: aThing toPackage: aPackage ].	aThing isVariableBinding		ifTrue: 			[ aParcel definedBindings keysAndValuesDo:				[ :env :keySet |				( ( keySet includes: aThing key ) and:						[ ( env asNameSpace bindingFor: aThing key ) = aThing ] )					ifTrue: [ ^XChangeSet current addBinding: aThing in: env  ].				]			].	aThing class == MethodInstallationRecord		ifTrue: [ ^XChangeSet current 					addSelector: aThing selector					class: aThing implementingClass					toPackage: aPackage				].	Dialog warn: ( (#UnknownParcelChange &lt;&lt; #packages &gt;&gt; 'Unknown parcel change (&lt;1s&gt;)&lt;n&gt; in &lt;2s&gt;')					expandMacrosWith: aThing printStringOld 					with: aPackage name ).</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="PackageCategories" selector="checkForClassesAndMethodsInZeroOrMultiplePackagesOn:">checkForClassesAndMethodsInZeroOrMultiplePackagesOn: aStream 	Root allClasses do: 		[ :class | 		( self containingPackageForClass: class ) == nil			ifTrue: [ class isMeta ifFalse: [ aStream nextPutAll: ((#x1sUnpackaged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; - Unpackaged')						expandMacrosWith: class printStringOld); cr ] ]			ifFalse: 				[ | cms |				cms := self extensionClassModelsForClassSymbol: class absoluteSymbol.				cms size &gt;= 2 ifTrue: 					[ class selectors do: 						[ :selector |   | pkgs |						pkgs := OrderedCollection new.						cms do: 							[ :cm | 							( cm includesSelector: selector meta: class isMeta )								ifTrue: [ pkgs add: cm package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1s2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: class printStringOld								with: selector asString								with: pkgs asArray printStringOld); cr ]						]					].					class dataKeys do:						[ :key |  | pkgs |						pkgs := OrderedCollection new.						cms do: 							[ :cm | 							( cm includesDataKey: key )								ifTrue: [ pkgs add: cm package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1sDot2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: class printStringOld								with: key asString								with: pkgs asArray printStringOld); cr ]						]				]		]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>parcel support</category><body package="PackageCategories" selector="parcel:change:to:">parcel: aParcel change: aThing to: aPackage	"aThing has been changed - reflect the update in aPackage."	aThing isNameSpace		ifTrue: [ ^XChangeSet current changeNameSpace: aThing toPackage: aPackage ].	aThing isBehavior		ifTrue: [ ^XChangeSet current changeClass: aThing toPackage: aPackage ].	aThing isVariableBinding		ifTrue: 			[ ^aParcel definedBindings keysAndValuesDo:				[ :env :keySet |				( keySet includes: aThing key )					ifTrue: [ XChangeSet current changeBinding: ( env asNameSpace bindingFor: aThing key ) in: env  ].				]			].	aThing class == MethodInstallationRecord		ifTrue: [ ^XChangeSet current 					changeSelector: aThing selector					class: aThing implementingClass					toPackage: aPackage				].	Dialog warn: ( (#UnknownParcelChange &lt;&lt; #packages &gt;&gt; 'Unknown parcel change (&lt;1s&gt;)&lt;n&gt; in &lt;2s&gt;')					expandMacrosWith: aThing printStringOld 					with: aPackage name ).</body></methods><methods><class-id>Store.MismatchedDatabaseError</class-id> <category>printing</category><body package="Store-Base" selector="defaultMessageText">defaultMessageText	| databasesString |	^parameter isNil 		ifTrue: 			[(#TheImageIsNotReconTheCurrentDatabase &lt;&lt; #store &gt;&gt; 'The image is not reconciled with the current database.') asString]		ifFalse: 			[databasesString := parameter allDatabases isEmpty				ifTrue: [(#noDatabase &lt;&lt; #store &gt;&gt; 'no database') asString]				ifFalse: [parameter allDatabases printStringOld].			#_1sIsReconciledTo2sTheEntDatabaseIs3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is reconciled to (&lt;2s&gt;). The current database is &lt;3s&gt;.' 					expandMacrosWith: parameter name					with: databasesString					with: DbRegistry databaseIdentifier]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-file out</category><body package="PackageCategories" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry bundleNamedOrCreate: ', self name printStringOld, '  ) '.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>public-change set access</category><body package="PackageCategories" selector="inspectChangeSet">inspectChangeSet	"Attempt to describe the changes to the bundle at a	high level."	"Could do better."	| stream |	stream := WriteStream on: String new.	self hasBeenModified		ifFalse: [stream nextPutAll: (#BundleHasNotBeenChanged &lt;&lt; #packages &gt;&gt; 'There are no changes to this bundle or its components') asString]		ifTrue: 			[| modPuns |			modPuns := OrderedCollection new.			self contentDescriptions do: 				[ :descrip | descrip hasBeenModified 					ifTrue: [ modPuns add: descrip component ]				].			modPuns size &gt; 0				ifTrue: 					[stream nextPutAll: (#SomeBundleComponentsHaveChanged &lt;&lt; #packages &gt;&gt; 'The following bundle components have been&lt;n&gt;modified (see component for details):') expandMacros; cr.					modPuns do: [:item | stream tab; nextPutAll: item name; cr].					stream cr].			self isChangeSetEmpty ifFalse: [stream nextPutAll: self changeSet printStringOld]].	Dialog warn: stream contents</body></methods><methods><class-id>Store.BasicVersionPolicy</class-id> <category>private</category><body package="Store-User Management" selector="increment:">increment: aString 	"Given a string, increment the last digit sequence. If 'aString' does not end 	with a digit, returns 'aString'"	| lastNonDigit incrementedVersionNumber | 	lastNonDigit := aString findLast: [ :char | char isDigit not ]. 	lastNonDigit = aString size ifTrue: [ ^aString ]. 	incrementedVersionNumber := ( aString copyFrom: lastNonDigit + 1 to: aString size ) asNumber + 1. 	^( aString copyFrom: 1 to: lastNonDigit ) 		, incrementedVersionNumber printStringOld</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="loadIntoPackage:from:">loadIntoPackage: aPackage from: aRecord 	"Make sure that modification goes to the proper package."	self canLoad		ifFalse: 			[ Dialog warn: ( (#DefinitionFor1sCaE2sIsNotLoaded &lt;&lt; #store &gt;&gt; 'Definition for &lt;1s&gt; cannot be loaded since &lt;2s&gt; is not loaded.') expandMacrosWith: self printStringOld with: symbol ).			^false 			].	Policies packagePolicy forcePackage: aPackage while: 		[ ^aRecord == nil			ifTrue: 				[ self existsInImage 					ifTrue: [ self removeFromSystemTolerant: false fromPackage: aPackage ].				true				]			ifFalse: [ self applyDefinitionFrom: aRecord ]		].</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>queries</category><body package="Store-Broker-Obsolete" selector="alterTableFor:pctIncreaseBy:">alterTableFor: aClass  pctIncreaseBy: aNumber	| sql |	sql :=  (self newSQLFor: aClass)			alterPstincrease: aNumber printStringOld.	self process: sql.	Transcript cr; show: sql, '-- Done!'.</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>private</category><body package="Store-Change Management" selector="formatStructure:">formatStructure: structure	"Answers a formatted print string for the bundle structure."		| stream |	stream := (String new: 256) writeStream.	structure do:		[ :array |		stream 			nextPutAll: array first printStringOld; tab; tab;			nextPutAll: array last; cr		].	^stream contents</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>accessing</category><body package="Store-Change Management" selector="systemVersion:">systemVersion: aCodeComponent	"Answer an appropiate version string for aCodeComponent."	^aCodeComponent databaseId 		ifNil: [ (#NotInConnectedDatabase &lt;&lt; #store &gt;&gt; 'Not in Connected Database') asString ]		ifNotNil: [ :id | id , ': ' , aCodeComponent primaryKey printStringOld ]</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>printing</category><body package="Store-Change Management" selector="version">version	^databaseId, ': ', primaryKey printStringOld</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>error handling</category><body package="StoreForGlorpBrowserUI" selector="handleGlorpError:">handleGlorpError: anAnnouncement	"Don't let anything hang us up here.	 The repository connection has terminated unexpectedly and we need to clean up the non-revivable browsers."	| session |	session := self navigator environment glorpSession.	session accessor connection = (anAnnouncement session ifNotNil: [:value | value accessor connection]) ifFalse: [^self].	[anAnnouncement wasUsed ifFalse: [Dialog warn: (#DatabaseInfoObsolete &lt;&lt; #store				&gt;&gt; 'The image is disconnected from the database,&lt;n&gt;and the version information is obsolete.&lt;n&gt;The window will now close.')						expandMacros].	self terminateBrowser]			on: Error			do: 				[Transcript show: ('Failed to terminate &lt;1s&gt; on Glorp Database Error.'							expandMacrosWith: self printStringOld)].	anAnnouncement wasUsed: true.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>instantiating</category><body package="Store-Database Model" selector="instantiateAllOfBundle:">instantiateAllOfBundle: aBundle	"Traverse everything in the bundle, making sure we've got no proxies left, so we have everything we need to write to the other side. Note that for sub-packages we only bring in enough to be able to print them, because we may not end up replicating them if they already exist in the target database"	aBundle bundles do: [:each | self instantiateAllOf: each].	aBundle packages do: [:each | each printStringOld].	aBundle blessings do: [:each | self followSourceFor: each].	self followCommentFor: aBundle.	aBundle propertiesRecordDictionary yourSelf isNil ifFalse: [		aBundle propertiesRecordDictionary do: [:each | self followSourceFor: each]].	aBundle propertiesBlob yourSelf.	aBundle files do: [:each | self followSourceFor: each ].</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;">&lt; aStoreMethod	| n1 n2 sel |	n1 := self classNameWithMeta.	n2 := aStoreMethod classNameWithMeta.	^n1 = n2		ifTrue:			[(self selector isString					ifTrue: [self selector]					ifFalse: [self selector printStringOld])				&lt; ((sel := aStoreMethod selector) isString						ifTrue: [sel]						ifFalse: [sel printStringOld])]		ifFalse: [n1 &lt; n2]</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		| target |	anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	anAlternative isUserInputResolution ifTrue: [^anAlternative value].	^anAlternative value isString		ifTrue: [anAlternative value]		ifFalse: 			[(anAlternative value value isKindOf: CompiledMethod)				ifFalse: 					[(target := anAlternative value value) isString 						ifTrue: [target]						ifFalse: [target printStringOld]]				ifTrue: [anAlternative value value method getSource]]</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName	| storeObject |	storeObject := ((base notNil and: [base isRemovalResolution]) ifTrue: [base base] ifFalse: [base ifNil: [original ifNil: [proposed]]]).	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value key printStringOld</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="longListName">longListName	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [nil].	^(alternative isNil		ifTrue: ['Unkown']		ifFalse: [alternative package name]) , (#SpaceBracketPropertyBracketSpace &lt;&lt; #store &gt;&gt; ' [Property] ') asString, self propertyKey printStringOld, self applyableString.</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>accessing</category><body package="Store-Database Model" selector="versionString">versionString	^(#definitionObjectVersionString &lt;&lt; #store &gt;&gt; ' &lt;1s&gt;, &lt;2s&gt; ' expandMacrosWith: self timestamp printStringOld with: self userName)</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>accessing</category><body package="Store-Database Model" selector="defaultParcelName">defaultParcelName	"This method is used to return a name that can be used in the creation	of a temporary source file (*.pst) when loading a parcel from a Store	database.  Currently only uses [name][primaryKey].pst but will need to	also have some way of identifying the database being accessed since	two different ParcelRecords in two different databases could have the	same name and the same primary key."	self needsMoreWork.	^self name, self primaryKey printStringOld</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>private</category><body package="Store-Database Model" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver		startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineClass:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'super' value: (self convertVariableNodeToXML: (data at: 'superclass:')).	self sax: driver tag: 'private' value: (data at: 'private:') value printStringOld.	self sax: driver tag: 'indexed-type' value: (data at: 'indexedType:') value asString.	self sax: driver tag: 'inst-vars' value: (data at: 'instanceVariableNames:') value.	self sax: driver tag: 'class-inst-vars' value: (data at: 'classInstanceVariableNames:') value.	self sax: driver tag: 'imports' value: (data at: 'imports:') value asString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	(data includesKey: 'attributes:') ifTrue:		[driver startElement: 'attributes' atts: nil.		(data at: 'attributes:') value do: [:attr |			(attr last isKindOf: Array)				ifTrue:					[driver startElement: attr first atts: nil.					attr last do: [:s | self sax: driver tag: 'item' value: s].					driver endElement]				ifFalse: [self sax: driver tag: attr first value: attr last displayString]].		driver endElement].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>private</category><body package="Store-Database Model" selector="convertToXML:">convertToXML: aString	| parse driver data sName eName init |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'shared-variable' atts: nil.	sName := (data at: 'defineSharedVariable:' ifAbsent: [data at: 'defineStatic:']) value asString.	self sax: driver tag: 'name' value: sName.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printStringOld.	self sax: driver tag: 'constant' value: (data at: 'constant:') value printStringOld.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	init := ( init := (data at: 'initializer:' ) value ) == nil		ifFalse: [ self sax: driver tag: 'initializer' value: init asString ].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>accessing</category><body package="Store-Database Model" selector="versionString">versionString	^(#definitionObjectVersionString &lt;&lt; #store &gt;&gt; ' &lt;1s&gt;, &lt;2s&gt; ' expandMacrosWith: self timestamp printStringOld with: self definition userName)</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>accessing</category><body package="Store-Database Model" selector="bracketedVersionString">bracketedVersionString	^'(&lt;1s&gt;, &lt;2s&gt;)' expandMacrosWith: self timestamp printStringOld with: self definition userName</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="Store-Database Model" selector="versionComment">versionComment	^self blessings inject: String new into: [:sum :each | sum, each printStringOld].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="blessingLevel">blessingLevel	^self blessingLevelNumber printStringOld</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printStringOld ]			].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="Store-Database Model" selector="textForItem">textForItem	^self printStringOld</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>load utilities</category><body package="Store-Database Model" selector="reloadPundle:id:fromDatabase:">reloadPundle: aString id: anInteger fromDatabase: aSymbol	"Loads a pundle based on the primary key."	"Note: must be sent to a subclass, not the abstract Pundle class."		| choice |	(DbRegistry databaseIdentifier = aSymbol or: [DbRegistry databaseIdentifier asSymbol printStringOld = aSymbol printStringOld]) ifFalse:		[^Dialog warn:			(#CannotLoad1sFrom2sNotLoggedOn &lt;&lt; #store &gt;&gt; 'Cannot load &lt;1s&gt; from &lt;2s&gt; - not logged on' expandMacrosWith: aString with: aSymbol printStringOld)].	choice := Dialog		choose: (#_1s2sWasLoadedOrPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2s&gt; was loaded or published.' expandMacrosWith: self instanceBehavior name with: aString)		labels:			(Array				with: (#ReloadFromTheDatabase &lt;&lt; #store &gt;&gt; 'Reload From the Database') asString				with: (#SetTheParent &lt;&lt; #store &gt;&gt; 'Set the Parent') asString				with: (#DoNothing &lt;&lt; #store &gt;&gt; 'Do Nothing') asString)		values: #(#reload #reset #cancel)		default: #reset.	choice == #cancel ifTrue: [^self].	choice == #reload 		ifTrue: [self loadPundleId: anInteger] 		ifFalse: [self resetPundleId: anInteger]</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		| stream |	anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	stream := WriteStream on: String new.	anAlternative isNoOpResolution		ifTrue: [stream nextPutAll: anAlternative value]		ifFalse: 			[anAlternative value 				do: 					[:each | 					stream 						nextPutAll: each first;						nextPutAll: ': ';						nextPutAll: each last printStringOld] 					separatedBy: [stream cr]].	^stream contents</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>accessing</category><body package="Store-Database Model" selector="blessingName">blessingName	^((Dialect smalltalkAt: #Store ifAbsent: [^blessingLevel printStringOld])		at: #Policies		ifAbsent: [blessingLevel printStringOld]) blessingPolicy		blessingName: blessingLevel.</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>private</category><body package="Store-Database Model" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'name-space' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineNameSpace:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printStringOld.	self sax: driver tag: 'imports' value: (data at: 'imports:') value.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>error handling</category><body package="Store-UI" selector="handleGlorpError:">handleGlorpError: anAnnouncement	"Don't let anything hang us up here.	 The repository connection has terminated unexpectedly and we need to clean up the non-revivable browsers."	| session |	session := self glorpSession ifNil: [^self].	"We can have multiple store sessions with the same underlying connection. Make sure that we close our browsers if there's an error on any of them."	session accessor connection = (anAnnouncement session ifNotNil: [:value | value accessor connection]) ifFalse: [^self].	[anAnnouncement wasUsed ifFalse: [Dialog warn:( #DatabaseInfoObsolete &lt;&lt; #store				&gt;&gt; 'The image is disconnected from the database,&lt;n&gt;and the version information is obsolete.&lt;n&gt;The window will now close.')						expandMacros].	self terminateBrowser]			on: Error			do: 				[Transcript show: ('Failed to terminate &lt;1s&gt; on Glorp Database Error.'							expandMacrosWith: self printStringOld)].	anAnnouncement wasUsed: true.</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>printing</category><body package="Store-User Management" selector="printOn:">printOn: aStream	aStream nextPutAll: name.	type == nil		ifFalse: [ aStream nextPut: $-; nextPutAll: type ].	aStream 		nextPut: $(;		nextPutAll: level printStringOld;		nextPut: $).</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	"What to do when the exception is unhandled."	Dialog warn:		( self definitionRecord isForMethod			ifTrue: [  ( #DefIsNotLoadable &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is not loadable.' ) expandMacrosWith: self definitionRecord printStringOld ]			ifFalse: [ ( #DefIsNotLoadable &lt;&lt; #store &gt;&gt;  '&lt;1s&gt; is not loadable.' ) expandMacrosWith: self definitionRecord name ]		)</body></methods><methods><class-id>Store.TextModification</class-id> <category>actions</category><body package="Store-Change Management" selector="apply">apply	"Apply a modification to the image."	"| imPkg | 	imPkg := TT_Registry packageNamed: packageName.	imPkg isNil ifTrue: [self error: 'Package ' , packageName , ' not found.'].	tag existsInImage		ifTrue: 			[| oldPkg |			oldPkg := tag containingPackage.			oldPkg isNil ifTrue: [self error: 'No containing package for: ' , tag printString].			oldPkg = imPkg ifFalse: [self halt]]."	self notify: tag printStringOld</body></methods><methods><class-id>XML.ElementContext</class-id> <category>accessing</category><body package="XML" selector="followSetDescription">followSetDescription	| types |	types := IdentitySet new.	self types do: [:tp |		types addAll: tp followSet].	^types asArray printStringOld</body></methods><methods><class-id>XML.Pattern</class-id> <category>coercing</category><body package="XML" selector="normalizeFor:">normalizeFor: aParser	| list done t r result |	list := OrderedCollection			with: (result := InitialPattern new addFollow: self)			with: self			with: TerminalPattern new.	self addFollow: list last.	done := OrderedCollection new.	[list isEmpty]		whileFalse:			[t := list removeFirst.			r := t pushDownFollowSet.			done add: t.			r == nil				ifFalse: [list addAll: r]].	done do: [:nd || replacements |		replacements := nd alternateHeads.		(replacements size = 1 and: [replacements first == nd])			ifFalse: [done do: [:nd2 |				nd2 replaceFollowSet: nd with: replacements]]].	done := IdentitySet new.	list := OrderedCollection with: result.	[list isEmpty]		whileFalse:			[t := list removeLast.			t isSimple				ifFalse: [aParser malformed: (#incompleteNormalizationOfPattern							&lt;&lt; #xml &gt;&gt; 'Incomplete translation')].			(self duplicatesNeedTested and: [t hasDuplicatesInFollowSet])				ifTrue: [aParser warn: (#nondeterministicContentModel							&lt;&lt; #xml &gt;&gt; 'Nondeterministic content model &lt;1s&gt;'								expandMacrosWith: self printStringOld)].			done add: t.			t followSet do: [:t1 |				(done includes: t1) ifFalse: [list add: t1]]].	^result</body></methods><methods><class-id>XML.Node</class-id> <category>printing</category><body package="XML" selector="simpleDescription">simpleDescription	^self printStringOld</body></methods><methods><class-id>XML.ConcretePattern</class-id> <category>accessing</category><body package="XML" selector="followSetDescription">followSetDescription	| s |	s := (String new: 32) writeStream.	s nextPut: $(.	followSet do: [:n | s nextPutAll: n printStringOld]		separatedBy: [s space].	s nextPut: $).	^s contents</body></methods><methods><class-id>XML.InitialPattern</class-id> <category>accessing</category><body package="XML" selector="description">description	^(followSet asArray collect: [:i | i description]) printStringOld</body></methods><methods><class-id>PostgreSQLEXDIBLOBValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	My string value is the string form of the integer which is the oid of the BLOB I represent. This is a 	non-trivial matter. I must submit several fuction calls to the PostgreSQL back end which create &amp; 	update the blob. By myself, I can't see the database; I need to get hold of the database connection. 	To acieve this, I throw an exception which is caught by the session. The session in turn then sends 	me the &gt;&gt;callFunctionInTheContextOf: with itself as the argument. This enables me to get hold of 	the connection and call the appropriate blob functions on the back end.  I then return control to 	the session, which in turn resumes the exception returning control here. Finally I take the oid of the 	blob and return it's value as a string. Phew!! 	NOTE: This way of handling blobs results in a new BLOB for every update. It is very important that 	database triggers are used to remove old blobs from the database when a row containing BLOB 	references is updated or deleted."	PostgreSQLEXDIFieldValueFunctionCallRequest signalWith: self.	^self oid printStringOld</body></methods><methods><class-id>FunctionResponse</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. In addition to information 	printed by my superclass ..."	super printOn: aStream.	aStream nextPutAll: 'Result value: ' , self value bytes printStringOld; cr.	^self</body></methods><methods><class-id>FieldDescription</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. ."	aStream nextPutAll: 'Field description.  Name: ' , self name.	aStream nextPutAll: '.  Object ID: ' , self objectID printStringOld.	aStream nextPutAll: '.  Type size: ' , self typeSize printStringOld.	aStream nextPutAll: '.  Type modifier: ' , self typeModifier printStringOld.	^self</body></methods><methods><class-id>AsciiRowMessage</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I write a representation of myself to aStream. In addition to 	information printed by my superclass, I write details of my fields."	super printOn: aStream.	self fields inject: 1		into: 			[:fieldNumber :aField | 			aStream nextPutAll: 'Field #' , fieldNumber printStringOld , ': '.			aField printOn: aStream.			aStream cr.			fieldNumber + 1].	^self</body></methods><methods><class-id>Core.Time</class-id> <category>printing</category><body package="GlorpExtensions" selector="glorpPadToTwoDigits:">glorpPadToTwoDigits: anInteger	| string |	string := anInteger truncated printStringOld.	^string size = 1 ifTrue: ['0', string] ifFalse: [string].</body></methods><methods><class-id>Core.Time class</class-id> <category>general inquiries</category><body package="Magnitude-General" selector="aTimeString:">aTimeString: theSeconds 	"Answer a String of the date and time where the argument, theSeconds,  	represents the number of seconds since 1901 began."	^TimeZone default 		convertGMT: theSeconds 		do: [:date :seconds | 			date printStringOld , ' ' , (Time fromSeconds: seconds) printStringOld]</body></methods><methods><class-id>Core.IllegalCharacterStreamErrorPolicy</class-id> <category>errors</category><body package="Collections-Streams" selector="noEncodingFor:in:">noEncodingFor: aCharacter in: aStream 	(UnsupportedCharacterError new)		messageText: (#errNoCharacter &lt;&lt; #dialogs &gt;&gt; 'No character available') 					asString , ' for character value ' 					, aCharacter asInteger printStringOld;		character: aCharacter;		raiseSignal.	^Character illegalCode asCharacter</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="Kernel-Objects" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	"The default behavior is to create a Notifier containing the 	appropriate message and to allow the user to open a Debugger. 	Subclasses can override this message in order to modify this behavior."	| excpt resumeValue |	excpt := Object messageNotUnderstoodSignal newException.	excpt		searchFrom: thisContext;		parameter: aMessage;		messageText: [| selectorString |			selectorString :=				[aMessage selector printStringOld]					on: Error					do: [:ex |						ex return:							(#errSelectorNotPrintable &lt;&lt; #dialogs &gt;&gt; '** unprintable selector **')							expandMacros asString].			(#errNotUnderstood &lt;&lt; #dialogs &gt;&gt; 'Message not understood: &lt;1s&gt;')				expandMacrosWith: selectorString];		originator: self;		makeSureResumable.	resumeValue := excpt raiseSignal.	^excpt reachedDefaultHandler		ifTrue: [self perform: aMessage selector withArguments: aMessage arguments]		ifFalse: [resumeValue]	"3 zork."</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Kernel-Objects" selector="displayString">displayString	"Allows any Object to be used as the basis for a Label, although the 	purpose of displayString is to provide something more suitable than 	printString, primarily for use in SequenceViews."	^self printStringOld</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Debugger-Support" selector="debugString">debugString	^self printStringOld</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Kernel-Objects" selector="printOn:">printOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."        | title |        title := self class printStringOld.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body></methods><methods><class-id>Core.Object</class-id> <category>tt-utilities</category><body package="Store-Base" selector="textRepresentation">textRepresentation	^self printStringOld.</body></methods><methods><class-id>Core.BehaviorShell</class-id> <category>printing</category><body package="Kernel-Classes" selector="printOn:">printOn: aStream 	"Append to the argument aStream a statement of which	superclass the receiver descends from."	aStream nextPutAll: (#aDescendentOf1s &lt;&lt; #dialogs &gt;&gt; 'a descendent of &lt;1s&gt;'		expandMacrosWith: self superclass printStringOld).</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="GlorpExtensions" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	"Print the date in ISO format. 'yyyy-mm-dd'  Don't rely on any dialect-specific formatting or padding mechanisms"	| monthString dayString |	aCommand 		nextPut: $';		print: self year;		nextPut: $-.	monthString := self monthIndex printStringOld.	monthString size = 1 ifTrue: [aCommand nextPut: $0 ].	aCommand nextPutAll: monthString.	aCommand nextPut: $-.	dayString := self dayOfMonth printStringOld.	dayString size = 1 ifTrue: [aCommand nextPut: $0 ].	aCommand nextPutAll: dayString.	aCommand nextPut: $'.</body></methods><methods><class-id>Core.Integer</class-id> <category>printing</category><body package="Tools-Trippy" selector="asShortSizeInBytes">asShortSizeInBytes	| baseOneKilobyte sizeUnits toGo leadingDigitIndex answer |	sizeUnits := #('' 'B' 'K' 'M' 'G' 'T').	self &lt; 0 ifTrue: [^'-', self negated asShortSizeInBytes].	self = 0 ifTrue: [^self printStringOld, (sizeUnits at: 2)]. 	baseOneKilobyte := Array new: sizeUnits size.	baseOneKilobyte at: 1 put: 0.	toGo := self.	2 to: sizeUnits size do:		[:each |			baseOneKilobyte at: each put: (toGo bitAnd: 1023).			toGo := toGo bitShift: -10		].	toGo &gt; 0 ifTrue: [baseOneKilobyte at: sizeUnits size put: toGo * 1024 + (baseOneKilobyte at: sizeUnits size)].	leadingDigitIndex := baseOneKilobyte findLast: [:one | one &gt; 0].	leadingDigitIndex = 0 ifTrue: [leadingDigitIndex := baseOneKilobyte size].	answer := String new writeStream.	(baseOneKilobyte at: leadingDigitIndex) printOn: answer.	leadingDigitIndex &gt; 2 ifTrue:		[			answer nextPut: $..			((baseOneKilobyte at: leadingDigitIndex - 1) * 100 // 1024)				printOn: answer paddedWith: $0 to: 2 base: 10		].	answer nextPutAll: (sizeUnits at: leadingDigitIndex).	^answer contents</body></methods><methods><class-id>Core.TimestampPrintPolicy</class-id> <category>accessing</category><body package="Internationalization" selector="tokenProcessingDispatchTable">tokenProcessingDispatchTable	"set up the code blocks to be executed in order to process tokens"	tokenProcessingDispatchTable == nil		ifFalse: [^tokenProcessingDispatchTable].	tokenProcessingDispatchTable := IdentityDictionary new.	tokenProcessingDispatchTable		at: $y			put: 				[:out :timestamp :token |				| yearString |				yearString := timestamp year printStringOld.				token numericModifier = 2					ifFalse: 						[NumberPrintPolicy							print: yearString asNumber							on: out							using: (token padding ifTrue: ['???0'] ifFalse: ['###0'])]					ifTrue: 						[yearString := yearString									copyFrom: yearString size - token numericModifier + 1									to: yearString size.						NumberPrintPolicy							print: yearString asNumber							on: out							using: '00']];		at: $b			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp month					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $B			put: 				[:out :timestamp :token |				| monthFormatMapping |				monthFormatMapping := #(2 1 3).	"Order of month formats accessed by allMonthNames, mapped to format modifiers"				out					nextPutAll: ((self allMonthNames							at: (monthFormatMapping at: token numericModifier)) at: timestamp month)];		at: $d			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp day					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $A			put: 				[:out :timestamp :token |				out nextPutAll: ((self allWeekdayNames at: token numericModifier)							at: timestamp asDate weekdayIndex)];		at: $h			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp hours					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $m			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp minutes					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $s			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp seconds					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $n			put: 				[:out :timestamp :token |				| millisecondFormat |				token padding					ifTrue: 						[millisecondFormat := String new: token numericModifier + 2 withAll: $?]					ifFalse: 						[millisecondFormat := String new: token numericModifier + 2 withAll: $0].				millisecondFormat at: 2 put: $..				out					nextPutAll: ((NumberPrintPolicy print: timestamp milliseconds / 1000							using: millisecondFormat) copyFrom: 3 to: millisecondFormat size)];		at: $p			put: 				[:out :timestamp :token |				"AM/PM"				timestamp hours &gt; 11					ifTrue: [out nextPutAll: (longAmPm at: 2)]					ifFalse: [out nextPutAll: (longAmPm at: 1)]];		at: $j			put: 				[:out :timestamp :token |				"day of year"				NumberPrintPolicy					print: timestamp dayOfYear					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $i			put: 				[:out :timestamp :token |				"hour (1 to 12)"				| iHour |				iHour := timestamp hours.				timestamp hours &gt; 12					ifTrue: [iHour := timestamp hours - 12]					ifFalse: [timestamp hours = 0 ifTrue: [iHour := 12]].				NumberPrintPolicy					print: iHour					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $k			put: 				[:out :timestamp :token |				"hour (0 to 11)"				| kHour |				kHour := timestamp hours.				timestamp hours &gt; 11 ifTrue: [kHour := timestamp hours - 12].				NumberPrintPolicy					print: kHour					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $l			put: 				[:out :timestamp :token |				"hour (1 to 24)"				| lHour |				lHour := timestamp hours.				timestamp hours = 0 ifTrue: [lHour := 24].				NumberPrintPolicy					print: lHour					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $Z			put: 				[:out :timestamp :token |				"Format code currently unsupported."				];		at: $Y			put: 				[:out :timestamp :token |				"year of week of year (ISO) - currently not supported"				];		at: $w			put: 				[:out :timestamp :token |				"week of year"				NumberPrintPolicy					print: (self weekOfYear: timestamp)					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $f			put: 				[:out :timestamp :token |				"week of month - not yet supported"				out error: #noWeekOfMonth &lt;&lt; #dialogs &gt;&gt; 'week of month is not supported'];		at: $a			put: 				[:out :timestamp :token |				"weekday (numeric)"				| dayOfWeek |				dayOfWeek := timestamp asDate weekdayIndex.	"Date class: Monday =1 Sunday=7"	"Convert to Sunday=1 ... Saturday=7 scheme."				dayOfWeek = 7					ifTrue: [dayOfWeek := 1]					ifFalse: [dayOfWeek := dayOfWeek - 1].				dayOfWeek = 0 ifTrue: [dayOfWeek := 1].				NumberPrintPolicy					print: dayOfWeek					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $c			put: 				[:out :timestamp :token |				"milliseconds in day"				(timestamp isKindOf: Timestamp)					ifTrue: 						["Not supported for Dates or Times, which do not contain enough information to resolve to milliseconds."						NumberPrintPolicy							print: timestamp asMilliseconds							on: out							using: (String new: token numericModifier									withAll: (token padding ifTrue: [$?] ifFalse: [$0]))]];		at: $z			put: 				[:out :timestamp :token |				"time zone - currently not supported"				];		at: $G			put: 				[:out :timestamp :token |				"Era - currently not supported"				];		at: $g			put: 				[:out :timestamp :token |				"Modified Julian day - Currently not supported"				];		at: $u			put: 				[:out :timestamp :token |				"currently not supported"				];		at: $r			put: 				[:out :timestamp :token |				"time zone (RFC822) - currently not supported"				].	^tokenProcessingDispatchTable</body></methods><methods><class-id>Core.Number</class-id> <category>printing</category><body package="GlorpVWPort" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	"VisualWorks has this unpleasant habit of appending characters to anything float-like that's not actually an instance of Float, 	which happens way down in the guts of the printing, so it's hard to avoid. 	This seems to be the only reasonable way to work around it without resorting to inefficient and non-portable print policies.	In addition, the exponent character, d, is more universally understood as e."	| basic real |	basic := self printStringOld.	real := basic last isDigit				ifTrue: [basic]				ifFalse: [basic copyFrom: 1 to: basic size - 1].	real := real asLowercase copyReplaceAll: 'd' with: 'e'.	aCommand nextPutAll: real</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>checking head</category><body package="Headless" selector="dumpStackToTranscriptBasic:label:">dumpStackToTranscriptBasic: aContext label: aString	"Dump a stack trace to the Transcript starting at aContext."	self stackDumpStream 		cr;		nextPutAll: '---------------------------------------------------'; cr;		nextPutAll: aString printStringOld;		cr;		nextPutAll: aContext printStack;		nextPutAll: '---------------------------------------------------'; cr;		flush</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>checking head</category><body package="Headless" selector="dumpStackToTranscriptUsingRTPDumper:label:">dumpStackToTranscriptUsingRTPDumper: aContext label: aString	"Dump a stack trace to the Transcript starting at aContext using the Runtime Packager's runtime facilities. Refer to them using a string so that we don't encourage the tracing mechanism to include them if it wouldn't otherwise do so."	| rtpDumper dumper |	rtpDumper := Smalltalk at: 'RuntimePackager.RuntimeFullDumper' ifAbsent: [^false].	self stackDumpStream cr; show: aString printStringOld.	[dumper := rtpDumper new.	dumper dumpStream: self stackDumpStream.	dumper dumpExceptionReport: nil context: aContext]		on: Error do: [:ex | self dumpStackToTranscriptBasic: ex initialContext label: 'error printing stack: ', ex description asString. ^false].	^true.</body></methods><methods><class-id>Core.Stream</class-id> <category>fileOut</category><body package="Collections-Streams" selector="timeStamp">timeStamp	"Append the current time to the receiver as a chunk."	| aStream |	aStream := WriteStream on: (String new: 16).	SystemUtils timeStamp: aStream.	self nextChunkPut: aStream contents printStringOld.	"double quotes and !s"	self cr; cr</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleStreamPositionOutOfBounds">exampleStreamPositionOutOfBounds	"Signal when you set position out of bounds of the stream. 	The handler resets position to half the size of the position."	"Exception exampleStreamPositionOutOfBounds"	| stream pos |	stream := ReadStream with: #(ua ba twa jal klm).	pos := 24.	[stream position: pos]		on: stream class positionOutOfBoundsSignal 		do: [:ex | pos := ex parameter. pos := pos // 2. 				Transcript cr; show: pos printStringOld.				ex retry].	Transcript cr; show: stream next</body></methods><methods><class-id>Core.Exception class</class-id> <category>private-examples</category><body package="Examples" selector="clientA">clientA	| v |	#('2' 7 5.5 -4 'abc' '1.5 ') do:		[:index | 		[v := self clientB: index.		Transcript cr; show: v printStringOld]			on: Object notFoundSignal			do: [:ex | 				Transcript show: (#NotFound &lt;&lt; #examples &gt;&gt; ' not found.').				ex return]]</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleCollectionAt">exampleCollectionAt	"Access a collection out-of-bounds and catch the error."	"Exception exampleCollectionAt"	| collection var |	collection := OrderedCollection new.	1 to: 10 do: [:i | collection add: i].	 [ 1 to: 20 do: 		[ :i | 		var := collection at: i.		Transcript space; show: var printStringOld		]	] on: Collection indexNotFoundSignal do:		[:ex | 		Transcript cr; show: (#ExceededCollectionSize &lt;&lt; #examples &gt;&gt; 'Exceeded collection size').		ex return		].</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleStreamNextPastEnd">exampleStreamNextPastEnd	"Signal reading past the end of the stream.	Exception handling removes checking for EOF every time 	in the main loop as in the following conventional code:		[fileStream atEnd] whileFalse:		[Transcript show: fileStream next printString].or 	[(char := fileStream next) == nil] whileFalse:		[Transcript show: char printString]"	"Exception exampleStreamNextPastEnd"	| fileStream fileName |	fileStream := (fileName := Filename named: 'tempFile') writeStream.	fileStream nextPutAll: 'ua jal twa ba klm'.	fileStream close.	fileStream := fileName readStream.	[[Transcript show: fileStream next printStringOld] repeat]		on: fileStream class endOfStreamSignal		do: [:ex | fileStream close.				ex return].	fileName delete</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleUserInterruptSignal">exampleUserInterruptSignal	"Control-Y causes a pause for one second."	"Exception exampleUserInterruptSignal"	[1 to: 100 do: 				[:i | Transcript show: ' ', i printStringOld]]		on: Object userInterruptSignal		do: [:ex | (Delay forSeconds: 1) wait.						ex resume]</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleDivideByZeroAbort">exampleDivideByZeroAbort	"Exception exampleDivideByZeroAbort"	-2.0 to: 2.0 do: 		[ :i |		[ 10.0 / i. Transcript cr; show: i printStringOld ]			on: Number divisionByZeroSignal do:				[ :ex | Transcript cr; show: (#divideByZeroAbort &lt;&lt; #examples &gt;&gt; 'divideByZero abort'). 				ex return ]		].</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleDictionaryAt">exampleDictionaryAt	"Signal reading at non-existing key. The handler creates the key	and restarts to read at the key."	"Exception exampleDictionaryAt"	| aDictionary value |	aDictionary := Dictionary new.	aDictionary at: #C put: $c.	[value := aDictionary at: #A] on: Dictionary keyNotFoundSignal		do: [ :ex | aDictionary at: #A put: $a. ex retry ].	Transcript cr; show: ((#x1sIn2s &lt;&lt; #examples &gt;&gt; '&lt;1s&gt; in &lt;2s&gt;')			expandMacrosWith: value printStringOld			with: aDictionary printStringOld)</body></methods><methods><class-id>Core.Exception class</class-id> <category>private-examples</category><body package="Examples" selector="clientB:">clientB: index	| hc |	hc := HandlerList new.	hc on: Object indexNotFoundSignal 		handle: [:ex | Transcript cr; show: 'index: ', ex parameter printStringOld.				ex pass].	hc on: Dictionary keyNotFoundSignal		handle: [:ex | Transcript cr; show: 'key: ', ex parameter printStringOld.				ex pass].	hc handleDo: [ ^self clientC: index ]</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleSignalCollection">exampleSignalCollection	"Signal sig1 and sig2 are caught by the handler,	but signal sig3 is not caught and a Notifier view 	shows up." 	"Exception exampleSignalCollection"	| sig1 sig2 sig3 sc |	sig1 := Signal new notifierString: (#sig1 &lt;&lt; #examples &gt;&gt; 'sig1').	sig2 := Signal new notifierString: (#sig2 &lt;&lt; #examples &gt;&gt; 'sig2').	sig3 := Signal new notifierString: (#sig3 &lt;&lt; #examples &gt;&gt; 'sig3').	sc := SignalCollection new.	sc add: sig1; add: sig2.	[sig1 raise] 		on: sc 		do: [:ex | Transcript cr; show: ex signal printStringOld].	[sig2 raise]		on: sc 		do: [:ex | Transcript cr; show: ex signal printStringOld].	[sig3 raise]		on: sc 		do: [:ex | Transcript cr; show: ex signal printStringOld].</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="Kernel-Classes" selector="printSubclassesOn:level:">printSubclassesOn: aStream level: level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| subs |	aStream crtab: level.	aStream print: self.	aStream space; nextPut: $(.	self instVarNames		do: [:aName | aStream print: aName]		separatedBy: [aStream space].	aStream nextPut: $).	subs := self subclasses.	self == Class ifTrue:		[aStream crtab: level+1; nextPutAll: (#AllTheMetaclasses &lt;&lt; #dialogs &gt;&gt; '... all the Metaclasses ...') asString.		subs := subs reject: [:sub | sub isMeta]].	"Print subclasses in alphabetical order"	(subs asSortedStrings:			[:p :x :y | | collation |			(collation := p collate: x name to: y name) &lt; 0			or: [collation = 0				and: [x == y or: [(p collate: x printStringOld to: y printStringOld) &lt;= 0]]]]) do:		[:sub |		sub printSubclassesOn: aStream level: level + 1]</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="Kernel-Classes" selector="printSubclassesWithStaticsOn:level:">printSubclassesWithStaticsOn: aStream level: level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| subs |	aStream crtab: level.	aStream print: self.	aStream space; nextPut: $(.	self asNameSpace keys		do: [:aName | aStream print: aName]		separatedBy: [aStream space].	aStream nextPut: $).	subs := self subclasses.	self == Class ifTrue:		[aStream crtab: level+1; nextPutAll: (#AllTheMetaclasses &lt;&lt; #dialogs &gt;&gt; '... all the Metaclasses ...') asString.		subs := subs reject: [:sub | sub isMeta]].	"Print subclasses in alphabetical order"	(subs asSortedStrings:			[:p :x :y | | collation |			(collation := p collate: x name to: y name) &lt; 0			or: [collation = 0				and: [x == y or: [(p collate: x printStringOld to: y printStringOld) &lt;= 0]]]]) do:		[:sub |		sub printSubclassesWithStaticsOn: aStream level: level + 1]</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing instances and variables</category><body package="Kernel-Classes" selector="instVarNames">instVarNames	"Answer an Array of the instance variable names.  Behaviors must make up fake	local instance variable names because Behaviors have instance variables for the	purpose of compiling methods, but these are not named instance variables.  "	| mySize superSize |	mySize := self instSize.	superSize := 		superclass == nil			ifTrue: [0]			ifFalse: [superclass instSize].	mySize = superSize ifTrue: [^#()].		^(superSize + 1 to: mySize) collect: [:i | 'inst' , i printStringOld]</body></methods><methods><class-id>Core.Behavior</class-id> <category>printing</category><body package="Kernel-Classes" selector="printOn:">printOn: aStream 	"Append to the argument aStream a statement of which	superclass the receiver descends from."	aStream nextPutAll: (#aDescendentOf1s &lt;&lt; #dialogs &gt;&gt; 'a descendent of &lt;1s&gt;'		expandMacrosWith: superclass printStringOld).</body></methods><methods><class-id>Core.Behavior class</class-id> <category>class creation</category><body package="Kernel-Classes" selector="formatFromType:super:instVars:">formatFromType: classBehaviorType super: superclassOfNew instVars: instVars	"Answer the value of the format word for a class with the	 given behavior type, instance variables and superclass."	| superclassBehaviorType behaviorType formatInteger vars |	superclassBehaviorType := superclassOfNew == nil										ifTrue: [#none]										ifFalse: [superclassOfNew behaviorType].	behaviorType := (self isType: classBehaviorType						legalSubclassTypeForSuperclassType: superclassBehaviorType)			ifTrue: [classBehaviorType]			ifFalse: [(self isType: classBehaviorType					promotableSubclassTypeForSuperclassType: superclassBehaviorType)				ifTrue: [superclassBehaviorType]				ifFalse: [self error: (#InvalidSubclassType &lt;&lt; #dialogs &gt;&gt; 'Invalid subclass behavior type for this superclass')]].	formatInteger := behaviorType = #none ifTrue: [PointersMask]			ifFalse: [behaviorType = #objects ifTrue: [PointersMask+IndexableMask]			ifFalse: [behaviorType = #bytes ifTrue: [IndexableMask]			ifFalse: [behaviorType = #weak ifTrue: [PointersMask+IndexableMask+WeakMask]			ifFalse: [behaviorType = #ephemeron ifTrue: [PointersMask+EphemeronMask]			ifFalse: [behaviorType = #immediate ifTrue: [0]			ifFalse: [self illegalBehaviorType]]]]]].	vars := superclassOfNew == nil			ifTrue: [#()]			ifFalse: [superclassOfNew allInstVarNames].	vars := vars, instVars.	((formatInteger noMask: PointersMask) and: [vars size &gt; 0]) ifTrue:		[self error: ((#InstVarsNotPermittedHere &lt;&lt; #dialogs &gt;&gt; 'A Class of type &lt;1s&gt; cannot have instance variables.')			expandMacrosWith: behaviorType)].	((formatInteger anyMask: EphemeronMask) and: [vars size = 0]) ifTrue:		[self error: ((#RequireAnInstVar &lt;&lt; #dialogs &gt;&gt; 'A Class of type &lt;1s&gt; must have at least one instance variable.')			expandMacrosWith: behaviorType)].	vars size &gt; FixedFieldsMask ifTrue:		[self error: ((#TooManyInstVars &lt;&lt; #dialogs &gt;&gt; 'A Class cannot have a total of more than &lt;1s&gt; instance variables.')			expandMacrosWith: FixedFieldsMask printStringOld)].	^formatInteger + vars size</body></methods><methods><class-id>Core.Behavior class</class-id> <category>class creation</category><body package="Kernel-Classes" selector="illegalBehaviorType">illegalBehaviorType	"Raise an error for an invalid behavior type"	self error: ((#ClassTypeMustConform &lt;&lt; #dialogs &gt;&gt; 'Class type must be one of &lt;1s&gt;')			expandMacrosWith: (LegalSubclassTypeMap keys asArray printStringOld						copyReplaceAll: '#(' with: '('))</body></methods><methods><class-id>Core.Signal</class-id> <category>accessing</category><body package="Kernel-Exception Handling" selector="errorStringExtra:with:">errorStringExtra: extraString with: parameter	"Answer the string for a Notifier, including the parameter if relevant. "	| errorString |	errorString := self errorStringExtra: extraString.	^(errorString notNil and: [errorString isEmpty not and: [errorString last = Character space]])		ifTrue: [errorString , parameter printStringOld]		ifFalse: [errorString]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>binary storage</category><body package="BOSS" selector="binaryReaderBlockForVersion:format:">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones.	The block's return value will be ignored.  The block	should use some means like #become: or #changeClassToThatOf:	to change the identity of the block's argument to an instance	of the class"	" By default, classes do not know how to do this. "	self error: 'Attempt to read incompatible version ', oldVersion printStringOld, ' with format = ', oldFormat printStringOld, ' of ', self printStringOld.	^[:oldObj | self error: 'Attempt to create instance of old version!'.  self new]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>organization</category><body package="Kernel-Classes" selector="logOrganizationChange">logOrganizationChange	"Record that the receiver is being reorganized on the changes file."	SourceFileManager default logChange:			self storeString,			' reorganizeFromString: ',			self organization printStringOld storeString</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>copying</category><body package="Kernel-Classes" selector="copy:from:classified:">copy: sel from: class classified: cat 	"Install the method associated with the first argument, sel, a message selector,	found in the method dictionary of the second argument, class, as one of the	receiver's methods.  Classify the message under the third argument, cat."	| code category |	"Useful when modifying an existing class"	code := class sourceMethodAt: sel.	code == nil		ifFalse: 			[cat == nil				ifTrue: [category := class organization categoryOfElement: sel]				ifFalse: [category := cat].			(methodDict includesKey: sel)				ifTrue: [code asString = (self sourceMethodAt: sel) asString 							ifFalse: [self notify: ((#MethodWillBeRedefined &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; &lt;2s&gt; will be redefined if you proceed.')			expandMacrosWith: self printStringOld			with: sel)]].			self compile: code classified: category]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>binary storage</category><body package="Kernel-Classes" selector="shapeChangeFrom:for:">shapeChangeFrom: importMap for: aCodeReader	"The receiver has changed shape on loading from a parcel file.	 Attempt to update its format (and soleInstance) appropriately.	 There are three formats to handle...		a) the original pre-version 6 formats have no shape-change info.  Just fail.		b) formats 6 though 9 have shape-change info after the book-keeping info		c) formats 10 onwards have the info before book-keeping.	 We assume that book-keeping has read-in valid inst var contents into	 a class that possibly has too many inst vars.  So no re-arrangement	 has to be done.  However, we may have to shorten the instance."	| storedInstVars newClass |	(aCodeReader fileFormat &lt; 6	or: [instanceVariables size &gt; 0		and: [| scivs | 			scivs :=  superclass allInstVarNames.			instanceVariables contains: [:ivn| scivs includes: ivn]]]) ifTrue:		[^CodeReader invalidClassFormatSignal			raiseWith: self fullName			errorString: ((#incompatible2s1sClassFormatForSystem &lt;&lt; #dialogs &gt;&gt; 'While Loading Parcel &lt;2s&gt;, the format of the class &lt;1s&gt; was found to be incompatible with its format in the system.')				expandMacrosWith: self printStringOld				with: aCodeReader parcelName)].	storedInstVars := importMap at: 2.	storedInstVars size &gt; self instSize ifTrue:		[newClass := self basicNew.		1 to: self instSize do:			[:i| newClass instVarAt: i put: (thisClass instVarAt: i)].		newClass become: thisClass]</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="Store-Image Objects" selector="textRepresentationDataAt:">textRepresentationDataAt: aDataKey	"Answer text for aDataKey"		^(self dataAt: aDataKey ifAbsent: [^(#twoStarUnresolvedTwoStar &lt;&lt; #store &gt;&gt; '**Unresolved**') asText]) printStringOld asText</body></methods><methods><class-id>Core.Class</class-id> <category>binary storage</category><body package="Kernel-Classes" selector="shapeChangeFrom:for:">shapeChangeFrom: importMap for: aCodeReader	"The receiver has changed shape on loading from a parcel file.	 Attempt to update its format appropriately."	(self isBits	or: [instanceVariables size &gt; 0		and: [| scivs | 			scivs :=  superclass allInstVarNames.			instanceVariables contains: [:ivn| scivs includes: ivn]]]) ifTrue:		[CodeReader invalidClassFormatSignal			raiseWith: self fullName			errorString: ((#incompatible2s1sClassFormatForSystem &lt;&lt; #dialogs &gt;&gt; 'While Loading Parcel &lt;2s&gt;, the format of the class &lt;1s&gt; was found to be incompatible with its format in the system.')				expandMacrosWith: self printStringOld				with: aCodeReader parcelName)].	format := (format bitAnd: FixedFieldsMask bitInvert)				bitOr: self allInstVarNames size</body></methods><methods><class-id>Core.Class</class-id> <category>class name</category><body package="Kernel-Classes" selector="renameReferencesFrom:">renameReferencesFrom: oldNameString	"The old name of the receiver is the argument, oldNameString.	Change all references in the system from the old name	to the new (current) one."	| oldName ref |	oldName := oldNameString asSymbol.	ref := self environment bindingFor: oldName.	ref == nil ifTrue: [ref := self environment bindingFor: self name].	SystemUtils allBehaviorsDo:		[:b | | meths |		meths := b whichSelectorsReferTo: ref.		meths size &gt; 0			ifTrue: [meths do:						[:sel | | s cat pos |						s :=  b sourceCodeAt: sel.						cat := b whichCategoryIncludesSelector: sel.						Transcript cr; show: b printStringOld , ' (' , cat , ') ' , '&gt;&gt; ' , sel.						pos := Compiler preferredParserClass new							scanPositionsFor: oldName							inString: s.						pos reverseDo:							[:p |							s := s copyReplaceFrom: p								to: p + oldName size - 1								with: name].						b compile: s classified: cat]]].</body></methods><methods><class-id>Core.Class</class-id> <category>fileIn/Out</category><body package="XML-source" selector="xmlDefinition:onto:">xmlDefinition: anXMLFormatter onto: aStream	| extra |	^anXMLFormatter		on: aStream 		tag: 'class' 		do: 			[:xmlFormatter :stream | 			| superclassName private |			xmlFormatter on: stream cr tag: 'name' value: self name.			xmlFormatter on: stream cr tag: 'environment' value: self environment fullName.			superclassName := self superclass isNil				ifTrue: ['']				ifFalse: [(self isAbsentClass ifTrue: [self absentSuperclass] ifFalse: [self superclass]) fullName].			xmlFormatter on: stream cr tag: 'super' value: superclassName.			private := self environment bindingFor: self name.			private := private isNil ifTrue: [false] ifFalse: [private isPrivate].			xmlFormatter on: stream cr tag: 'private' value: private printStringOld.			xmlFormatter on: stream cr tag: 'indexed-type' value: self behaviorType.			xmlFormatter on: stream cr tag: 'inst-vars' value: self instanceVariablesString.			xmlFormatter on: stream cr tag: 'class-inst-vars' value: self class instanceVariablesString.			xmlFormatter on: stream cr tag: 'imports' value: self asNameSpace importString.			xmlFormatter on: stream cr tag: 'category' value: self category asString.			extra := self extraAttributesForDefinition.			extra isEmpty ifFalse: 				[xmlFormatter on: stream cr tag: 'attributes' do: 					[:innerXMLFormatter :innerStream |					extra do: 						[:each |						(each last isKindOf: Array)							ifTrue: [innerXMLFormatter on: innerStream cr tag: each first do: 								[:extraItemsXMLFormatter :extraItemsStream |								each last do: [:eachItems | extraItemsXMLFormatter on: extraItemsStream tag: 'item' encodeLiteral: eachItems] separatedBy: [extraItemsStream space]]]							ifFalse: [innerXMLFormatter on: innerStream cr tag: each first value: each last displayString]].						stream cr]].			stream cr]</body></methods><methods><class-id>Core.Class</class-id> <category>pool variables</category><body package="Kernel-Classes" selector="removeSharedPool:">removeSharedPool: aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool dictionaries.	Create an error if the dictionary is not one of the pools."	| satisfiedSet |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: (#RemovedImportNotPresent &lt;&lt; #dialogs &gt;&gt; 'the dictionary is not in my pool')].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet := Set with: self with: self class.	satisfiedSet do: 		[:sub | 		aDictionary bindingsDo: 			[:aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: ((#ImportedVariableStillUsed &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; is still used in code of class &lt;2s&gt;')			expandMacrosWith: aGlobal key			with: sub printStringOld)]]].	self setSharedPools: (self sharedPools remove: aDictionary; yourself).</body></methods><methods><class-id>Core.Message</class-id> <category>compilation</category><body package="Debugger-Support" selector="methodStubSource">methodStubSource	"Return a String of a method body for the message which contains a single self halt statement."	"nil zork" "nil zork: 1" "nil zork: 1 zork: $1" "nil zork: 1 zork: 1 zork: 1"	| str na |	str := (String new: 1024) writeStream.	(na := args size) = 0		ifTrue: [str nextPutAll: selector]		ifFalse:			[| argNames |			argNames := OrderedCollection new: na.			args				with: selector keywords				do:	[:arg :keyword| | argName |					argName := ((arg isBehavior											ifTrue: ['a', arg basicPrintString]											ifFalse: [arg basicPrintString]) copyWithout: Character space) copyWithout: $. .					(argNames includes: argName) ifTrue:						[| newName n |						n := 2.						[newName := argName, n printStringOld.						argNames includes: newName]							whileTrue: [n := n + 1].						argName := newName].					argNames add: argName.					str nextPutAll: keyword; space; nextPutAll: argName.					str space]].	str crtab; nextPutAll: 'self halt'.	^str contents	"(Message			selector: #with:with:			arguments: (Array with: Store.PackageModel with: Store.PackageModel)) methodStubSource"</body></methods><methods><class-id>Core.VariableBinding</class-id> <category>printing</category><body package="PackageCategories" selector="definitionString">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineSharedVariable: #';		nextPutAll: self key;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: self isPrivate printStringOld;		cr;		tab;		nextPutAll: 'constant: ';		nextPutAll: self isConstant printStringOld;		cr;		tab;		nextPutAll: 'category: ';		nextPutAll: self category asString printStringOld;		cr;		tab;		nextPutAll: 'initializer: '.	self method isNil 		ifTrue: [definitionStream nextPutAll: 'nil']		ifFalse: [definitionStream nextPutAll: self method getSource printStringOld].	^definitionStream contents</body></methods><methods><class-id>Core.ConstantAccessor</class-id> <category>printing</category><body package="System-Dependency Events" selector="printOn:">printOn: aStream	"Append the ASCII representation of the receiver to &lt;aStream&gt;."	self class printOn: aStream.	aStream nextPutAll: ' (', object printStringOld, ')'</body></methods><methods><class-id>Core.ErrorDumper</class-id> <category>dumping-support</category><body package="ErrorNotifier" selector="saveDateTimeStrings">saveDateTimeStrings	"Save the current date and time for printing.	Date/time printString is avoided due to	the potential impact of internationalization.	Hopefully no one is tinkering with printString."	"self contained date conversion (once again)"	| now dateNow timeNow |	now := Date dateAndTimeNow.	dateNow := now at: 1.	timeNow := now at: 2.	dumpDate := dateNow year printStringOld, '/',		dateNow monthIndex printStringOld, '/',		dateNow dayOfMonth printStringOld.	dumpTime := timeNow hours printStringOld, ':',		( timeNow minutes &lt; 10			ifTrue: [ '0', timeNow minutes printStringOld ]			ifFalse: [ timeNow minutes printStringOld ] ), ':',		( timeNow seconds &lt; 10			ifTrue: [ '0', timeNow seconds printStringOld ]			ifFalse: [ timeNow seconds printStringOld ] )</body></methods><methods><class-id>Core.ErrorDumper</class-id> <category>dumping-support</category><body package="ErrorNotifier" selector="dumpValue:maxSize:">dumpValue: aValue maxSize: aNumber	"Write a description of a value onto the dump"	| valueString |	" Get the printString with some error protection"	[ valueString := aValue printStringOld ]		on: Error		do: [ :ex |			valueString := '--Error printing object of class ', aValue class printStringOld. ].	" Trim the size of the printString to something reasonable"	valueString size &gt; aNumber ifTrue: [		valueString := ( valueString copyFrom: 1 to: aNumber - 3 ), '...' ].	dumpStream		nextPutAll: '(id=';		print: aValue identityHash;		nextPutAll: ') ';		nextPutAll: valueString.</body></methods><methods><class-id>Core.EncodedStream class</class-id> <category>testing</category><body package="Collections-Streams" selector="readWriteTestWith:">readWriteTestWith: aStreamEncoder	"Test EncodedStream with aStreamEncoder by reading and writing	 ``/s/st/src/converters/jis-unicode.map'' file."	| mapFile tmpFile si ucode jcode |	mapFile := '/s/st/src/converters/jis-unicode.map' asFilename withEncoding: #JapaneseEUC.	tmpFile := 'jis-unicode.tmp' asFilename withEncoding: aStreamEncoder streamEncodingType.	"copy mapFile to tmpFile in different encoding"	Transcript cr; show: ((#CopyingWith1s &lt;&lt; #dialogs &gt;&gt; 'Copying with &lt;1s&gt;...')			expandMacrosWith: aStreamEncoder printStringOld).	mapFile copyTo: tmpFile.	Transcript show: (#done &lt;&lt; #dialogs &gt;&gt; 'done').	"read again and check character"	Transcript cr; show: ((#CheckingWith1s &lt;&lt; #dialogs &gt;&gt; 'Checking with &lt;1s&gt;...')			expandMacrosWith: aStreamEncoder printStringOld).	si := tmpFile readStream.	[(ucode := self nextHexa: si) isNil]		whileFalse: [			jcode := self nextHexa: si.			jcode notNil ifTrue: [				si next asInteger == ucode					ifFalse: [Transcript show: (#failed &lt;&lt; #dialogs &gt;&gt; 'failed.').						    ^false]]].	Transcript show: (#ok &lt;&lt; #dialogs &gt;&gt; 'ok').	"skip: -1 test"	Transcript show: ((#SkipTestWith1s &lt;&lt; #dialogs &gt;&gt; 'Skip Test with &lt;1s&gt;...')			expandMacrosWith: aStreamEncoder printStringOld).	si reset.	[(ucode := si next) isNil]		whileFalse: [			si skip: -1.			si next == ucode				ifFalse: [Transcript show: (#failed &lt;&lt; #dialogs &gt;&gt; 'failed.'); cr.					    ^false]].	si close.	Transcript show: (#ok &lt;&lt; #dialogs &gt;&gt; 'ok'); cr.	tmpFile delete.	^true</body></methods><methods><class-id>Core.CollectionAccessor</class-id> <category>printing</category><body package="System-Dependency Events" selector="printOn:">printOn: aStream	"Append the ASCII representation of the receiver to aStream."	self class printOn: aStream.	aStream nextPutAll: ' (', elementName printStringOld, ')'</body></methods><methods><class-id>Core.NumberPrintPolicy</class-id> <category>private-printing</category><body package="Internationalization" selector="print:on:using:">print: number on: outputStream using: tokens	"Print the argument, number, according to the rules described in the format tokens. Answer the receiver. Consult the class comments for details on the contents of tokens."	| commaScalingFactor fractionLength decimalFieldWidth decimal float index fraction decimalPower doingFraction useThousandsSeparator exponentShift exponentLength shiftedNumber zero zeroCh allOptional |	(tokens == nil or: [tokens isEmpty]) ifTrue: [^String new].	zero := self zeroCode.	zeroCh := Character value: zero.	fractionLength := self fractionLengthFor: tokens.	decimalFieldWidth := self decimalFieldWidthFor: tokens.	useThousandsSeparator := self includesThousandsSeparatorFor: tokens.	commaScalingFactor := self commaScalingFactorFor: tokens.	shiftedNumber := number / commaScalingFactor.	doingFraction := false.	index := 1.	exponentShift := 0.	exponentLength := self exponentLengthFor: tokens.	(exponentLength ~~ nil and: [shiftedNumber isZero not])		ifTrue: 			[exponentShift := decimalFieldWidth - shiftedNumber abs log floor - 1.			shiftedNumber := shiftedNumber asDouble * (10 raisedTo: exponentShift)].	(tokens includes: #%) ifTrue: [shiftedNumber := shiftedNumber * 100].	float := shiftedNumber roundTo: (10 raisedTo: fractionLength negated).	decimal := float abs truncated.	fraction := float abs \\ 1.	decimalPower := decimal = 0				ifTrue: [0]				ifFalse: [0 max: decimal printStringOld size - 1].	[index &lt;= tokens size] whileTrue: 			[| token |			token := tokens at: index.			(token == #'#' or: [token == #'0' or: [token == #?]])				ifTrue: 					[decimalPower + 1 &lt; decimalFieldWidth						ifTrue: 							[token == #? ifTrue: [outputStream nextPut: Character space].							token == #'0' ifTrue: [outputStream nextPut: zeroCh].							index := index + 1.							decimalFieldWidth := decimalFieldWidth - 1.							(useThousandsSeparator								and: [decimalFieldWidth \\ groupingSize = 0 and: [token == #'0']])									ifTrue: [outputStream nextPut: self thousandsSeparator]]						ifFalse: 							[| num digit tmp |							doingFraction								ifTrue: 									[fraction := fraction * 10.									digit := fraction truncated.									fraction := fraction - digit.									index := index + 1.									(fraction == 0 and: [digit == 0])										ifTrue: 											[token == #'0' ifTrue: [outputStream nextPut: zeroCh].											token == #? ifTrue: [outputStream nextPut: Character space]]										ifFalse: [outputStream nextPut: (Character value: zero + digit)]]								ifFalse: 									[num := decimal // (10 raisedTo: decimalPower).									decimalPower := decimalPower - 1.									tmp := num // 10.									digit := num - (tmp * 10).									decimalPower + 1 &gt;= decimalFieldWidth										ifFalse: 											[index := index + 1.											decimalFieldWidth := decimalFieldWidth - 1].									(digit == 0 and: [decimal &lt;= 0 and: [(token == #'0') not]])										ifFalse: [outputStream nextPut: (Character value: zero + digit)]].							(useThousandsSeparator								and: [(decimalPower + 1) \\ groupingSize = 0 and: [decimalPower &gt; 0]])									ifTrue: [outputStream nextPut: self thousandsSeparator]]]				ifFalse: 					[token == #'.'						ifTrue: 							[index := index + 1.							(allOptional := fraction isZero)								ifTrue: 									[index to: index + fractionLength - 1										do: [:idx | (tokens at: idx) == #'#' ifFalse: [allOptional := false]]].							allOptional ifFalse: [outputStream nextPut: self decimalPoint].							doingFraction := true]						ifFalse: 							[token == #,								ifTrue: [index := index + 1]								ifFalse: 									[(token == #d or: [token == #e])										ifTrue: 											[decimalFieldWidth := exponentLength.											doingFraction := false.											decimal := exponentShift abs.											fraction := 0.											decimalPower := decimal = 0														ifTrue: [0]														ifFalse: [0 max: decimal printStringOld size - 1].											outputStream nextPut: token first.											(exponentShift isZero not and: [exponentShift positive])												ifTrue: [outputStream nextPut: $-].											index := index + 1]										ifFalse: 											[self printToken: token on: outputStream.											index := index + 1]]]]]</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-spin button</category><body package="Collections-Text" selector="incrementBy:boundedBy:">incrementBy: intervalValue boundedBy: aBlock	^(aBlock value: (self asNumber + intervalValue)) printStringOld</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-spin button</category><body package="Collections-Text" selector="decrementBy:boundedBy:">decrementBy: intervalValue boundedBy: aBlock	^(aBlock value: (self asNumber - intervalValue)) printStringOld</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-spin button</category><body package="UIBasics-Support" selector="spinBy:boundedBy:">spinBy: aNumber boundedBy: aBlock	"This API is used by spin box widgets to produce a new value adjusted by aNumber. The receiver is interpreted as if it were a number and then coerced back to a string. aBlock is a single arg block which can be used to condition/filter the (numerical) result."		^(aBlock value: self asNumber + aNumber) printStringOld</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private-dataset</category><body package="Database" selector="addColumnLabel:width:">addColumnLabel: aString width: aNumber	"Add a column to the dataset view. To go into effect, send &gt;&gt;invalidate to the dataset."	| columnCollection newColumn dataset columnSpec newColumnNumber aspectSymbol |	dataset := self datasetWidget.	columnCollection := dataset columnDescriptors asOrderedCollection.	columnSpec := columnCollection first description copyOld.	newColumnNumber := columnCollection size + 1.	aspectSymbol := ('selectedRow ', newColumnNumber printStringOld) asSymbol.	columnSpec				label: aString;				model: aspectSymbol;				width: aNumber.	newColumn := columnSpec columnWithBuilder: self builder.	columnCollection add: newColumn.	dataset columnDescriptors: columnCollection.</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private-dataset</category><body package="Database" selector="columnWidthsFromData:">columnWidthsFromData: rows	"Update the space needed for each column of data	by finding the longest entry of all rows for that column."	| datum maxColumnWidths |	maxColumnWidths := Array new: (rows first size) withAll: 0.	rows do: 			[:rowData |			1 to: rowData size				do: 					[:col |					| len |					datum := (rowData at: col) printStringOld trimBlanks.					len := datum asComposedText width + 10.					len &gt; (maxColumnWidths at: col) ifTrue: [maxColumnWidths at: col put: len]]].	^maxColumnWidths</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>accessing</category><body package="Database" selector="turnOnOEMEncoding">turnOnOEMEncoding	self encoding: OSSystemSupport concreteClass new GetOEMCP printStringOld asSymbol</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>accessing</category><body package="Database" selector="turnOffOEMEncoding">turnOffOEMEncoding	encoding == OSSystemSupport concreteClass new GetOEMCP printStringOld asSymbol ifTrue: [		self encoding: nil.		self encoding.	]</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>tracing</category><body package="Database" selector="trace:">trace: aStringOrNil	"Emit the standard trace header followed by aString (if not nil) into the trace log."	| header when sender depth |	TraceCollector == nil ifTrue: [ ^self ].	header := WriteStream on: (String new: 64).	when := Time dateAndTimeNow.	sender := thisContext sender.	depth := TraceLevel &gt; 4 ifTrue: [ TraceLevel - 4 ] ifFalse: [ 1 ].	"Emit a timestamp"	header		nextPutAll: '{';		"print: (when at: 1);"  nextPutAll: ((when at: 1) printFormat: #(1 2 3 $ 2 2));		nextPutAll: ' ';		print: (when at: 2);		nextPutAll: '} 	'.		"curly-brace, space and a tab"	"Emit a stack trace"	[ depth &gt; 0 ] whileTrue:		[ header			nextPutAll: sender mclass printStringOld;			nextPutAll: '&gt;&gt;';			nextPutAll: sender selector asString.		sender := sender sender.		(depth := depth - 1) &gt; 0 ifTrue:			[ header cr; tab: 6 ] ].	TraceSequencer critical:		[ TraceCollector nextPutAll: header contents; cr.		( aStringOrNil size &gt; 0 ) ifTrue:			[ TraceCollector tab; nextPutAll: aStringOrNil; cr ].		TraceCollector flush ]</body></methods><methods><class-id>Glorp.GlorpInvalidTypeError</class-id> <category>accessing</category><body package="GlorpMisc" selector="defaultMessageText">defaultMessageText	^'Object being written does not match the type of the attribute: ''', self object printStringOld,  ''' ~= ''' , self expectedType printStringOld, ''''.</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>fields</category><body package="GlorpDatabase" selector="addForeignKeyFrom:to:suffixExpression:">addForeignKeyFrom: sourceField to: targetField suffixExpression: suffixExpression	| newFK |	newFK := ForeignKeyConstraint					sourceField: sourceField					targetField: targetField					suffixExpression: suffixExpression.	newFK name: (newFK name , (foreignKeyConstraints size + 1) printStringOld).	foreignKeyConstraints add: newFK.	^newFK.</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>fields</category><body package="GlorpDatabase" selector="addForeignKeyFromAll:toAll:suffixExpression:">addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: suffixExpression	| newFK |	newFK := ForeignKeyConstraint					sourceFields: sourceFields					targetFields: targetFields					suffixExpression: suffixExpression.	newFK name: (newFK name , (foreignKeyConstraints size + 1) printStringOld).	^foreignKeyConstraints add: newFK.</body></methods><methods><class-id>Glorp.FixedSizeQueue</class-id> <category>printing</category><body package="GlorpCore" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	aStream nextPutAll: items size printStringOld.	aStream nextPut: $/.	aStream nextPutAll: maximumSize printStringOld.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>accessing</category><body package="GlorpQueries" selector="initializeQuery">initializeQuery	query := Query		read: localBase descriptor describedClass		where: rightChild.	query tablePrefix: ('s', localBase ultimateBaseExpression availableSubSelectNumber printStringOld, 't')."	query baseExpression: localBase."	query session: localBase descriptor session.	localBase descriptor tables do: [:eachTable |		eachTable primaryKeyFields do: [:each | query retrieve: [:base | base getField: each]]].</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	| w |	platform supportsVariableSizedNumerics ifFalse: [^typeString].	w := WriteStream on: String new.	w nextPutAll: typeString.	precision isNil 		ifFalse: 			[w nextPutAll: '(' , precision printStringOld.			scale isNil ifFalse: [w nextPutAll: ',' , scale printStringOld].			w nextPutAll: ')'].	^w contents</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	^self typeName, '(', width printStringOld, ')'.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>creating mappings</category><body package="GlorpMappings" selector="directMappingFor:">directMappingFor: attributeName	"Create a direct mapping from the attribute of this name to the field in the table with a matching name. For convenience when there's a good correspondence between the field and instance variable names."	| field |	self tables do: [:each |		field := each fieldNamed: attributeName ifAbsent: [nil] caseSensitive: false].	field isNil ifTrue: [self error: 'Cannot find field named ', attributeName printStringOld].	^self directMapping from: attributeName to: field.</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>converting</category><body package="GlorpQueries" selector="nullFieldFor:">nullFieldFor: eachField	self platform requiresCastsForNullsInUnions ifFalse: [^(ConstantExpression for: nil) alias: eachField table name, 'nullField', eachField position printStringOld].	^FunctionExpression		for: #cast:		withArguments: (Array with: (ConstantExpression for: eachField type))		basedOn: (ConstantExpression for: nil).</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>accessing</category><body package="GlorpMisc" selector="getVisualAgeMessageText">getVisualAgeMessageText		| tempTag |	tempTag := self basicTag.	^tempTag isNil ifTrue: [self printStringOld] ifFalse: [tempTag errorText].</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>accessing</category><body package="GlorpMisc" selector="getMessageText">getMessageText	"This is horribly ugly. Not only are dialects inconsistent, but behaviour between types of exceptions is inconsistent within dialects"		Dialect isVisualWorks ifTrue: [^self getVisualWorksMessageText].	Dialect isVisualAge ifTrue: [^self getVisualAgeMessageText].	Dialect isSqueak ifTrue: [^self databaseError].	^self printStringOld.</body></methods><methods><class-id>Glorp.PGSequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select nextval('.			self qualifiedName printOn: stream.			stream nextPutAll: ') from ' , aTable name.			stream nextPutAll: ' limit '.			stream nextPutAll: (aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printStringOld]).			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.NoTableFound</class-id> <category>accessing</category><body package="GlorpMisc" selector="messageText">messageText	messageText ifNotNil: [^messageText].	self model isString ifTrue: [^'No table &lt;1s&gt; found' expandMacrosWith: self model].	^'No table found for &lt;1s&gt;, expected to see one of  &lt;2s&gt;' expandMacrosWith: self model name with: self expectedTables printStringOld</body></methods><methods><class-id>Glorp.GlorpDatabaseType class</class-id> <category>printing</category><body package="GlorpDatabaseTypes" selector="padToThreeDigits:">padToThreeDigits: anInteger	| string |	string := anInteger truncated printStringOld.	string size = 3 ifTrue: [^string].	string size = 2 ifTrue: [^'0', string].	string size = 1 ifTrue: [^'00', string].</body></methods><methods><class-id>Glorp.GlorpDatabaseType class</class-id> <category>printing</category><body package="GlorpDatabaseTypes" selector="padToTwoDigits:">padToTwoDigits: anInteger	| string |	string := anInteger truncated printStringOld.	^string size = 1 ifTrue: ['0', string] ifFalse: [string].</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions" selector="printValue:on:">printValue: value on: aCommand	| type |	type := [self leftChild type] on: Dialect error do: [:ex | self error: 'Invalid comparison operation: ', self printStringOld].	(self useBindingFor: value to: type in: aCommand) ifTrue: [^aCommand nextPutAll: '?'].	self expectsCollectionArgument		ifTrue:			[type				printCollection: value				on: aCommand]		ifFalse:			[type				print: value				on: aCommand].</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="connectionClassForLogin:">connectionClassForLogin: aLogin 	aLogin database isDB2Platform ifTrue: [^ Smalltalk at: #AbtIbmCliDatabaseManager].	aLogin database class == OraclePlatform 		ifTrue: [^Smalltalk at: #AbtOracle10DatabaseManager].	aLogin database isODBCPlatform 		ifTrue: [^Smalltalk at: #AbtOdbcDatabaseManager].	aLogin database isPostgreSQLPlatform 		ifTrue: [self error: 'PostgreSQL is not yet supported under VA'].	self error: 'Unknown database platform' , aLogin database printStringOld</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="loginIfError:">loginIfError: aBlock 	"		This method creates a NEW database connection.	"	| dbMgrClass anAbtDatabaseLogonSpec anAbtDatabaseConnectionSpec aliasNameString baseAliasName |	self log: 'Login'.	self logOnly ifTrue: [^self].	aliasNameString := baseAliasName := currentLogin connectString.	"		We try to generate a unique alias name to get a new connection and to 		prevent the normal VAST behaviour to reuse a connection	"		[((Smalltalk at: #AbtDbmSystem) 		activeDatabaseConnectionWithAlias: aliasNameString) notNil] 			whileTrue: 				[aliasNameString := baseAliasName , Time millisecondClockValue printStringOld].	"		Get the native VA class responsible for doing the work against the		three special connections available in VA	"	dbMgrClass := self connectionClass.	"		Get the logon specification for the database ... do not use		any server information	"	anAbtDatabaseLogonSpec := (Smalltalk at: #AbtDatabaseLogonSpec) 				id: currentLogin username				password: currentLogin password				server: self serverName.	"			Get the specification for the connection ...    "	anAbtDatabaseConnectionSpec := (Smalltalk at: #AbtDatabaseConnectionSpec) 				forDbmClass: dbMgrClass				dataSourceName: self databaseName.	connection := anAbtDatabaseConnectionSpec 				connectUsingAlias: aliasNameString				logonSpec: anAbtDatabaseLogonSpec				ifError: 					[:error | 					"throw away the connection ..."					connection := nil.					aBlock value: error].	connection isNil ifFalse: [		connection databaseMgr errorBlock: [:err | self externalDatabaseErrorSignal signalWith: err]].</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	typeString isNil		ifTrue:			[typeString := self typeName.			width isNil				ifFalse: [typeString := typeString , '(' , width printStringOld , ')']].	^typeString.</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="name">name	"This can get called when we're masquering as a class, for purposes of indexing descriptors, so just print something useful"	^self printStringOld.</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>public</category><body package="GlorpDatabase" selector="creationString">creationString	^self sequenceIncrement &gt; 1		ifFalse: ['create sequence ', self qualifiedName]		ifTrue: ['create sequence ', self qualifiedName, ' increment by ', self sequenceIncrement printStringOld]</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>private</category><body package="GlorpCore" selector="backupReserveCommand:in:">backupReserveCommand: anInteger in: aSession	| command stream |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select '.	stream nextPutAll: self qualifiedName.	stream nextPutAll: '.nextval from SYS.ALL_OBJECTS '.	stream nextPutAll: ' WHERE rownum &lt;= '.	stream		nextPutAll:			(aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printStringOld]).	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select '.			stream nextPutAll: self qualifiedName.			stream nextPutAll: '.nextval from '.			stream nextPutAll: aTable name.			stream nextPutAll: ' WHERE rownum &lt;= '.			stream nextPutAll: (aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printStringOld]).			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand blockFactor: anInteger.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="integerToString:for:">integerToString: anInteger for: aType	anInteger isNil ifTrue: [^nil].	^self padString: anInteger printStringOld for: aType.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services columns</category><body package="GlorpDatabase" selector="printSqlStatementToPopulateColumn:with:on:">printSqlStatementToPopulateColumn: aDatabaseField with: aValue on: aStream	| converter dbValue |	converter := aDatabaseField converterForStType: aValue class.	dbValue := converter		convert: aValue		toDatabaseRepresentationAs: aDatabaseField type.	aStream		nextPutAll: 'UPDATE ';		nextPutAll: (self ddlTableNameFor: aDatabaseField table);		nextPutAll: ' SET ';		nextPutAll: (self nameForColumn: aDatabaseField name);		nextPutAll: ' = ';		nextPutAll: dbValue printStringOld;		nextPutAll: ' WHERE (';		nextPutAll: ( self nameForColumn: aDatabaseField name);		nextPutAll: ' IS NULL OR ';		nextPutAll: (self nameForColumn: aDatabaseField name);		nextPutAll: ' &lt;&gt; ';		nextPutAll: dbValue printStringOld;		nextPutAll: ')'</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestamp on: aStream for: aType	aTimestamp isNil ifTrue: [aTimestamp glorpPrintSQLOn: aStream. ^self].	aStream nextPut: $'; nextPutAll: aTimestamp printStringOld; nextPut: $'.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>private</category><body package="GlorpMappings" selector="raiseInvalidAttributeError">raiseInvalidAttributeError	self error: 'Invalid attribute: ', classModel printStringOld, '&gt;&gt;', name printStringOld.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>printing</category><body package="GlorpMappings" selector="printOn:">printOn: aStream	aStream nextPutAll: self classModel printStringOld, '&gt;&gt;', self name.</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	"Don't bind the number in the fetch first nn clause."	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select next value for '.			stream nextPutAll: self qualifiedName.			stream nextPutAll: ' from '.			stream nextPutAll: aTable name.			stream nextPutAll: ' fetch first '.			stream nextPutAll: anInteger printStringOld.			stream nextPutAll: ' rows only'.			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand blockFactor: anInteger.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>private</category><body package="GlorpCore" selector="backupReserveCommand:in:">backupReserveCommand: anInteger in: aSession	"syscat.tables is a public view of all the tables.	Don't bind the number in the fetch first nn clause."	| command stream |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select next value for '.	stream nextPutAll: self qualifiedName.	stream nextPutAll: ' from SYSCAT.TABLES'.	stream nextPutAll: ' fetch first '.	stream nextPutAll: anInteger printStringOld.	stream nextPutAll: ' rows only'.	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>logging</category><body package="GlorpDatabase" selector="logCommand:bound:">logCommand: aDatabaseCommand bound: aBoolean	"Log the execution of a command"	| string |	self changed: #command: with: aDatabaseCommand.	self logging ifFalse: [^self].	string := aDatabaseCommand sqlString. 	aBoolean ifTrue: [string := string , '  ' , aDatabaseCommand bindings printStringOld].	self logString: string.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>logging</category><body package="GlorpDatabase" selector="logError:">logError: anErrorObject 	self log: anErrorObject printStringOld</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase" selector="dropSequences:">dropSequences: anArray	anArray do:		[:each |		self			dropSequence: each			ifAbsent:				[:ex | 				self log: (ex messageText ifNil: [ex printStringOld]).				ex return: nil]].</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>logging</category><body package="GlorpDatabase" selector="logTime:">logTime: aTimeOrBlock	| time |	self logOnly ifTrue: [^self].	self changed: #time: with: aTimeOrBlock.	self logging ifFalse: [^self].	time := (Dialect isBlock: aTimeOrBlock)		ifTrue: [aTimeOrBlock value]		ifFalse: [aTimeOrBlock].	self logString: '(' , (time / 1000.0) printStringOld , ' s)'.</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>accessing</category><body package="GlorpMappings" selector="addMember:">addMember: aDescriptor	members isNil ifTrue: [members := OrderedCollection new].	(members includes: aDescriptor)		ifFalse: [members add: aDescriptor]		ifTrue: [Transcript cr; show: ('Your system does a duplicate registration of ', aDescriptor printStringOld, ' in ', self printStringOld)]</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printDate:for:">printDate: aDateString for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form '1959-09-30'."	aDateString isNil ifTrue: [^'NULL'].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aDateString class = Date ifTrue: [self error: 'SQLite does not support date types;  this should have been a String'].	^aDateString printStringOld</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printTime:for:">printTime: aTimeString for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form 10:20:23."	aTimeString isNil ifTrue: [^'NULL'].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aTimeString class = Time ifTrue: [self error: 'SQLite does not support time types;  this should have been a String'].	^aTimeString printStringOld</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	| targetClassModel |	super validate.	(self collectionType = GlorpCursoredStream and: [self shouldUseFilteredRead]) ifTrue: [self error: 'Filtered mappings can cause duplicates and so cannot return cursors'].	(shouldWriteTheOrderField and: [orderBy isNil]) ifTrue: [self error: 'Mapping tries to write the collection order to a field, but has no order by field specified'].	(shouldWriteTheOrderField &amp; usesLinkTable)		ifTrue: [ | targetTable |			targetTable := (self linkTableJoin allTargetFields collect: [:each | each table]) first.			targetTable primaryKeyFields isEmpty ifTrue: [self error: 'A mapping with a link table and which writes the order field must define primary key fields and must not include the order field as a primary key']].		orderBy isNil ifTrue: [^self].	targetClassModel := self system classModelFor: attribute type.	"Note that this will only validate when the orderBy is a symbol - not a block, expression, or field"	orderBy do: [:attributeName |		attributeName isSymbol ifTrue: [			(targetClassModel hasAttributeNamed: attributeName) ifFalse: [				self error: attribute printStringOld, ' is attempting to order by #', attributeName, ' which is not a mapped attribute of ', targetClassModel describedClass name]]].</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	"Since tableSelectCommand was never nilled, a second pundle version reusing this sequence used to get an SQL string embedding the first's integer value.  If it was a version of a different pundle, its integer probably differed;  when a call to reserve e.g. 1233 returns a maximum got by reusing the prior version's call to reserve e.g. 85, the result is 1148 duplicate keys.  If #insertOnly was set,  replication failed on an illegal command.  If we reached one of the fix-up states where it was not, then our cache assured us we were updating and we happily overwrote e.g. the blob for a class definition with that for a method definition (as I experienced :-/).  As sequences are set in the descriptor system and reused, this persisted until the session was discarded or its system was revised.  We now check the integer."	| stream useBinding |	"Binding into this doesn't seem to work"	useBinding := false.	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:		[stream := WriteStream on: (String new: 200).		stream nextPutAll: 'select gen_id('.		stream nextPutAll: self qualifiedName.		stream nextPut: $,.		stream nextPutAll: (useBinding ifTrue: ['?'] ifFalse: [anInteger printStringOld]).		stream nextPutAll: ') from rdb$database'.		tableSelectCommand := SQLStringSelectCommand new.		tableSelectCommand parameters: (Array with: anInteger).		tableSelectCommand setSQLString: stream contents.		tableSelectCommand session: aSession].	^tableSelectCommand</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>validation</category><body package="GlorpMappings" selector="noDescriptorInitializerFound:">noDescriptorInitializerFound: aDescriptor	self error: 'No descriptor initializer found for ', aDescriptor printStringOld.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>validation</category><body package="GlorpMappings" selector="noTableInitializerFound:">noTableInitializerFound: aDatabaseTable	self error: 'No table initializer found for ', aDatabaseTable printStringOld.</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="typeString">typeString		^self typeName,   ( width ifNil: [''] ifNotNil: [ :w |'(', w printStringOld, ')'])</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	aStream		print: base;		nextPut: $.;		nextPutAll: (name isString ifTrue: [name] ifFalse: [name printStringOld])</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="validate">validate	self mappingFromMeOrSubclasses isNil ifTrue: [self error: 'no mapping for ', self printStringOld].</body></methods><methods><class-id>Glorp.MultipleMappingsForInstanceVariable</class-id> <category>accessing</category><body package="GlorpMisc" selector="messageText">messageText	^'Multiple readable mappings for one instance variable:&lt;1s&gt;' expandMacrosWith: self readableMappings  printStringOld</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>debugging</category><body package="GlorpQueries" selector="printOn:">printOn: aStream	aStream nextPutAll: self printStringOld.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>debugging</category><body package="GlorpQueries" selector="basicPrintString">basicPrintString	^self printStringOld.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>converting</category><body package="GlorpMappings" selector="asGlorpExpressionOn:">asGlorpExpressionOn: anExpression	"If we're being converted into an expression, that means we're a subselect inside an expression block. We don't actually have any relationship to anExpression, so create our own base and make a pseudo-mapping with no join to describe the relationship. Don't even give it a string-name, just use ourselves as the key"		| expression localBase phantomMapping phantomExpression |	phantomMapping := OneToOneMapping new		referenceClass: self resultClass;		attributeName: #temporaryAttributeFromSubselect;		join: Join new;		descriptor: (anExpression system descriptorFor: self resultClass).	phantomExpression := anExpression getMapping: phantomMapping named: self.	expression := GeneralSubSelectExpression 		basedOn: phantomExpression.	expression query: self.	localBase := SubSelectBaseExpression on: phantomExpression.	self baseExpression: localBase.	self tablePrefix: ('s', anExpression ultimateBaseExpression availableSubSelectNumber printStringOld, 't').	^expression.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>fields</category><body package="GlorpExpressions" selector="findFieldNamed:">findFieldNamed: aString	| fields |	fields := OrderedCollection new: 1.	self tables do: [:each |		| field |		field := each fieldNamed: aString ifAbsent: [nil].		field isNil ifFalse: [fields add: field]].	fields isEmpty ifTrue: [self error: 'No field named ', aString, ' in ', self printStringOld].	fields size &gt; 1 ifTrue: [self error: 'Ambiguous field ', aString, ' in ', self printStringOld].	^fields at: 1.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="assignTableAliasesStartingAt:prefix:">assignTableAliasesStartingAt: anInteger prefix: aString	| tableNumber prefix |	self controlsTables ifFalse: [^anInteger].	self hasTableAliases ifTrue: [^anInteger].	tableNumber := anInteger.	prefix := aString isNil ifTrue: ['t'] ifFalse: [aString].	self tables		do:			[:each | 			self aliasTable: each to: prefix , tableNumber printStringOld.			tableNumber := tableNumber + 1].	^tableNumber.</body></methods><methods><class-id>Text2.FlowLine</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayLineNumberOn:">displayLineNumberOn: aGraphicsContext	"Draw the line number of the line to the left of its margin."	| lineNumberString lineNumberWidth |	(aGraphicsContext clientDataAt: #showLineNumbers ifAbsent: [false]) ifFalse: [^self].	(aGraphicsContext clientDataAt: #showLineNumbersStyle ifAbsent: [^self]) installOn: aGraphicsContext.	lineNumberString := number printStringOld.	lineNumberWidth := (lineNumberString measureWithFont: aGraphicsContext font from: 1 to: lineNumberString size) x.	aGraphicsContext displayString: lineNumberString at: (-5 - lineNumberWidth) @ baseline</body></methods><methods><class-id>Text2.DocumentListItem class</class-id> <category>types - numeric</category><body package="Graphics-Text2-Document" selector="decimal">decimal	&lt;type&gt;	^[:number | number printStringOld]</body></methods><methods><class-id>Text2.DocumentListItem class</class-id> <category>private</category><body package="Graphics-Text2-Document" selector="remapBase10:with:">remapBase10: anInteger with: base10characters	^anInteger printStringOld collect: [:character | (base10characters at: character codePoint - $0 codePoint + 1) asCharacter]</body></methods><methods><class-id>Text2.Flow</class-id> <category>private - lines</category><body package="Graphics-Text2-Flow" selector="validate">validate	"Debugging: Determine if the internal structures have become inconsistent. By default this is disabled, but if something isn't working properly, it might help to enable it."	| debug |	debug := false.	debug ifFalse: [^self].	(linesByNumber allButLast: 1) with: (linesByNumber allButFirst: 1) do: [:a :b |		a stop &lt;= b start ifFalse: [self error: 'contiguity of lines lost'].		a bottom = b top ifFalse: [self error: 'lines not touching?'].		a bottom &lt;= b top ifFalse: [self error: 'overlapping lines?']].	linesByNumber keysAndValuesDo: [:index :line |		| paragraphLinesNode paragraphLines |		line height &gt; 0 ifFalse: [self error: 'line ', index printStringOld, ' has no height'].		paragraphLinesNode := self lineNodesByParagraphStart: line start ifAbsent: [self error: 'lineNodesByParagraphStart ', index printStringOld, ' is inconsistent'].		paragraphLinesNode value isSequenceable			ifTrue: [paragraphLines := paragraphLinesNode value]			ifFalse: [paragraphLines := Array with: paragraphLinesNode value].		paragraphLines detect: [:each | each start = line start] ifNone: [self error: 'lineNodesByParagraphStart ', index printStringOld, ' is inconsistent'].		linesByTop at: line top ifAbsent: [self error: 'linesByTop ', index printStringOld, ' is inconsistent'].		linesByWidth at: line width ceiling ifAbsent: [self error: 'linesByWidth ', index printStringOld, ' is inconsistent']]</body></methods><methods><class-id>Kernel.CodeReader class</class-id> <category>private</category><body package="System-Code Storage" selector="checkFormatOf:against:inParcel:">checkFormatOf: aBehavior against: storedFormat inParcel: parcelName	"Check that the stored format for aBehavior is compatible with its current format."	| ignoredMask |	ignoredMask := FixedFieldsMask + WeakMask + EphemeronMask.	((storedFormat bitXor: aBehavior format) bitOr: ignoredMask) = ignoredMask ifFalse:		[self invalidClassFormatSignal			raiseWith: aBehavior fullName			errorString: ((#incompatible2s1sClassFormatForSystem &lt;&lt; #dialogs &gt;&gt; 'While Loading Parcel &lt;2s&gt;, the format of the class &lt;1s&gt; was found to be incompatible with its format in the system.')				expandMacrosWith: aBehavior printStringOld				with: parcelName)]</body></methods><methods><class-id>Kernel.CodeReader class</class-id> <category>private</category><body package="System-Code Storage" selector="checkFormatOf:against:">checkFormatOf: aBehavior against: storedFormat	"Check that the stored format for aBehavior is compatible with its current format."	| ignoredMask |	ignoredMask := FixedFieldsMask + WeakMask + EphemeronMask.	((storedFormat bitXor: aBehavior format) bitOr: ignoredMask) = ignoredMask ifFalse:		[self invalidClassFormatSignal			raiseWith: aBehavior fullName			errorString: ' : ', aBehavior printStringOld]</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="Store-Image Objects" selector="textRepresentationDataAt:">textRepresentationDataAt: aDataKey	"Answer text for aDataKey"		^(self definitionOf: aDataKey ifAbsent: [^(#twoStarUnresolvedTwoStar &lt;&lt; #store &gt;&gt; '**Unresolved**') asText]) printStringOld asText</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>actions</category><body package="Kernel-Support" selector="timeStamp:">timeStamp: aStream	| tempStream |	tempStream := WriteStream on: (String new: 16).	SystemUtils timeStamp: tempStream.	aStream nextChunkPut: tempStream contents printStringOld.	"double quotes and !s"	aStream cr</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>actions</category><body package="Kernel-Support" selector="reorganize:on:">reorganize: object on: aStream	aStream cr; cr; nextChunkPut:				object storeString ,				' reorganizeFromString: ' ,				object organization printStringOld storeString</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>actions</category><body package="Kernel-Support" selector="reorganizeNameSpace:on:">reorganizeNameSpace: object on: aStream	aStream cr; cr; nextChunkPut:				object storeString ,				' asNameSpace reorganizeFromString: ' ,				object asNameSpace organization printStringOld storeString</body></methods><methods><class-id>Kernel.NameSpaceOrganizer</class-id> <category>accessing</category><body package="System-Name Spaces" selector="changeFromString:">changeFromString: aString 	"Parse the string and make this be the receiver's structure.  Categories	or elements not found are not affected.  New elements are ignored."	| scanner newCat bind |	self environment checkInstalled.	scanner := Compiler preferredParserClass new scanTokens: aString.	scanner do: [:cat |		newCat := (cat at: 1) asSymbol.		2 to: cat size do: [:i |			bind := self environment bindingFor: (cat at: i).			bind == nil ifFalse: [bind category: newCat]]].	SourceFileManager default logChange:					self environment namedReferent fullName,					' asNameSpace reorganizeFromString: ',					self printStringOld storeString.</body></methods><methods><class-id>Kernel.NameSpaceOrganizer class</class-id> <category>class initialization</category><body package="System-Name Spaces" selector="initializeSmalltalk">initializeSmalltalk	"NameSpaceOrganizer initializeSmalltalk"	| org |	org := self new.	org environment: Smalltalk.	org changeFromString: Smalltalk organization printStringOld.	Smalltalk organization: org</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>initialize-release</category><body package="System-Compiler-Names and Scopes" selector="generateNames:">generateNames: count	"Generate a collection of unique temporary names,	but do not bind them.  The client is responsible for	calling addTemporaries: to actually bind the variables.	Note that the names generated here are not	syntactically legal: this is deliberate, so they can be	hidden by the debugger."	| name index |	index := variables size.	^(1 to: count) collect:		[:i |		[index := index + 1.		name := '.t', nesting printStringOld, 'i', index printStringOld.		(self variableAt: name from: nil) notNil]			whileTrue.		name]</body></methods><methods><class-id>Kernel.AbsentClassImport</class-id> <category>printing</category><body package="System-Code Storage" selector="convertToXML">convertToXML		| driver |	driver := XML.DOM_SAXDriver new.	driver		startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: self name asString.	self sax: driver tag: 'environment' value: self name asQualifiedReference environment fullName.	self sax: driver tag: 'super' value: Object fullName.	self sax: driver tag: 'private' value: false printStringOld.	self sax: driver tag: 'indexed-type' value: (self class behaviorTypeForFormat: format) asString.	self sax: driver tag: 'inst-vars' value: self instVarNames.	self sax: driver tag: 'class-inst-vars' value: ''.	self sax: driver tag: 'imports' value: '' asString.	self sax: driver tag: 'category' value: 'As yet unclassified' asString.	driver		endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>file-in/out</category><body package="System-Name Spaces" selector="xmlDefinition:onto:">xmlDefinition: anXMLFormatter onto: aStream	self binding isForGeneral		ifFalse: [^self value				xmlDefinition: anXMLFormatter				onto: aStream].	^anXMLFormatter		on: aStream tag: 'shared-variable' do: [:xml :str |			xml on: str cr tag: 'name' value: self simpleName.			xml on: str cr tag: 'environment' value: self environment fullName.			xml on: str cr tag: 'private' value: self binding isPrivate printStringOld.			xml on: str cr tag: 'constant' value: self binding isConstant printStringOld.			xml on: str cr tag: 'category' value: (self environment asNameSpace organization categoryOfItem: self simpleName).			self binding sourceCode == nil				ifFalse: [xml on: str cr tag: 'initializer' value: self binding sourceCode].			str cr]</body></methods><methods><class-id>Kernel.CodeComponent class</class-id> <category>signal handlers</category><body package="System-Code Components" selector="handleCodeReaderSignalsDo:for:">handleCodeReaderSignalsDo: aBlock for: componentSource	"Catch signals from CodeReader and reraise them as Parcel signals"	|  acceptAbsentClassImports componentName |	componentName := componentSource asString.	acceptAbsentClassImports := false.	^aBlock		on: CodeReader codeReaderSignal		do: [:ex |			ex creator = CodeReader prerequisiteSignal ifTrue:				[ex resume: (self handlePrerequisite: ex parameter)].			ex creator = CodeReader fileFormatSignal ifTrue:				[self fileFormatSignal					raiseWith: componentName 					errorString: ((#errParcelOnFile &lt;&lt; #dialogs &gt;&gt; ' on file : &lt;1s&gt;') expandMacrosWith: componentName )].			ex creator = CodeReader missingNamespaceSignal ifTrue:				[self missingNamespaceSignal					raiseWith: (Array with: ex parameter with: componentName)					errorString: ((#parcelRequiresNamespace &lt;&lt; #dialogs &gt;&gt; 'Parcel requires namespace ''&lt;1s&gt;'' to be present in the image.') expandMacrosWith: ex parameter)].			ex creator = CodeReader classAlreadyLoadedSignal ifTrue:				[self classAlreadyLoadedSignal					raiseWith: (Array with: ex parameter with: componentName )					errorString: ((#errParcelFromFile &lt;&lt; #dialogs &gt;&gt; ' : &lt;1s&gt;  from file : &lt;2s&gt;') expandMacrosWith: ex parameter with: componentName )].			ex creator = CodeReader dependentClassSignal ifTrue:				[acceptAbsentClassImports ifFalse:					[CodeReader requestWarningSuppressionSignal raiseRequest == true ifTrue:						[acceptAbsentClassImports := true]].				acceptAbsentClassImports ifTrue:					[Transcript cr; show: ((#codeInAnotherParcel2 &lt;&lt; #dialogs &gt;&gt; 'Extended class &lt;1s&gt; does not exist; extensions will be installed when the class is loaded.') expandMacrosWith: ex parameter)].				ex resume: true].			ex creator = CodeReader invalidClassFormatSignal ifTrue:				[self invalidClassFormatSignal					raiseWith: (Array with: ex parameter with: componentName )					errorString: ((#incompatible2s1sClassFormatForSystem &lt;&lt; #dialogs &gt;&gt; 'While Loading Parcel &lt;2s&gt;, the format of the class &lt;1s&gt; was found to be incompatible with its format in the system.') 						expandMacrosWith: ex parameter printStringOld						with: componentName )].			ex creator = CodeReader noSourceFileSignal ifTrue:				[self handleNoSourceSignal: ex name: componentName].			ex creator = CodeReader actionFailedSignal ifTrue:				[self abortLoadingSignal					raiseWith: (Array with: nil with: componentName )					errorString: ((#errLoadActionFailed &lt;&lt; #dialogs &gt;&gt; 'Load action failed  : &lt;1s&gt;  from file : &lt;2s&gt;') expandMacrosWith: ex parameter with: componentName )].			"The CodeReader raised a signal we don't know about"			self error: (#unknownError &lt;&lt; #dialogs &gt;&gt; 'Unknown error').			]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="Kernel-Support" selector="fileOutSharedVariables:for:logging:">fileOutSharedVariables: aSet for: aClassOrNamespace logging: logging	"File a description of the shared variables of aClassOrNamespace whose selectors	 are in aSet onto the target file."	| org sels |	(org := aClassOrNamespace asNameSpace organization) categories do: 		[:cat | 		sels := (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels notEmpty ifTrue: 			[logging ifTrue: [Transcript cr; show: aClassOrNamespace printStringOld , '&gt;' , cat].			sels do: [:sel| self storeObjectDefinition: (aClassOrNamespace asNameSpace fullyQualifiedReferenceOf: sel)]]]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>utilities</category><body package="Kernel-Support" selector="condenseFile:">condenseFile: index	"Move all the changes onto a compacted sources file.	Because this gets the changes file out of synch with any stored image	file, the user is asked whether to snapshot now."		"SourceFileManager default condenseFile: 2."	| changesFile new home newFile |	(changesFile := names at: index) == nil		ifTrue:	[^self].	self backup: changesFile withExtension: Filename backupExtension.	new := self class new.	home := changesFile head asFilename.	newFile := home construct:			(OSHandle currentProcessID printStringOld, Filename changeExtension).	new file: index name: newFile writable: true.	new target: index.	new timeStamp.	new copyAllMessagesResidingOn: index.	self close: index.	ExternalStream closeOpenStreamsNamed: changesFile.	changesFile delete.	newFile renameTo: changesFile.	self file: index name: changesFile writable: changesFile isWritable</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>private - invalid source files</category><body package="Kernel-Support" selector="printInvalidFileOn:withFileIndex:">printInvalidFileOn: textStreamwithFileIndex: fileIndex	| fileName longForm |	textStream cr; crtab; emphasis: #large.	textStream nextPutAll: 'SourceFileManager default '.	fileName := (names at: fileIndex) asLogicalFileSpecification.	(fileIndex == self changesIndex and: [fileName exists and: [fileName isWritable]])		ifTrue:			[				textStream crtab: 3; nextPutAll: 'changesFileName: '.				longForm := false			]		ifFalse:			[				(fileIndex == self sourcesIndex and: [fileName exists and: [fileName isWritable not]])					ifTrue:						[							textStream crtab: 3; nextPutAll: 'sourcesFileName: '.							longForm := false						]					ifFalse:						[							textStream nextPutAll: 'file: ',fileIndex printStringOld.							textStream crtab: 3; nextPutAll: 'name: '.							longForm := true						]			].	textStream emphasis: #(#large #bold).	textStream store: (self nameStringAt: fileIndex); emphasis: #large.	longForm ifTrue:		[			textStream crtab: 3; nextPutAll: 'writable: '.			textStream print: (fileName exists and: [fileName isWritable])		].	textStream cr; cr</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="Kernel-Support" selector="fileOutMessages:for:logging:">fileOutMessages: aSet for: aClass logging: logging	"File a description of the messages of aClass whose selectors are in aSet onto the	target file.  If updateSourcePointers is true, then set the methods' sourcePointers in	order to indicate where to find the source code."	| org sels |	(org := aClass organization) categories do: 		[:cat | 		sels := (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels size &gt; 0			ifTrue: 				[logging ifTrue: [Transcript cr; show: aClass printStringOld , '&gt;' , cat].				self printCategoryChunk: cat for: aClass.				sels do: [:sel | self printMethodChunk: sel for: aClass].				self closeMethodGroup]]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>utilities</category><body package="Kernel-Support" selector="copyChangesTo:">copyChangesTo: newFileName	"If the file name supplied is different than the current changes 	file name, copy the changes file and install the new copy as the 	changes file."	| oldFile newFile |	(oldFile := self nameAt: currentTarget) == nil ifTrue: [^self].	(newFile := newFileName asFilename asAbsoluteFilename) = oldFile asAbsoluteFilename ifFalse: 		[self close: currentTarget.		oldFile exists ifTrue:			[Transcript cr; show: ((#copyingChanges &lt;&lt; #dialogs &gt;&gt; 'Copying &lt;1s&gt;  to &lt;2s&gt;...') expandMacrosWith: oldFile asString with: newFile asString).			Cursor write showWhile:				[| tempName tempFile |				tempName := OSHandle currentProcessID printStringOld,									Filename changeExtension.				tempFile := newFile directory construct: tempName.				tempFile exists ifTrue: [tempFile delete].				oldFile copyTo: tempFile.				tempFile setWritable: true.				[newFile delete]					on: OSErrorHolder nonexistentSignal					do: 						[:ex | ex return].				tempFile renameTo: newFile].			Transcript show: (#copyDone &lt;&lt; #dialogs &gt;&gt; ' done') asString; cr].		self file: currentTarget name: newFile writable: true]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="PackageCategories" selector="fileOutData:for:logging:">fileOutData: aSet for: aNameSpace logging: logging 	"File a description of the data of aNameSpace whose keys are in aSet onto the	target file."	aSet do: 			[:key | 			(aNameSpace asNameSpace includesKey: key) 				ifTrue: 					[self storeObjectDefinition: (aNameSpace asNameSpace 								fullyQualifiedReferenceOf: key).					logging 						ifTrue: 							[Transcript								cr;								show: aNameSpace printStringOld;								show: '.';								show: key]]				ifFalse: 					[Dialog 						warn: ((#_1p2sIsNotDefined &lt;&lt; #store &gt;&gt; '&lt;1p&gt;.&lt;2s&gt; is not defined.') expandMacrosWith: aNameSpace with: key)]]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="Kernel-Support" selector="fileOutOverriddenMethod:for:logging:">fileOutOverriddenMethod: anOverriddenMethod for: aClass logging: logging	"File a description of the method in &lt;anOverriddenMethod&gt; of &lt;aClass&gt; into the	target file.  If updateSourcePointers is true, then set the methods' sourcePointers in	order to indicate where to find the source code."	|protocol|	protocol := anOverriddenMethod protocol.	logging ifTrue: [Transcript cr; show: aClass printStringOld , '&gt;' , protocol].	self printCategoryChunk: protocol for: aClass.	self printOverriddenMethodChunk: anOverriddenMethod for: aClass.	self closeMethodGroup</body></methods><methods><class-id>Kernel.ChangeSet</class-id> <category>converting</category><body package="System-Changes" selector="asSortedCollection">asSortedCollection	"Answer a new instance of SortedCollection whose elements are Strings describing the changes represented by the receiver."	| summary |	summary := SortedCollection forStrings.	self objectChanges keysAndValuesDo: 		[:clName :chGrp | 		chGrp changes do: 			[:changeType | summary add: clName, ' - ', changeType].		chGrp methodChanges keysAndValuesDo: 			[:mSel :mChange | summary add: clName, ' ', mSel, ' - ', mChange]].	self objectRemoves keysAndValuesDo:		[:name :type | summary add: ((#x1sRemove &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; - remove')			expandMacrosWith: name)].	specialDoIts isEmpty not ifTrue:		[summary add: ((#SpecialDoIts1s &lt;&lt; #dialogs &gt;&gt; 'SpecialDoIts - (&lt;1s&gt;)')			expandMacrosWith: specialDoIts size printStringOld)].	self componentChangesDo: 		[ :change | summary addChange: change description ].	^summary</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>fileout</category><body package="System-Overrides" selector="convertToXML">convertToXML	| driver |	driver := XML.DOM_SAXDriver new.	driver startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: self name asString.	self sax: driver tag: 'environment' value: self environment fullName.	self sax: driver tag: 'super' value: ( self argumentForKeyWord: 'superclass'  ) fullName.	self sax: driver tag: 'private' value: ( self argumentForKeyWord: 'private' ) printStringOld.	self sax: driver tag: 'indexed-type' value: ( self argumentForKeyWord: 'indexedType' ) asString.	self sax: driver tag: 'inst-vars' value: ( self argumentForKeyWord: 'instanceVariableNames' ).	self sax: driver tag: 'class-inst-vars' value: ( self argumentForKeyWord: 'classInstanceVariableNames' ).	self sax: driver tag: 'imports' value: ( self argumentForKeyWord: 'imports' ) asString.	self sax: driver tag: 'category' value: ( self argumentForKeyWord: 'category' ) asString.	( self argumentForKeyWord: 'attributes' ) == nil 		ifFalse:			[ driver startElement: 'attributes' atts: nil.			( self argumentForKeyWord: 'attributes' ) do: 				[ :attr |				( attr last isKindOf: Array )					ifTrue:						[ driver startElement: attr first atts: nil.						attr last do: [ :s | self sax: driver tag: 'item' value: s ].						driver endElement						]					ifFalse: [ self sax: driver tag: attr first value: attr last displayString ]				].			driver endElement			].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Kernel.SystemOrganizer</class-id> <category>accessing</category><body package="Kernel-Support" selector="changeFromString:">changeFromString: aString	"Intercept to notify the system change set of the system reorganization."	self environment checkInstalled.	super changeFromString: aString.	SourceFileManager default logChange:					self environment namedReferent fullName,					' asNameSpace reorganizeFromString: ',					self printStringOld storeString.</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>private storage</category><body package="System-Code Storage" selector="storeSourceHeader">storeSourceHeader	"Store human-readable header information to the Parcel's source file.	 Arrange that the first two fields in the header are the Parcel's name	 followed by its notice (if any)."	| s |	sourceStream isNil ifTrue: [^self].	s := (String new: 1024) writeStream.	(properties keys asSortedCollection asOrderedCollection		remove: #postUnloadBlock ifAbsent: nil;		remove: #preLoadBlock ifAbsent: nil;		remove: #postLoadBlock ifAbsent: nil;		remove: #preUnloadBlock ifAbsent: nil;		remove: #preSaveBlock ifAbsent: nil;		remove: #loadOrderedClasses ifAbsent: nil;		remove: #timestamp ifAbsent: nil;		remove: #notice ifAbsent: nil;		remove: #recompile ifAbsent: nil;		remove: #name;		addFirst: #notice;		addFirst: #name;		yourself) do:		[:key| | value |		(properties includesKey: key) ifTrue:			[value := properties at: key.			value isString ifFalse: [value := value printStringOld].			s	cr;				nextPut: key first asUppercase;				nextPutAll: (key copyFrom: 2 to: key size);				nextPut: $:;				space;				nextPutAll: value]].	Parcel binaryActions do:		[:key| | label |		(properties at: key ifAbsent: nil) notNil ifTrue:			[label := key asString.			 label at: 1 put: label first asUppercase.			 s cr.			1 to: key size do:				[:i| "Map e.g. #preLoadBlock to 'Pre-load block', etc"				i = 1					ifTrue: [s nextPut: (key at: i) asUppercase]					ifFalse:						[(key at: i) isUppercase ifTrue:							[s nextPut: (i &lt;= 5 ifTrue: [$-] ifFalse: [$ ])].						s nextPut: (key at: i)]].			s nextPutAll: ': '; crtab.			s nextPutAll: ((CodeComponent stringFromAction: (properties at: key))							copyReplaceAll: '"' with: '''''')]].	s	cr; nextPutAll: (#DateC &lt;&lt; #dialogs &gt;&gt; 'Date: ') asString; nextPutAll: timeString; space; nextPutAll: dateString.	s	cr.	sourceStream addComment: s contents.	sourceStream timeStamp.	sourceStream storeExpression: '(Dialog confirm: ''You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?'' withCRs) ifFalse: [self error: ''Parcel file-in abandoned.  Choose terminate or close.'']'.</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>storage</category><body package="System-Code Storage" selector="storeStringCollection:">storeStringCollection: anArrayOfStringsOrSymbols		anArrayOfStringsOrSymbols isNil		ifTrue: [stream storeLength: 0]		ifFalse:			[stream storeLength: anArrayOfStringsOrSymbols size.			anArrayOfStringsOrSymbols do: [:each | stream storeString: (each isSymbol ifTrue: [each printStringOld] ifFalse: [each])]]</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>private</category><body package="System-Code Storage" selector="computePrerequisites">computePrerequisites	"We compute the prerequisites array here because its logically part of the header.	 The number of prerequisite strings _is_ stored in the header, but the strings themselves	 get written immediately following. i.e. the prerequisite strings do not contribute to the	 header size.  This is all backwards-compatibility nonsense; we beseech your indulgence."	| s prereqs comment bytes tempStr |	s := Array new writeStream.	#(preReadBlock versionSelectionBlock warningSuppressionBlock) do:		[:actionBlockName | | actionBlockString |		actionBlockString := properties at: actionBlockName ifAbsent: nil.		nil ~~ actionBlockString ifTrue:			[s				nextPut: actionBlockName asString;				nextPut: actionBlockString;				nextPut: '']].	prereqs := properties at: #prerequisiteParcels ifAbsent: nil.	nil ~~ prereqs ifTrue:		[prereqs do:			[:parcelNameStringVersionNumberPair|			s				nextPut: 'parcel';				nextPut: parcelNameStringVersionNumberPair first;				nextPut: parcelNameStringVersionNumberPair last]].	nil ~~ (comment := properties at: #comment ifAbsent: nil) ifTrue:		[s			nextPut: 'comment';			nextPut: comment;			nextPut: ''].	s		nextPut: 'space';		nextPut: analysisTracer numberOfObjects printStringOld;		nextPut: (bytes := analysisTracer numberOfBytes) printStringOld.	prerequisites := s contents.	stream likelyLength: (bytes / 1.1) asInteger.	tempStr := (String new: 32) writeStream.	(Locale named: #C) timePolicy print: Date today on: tempStr.	dateString := tempStr contents.	tempStr reset.	(Locale named: #C) timePolicy print: Time now on: tempStr.	timeString := tempStr contents.	"Here's some code to estimate the scale factor for stream size"	"| d |	d := Dictionary new.	[Parcel setFileCachesTo: [Dictionary new].	Parcel searchPathModel value do:		[:dir|		Parcel cachedParcelFileInfoIn: dir for: nil do:			[:info :fileName| | len space |			len := fileName asFilename fileSize asFloat.			space := info at: #space.			(d includesKey: (info at: #parcel)) ifFalse:				[d					at: (info at: #parcel)					put: (Array							with: len asInteger							with: (Integer readFrom: space first readStream) / len							with: (Integer readFrom: space last readStream) / len)]]]]		ensure: [Parcel setFileCachesTo: [nil]].	d"</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>private</category><body package="System-Code Storage" selector="createTemporaryStreamsFor:and:">createTemporaryStreamsFor: parcelFileName and: sourceFilenameOrNil	| destDir tempParcelName tempSourceName |	destDir := parcelFileName asLogicalFileSpecification head asFilename.	tempParcelName := 't', OSHandle currentProcessID printStringOld.	tempSourceName := destDir constructString: tempParcelName, Parcel sourceExtension.	self checkWritabilityOfAll: (Array with: parcelFileName with: sourceFilenameOrNil with: tempSourceName)		errorMessage: (#cantWriteFiles &lt;&lt; #dialogs &gt;&gt; 'can''t write files').	self deleteIfExists: tempSourceName.	stream := InternalCodeWriterStream on: (BinaryStorageBytes new: 0).	sourceFilenameOrNil notNil ifTrue:		[self createSourceStreamFromFileNamed: tempSourceName].</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>fileIn/Out</category><body package="System-Support" selector="timeStamp:">timeStamp: aStream 	"Write the system version and current time on stream aStream."	| dateTime |	dateTime := Time dateAndTimeNow.	aStream nextPutAll: ((#From1sOn2sAt3s &lt;&lt; #dialogs &gt;&gt; 'From &lt;1s&gt; on &lt;2s&gt; at &lt;3s&gt;')			expandMacrosWith: self version			with: (dateTime at: 1) printStringOld			with: (dateTime at: 2) printStringOld)</body></methods><methods><class-id>Kernel.Override</class-id> <category>printing</category><body package="System-Overrides" selector="text">text	"Answers a string that represents the definition."	| stream tokens tokenStream |	stream := ( String new: 100 ) writeStream.	tokens := definition selector tokensBasedOn: $:.	tokens removeLast.		"Removes trailing empty string"	stream nextPutAll: definition receiver unambiguousName; space.	tokenStream := tokens readStream.	definition arguments 		do: 			[:arg|			stream 				nextPutAll: tokenStream next;				nextPutAll: ': ';				nextPutAll: arg printStringOld]		separatedBy: 			[stream cr;tab].	^stream contents</body></methods><methods><class-id>Kernel.CompiledMethod class</class-id> <category>instance creation</category><body package="Kernel-Methods" selector="withPrimitive:numArgs:ifFail:">withPrimitive: index numArgs: numArgs ifFail: failBlock	" Answer a CompiledMethod that invokes the given primitive.	If the primitive fails, the method evaluates failBlock,	with the primitive error code as the argument. "	" Ordinarily we would do this using the compiler's code generator,	but we want it to work even in a system with no compiler.	The code isn't the most efficient possible, but it works. "	^AssemblerCodeStream new		class: Object;		forMethod: ((1 to: numArgs) collect: [:i | 't',i printStringOld]);		addTemporaries: #('_err');		methodPrimitive: index;		storePopLocal: '_err';		pushConstant: failBlock;		pushLocal: '_err';		send: #value: numArgs: 1;		putLocalReturn;		generateMethod</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>accessing</category><body package="Kernel-Processes" selector="highestPriority:">highestPriority: newHighestPriority	"Change the number of priority levels currently available for use."	| newProcessLists |	(quiescentProcessLists size &gt; newHighestPriority		and: [self anyProcessesAbove: newHighestPriority])			ifTrue: [self error: ((#ProcessPrioritiesTooHigh &lt;&lt; #dialogs &gt;&gt; 'There are processes with priority higher than &lt;1s&gt;')			expandMacrosWith: newHighestPriority printStringOld)].	newProcessLists := Array new: newHighestPriority.	1 to: ((quiescentProcessLists size) min: (newProcessLists size)) do: 		[:priority | newProcessLists at: priority put: (quiescentProcessLists at: priority)].	quiescentProcessLists size to: newProcessLists size do: 		[:priority | newProcessLists at: priority put: LinkedList new].	quiescentProcessLists become: newProcessLists</body></methods><methods><class-id>Kernel.ClassCategoryReader</class-id> <category>fileIn/Out</category><body package="Kernel-Support" selector="scanFrom:using:">scanFrom: aStream using: aFormatter	"Files in methods from the stream, aStream.  Prints the name and	category of the methods in the transcript view."	| string |	Transcript cr; nextPutAll: class printStringOld; nextPut: $&lt;; nextPutAll: category; endEntry.	[string := aFormatter methodBodyFrom: aStream.	string size &gt; 0]						"done when double terminators"		whileTrue: [class compile: string classified: category]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>Refactoring Browser</category><body package="Browser-BrowserUI" selector="textForItem">textForItem	^self printStringOld</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>load/unload</category><body package="System-Code Components" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Parcel createParcelNamed: ', self name printStringOld, ' ) '.</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>printing</category><body package="System-Code Components" selector="putStatsOn:">putStatsOn: stream 	"Write a human-readable description of all the code in the receiver, including uninstalled code."	| added extended uninstalled prereqs |	self isEmpty ifTrue: [stream nextPutAll: (#anEmptyParcel &lt;&lt; #dialogs &gt;&gt; 'an Empty Parcel') asString. ^self].	(added := self definedObjects) isEmpty ifFalse: 		[stream nextPutAll: (#DefinedNameSpacesColon &lt;&lt; #dialogs &gt;&gt; 'Defined NameSpaces:') asString; cr.		(added asSortedCollection: [:ns1 :ns2| ns1 printStringOld &lt; ns2 printStringOld]) do:			[:nameSpace | stream tab; print: nameSpace; cr].		stream cr].	(added := self definedBindings) isEmpty ifFalse: 		[stream nextPutAll: (#DefinedBindingsColon &lt;&lt; #dialogs &gt;&gt; 'Defined Bindings:') asString; cr.		(added keys asSortedCollection: [:ns1 :ns2| ns1 printStringOld &lt; ns2 printStringOld]) do:			[:nameSpace |			(nameSpace isBehavior and: [definedClasses includes: nameSpace]) ifFalse:				[(added at: nameSpace) asSortedCollection do:					[:k|					stream						tab;						nextPutAll: (nameSpace asNameSpace								fullyQualifiedReferenceOf: k								from: Smalltalk) printStringOld;						cr]]].		stream cr].	(added := self definedClasses) isEmpty ifFalse: 		[stream nextPutAll: (#DefinedClassesColon &lt;&lt; #dialogs &gt;&gt; 'Defined classes:') asString; cr.		(added asSortedCollection: [:c1 :c2| c1 printStringOld &lt; c2 printStringOld]) do:			[:class | stream tab; print: class; cr].		stream cr].	(extended := self extendedBehaviors) isEmpty ifFalse:		[stream nextPutAll: (#ExtendedClassesColon &lt;&lt; #dialogs &gt;&gt; 'Extended classes:') asString; cr.		(extended asSortedCollection: [:b1 :b2| b1 printStringOld &lt; b2 printStringOld]) do:			[:b |			stream tab; print: b; cr.			(self definedSelectorsFor: b) asSortedCollection do:				[:selector | stream tab; tab; nextPutAll: selector; cr].			stream cr]].	(uninstalled := properties at: #uninstalledClasses ifAbsent: nil) size &gt; 0 ifTrue:		[stream nextPutAll: (#UninstalledClassesColon &lt;&lt; #dialogs &gt;&gt; 'Uninstalled classes:') asString; cr.		stream emphasis: #italic.		(uninstalled collect: [:ea| ea fullName]) asSortedCollection do:			[:className|			stream tab; nextPutAll: className; cr].		stream emphasis: nil; cr].	(uninstalled := properties at: #uninstalledMethods ifAbsent: nil) size = 0 ifFalse:		[stream nextPutAll: (#UninstalledMethodsColon &lt;&lt; #dialogs &gt;&gt; 'Uninstalled methods:') asString; cr.		stream emphasis: #italic.		uninstalled asSortedCollection do:			[:mir| stream tab; print: mir; cr].			stream emphasis: nil].	(uninstalled := properties at: #uninstalledBindings ifAbsent: nil) size = 0 ifFalse:		[stream nextPutAll: (#UninstalledSharedVariablesColon &lt;&lt; #dialogs &gt;&gt; 'Uninstalled shared variables:') asString; cr.		stream emphasis: #italic.		uninstalled asSortedCollection do:			[:mir| stream tab; print: mir; cr].			stream emphasis: nil].	(prereqs := self prerequisiteParcels) size &gt; 0 ifTrue:		[stream nextPutAll: (#PrerequisiteParcelsColon &lt;&lt; #dialogs &gt;&gt; 'Prerequisite parcels:') asString.		prereqs do:			[:ea|			stream crtab; nextPutAll: (ea at: 1).			(ea at: 2) size &gt; 0 ifTrue: [stream tab; nextPutAll: 'version '; nextPutAll: (ea at: 2)]].		stream cr]</body></methods><methods><class-id>Kernel.DefineOpcodePool class</class-id> <category>private-initialization</category><body package="System-Compiler-Support" selector="vw40ExtendedSpecialSelectors">vw40ExtendedSpecialSelectors	"These are the most common selectors	(with at least 20 occurrences)	in the current license image"	^#(		#do: #cr #on: #nextPut: #bounds #x #y #isEmpty		#copyOld #name #with: #at:ifAbsent: #-&gt; #error: #first #bitShift:		#includes: #contents #key #asString #last #extent #componentAt: #printStringOld		#bitAnd: #scaledRed:scaledGreen:scaledBlue: #view #rounded #window #/ #next #paint:		#yourself #space #asSymbol #controller #sensor #max: #height #isKindOf:		#subclassResponsibility #default #with:with: #asValue #collect: #tab #addLast: #print:		#initialize #builder #extent: #width #handle:do: #top #copyFrom:to: #negated		#widget #close #errorSignal #left #displayRectangle: #current #origin #layout		#perform: #asInteger #min: #black #selection #asPointerParameter #bottom #model		#removeLast #list #component #externalAccessFailedWith: #environment #raise #select: #extent:depth:bitsPerPixel:palette:usingBits:		#peekForTypeNoPush: #asFilename #asText #adapt:forAspect:channel: #showWhile: #tab: #organization #displayOn:at:		#primitiveFailed #release #notifierString: #writeStream #menuItemLabeled: #monoMaskPalette #atEnd #selector		#show: #addAll: #aspectAt:put: #nameClass:message: #model: #right #preferredBounds #emphasis:		#bindValue:to: #indexOf: #expected: #keyboard #disable #white #matchAt:put: #invalidate		#scale #replaceFrom:to:with:startingAt: #on:do: #to: #value:value: #fullName #readStream #valueNowOrOnUnwindDo:		#removeDependent: #byteAt: #onChangeSend:to: #asArray #asFloat #changed: #corner: #text		#labeled: #detect:ifNone: #warn: #name: #center #decodeAsLiteralArray #isSymbol #isString		#changed:with: #label: #position #printOn: #wait #\\ #keysAndValuesDo: #asValueReference		#preferenceFor: #includesKey: #abs #return #shouldNotImplement #returnWith: #critical: #list:		#displayBox #species #withCRs #replaceStackTop: #components #foregroundColor #with:with:with: #selection:		#bitOr: #label #parameter #string #lineGrid #backgroundColor #type #withColors:		#separator #palette #hash #graphicsContext #layout: #sender #open #enable		#remove:ifAbsent: #skip: #textStyle #| #scanToken #insetBy: #targetClass #selectionIndexHolder		#changeRequest #byteAt:put: #memberAt:put: #htmlEntity #wrapper #isEnabled #raiseWith: #displayOn:		#addDependent: #bounds: #perform:with: #x: #containsPoint: #preferenceModelFor: #numArgs #keyboardProcessor		#component: #cursorPoint #externalAccessFailedSignal #intersects: #origin:extent: #store: #zero #widgetState		#remove: #extent:depth:palette:bits:pad: #topComponent #memberAt: #fromBytes:	)</body></methods><methods><class-id>Kernel.Change</class-id> <category>file accessing</category><body package="System-Changes" selector="fileName">fileName	"Return the name of the receiver's stream"	^self isInSystem		ifTrue:			[| fileIndex |			(fileIndex := self systemFileIndex) == nil				ifTrue: [(#currentSystem &lt;&lt; #dialogs &gt;&gt; 'current system') asString]				ifFalse: [((#currentSystemFile1s &lt;&lt; #dialogs &gt;&gt; 'current system, source file &lt;1s&gt;')			expandMacrosWith: fileIndex printStringOld)]]		ifFalse:			[| file |			(file := self file) == nil				ifTrue: [(#someLocalStream &lt;&lt; #dialogs &gt;&gt; 'some local stream') asString]				ifFalse: [file displayString]]</body></methods><methods><class-id>Kernel.ClassDefinitionChange</class-id> <category>fileIn/Out</category><body package="System-Changes" selector="xmlDefinition:onto:">xmlDefinition: anXMLFormatter onto: aStream	^anXMLFormatter		on: aStream tag: 'class' do: [:xml :str | | parameters  |			xml on: str cr tag: 'name' value: self shortName.			xml on: str cr tag: 'environment' value: nameSpaceName.			parameters := IdentityDictionary withAll: otherParameters.			parameters at: #superclass: 	ifPresent:[:value | xml on: str cr tag: 'super' value: value asString].			parameters at: #private: ifPresent:[:value | xml on: str cr tag: 'private' value: value printStringOld].			parameters at: #indexedType: ifPresent:[:value | xml on: str cr tag: 'indexed-type' value: value].			parameters at: #instanceVariableNames: ifPresent:[:value | xml on: str cr tag: 'inst-vars' value: value].			parameters at: #classInstanceVariableNames: ifPresent:[:value | xml on: str cr tag: 'class-inst-vars' value: value].			parameters at: #imports: ifPresent:[:value | xml on: str cr tag: 'imports' value: value].			parameters at: #category: ifPresent:[:value | xml on: str cr tag: 'category' value: value].			parameters at: #attributes: ifPresent:[:values | 				xml on: str cr tag: 'attributes' do: [:xml1 :str1 |					values do: [:attr | 						xml1 on: str1 cr tag: attr first encodeLiteral: attr last].						str cr]].			str cr]</body></methods><methods><class-id>Kernel.ClassOtherChange</class-id> <category>accessing</category><body package="System-Changes" selector="systemText">systemText	"Return the system version of either a metaclass definition, a class	 reorganization or a class initialization.  If there is no system version	 of the receiver's class then return nil."	| classOrRef |	^nil ~~ (classOrRef := self targetObject) ifTrue: 		[type == #'class initialize' ifTrue:			[^(classOrRef isBindingReference				ifTrue: [classOrRef printStringOld]				ifFalse: [className]) , ' initialize'].		type == #'class reorganize' ifTrue: [			^className , ' reorganizeFromString: ' ,						classOrRef organization printStringOld storeString].		^classOrRef definition]</body></methods><methods><class-id>Kernel.OtherChange</class-id> <category>accessing</category><body package="System-Changes" selector="text">text	"Answer the text displayed by the receiver."	text == nil ifTrue: [text := super text].	^(type == nil or: [type == #comment])		ifTrue: [text]		ifFalse: [text asString printStringOld]</body></methods><methods><class-id>Kernel.Decompiler</class-id> <category>private-initialize-release</category><body package="System-Compiler-Public Access" selector="newTemps:">newTemps: count	"Generate this many new temp names"	| temp |	^(1 to: count) collect:		[:i |		temp := tempCount value + 1.		tempCount value: temp.		builder declareVariableName: ('t', temp printStringOld)]</body></methods><methods><class-id>Kernel.Decompiler</class-id> <category>private</category><body package="System-Compiler-Public Access" selector="expandBoxedTemporaries:">expandBoxedTemporaries: index	| newSlots oldVar |	newSlots := stack last value.   "There needs to be a pop later to get rid of it."	oldVar := localVars first at: index+1.	localVars first at: index+1		put: ((1 to: newSlots) collect: [:n |				builder declareVariableName: oldVar name, '.', n printStringOld]).</body></methods><methods><class-id>Kernel.Decompiler</class-id> <category>private</category><body package="System-Compiler-Public Access" selector="renumber:startingWith:">renumber: list startingWith: savedTC	1 to: list size do:		[:i |		(list at: i) variable name: 't', (savedTC+i) printStringOld].</body></methods><methods><class-id>Kernel.LiteralNode</class-id> <category>code generation</category><body package="System-Compiler-Program Objects" selector="emitStorePop:value:from:">emitStorePop: codeStream value: val from: var 	codeStream		error: ((#x1sIsReadonly &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; is read-only ')			expandMacrosWith: value printStringOld)		from: var.	^self</body></methods><methods><class-id>Kernel.LiteralNode</class-id> <category>code generation</category><body package="System-Compiler-Program Objects" selector="emitStore:value:from:">emitStore: codeStream value: val from: var 	codeStream		error: ((#x1sIsReadonly &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; is read-only ')			expandMacrosWith: value printStringOld)		from: var.	^self</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>private-initialize-release</category><body package="BOSS" selector="writeHeader">writeHeader	stream nextPutAll: (self headerMagicBytes, self streamFormatNumber printStringOld , ' ') asByteArray.	platformDescription := ByteArray with: (self imageIsBigEndian ifTrue: [16r80] ifFalse: [0]).	stream		nextPut: platformDescription size;		nextPutAll: platformDescription.	initialPosition := stream position</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>actions</category><body package="XML-source" selector="reorganize:on:">reorganize: object on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'reorganize' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: object) value: object fullName.		str space.		xml on: str tag: 'organization' value: object organization printStringOld.		str cr]</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>actions</category><body package="XML-source" selector="reorganizeNameSpace:on:">reorganizeNameSpace: object on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'reorganize-data' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: object) value: object fullName.		str space.		xml on: str tag: 'organization' value: object organization printStringOld.		str cr]</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="XML-source" selector="component:named:definitionName:meta:selector:change:on:">component: typeSymbol named: name definitionName: aString meta: isMeta selector: aSelector change: aSymbol on: aStream	"Add the addition/removal of a method from a CodeComponent event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component_selector_change' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'definitionName' value: aString.		str space.		xml on: str tag: 'meta' value: isMeta printStringOld.		str space.		xml on: str tag: 'selector' value: aSelector.		str space.		xml on: str tag: 'definitionChange' value: aSymbol.		str cr		]</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-simulation</category><body package="Debugger-Support" selector="send:receiver:class:super:numArgs:">send: selector receiver: rcvr class: rclass super: flag numArgs: na	"Don't simulate calls on error:."	(flag | self class doSend or: [self onlySlowSendsForClass: rclass selector: selector])		ifFalse: [^self sendFast: selector receiver: rcvr numArgs: na].	(self isSendLoop and: [(rclass includesBehavior: GenericException) and: [selector == #aboutToDebug]])		ifTrue: [^ContextEmergencyError signalWith: rcvr].	self findMethod: selector		class: rclass		ifFound:			[:meth :mclass |			flag ifTrue: [self pop].  "remove class for super"			^self runMethod: meth numArgs: na contextClass: MethodContext].	self findMethod: #doesNotUnderstand:		class:  (self _objectClass: rcvr)		ifFound:			[:meth :mclass |			| args |			flag ifTrue: [self pop].  "remove class for super"			args := Array new: na.			na to: 1 by: -1 do: [:i | args at: i put: self topPop].			self push: (Message selector: selector arguments: args).			^self runMethod: meth numArgs: 1 contextClass: MethodContext].	self error: ((#MessageNotFoundC1s &lt;&lt; #pdp &gt;&gt; 'Message not found: &lt;1s&gt;')			expandMacrosWith: selector printStringOld).	"To continue, just return the receiver of the message."	flag ifTrue: [self pop].  "remove class for super"	stackp := stackp - na.	self localAt: stackp put: rcvr</body></methods><methods><class-id>Kernel.InstructionClient</class-id> <category>opcodes-undefined</category><body package="Kernel-Methods" selector="undefined:">undefined: byte	self error: ((#UndefinedOpcodeC1s &lt;&lt; #dialogs &gt;&gt; 'Undefined opcode: &lt;1s&gt;')			expandMacrosWith: byte printStringOld)</body></methods><methods><class-id>Kernel.InstructionClient</class-id> <category>opcodes-undefined</category><body package="Kernel-Methods" selector="undefined:with:">undefined: byte with: x1	self error: ((#UndefinedOpcodeC1s2s &lt;&lt; #dialogs &gt;&gt; 'Undefined opcode: &lt;1s&gt; &lt;2s&gt;')			expandMacrosWith: byte printStringOld			with: x1 printStringOld)</body></methods><methods><class-id>Kernel.InstructionClient</class-id> <category>opcodes-undefined</category><body package="Kernel-Methods" selector="undefined:with:with:">undefined: byte with: x1 with: x2	self error: ((#UndefinedOpcodeC1s2s3s &lt;&lt; #dialogs &gt;&gt; 'Undefined opcode: &lt;1s&gt; &lt;2s&gt; &lt;3s&gt;')			expandMacrosWith: byte printStringOld			with: x1 printStringOld			with: x2 printStringOld)</body></methods><methods><class-id>Kernel.SystemError class</class-id> <category>private</category><body package="Kernel-Support" selector="installSystemErrors">installSystemErrors	"Build the set of system errors."	| list |	list := Array new: 100.	list at:  1 put: (self named: #'generic error' parameter: nil).	list at:  2 put: (self named: #'allocation failed' parameter: nil).	list at:  3 put: (self named: #'C allocation failed' parameter: nil).	list at:  4 put: (self named: #'bad argument' parameter: nil).	list at:  5 put: (self named: #'invalid receiver state' parameter: nil).	list at:  6 put: (self named: #'inappropriate operation' parameter: nil).	list at:  7 put: (self named: #'invalid index' parameter: nil).	list at:  8 put: (self named: #'wrong number of arguments' parameter: nil).	list at:  9 put: (self named: #'translator error' parameter: nil).	list at: 10 put: (self named: #'io error' parameter: nil).	list at: 11 put: (self named: #'no match' parameter: nil).	list at: 12 put: (self named: #'threaded api error' parameter: nil).	list at: 13 put: (self named: #'unsupported operation' parameter: nil).	list at: 14 put: (self named: #'bad handle' parameter: nil).	list at: 15 put: (self named: #'no thread for process' parameter: nil).	list at: 16 put: (self named: #'process unattached to thread' parameter: nil).	list at: 17 put: (self named: #'out of threads' parameter: nil).	list at: 18 put: (self named: #'exception occured' parameter: nil).	list at: 19 put: (self named: #'hresult error' parameter: nil).	list at: 20 put: (self named: #'object engine internal error' parameter: nil).	list at: 21 put: (self named: #'failed to export object' parameter: nil).	list at: 22 put: (self named: #'failed to import object' parameter: nil).	list at: 23 put: (self named: #'platform error' parameter: nil).	list at: 24 put: (self named: #'no modification' parameter: nil).	list at: 25 put: (self named: #'uninitialized' parameter: nil).	list at: 26 put: (self named: #'invalid version' parameter: nil).	list at: 27 put: (self named: #'overflow' parameter: nil).	28 to: list size do: [:i |		list at: i put: (self named: ('error ',i printStringOld) asSymbol parameter: nil)].	self setSystemErrors: list</body></methods><methods><class-id>Kernel.NonInteractiveCompilerErrorHandler</class-id> <category>private</category><body package="System-Compiler-Support" selector="nonInteractiveError:">nonInteractiveError: message	"We spit out whatever error to the Transcript, cr after, and make sure the Transcript is ready for more"		| classPrintString |	classPrintString := class printStringOld.	selector ifNotNil: [classPrintString := classPrintString , ' ' , selector printStringOld].	Transcript show: '(' , classPrintString , ' - ' , message , ')'.	Transcript cr.	Transcript endEntry</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="definition">definition	"Answer a string that defines the receiver."	| aStream msg |	aStream := WriteStream on: (String new: 300).	msg := self definitionMessage.	aStream nextPutAll: (msg receiver == nil				ifTrue: [nil printStringOld]				ifFalse: [msg receiver unambiguousName]).	msg selector keywords with: msg arguments do:		[:word :arg |		arg = self name			ifTrue: [aStream space]			ifFalse: [aStream cr; tab].		aStream nextPutAll: word; space; store: arg].	^aStream contents</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>convenience</category><body package="System-Name Spaces" selector="logOrganizationChange">logOrganizationChange	"need to make this log the change to the change set"	SourceFileManager default logChange:			self storeString,			' reorganizeFromString: ',			self organization printStringOld storeString</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>printing</category><body package="XML-source" selector="xmlDefinition:onto:">xmlDefinition: anXMLFormatter onto: aStream	^anXMLFormatter		on: aStream tag: 'name-space' do: [:xml :str | | nm private |			xml on: str cr tag: 'name' value: self name.			self environment == nil				ifTrue:					[nm := ''.					private := false]				ifFalse:					[nm := self environment fullName.					private := (self environment bindingFor: self name) isPrivate].			xml on: str cr tag: 'environment' value: nm.			xml on: str cr tag: 'private' value: private printStringOld.			xml on: str cr tag: 'imports' value: self importString.			xml on: str cr tag: 'category' value: self category.			str cr]</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>fileout</category><body package="System-Overrides" selector="convertToXML">convertToXML	| driver |	Dictionary new.	driver := XML.DOM_SAXDriver new.	driver startDocumentFragment;		startElement: 'name-space' atts: nil.	self sax: driver tag: 'name' value: self name asString.	self sax: driver tag: 'environment' value: self environment fullName.	self sax: driver tag: 'private' value: ( self argumentForKeyWord: 'private' ) printStringOld.	self sax: driver tag: 'imports' value: ( self argumentForKeyWord: 'imports' ).	self sax: driver tag: 'category' value: ( self argumentForKeyWord: 'category'  ) asString.	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>fileout</category><body package="System-Overrides" selector="convertToXML">convertToXML		| driver initializer |	driver := XML.DOM_SAXDriver new.	driver		startDocumentFragment;		startElement: 'shared-variable' atts: nil.	self sax: driver tag: 'name' value: self name asString.	self sax: driver tag: 'environment' value: self owner fullName.	self sax: driver tag: 'private' value: (self argumentForKeyWord: 'private') printStringOld.	self sax: driver tag: 'constant' value: (self argumentForKeyWord: 'constant') printStringOld.	self sax: driver tag: 'category' value: (self argumentForKeyWord: 'category') asString.	initializer := self argumentForKeyWord: 'initializer'.	initializer ifNotNil: [self sax: driver tag: 'initializer' value: initializer asString].	(self argumentForKeyWord: 'attributes') ifNotNil:		[driver startElement: 'attributes' atts: nil.		(self argumentForKeyWord: 'attributes') value do:			[:eachAttribute | 			(eachAttribute last isKindOf: Array)				ifTrue:					[driver startElement: eachAttribute first atts: nil.					eachAttribute last do: [:s | self sax: driver tag: 'item' value: s].					driver endElement]				ifFalse: [self sax: driver tag: eachAttribute first value: eachAttribute last displayString]].			driver endElement].	driver		endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Kernel.SpecialSelectorCounter class</class-id> <category>utilities</category><body package="System-Compiler-Support" selector="specialSelectors">specialSelectors	^#(#+ #- #&lt; #&gt; #&lt;= #&gt;= #= #~= #* #// #@ #, #not #isNil #notNil #basicAt: #at: #at:put: #size #~~ #basicNew #nextPutAll: #== #class #add: #value #value: #basicSize #new #new: #basicAt:put: #basicNew: #do: #cr #on: #nextPut: #bounds #x #y #isEmpty #copyOld #name #with: #at:ifAbsent: #-&gt; #error: #first #bitShift: #includes: #contents #key #asString #last #extent #componentAt: #printStringOld #bitAnd: #scaledRed:scaledGreen:scaledBlue: #view #rounded #window #/ #next #paint: #yourself #space #asSymbol #controller #sensor #max: #height #isKindOf: #subclassResponsibility #default #with:with: #asValue #collect: #tab #addLast: #print: #initialize #builder #extent: #width #handle:do: #top #copyFrom:to: #negated #widget #close #errorSignal #left #displayRectangle: #current #origin #layout #perform: #asInteger #min: #black #selection #asPointerParameter #bottom #model #removeLast #list #component #externalAccessFailedWith: #environment #raise #select: #extent:depth:bitsPerPixel:palette:usingBits: #peekForTypeNoPush: #asFilename #asText #adapt:forAspect:channel: #showWhile: #tab: #organization #displayOn:at: #primitiveFailed #release #notifierString: #writeStream #menuItemLabeled: #monoMaskPalette #atEnd #selector #show: #addAll: #aspectAt:put: #nameClass:message: #model: #right #preferredBounds #emphasis: #bindValue:to: #indexOf: #expected: #keyboard #disable #white #matchAt:put: #invalidate #scale #replaceFrom:to:with:startingAt: #on:do: #to: #value:value: #fullName #readStream #valueNowOrOnUnwindDo: #removeDependent: #byteAt: #onChangeSend:to: #asArray #asFloat #changed: #corner: #text #labeled: #detect:ifNone: #warn: #name: #center #decodeAsLiteralArray #isSymbol #isString #changed:with: #label: #position #printOn: #wait #\\ #keysAndValuesDo: #asValueReference #preferenceFor: #includesKey: #abs #return #shouldNotImplement #returnWith: #critical: #list: #displayBox #species #withCRs #replaceStackTop: #components #foregroundColor #with:with:with: #selection: #bitOr: #label #parameter #string #lineGrid #backgroundColor #type #withColors: #separator #palette #hash #graphicsContext #layout: #sender #open #enable #remove:ifAbsent: #skip: #textStyle #| #scanToken #insetBy: #targetClass #selectionIndexHolder #changeRequest #byteAt:put: #memberAt:put: #htmlEntity #wrapper #isEnabled #raiseWith: #displayOn: #addDependent: #bounds: #perform:with: #x: #containsPoint: #preferenceModelFor: #numArgs #keyboardProcessor #component: #cursorPoint #externalAccessFailedSignal #intersects: #origin:extent: #store: #zero #widgetState #remove: #extent:depth:palette:bits:pad: #topComponent #memberAt: #fromBytes:)</body></methods><methods><class-id>Kernel.ObjectMemory</class-id> <category>utilities</category><body package="Tools-Trippy" selector="print:used:total:threshold:objects:on:">print: name used: used total: total threshold: threshold objects: objects on: aStream	"name:	used / total[ @ threshold][, objs]"	aStream		cr;		nextPutAll: name;		nextPutAll: ':	';		nextPutAll: used asShortSizeInBytes;		nextPutAll: ' / ';		nextPutAll: total asShortSizeInBytes.	threshold		ifNotNil: 			[aStream				nextPutAll: ' @ ';				nextPutAll: threshold asShortSizeInBytes].	objects		ifNotNil: 			[aStream				nextPutAll: ', ';				nextPutAll: objects printStringOld]</body></methods><methods><class-id>Kernel.ProgramNodeBuilder</class-id> <category>node creation-composite-data</category><body package="System-Compiler-Program Objects" selector="newVariable">newVariable	^self newVariableName: 'var', Time millisecondClockValue printStringOld</body></methods><methods><class-id>Kernel.UserPrimitiveMethod</class-id> <category>private</category><body package="Kernel-Methods" selector="moduleExtensionForCurrentPlatform">moduleExtensionForCurrentPlatform	(MacOSXSystemSupport matchesPlatform: ExternalInterface currentPlatform) ifTrue: [^'.dylib'].	OSHandle currentOS == #unix ifTrue: [^'.so'].	OSHandle currentOS == #win32 ifTrue: [^'.dll'].	self error: 'Don''t know what to do on platform ', ExternalInterface currentPlatform printStringOld</body></methods><methods><class-id>Kernel.LoggingCompilerErrorHandler</class-id> <category>error handling</category><body package="System-Compiler-Support" selector="error:with:in:from:">error: type with: message in: node from: codeStream	"Possible values of type:		#error, message = error message		#warning, message = error message		#readBeforeWritten, message = var name		#neverRead, message = var name, node = assignment		#neverUsed, message = var name		#redeclared, message = var name		#redeclaredBlockArg, message = var name		#undeclared, message = var Association		#undeclaredStore, message = var Association, node = assignment		#undeclaredSoftLink, message = BindingReference		#noEffect, message = nil, node = statement		#notOptimized, message = argument index, node = message send."	| msg |	msg := message isVariableBinding		ifTrue: [message key, ' : ']		ifFalse: [message isString			ifTrue: [message, ' : ']			ifFalse: ['']].	logFile cr; nextPutAll: class printStringOld , ' ' , "selector ," ' - ' , msg , type.	logFile == Transcript ifTrue: [logFile endEntry].	type == #error ifTrue: [^self abort]</body></methods><methods><class-id>Kernel.LoggingCompilerErrorHandler</class-id> <category>error handling</category><body package="System-Compiler-Support" selector="undeclared:in:from:">undeclared: binding in: node from: codeStream	binding key isSymbol		ifFalse: [binding key: binding key asSymbol].	SystemUtils undeclareNewBinding: binding.	logFile cr; nextPutAll: ((#x1s2sundeclared &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;  - &lt;2s&gt; : undeclared')			expandMacrosWith: class printStringOld			with: binding key).	logFile == Transcript ifTrue: [logFile endEntry].</body></methods><methods><class-id>Kernel.LoggingCompilerErrorHandler</class-id> <category>error handling</category><body package="System-Compiler-Support" selector="undeclaredStore:in:from:">undeclaredStore: binding in: node from: codeStream	binding key isSymbol		ifFalse: [binding key: binding key asSymbol].	SystemUtils undeclareNewBinding: binding.	logFile cr; nextPutAll: ((#x1s2sundeclaredStore &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;  - &lt;2s&gt; : undeclaredStore')			expandMacrosWith: class printStringOld			with: binding key).	logFile == Transcript ifTrue: [logFile endEntry].</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="description">description	^self printStringOld</body></methods><methods><class-id>StartupPacket</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Packet size: ' , self packetSize value printStringOld; cr.	aStream nextPutAll: 'Protocol version number: ' , self protocolVersionNumber bytes printStringOld; cr.	aStream nextPutAll: 'Database name: ' , self databaseName value printStringOld; cr.	aStream nextPutAll: 'User name: ' , self userName value printStringOld; cr.	aStream nextPutAll: 'Additional arguments: ' , self additionalArguments value printStringOld; cr.	aStream nextPutAll: 'Debugging TTY: ' , self debuggingTTY value printStringOld; cr.	^self</body></methods><shared-variable><name>CharacterClasses</name><environment>XML</environment><private>false</private><constant>true</constant><category>XML-Parsing</category><initializer>| ch sets t pc |ch := CharacterTable new: 16r110000.sets := Array			with: (16r20 to: 16rD7FF)			with: (16rE000 to: 16rFFFD)			with: (16r10000 to: ch size - 1).pc := XMLParser.t := Time millisecondsToRun: 				[sets do: 						[:s |						| startS endS |						startS := s first.						endS := s last.						startS to: endS							do: 								[:i |								| n |								n := 1.								(pc isNameStartChar: i) ifTrue: [n := n bitOr: 6].								(pc isNameChar: i) ifTrue: [n := n bitOr: 2].								ch at: i + 1 put: n]]].ch at: 9 + 1 put: 1.ch at: 10 + 1 put: 1.ch at: 13 + 1 put: 1.ch at: $_ asInteger + 1 put: 7.ch at: $- asInteger + 1 put: 3.ch at: $. asInteger + 1 put: 3.Transcript	cr;	show: 'Time = ' , t printStringOld.ch compress.ch</initializer><attributes><package>XML</package></attributes></shared-variable><remove-selector><class-id>Core.CompositeLocale</class-id> <selector>printString</selector></remove-selector><remove-selector><class-id>Protocols.ProtoObject</class-id> <selector>printString</selector></remove-selector><remove-selector><class-id>Core.Object</class-id> <selector>printString</selector></remove-selector><remove-selector><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <selector>printString</selector></remove-selector><remove-selector><class-id>Glorp.AbstractProxy</class-id> <selector>printString</selector></remove-selector><remove-selector><class-id>Core.String</class-id> <selector>printString</selector></remove-selector><remove-selector><class-id>BSTNode</class-id> <selector>printString</selector></remove-selector><remove-selector><class-id>Glorp.MessageArchiver</class-id> <selector>printString</selector></remove-selector><remove-selector><class-id>BST</class-id> <selector>printString</selector></remove-selector><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 isNil		ifFalse: [leftView value: s1 printString]		ifTrue: [leftView value: ''].	s2 isNil		ifFalse: [rightView value: s2 printString]		ifTrue: [rightView value: ''].	^self</body></methods><methods><class-id>BST</class-id> <category>printing</category><body package="CS474" selector="printOn:">printOn: aStream 	"Append to the argument, aStream, the elements of the Array 	enclosed by parentheses."	aStream nextPutAll: '{'.	root notNil ifTrue: [root printOn: aStream].	aStream nextPut: $}</body></methods><methods><class-id>BSTNode</class-id> <category>printing</category><body package="CS474" selector="printOn:">printOn: aStream 	"Append to the argument, aStream, the elements of the Array 	enclosed by parentheses."	left notNil ifTrue: [left printOn: aStream].      aStream nextPutAll: value asString.		right notNil ifTrue: [right printOn: aStream].</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#min: #(#{Core.Point} 685 400 ) 			#max: #(#{Core.Point} 685 400 ) 			#bounds: #(#{Graphics.Rectangle} 717 439 1402 839 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 102 351 182 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 92 370 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 191 351 271 370 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 isNil		ifFalse: [leftView value: s1]		ifTrue: [leftView value: ''].	s2 isNil		ifFalse: [rightView value: s2]		ifTrue: [rightView value: ''].	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#min: #(#{Core.Point} 685 400 ) 			#max: #(#{Core.Point} 685 400 ) 			#bounds: #(#{Graphics.Rectangle} 717 439 1402 839 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 102 351 182 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 92 370 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 191 351 271 370 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><remove-selector><class-id>BST</class-id> <selector>printStringOld</selector></remove-selector><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 isNil		ifFalse: [leftView value: s1 asString]		ifTrue: [leftView value: ''].	s2 isNil		ifFalse: [rightView value: s2 asString]		ifTrue: [rightView value: ''].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 isNil		ifFalse: [leftView value: s1 printString]		ifTrue: [leftView value: ''].	s2 isNil		ifFalse: [rightView value: s2 printString]		ifTrue: [rightView value: ''].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 notNil		ifTrue: [leftView value: s1 printString]		ifFalse: [leftView value: ''].	s2 notNil		ifTrue: [rightView value: s2 printString]		ifFalse: [rightView value: ''].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 notNil		ifTrue: [leftView value: (s1 printString)]		ifFalse: [leftView value: ''].	s2 notNil		ifTrue: [rightView value: (s2 printString)]		ifFalse: [rightView value: ''].	^self</body></methods><remove-selector><class-id>BST</class-id> <selector>printOn:</selector></remove-selector><do-it>BST organization removeCategory: #printing</do-it><do-it>BST organization addCategory: #converting</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>asString</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>asString</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>aString</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>aString</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BST</class-id> <category>converting</category><body package="CS474" selector="asString">asString	^root notNil ifTrue: [root asString] ifFalse: ['']</body></methods><remove-selector><class-id>BSTNode</class-id> <selector>printStringOld</selector></remove-selector><remove-selector><class-id>BSTNode</class-id> <selector>printOn:</selector></remove-selector><do-it>BSTNode organization removeCategory: #printing</do-it><do-it>BSTNode organization addCategory: #converting</do-it><methods><class-id>BSTNode</class-id> <category>converting</category><body package="CS474" selector="asString">asString		| aString |	aString := value asString.	left notNil ifTrue: [aString := left asString, ' ', aString].	right notNil ifTrue: [aString := aString, ' ', right asString].	^aString</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 notNil		ifTrue: [leftView value: (s1 asString)]		ifFalse: [leftView value: ''].	s2 notNil		ifTrue: [rightView value: (s2 asString)]		ifFalse: [rightView value: ''].	^self</body></methods><methods><class-id>BSTNode</class-id> <category>converting</category><body package="CS474" selector="asString">asString		| aString |	aString := value printString.	left notNil ifTrue: [aString := left asString, ' ', aString].	right notNil ifTrue: [aString := aString, ' ', right asString].	^aString</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Kernel-Objects" selector="printString">printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><remove-selector><class-id>Core.Object</class-id> <selector>printString</selector></remove-selector><methods><class-id>Core.CompositeLocale</class-id> <category>printing</category><body package="Internationalization" selector="printString">printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	aStream nextPutAll: 'a CompositeLocale named: #''' , self name , ''''.	^aStream contents</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>printing</category><body package="Protocols-Common" selector="printString">printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Kernel-Objects" selector="printString">printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <category>accessing</category><body package="Debugger-Probes" selector="printString">printString	action == nil		ifTrue: [^self nameString].	^(#('r' 'rw' 'w') at: action) , ' ' , class shortName , '&gt;&gt;' , selector</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>printing</category><body package="GlorpQueries" selector="printString">printString	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>Core.String</class-id> <category>printing</category><body package="Collections-Text" selector="printString">printString	"Answer a String whose characters are a description of the receiver. Take advantage of knowing what these normally look like to optimize."	| ws result |	ws := WriteStream on: (result := String new: self expectedPrintStringSize).	self printOn: ws.	"Since we own the lifecycle of the write stream, we can further exploit this 	 by taking the collection directly most of the time."	^result size = ws position ifTrue: [result] ifFalse: [ws contents]</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>debugging</category><body package="GlorpQueries" selector="printString">printString	"Hard-code this for maximum dialect portability"	^'a MessageArchiver'.</body></methods><methods><class-id>PostgreSQLEXDIStringValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	I return a PostgreSQL friendly (single quoted) string representation of my &gt;&gt;object.  Note that I take special action for Symbols because I don't want the preceeding hash in the external form.  I also take special action to escape $/ characters, unless the database is configured to use standard_conforming_strings."	| rawString |	rawString := (self object isSymbol ifTrue: [self object asString] ifFalse: [self object]) printString.	^self session connection serverConfigurationParameters useStandardConformingStrings		ifTrue: [rawString]		ifFalse: 			[| rawStream refinedStream |			rawStream := ReadStream on: rawString.			refinedStream := WriteStream on: String new.			[rawStream atEnd] whileFalse: 					[| character |					character := rawStream next.					character = $\ ifTrue: [refinedStream nextPut: $\].					refinedStream nextPut: character].			refinedStream contents]</body></methods><methods><class-id>SpDate</class-id> <category>printing</category><body package="SpTimes" selector="asISO8610StringOn:">asISO8610StringOn: aStream 	aStream		nextPutAll: self underlyingDate year printString;		nextPut: $-.	self underlyingDate monthIndex &lt; 10 ifTrue: [aStream nextPut: $0].	aStream		nextPutAll: self underlyingDate monthIndex printString;		nextPut: $-.	self underlyingDate dayOfMonth &lt; 10 ifTrue: [aStream nextPut: $0].	aStream nextPutAll: self underlyingDate dayOfMonth printString.	^self</body></methods><methods><class-id>UI.HotSlice</class-id> <category>printing</category><body package="UIPainter" selector="displayString">displayString	selector isNil ifTrue: [^(#none1 &lt;&lt; #UIPainter &gt;&gt; '[none]') asString].	^selector printString</body></methods><methods><class-id>UI.MenuAutomaticGenerator</class-id> <category>private</category><body package="Interface-Menus" selector="decodeLabel:">decodeLabel: label	label isSymbol ifTrue:		[^[menuDefiner perform: label]].	label isString ifTrue: 		[^label].	^label class == Array		ifTrue: 			[[UserMessage fromPragmaArgument: label]				on: Error				do: [:ex | ex return: label printString]]		ifFalse: [label printString]</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>private</category><body package="Interface-Models" selector="convertToLiteral:">convertToLiteral: aString	| array s indx obj |	array := Scanner new scanTokens: aString.	array size = 0 ifTrue: [^nil].	obj := array first.	array size = 1 ifTrue: [obj == #true ifTrue: [^true].						obj == #false ifTrue: [^false].						obj == #'nil' ifTrue: [^nil].						^obj].	obj == #'#'		ifTrue: [indx := 2]		ifFalse: [indx := 1].	s := String new writeStream.	indx to: array size do:		[:i |		| e |		e := array at: i.		s			nextPutAll: (e isCharacters						ifTrue: [e]						ifFalse: [e printString]);			space].	s skip: -1.	^s contents asSymbol</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForSymbol">initForSymbol	"Initialize the receiver to convert to and from	Symbol's print representations."	toPrint := 			[:m | 			| val |			(val := m) == nil ifTrue: [String new] ifFalse: [val printString]].	toRead := 			[:v | 			| t |			v size &gt; 0 				ifTrue: 					[v first == $# 						ifTrue: 							[t := v copyFrom: 2 to: v size.							(t first == $' and: [t last == $']) 								ifTrue: 									[t := t copyFrom: 2 to: t size - 1.									(t includes: $') 										ifTrue: 											[t := (t copyFrom: 2 to: t size) inject: (String with: t first)														into: 															[:sofar :c | 															(c == $' and: [sofar last == $']) 																ifTrue: [sofar]																ifFalse: [sofar copyWith: c]]]]]						ifFalse: [t := v]]				ifFalse: [t := String new].			t isEmpty 				ifTrue: [nil]				ifFalse: [(self stripTrailingSeparators: t) asSymbol]]</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForAspect">initForAspect	"Initialize the receiver to convert to and from	Symbol's print representations."	toPrint :=			[:m |			| val |			(val := m ) == nil				ifTrue: [String new]				ifFalse:					[(val detect: [:c | c isSeparator] ifNone: []) notNil						ifTrue: ['#', val]						ifFalse: [val printString]]].	toRead := 			[ :v | 			| t |			v size &gt; 0				ifTrue:					[v first == $#						ifTrue: [t := v copyFrom: 2 to: v size]						ifFalse: [t := v]]				ifFalse: [t := String new].			t isEmpty				ifTrue: [nil]				ifFalse: [(self stripTrailingSeparators: t) asSymbol]]</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForByteArray">initForByteArray	toPrint :=		[:m |		| val |		(val := m ) == nil			ifTrue: [String new]			ifFalse: [val printString]].	toRead :=		[:v |		v isEmpty			ifTrue: [nil]			ifFalse: [self convertToByteArray: v]]</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForBoolean">initForBoolean	toPrint := 			[:m | 			| val |			(val := m ) == nil				ifTrue: [String new]				ifFalse: 					[val printString]].	toRead := [:v | v isEmpty				ifTrue: [nil]				ifFalse:					[#('T' 'TRUE' 'Y' 'YES' '1') includes:						(v asString asUppercase)]].</body></methods><methods><class-id>UI.PrintConverter</class-id> <category>initalize-release</category><body package="Interface-Models" selector="initForI18NKey">initForI18NKey	"Initialize the receiver to convert to and from	a message catalog key's print representations."	toPrint := 			[:m | 			| val |			(val := m) == nil ifTrue: [String new] ifFalse: [val printString]].	toRead := 			[:v | 			| t |			t := v size &gt; 0 ifTrue: [v] ifFalse: [String new].			t isEmpty 				ifTrue: [nil]				ifFalse: [(t select: [:c | c isAlphaNumeric or: [c = $_]]) asSymbol]]</body></methods><methods><class-id>UI.SlotAdaptor</class-id> <category>printing</category><body package="Interface-Models" selector="printOn:">printOn: aStream	aStream print: self class.	aStream nextPut: $(.	self target printOn: aStream.	aStream space.	self printPathOn: aStream.	aStream nextPutAll: 'instVarAt: '.	aStream nextPutAll: index printString.	aStream nextPut: $).</body></methods><methods><class-id>UI.HoverHelpAssistant</class-id> <category>private</category><body package="Interface-Hoverhelp" selector="shouldOpenTooltipSoon">shouldOpenTooltipSoon	self		log: #shouldOpenNow , '=' , self hoverHelpSystem isCloseRecent printString.	^self hoverHelpSystem isCloseRecent</body></methods><methods><class-id>UI.HoverHelpAssistant</class-id> <category>initialize-release</category><body package="Interface-Hoverhelp" selector="resetStateMachine">resetStateMachine	self lock critical: [		stateMachine ifNotNil: [			self log: (#resetStateMachine, ' deactivate: ', stateMachine currentState name printString).			stateMachine reset]]</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="Interface-Support" selector="iconLabelLengthValue">iconLabelLengthValue	| iconLabelLength |	iconLabelLength := PluggableAdaptor on: Window.	iconLabelLength		getBlock: 			[:win | 			win maxIconLabelLength = 0				ifTrue: ['No label']				ifFalse: [win maxIconLabelLength &gt; Window unlimitedIconLabelLengthBoundary						ifTrue: ['Unlimited']						ifFalse: [win maxIconLabelLength printString]]]		putBlock:			[:win :newValueString |				newValueString size &gt; 0 ifTrue: 					[win maxIconLabelLength: (newValueString = 'No label'							ifTrue: [0]							ifFalse: [newValueString first isDigit									ifTrue: [newValueString asNumber]									ifFalse: [Window unlimitedIconLabelLengthBoundary]])]]		updateBlock: [:m :a :p | true].	^iconLabelLength</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>menu messages</category><body package="UIBasics-Support" selector="printIt">printIt	"Evaluate the current selection as an expression.  If successful, insert and	select the printString of the result of evaluation after the current selection."	self maybeSelectCurrentLine.	self hasRangeSelection ifTrue:		[[self			insertAndSelect: (' ' , self evaluateSelection printString) 			at: self selectionStopIndex]				on: self class compilationErrorSignal				do: [:ex | ex return]]</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>editing-functions</category><body package="UIBasics-Support" selector="displayDate">displayDate	self appendToSelection: Date today printString</body></methods><methods><class-id>UI.WinXPProgressWidgetView</class-id> <category>displaying</category><body package="UILooks-WinXP" selector="displayOn:">displayOn: graphicsContext 	| string origin extent stringOrigin |	origin := self barOrigin.	extent := self barExtent.	graphicsContext paint: self bgColor.	graphicsContext displayRectangle: (self bounds insetBy: 3).	graphicsContext paint: self fgColor.	graphicsContext displayRectangle: ((origin extent: extent) insetBy: 2).	string := (lastValue printString , '%') asText allBold asComposedText.	stringOrigin := ((self bounds extent + (-1 @ -1)) - string bounds extent / 2.0) rounded.	string displayOn: graphicsContext at: stringOrigin.	graphicsContext paint: self bgColor.	graphicsContext intersectClip: ((origin extent: extent) insetBy: 2).	string displayOn: graphicsContext at: stringOrigin.</body></methods><methods><class-id>UI.IndexedAdaptor</class-id> <category>printing</category><body package="Interface-Models" selector="printOn:">printOn: aStream	aStream print: self class.	aStream nextPut: $(.	self target printOn: aStream.	aStream space.	self printPathOn: aStream.	aStream nextPutAll: index printString.	aStream nextPut: $).</body></methods><methods><class-id>UI.ProgressWidgetView</class-id> <category>displaying</category><body package="UIBasics-Components" selector="displayOn:">displayOn: graphicsContext 	| string origin extent stringOrigin |	origin := self barOrigin.	extent := self barExtent.	graphicsContext paint: self bgColor.	graphicsContext displayRectangle: self bounds.	graphicsContext paint: self fgColor.	graphicsContext displayRectangle: (origin extent: extent).	string := (lastValue printString , '%') asText allBold asComposedText.	stringOrigin := (self bounds extent - string bounds extent / 2.0) rounded.	string displayOn: graphicsContext at: stringOrigin.	graphicsContext paint: self bgColor.	graphicsContext intersectClip: (origin extent: extent).	string displayOn: graphicsContext at: stringOrigin</body></methods><methods><class-id>UI.WindowsInputManager class</class-id> <category>private class initialization</category><body package="Internationalization" selector="charSet:">charSet: aNumber 	"WindowsInputManager charSet: 204"	| codepage newEncoder |	"If somehow we get this message on a Unicode VM, the event is not	useful since for all keyboard code pages we should still use the UTF16	encoding."	(aNumber = 0 or: [Win32SystemSupport vmPreferredEncoding = #UTF16])		ifTrue: [self initializeEncoder.  ^self].	#(		#(#RUSSIAN_CHARSET 204 1251)		#(#EE_CHARSET 238 1250)		#(#GREEK_CHARSET 161 1253)		#(#TURKISH_CHARSET 162 1254)		#(#BALTIC_CHARSET 186 1257)		#(#HEBREW_CHARSET 177 1255)		#(#ARABIC_CHARSET 178 1256)		#(#THAI_CHARSET 222 874))			do: [:map | (map at: 2) = aNumber ifTrue: [codepage := map at: 3]].	newEncoder := CharacterEncoderPool		at: ('MS_CP_', codepage printString) asSymbol		ifAbsent: [nil].	newEncoder isNil		ifTrue: [self initializeEncoder]		ifFalse: [Encoder := newEncoder].	^Encoder</body></methods><methods><class-id>UI.MenuItem</class-id> <category>enabled/disabled</category><body package="Interface-Menus" selector="isEnabled">isEnabled	"Answer whether the menu item should be enabled on the menu.  If its not enabled it can't be selected."	| result im |	result := enabled evaluate.	(result isKindOf: Boolean) ifFalse: 		[Transcript			cr;			show: ((#MenuEnablementNotBoolean &lt;&lt; #dialogs &gt;&gt; 'Menu enablement for &lt;1s&gt; answers &lt;2s&gt; instead of a Boolean.')			expandMacrosWith: label printString			with: result printString);			cr;			show: (#AnsweringTrue &lt;&lt; #dialogs &gt;&gt; 'Answering true').		result := true].	im := self labelImage.	im isNil ifFalse: [im downcastEvent: #enablement with: result from: self].	^result</body></methods><methods><class-id>UI.MenuItem</class-id> <category>labeling</category><body package="Interface-Menus" selector="rawLabel">rawLabel	^[label evaluate] on: Error do: [:ex | ex return: label printString]</body></methods><methods><class-id>UI.Notice</class-id> <category>aspects</category><body package="Interface-Support" selector="show:">show: aString	messages == nil ifTrue: [^self].	messages position == 0 ifFalse: [messages cr].	messages show: '[' , Time now printString , '] ' , aString.</body></methods><methods><class-id>UI.Notice class</class-id> <category>instance creation</category><body package="Interface-Support" selector="showNotice:complete:while:title:">showNotice: aString complete: anInteger while: aBlock title: titleString	"Show a progress indicator window while executing a block of 	code. A mini-transcript is included in the notice window.	anInteger is the completeness count (ie = 100%). 	IncrementNotification is raised to denote progress. To reset the	progress bar, raise an IncrementNotification signal with the parameter 'reset'.	MessageNotification is raised to add a message in the window's transcript."	"Example:"	"self 		showNotice: 'In Progress' 		complete: 10 		while: 			[#(10 6 0 20) do:				[:count |				MessageNotification raiseSignal: 'a message ', count printString.				ResetIncrementNotification signalWith: count.  				count timesRepeat: 					[(Delay forMilliseconds: 400) wait.					IncrementNotification raiseSignal]]]		title: 'Testing'"	|  noticeModel int increment progress res title newValue |	title := ((titleString isNil or: [titleString asString isEmpty]) ifTrue: [(#PleaseWait &lt;&lt; #dialogs &gt;&gt; 'Please Wait') asString] ifFalse: [titleString asString]), (#NoticeDoneMacro &lt;&lt; #labels &gt;&gt; ' : &lt;1s&gt;%% done') asString.	noticeModel := self new. 	self openOn: noticeModel withSpec: #noticeWindowSpec.	noticeModel message: aString asText allBold. 	noticeModel postOpenWith: nil.	InputState default grabInputFor: noticeModel builder window.	noticeModel builder window windowManager processOutstandingEvents.	int := anInteger isZero				ifTrue: [1]				ifFalse: [anInteger].	increment := 1.0 / int.	progress := (noticeModel builder componentAt: #progressBar1) widget model.	progress value: 0.0.	[ [ [ [ Cursor wait showWhile: [ res := aBlock value ] ]			on: IncrementNotification do: 				[:not | 				[noticeModel builder window raise.				newValue := progress value + (not ticks * increment).				((progress value * 100.0) rounded min: 100) = ((newValue * 100.0) rounded min: 100) ifFalse: 					[noticeModel builder window label: (title expandMacrosWith: ((newValue * 100.0) rounded min: 100) printString)].				progress value: newValue.				noticeModel builder window windowManager processOutstandingEvents] uiEventNowFor: noticeModel builder window.				not resume				]		 ] on: MessageNotification do:			[ :not | 			[noticeModel builder window raise.			noticeModel show: not messageText.			noticeModel builder window windowManager processOutstandingEvents] uiEventNowFor: noticeModel builder window.			not resume			]	  ] on: ResetIncrementNotification do:			[ :not | | count |			[noticeModel builder window raise.			not oldCount: (Array with: (1 / increment) rounded with: ((progress value)  * (1 / increment)) rounded).			count := not count isZero				ifTrue: [ 1 ]				ifFalse: [ not count ].			progress value: 0.0.			noticeModel builder window label: (title expandMacrosWith: '0').			increment := 1.0 / count.			noticeModel builder window windowManager processOutstandingEvents] uiEventNowFor: noticeModel builder window.			not resume.			]	] ensure: 		[InputState default ungrabInputFor: noticeModel builder window.		noticeModel closeAndUnschedule].	^res</body></methods><methods><class-id>UI.Notice class</class-id> <category>instance creation</category><body package="Interface-Support" selector="showProgress:complete:while:title:">showProgress: aString complete: anInteger while: aBlock title: titleString	"Show a progress indicator window while executing a block of 	code. anInteger is the completeness count (ie = 100%). 	IncrementNotification is raised to denote progress. To reset the	progress bar, raise an IncrementNotification signal with the parameter 'reset'.	MessageNotification is raised to add a message in the window's transcript."	"Example:"	"self 		showProgress: 'In Progress' 		complete: 100000 		while: [100000 timesRepeat: [IncrementNotification raiseSignal]]		title: 'Testing'"	|  noticeModel int increment progress res title newValue |	title := ((titleString isNil or: [titleString asString isEmpty]) ifTrue: [(#PleaseWait &lt;&lt; #dialogs &gt;&gt; 'Please Wait') asString] ifFalse: [titleString asString]), (#NoticeDoneMacro &lt;&lt; #labels &gt;&gt; ' : &lt;1s&gt;%% done') asString.	noticeModel := self new.	self openOn: noticeModel withSpec: #progressWindowSpec.	InputState default grabInputFor: noticeModel builder window.	noticeModel message: aString asText allBold.	noticeModel postOpenWith: nil.	noticeModel builder window refresh.	int := anInteger isZero				ifTrue: [1]				ifFalse: [anInteger].	increment := 1.0 / int.	progress := (noticeModel builder componentAt: #progressBar1) widget model.	progress value: 0.0.	[ [Cursor wait showWhile: [res := aBlock value]]			on: IncrementNotification			do: 				[:not | 				[noticeModel builder window raise.				not messageText = (#reset &lt;&lt; #dialogs &gt;&gt; 'reset') asString ifTrue: [progress value: 0.0].				newValue := progress value + (not ticks * increment).				((progress value * 100.0) rounded min: 100) = ((newValue * 100.0) rounded min: 100) ifFalse: 					[noticeModel builder window label: (title expandMacrosWith: ((newValue * 100.0) rounded min: 100) printString)].				progress value: newValue .				noticeModel builder window windowManager processOutstandingEvents] uiEventNowFor: noticeModel builder window.				not resume] ]			ensure: 				[InputState default ungrabInputFor: noticeModel builder window.				noticeModel closeAndUnschedule].	^res</body></methods><methods><class-id>UI.RowVisualComposite</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="rowSelectorVisual">rowSelectorVisual		container rowLabelsAsButtons		ifTrue: [^self rowSelectorButtonVisual].	^VisualBlock		block:			[:graphicsContext :boundingBox | 			| box offset |			(container isSelected: index)				ifTrue:					[box := DefaultSelectionMask bounds.					offset := boundingBox center - box extent half.					graphicsContext paint: self foregroundColor.					DefaultSelectionMask displayOn: graphicsContext at: offset].			((container isSelected: index) not and: [container showLineNumbers])				ifTrue:					[| label textStyle lookPolicy |					lookPolicy := container widgetPolicy lookPolicyClass.					textStyle := lookPolicy useSystemFontsOnWidgets						ifTrue: [lookPolicy systemWidgetTextStyle]						ifFalse: [lookPolicy systemTextStyle].					label := Label						with: index printString						attributes: textStyle.					offset := boundingBox center - label bounds extent half.					label displayOn: graphicsContext at: offset]]		"bounds: self elementBox"</body></methods><methods><class-id>UI.RowVisualComposite</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="rowSelectorButtonVisual">rowSelectorButtonVisual	^VisualBlock block: 			[:graphicsContext :boundingBox |			| box lookPolicy borderedButton |			box := boundingBox insetBy: (0 @ 0								extent: (container showVerticalLines ifTrue: [1] ifFalse: [0])										@ (container showHorizontalLines ifTrue: [1] ifFalse: [0])).			lookPolicy := container widgetPolicy lookPolicyClass.			borderedButton := self borderedButtonFor: lookPolicy.			((container isSelected: index) not and: [container showLineNumbers])				ifTrue: 					[| label textStyle |					textStyle := lookPolicy useSystemFontsOnWidgets								ifTrue: [lookPolicy systemWidgetTextStyle]								ifFalse: [lookPolicy systemTextStyle].					label := Label with: index printString attributes: textStyle.					borderedButton component label: label].			(container isSelected: index)				ifTrue: 					[| label |					label := self selectionIconLabel.					borderedButton component label: label].			borderedButton bounds: box.			borderedButton container: container.			borderedButton displayOn: graphicsContext at: 0 @ 0]</body></methods><methods><class-id>UI.InputSensor</class-id> <category>private</category><body package="Interface-Support" selector="forkEmergencyEvaluatorAt:">forkEmergencyEvaluatorAt: priority	"Fork a process running a simple Smalltalk evaluator using as little of the system as possible.  Used for desperate debugging.  May be invoked by control-shift-C."	[ | eWindow event |		eWindow := ScheduledWindow 			openNewIn: (Screen default bounds origin + (20@20) extent: Screen default bounds extent // 2).		eWindow controller.		EmergencyWindows add: eWindow.		[ | stream char gc lineSpacing leftMargin string bottom ct newbottom textStyle |			eWindow label: (#emergencyEvaluator &lt;&lt; #labels &gt;&gt; 'EMERGENCY EVALUATOR').			[eWindow sensor hasDamage] whileFalse.			eWindow checkForEvents.			textStyle := TextAttributes default.			gc := eWindow graphicsContext.			lineSpacing := textStyle lineGridFor: gc fontPolicy.			gc paint: ColorValue black.			leftMargin := 20.			((#emergencyEvaluatorExpression &lt;&lt; #dialogs &gt;&gt; 				'Emergency Evaluator (priority &lt;1p&gt;) -- type an expression terminated by ESC') 				expandMacrosWith: priority) asComposedText					displayOn: gc 					at: leftMargin@0.			stream := WriteStream on: String new.			bottom := lineSpacing.			ct := String new asComposedText.			[(char := (event := eWindow sensor nextKeyboardEvent) keyCharacter) = Character esc] whileFalse:				[event isKeyPress ifTrue: 					[(char = Character backspace or: [char = Character del]) 						ifTrue: 							[stream position &gt; 0 ifTrue: 								[stream skip: -1.								gc paint: ColorValue white.								gc displayRectangle: (0 @ (bottom-lineSpacing) corner: gc medium width @ bottom).								gc paint: ColorValue black]]						ifFalse: [(event isKeyboard and: [char isNil not]) ifTrue: [stream nextPut: char]].					ct := stream contents asComposedText.					newbottom := ct height + lineSpacing.					newbottom &gt; bottom ifTrue: 						[gc paint: ColorValue white.						gc displayRectangle: (0 @ lineSpacing corner: gc medium width @ newbottom).						gc paint: ColorValue black].					newbottom &lt; bottom ifTrue: 						[gc paint: ColorValue white.						gc displayRectangle: (0 @ newbottom corner: gc medium width @ bottom).						gc paint: ColorValue black].					bottom := newbottom.					ct  displayOn: gc at: leftMargin@lineSpacing.					gc flush]].			string := nil.			[string := Cursor execute showWhile: [(self class evaluatorClass evaluate: stream contents) printString]]				on: Object errorSignal				do: 				[:ex |				(ex errorString , (String with: Character cr with: Character cr) , 				ex initialContext printString) asComposedText					displayOn: gc					at: leftMargin@(lineSpacing+ ct height ).				ex return].			[string notNil ifTrue:				[('------', (String with: Character cr ) ,string) asComposedText					displayOn: gc					at: leftMargin@(lineSpacing*2+ ct height).				gc flush]]				on: Object errorSignal				do: [:ex | ex return].			(Delay forSeconds: 2) wait.			eWindow close]			ensure:				[EmergencyWindows remove: eWindow ifAbsent: [].				EmergencyWindows removeAllSuchThat: [:w | w isOpen not]]]					forkAt: priority</body></methods><methods><class-id>UI.InputState class</class-id> <category>class initialization</category><body package="OS-Window System" selector="initKeys">initKeys	"InputState initKeys"	FunctionKeyNames := #(		Compose Home Left Right Up Down PageUp PageDown End Begin		PF1 PF2 PF3 PF4 Insert ShiftL ShiftR Control CapsLock MetaL MetaR		AltL AltR Help Enter Clear FwdDelete NumLock BackTab nil nil nil		F1 F2 F3 F4 F5 F6 F7 F8 F9 F10		F11 F12 F13 F14 F15 F16 F17 F18 F19 F20		F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 F32 F33 F34 F35).	FunctionKeyValues := IdentityDictionary new: FunctionKeyNames size * 2.	FunctionKeyNames with: (1 to: FunctionKeyNames size) do:		[:keyName :index|		 keyName notNil ifTrue:			[FunctionKeyValues at: keyName put: index]].	"Now add L and R function key homonyms for F16 through F25 (L1 through L10)	 and F26 through F35 (R1 through R10)"	1 to: 10 do:		[:fKeyIndex|		FunctionKeyValues			at: ('L', fKeyIndex printString) asSymbol put: fKeyIndex + 42;			at: ('R', fKeyIndex printString) asSymbol put: fKeyIndex + 52].	MetaFunctionKeyMap := 0.	#(ShiftL ShiftR Control CapsLock MetaL MetaR AltL AltR) do: 			[:keyName | 			| index |			index := (FunctionKeyValues at: keyName) - 1.			MetaFunctionKeyMap := MetaFunctionKeyMap bitOr: (1 bitShift: index)]</body></methods><methods><class-id>UI.NamedSpec</class-id> <category>private</category><body package="UIPainter" selector="assignNameFrom:">assignNameFrom: aPainterController	| tempName wrappers specsLikeMe specNames index |	tempName := self componentName asString copyWithout: $ .	wrappers := self drilledWrappersFrom: aPainterController view components.	specsLikeMe := wrappers select: [:each | each spec isKindOf: self class].	specNames := specsLikeMe collect: [:each | each spec name].	index := 0.	[index := index + 1.	(specNames includes: (tempName, index printString) asSymbol)] whileTrue.	name := (tempName, index printString) asSymbol.</body></methods><methods><class-id>UI.MacOSXProgressWidgetView</class-id> <category>displaying</category><body package="UILooks-MacOSX" selector="displayOn:">displayOn: gc	"Draw a gray border arround the bar and draw text in darkGray only."	"MacXProgressWidgetView slowExample"		| string origin extent stringOrigin originOffset outerRect |	self installProcessIfNeeded.	origin := self barOrigin.	extent := self barExtent.	"Progress bar is always 16 pixel high, so adjust things here"	originOffset := (extent y - 16) // 2.	origin y: origin y + originOffset.	gc paint: ColorValue lightGray.	gc		displayRectangularBorder:			(outerRect := origin extent: (self bounds insetBy: 1) extent x @ 15).	gc intersectClip: outerRect.	self		displayImage: self class bgImage		from: (origin x + 1) @ origin y		to: outerRect extent x - 2		on: gc.	gc intersectClip: (origin + 1 extent: (extent x - 3) @ 14).	mutex		critical:			[self				displayImage: self class fgImage				from: iterativeIndex negated @ origin y				to: extent x - 2				on: gc].	gc intersectClip: self bounds.	string := (lastValue printString , '%') asText allBold asComposedText.	stringOrigin := (self bounds extent - string bounds extent) half rounded.	gc paint: ColorValue darkGray.	string displayOn: gc at: stringOrigin</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>private</category><body package="UIBuilder-Framework" selector="rebuildMenu:named:with:augmentTo:">rebuildMenu: oldMenu named: aSymbol with: newMenu augmentTo: aClass	"A menu action method may have been added or removed.  Regenerate the menu to reflect the change.  For robustness catch and ignore any errors."		[	[newMenu		augmentFrom: self class		to: aClass		menuName: aSymbol		for: self.	oldMenu menuItems do: [:item | oldMenu removeItem: item].	oldMenu addPart: newMenu.	"Now get the menu bar view to update itself from the menu. 	Getting to the menuBarView this way is a hack."	self builder keyboardProcessor menuBar == nil		ifFalse: [self builder keyboardProcessor menuBar updateMenu]]			on: MenuAugmentationError			do: 				[:ex |				| err param |								[Transcript					cr;					show: (#SomeMenuItemsNotUsed &lt;&lt; #dialogs								&gt;&gt; 'The following menu items were not added for &lt;1s&gt;'									expandMacrosWith: self class name)]						on: Error						do: 							[:ex2 |							Transcript beginEntry.							ex2 return].				((param := ex parameter) notNil and: [param isSequenceable])					ifTrue: 						[param do: 								[:association |																[Transcript									cr;									tab;									show: association key first value storeString;									show: ' -&gt; ';									show: (err := association value) printString;									show: '(';									show: err messageText;									show: ')']										on: Error										do: 											[:ex2 |											Transcript beginEntry.											ex2 return]]].				ex isResumable ifTrue: [ex resume] ifFalse: [ex pass]]]			on: Error			do: [:ex | ex return]</body></methods><methods><class-id>UI.EmergencyWindow</class-id> <category>events</category><body package="OS-Window System" selector="processEscape">processEscape	| string graphicsContext method |	graphicsContext := self graphicsContext.	string := nil.	[string := Cursor execute showWhile:		[method := self compileExpression: commandStream contents.		(nil performMethod: method) printString]]		on: Error		do: [:error |			(error errorString , (String with: Character cr with: Character cr) , error initialContext printString) asComposedText				displayOn: graphicsContext				at: leftMargin @ lastBottom.			error return].	[string notNil		ifTrue:			[('------', (String with: Character cr ) , string) asComposedText				displayOn: graphicsContext				at: leftMargin @ lastBottom.			graphicsContext flush]]		on: Error		do: [:error | error return].	(Delay forSeconds: 3) wait.	self close.</body></methods><methods><class-id>UI.SourceCodeEditor</class-id> <category>actions - performing</category><body package="UIBasics-Text2" selector="displayDate">displayDate	&lt;state: #active modifiers: #(control shift) key: $D&gt;	self insert: Date today printString</body></methods><methods><class-id>UI.TreeViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter" selector="addBindingsTo:for:channel:">addBindingsTo: env for: inst channel: aChannel 	super		addBindingsTo: env		for: inst		channel: aChannel.	env 		at: #minimumHeight 		put: (self adapt: inst forAspect: #minimumHeight channel: aChannel).	env at: #displayStringSelector put: (TypeConverter onSymbolValue: (self				adapt: inst				forAspect: #displayStringSelector				channel: aChannel)).	env at: #useIcons put: (self			adapt: inst			forAspect: #useIcons			channel: aChannel).	env at: #fullLineSelect put: (self			adapt: inst			forAspect: #fullLineSelect			channel: aChannel).	env at: #rootExpander put: ( self			adapt: inst			forAspect: #rootExpander			channel: aChannel).	env at: #iconSelectors put: ((TypeConverter on: (self				adapt: inst				forAspect: #iconSelectors				channel: aChannel))			getBlock: 				[:m | 				| val |				(val := m value) isNil					ifTrue: [String new]					ifFalse: 						[| str |						str := (String new: 80) writeStream.						val do: [:ea | str nextPutAll: ea printString; space].						str contents]]			putBlock: 				[:m :v | 				| tokens t |				v isEmpty					ifTrue: [t := #()]					ifFalse: 						[tokens := (v tokensBasedOn: Character space) reject: [:s | s = ''].						t := Array new: tokens size.						1 to: tokens size							do: 								[:i | 								| s |								s := tokens at: i.								s first == $# ifTrue: [s := s copyFrom: 2 to: s size].								t at: i put: s asSymbol]].				t isEmpty					ifTrue: [m value: nil]					ifFalse: [m value: t]]			updateBlock: [:m :a :p | true]).	env at: #inPlaceEditedSelector put: (self			adapt: inst			forAspect: #inPlaceEditedSelector			channel: aChannel).	env at: #openedEmphasis put: (self			adapt: inst			forAspect: #openedEmphasis			channel: aChannel).	env at: #closedEmphasis put: (self			adapt: inst			forAspect: #closedEmphasis			channel: aChannel).	env at: #leafEmphasis put: (self			adapt: inst			forAspect: #leafEmphasis			channel: aChannel).	env at: #useChildImages put: (self			adapt: inst			forAspect: #useChildImages			channel: aChannel).	env at: #useLines put: (self			adapt: inst			forAspect: #useLines			channel: aChannel)</body></methods><methods><class-id>UI.ClickableGraphic class</class-id> <category>example</category><body package="Graphics-Visual Objects" selector="example">example	"self example"	| me window text |	window := ScheduledWindow new.	window component: CompositePart new.	0 to: 1		do: 			[:x |			0 to: 1				do: 					[:y |					me := self new.					text := (x @ y) printString asText.					me idleGraphic: (Label with: text).					me						mouseOverGraphic: (Label with: (text copyOld emphasizeAllWith: #underline)).					me mouseDownGraphic: (Label with: (text copyOld emphasizeAllWith: #italic)).					me when: Clicked						do: 							[Transcript								show: 'Clicked: ' , (x @ y) printString;								cr].					window component add: me in: (x @ y / 2 extent: 1 asPoint / 2)]].	window openWithExtent: 200 @ 200</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu messages</category><body package="UIBasics-Controllers" selector="printIt">printIt	"Evaluate the current selection as an expression.  If successful, insert and	select the printString of the result of evaluation after the current selection."	self maybeSelectCurrentLine.	self hasRangeSelection		ifTrue: 			[			[self insertAndSelect: ' ' , self evaluateSelection printString				at: self selectionStopIndex]					on: self class compilationErrorSignal					do: [:ex | ex return]]</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>editing-functions</category><body package="UIBasics-Controllers" selector="displayDate">displayDate	self appendToSelection: Date today printString</body></methods><methods><class-id>UI.TypeConverter</class-id> <category>initialize algorithm</category><body package="Interface-Models" selector="objectToText">objectToText	" Initialize the receiver to perform the action	when assigned a value "	self		getBlock:			[:m |			| val |			(val := m value) == nil				ifTrue: [String new]				ifFalse: [val printString]]		putBlock:			[:m :v | v isEmpty				ifTrue: [m value: nil]				ifFalse: [m value: (Object readFrom: v readStream)]]		updateBlock: [:m :a :p | true]</body></methods><methods><class-id>UI.TypeConverter</class-id> <category>private</category><body package="Interface-Models" selector="convertToLiteral:">convertToLiteral: aString	| array s indx obj |	array := Scanner new scanTokens: aString.	array size = 0 ifTrue: [^nil].	obj := array first.	array size = 1 ifTrue: [obj == #true ifTrue: [^true].						obj == #false ifTrue: [^false].						obj == #'nil' ifTrue: [^nil].						^obj].	obj == #'#'		ifTrue: [indx := 2]		ifFalse: [indx := 1].	s := String new writeStream.	indx to: array size do:		[:i |		| e |		e := array at: i.		s			nextPutAll: (e isCharacters						ifTrue: [e]						ifFalse: [e printString]);			space].	s skip: -1.	^s contents asSymbol</body></methods><methods><class-id>UI.TypeConverter</class-id> <category>private</category><body package="Interface-Models" selector="aspectToText">aspectToText	" Initialize the receiver to perform the action	when assigned a value "	self		getBlock:			[:m |			| val |			(val := m value) == nil				ifTrue: [String new]				ifFalse:					[(val detect: [:c | c isSeparator] ifNone: []) notNil						ifTrue: ['#', val]						ifFalse: [val printString]]]		putBlock:			[:m :v | 			| t |			v size &gt; 0				ifTrue:					[v first == $#						ifTrue: [t := v copyFrom: 2 to: v size]						ifFalse: [t := v]]				ifFalse: [t := String new].			t isEmpty				ifTrue: [m value: nil]				ifFalse: [m value: (self stripTrailingSeparators: t) asSymbol]]		updateBlock: [:m :a :p | true]</body></methods><methods><class-id>PostgreSQLEXDITimestampValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"I return a PostgreSQL-friendly (single quoted) string representation of my timestamp object."	| timestamp |	timestamp := self object.	^((String new writeStream)		print: timestamp year;		nextPut: $-;		print: timestamp month;		nextPut: $-;		print: timestamp day;		space;		print: timestamp hour;		nextPut: $:;		print: timestamp minute;		nextPut: $:;		print: timestamp second;		nextPut: $.;		nextPutAll: ('000000', timestamp microsecond printString last: 6);		contents) printString</body></methods><methods><class-id>OS.SocketAddress</class-id> <category>printing</category><body package="OS-Sockets" selector="printOn:">printOn: aStream 	"Append to the argument, aStream, the printable representation of the	domain code and the remaining bytes."	| fn fc |	aStream print: self class.	aStream nextPut: $(.	self class = SocketAddress		ifTrue: 			[fc := self domainCode.			fn := [self class domainNameFromCode: fc]				on: KeyNotFoundError				do: [:ex | ex returnWith: 'af' , fc printString].			aStream nextPutAll: fn asString.			aStream space].	self printBytesOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>OS.MC_FileBTree class</class-id> <category>testing</category><body package="UIBasics-Internationalization" selector="test">test	"FileBTree test."	| test |	test := self named: 'test1.ism'.	1 to: 100 do:		[:i |		test at: 'foo', i printString put: i].	^test</body></methods><methods><class-id>OS.IPSocketAddress</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	&lt;inspectorFields&gt;	^Array		with:			(Tools.Trippy.TextAttribute				label: #hostName &lt;&lt; #dialogs &gt;&gt; 'host name'				textBlock: [self hostName])		with:			(Tools.Trippy.TextAttribute				label: #hostAddress &lt;&lt; #dialogs &gt;&gt; 'host address'				textBlock: [ | output |					output := String new writeStream.					self printAddressOn: output.					output contents ])		with:			(Tools.Trippy.TextAttribute				label: #port &lt;&lt; #dialogs &gt;&gt; 'port'				textBlock: [self port printString])</body></methods><methods><class-id>OS.WinProcess</class-id> <category>initialize-release</category><body package="OS-ExternalProcess" selector="oemEncoding">oemEncoding	^OSSystemSupport concreteClass new GetOEMCP printString asSymbol.</body></methods><methods><class-id>OS.WinProcess</class-id> <category>printing</category><body package="OS-ExternalProcess" selector="printOn:">printOn: aStream 	aStream nextPutAll: 'a WinProcess '.	self key notNil		ifTrue: [aStream nextPutAll: 'PID: ' , (self key memberAt: #dwProcessId) printString]		ifFalse: [aStream nextPutAll: '(Inactive)']</body></methods><methods><class-id>OS.ObjectiveCRuntimeTypeEncoder</class-id> <category>api</category><body package="OS-MacOSX" selector="decode:">decode: rtti	| stream types type |	stream := rtti readStream.	types := OrderedCollection new.	[stream atEnd] whileFalse: [types add: (self decodeTypeFromStream: stream)].	type := CProcedureType		resultType: types first		argumentTypes: (types allButFirst: 1)		argumentNames: ((1 to: types size - 1) collect: [:each | 'arg', each printString]).	^type</body></methods><methods><class-id>OS.ObjectiveCRuntimeTypeEncoder</class-id> <category>private</category><body package="OS-MacOSX" selector="decodeCompositeTypeFromStream:type:endingWith:">decodeCompositeTypeFromStream: stream type: compositeType endingWith: anEndingCharacter	| compositeName composite types existing |	types := OrderedCollection new.	compositeName := String new writeStream.	[stream atEnd or: [stream peek = $= or: [stream peek = anEndingCharacter]]] whileFalse: [compositeName nextPut: stream next].	compositeName := compositeName contents asSymbol.	existing := true.	composite := AbstractObjectiveCRuntime concreteClass externals at: compositeName ifAbsent:		[existing := false.		composite := CCompositeType new perform: compositeType; name: compositeName; yourself.		compositeName = #?			ifTrue:	[composite]			ifFalse:	[AbstractObjectiveCRuntime concreteClass externals at: compositeName put: composite]].	stream next = anEndingCharacter ifFalse:		[[stream atEnd or: [stream peek = anEndingCharacter]] whileFalse: [types add: (self decodeTypeFromStream: stream)].		stream next. "anEndingCharacter"].	existing ifTrue: [^composite].	types keysAndValuesDo: [:key :value | composite at: ('member', key printString) asSymbol put: (key - 1) -&gt; value].	^composite</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>accessing-zlib constants</category><body package="Compression-ZLib" selector="errorStringFor:">errorStringFor: errorCode	^(errorCode between: self Z_VERSION_ERROR and: self Z_NEED_DICT)		ifTrue: [(self cZError: errorCode) copyCStringFromHeap]		ifFalse: ['unknown error ', errorCode printString]	"| i |	 i := self new.	 (i Z_VERSION_ERROR to: i Z_NEED_DICT) collect: [:ec| i errorStringFor: ec]"</body></methods><methods><class-id>OS.Win32PrinterInterface class</class-id> <category>utils</category><body package="OS-PC" selector="printStringFor:">printStringFor: aCompositePointer 	| s |	s := (String new: 50) writeStream.	aCompositePointer type referentType		keysAndValuesDo: 			[:k :v | 			s nextPutAll: k printString.			s nextPutAll: '-&gt;'.			s nextPutAll: (aCompositePointer memberAt: k) printString; cr].	^s contents</body></methods><methods><class-id>PostgreSQLConnectionLog</class-id> <category>services</category><body package="PostgreSQLLogging" selector="logMessage:">logMessage: aMessage 	"^self 	I log aMessage to my target stream. I write out a timestamp, 	followed by a representation of aMessage. Lastly I flush the stream."	(self targetStream) cr; nextPutAll: Timestamp now printString; cr.	aMessage printOn: self targetStream.	self targetStream flush.	^self</body></methods><methods><class-id>PasswordPacket</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Packet size: ' , self packetSize value printString; cr.	aStream nextPutAll: 'Password: ' , self passwordBytes asString printString; cr.	^self</body></methods><methods><class-id>ByteValue</class-id> <category>debugging</category><body package="PostgreSQLDriver" selector="asString">asString	"^a String 	*FOR DEBUGGING ONLY*	I return a String representation of myself."	^'&lt;a ByteValue&gt;:', self value printString</body></methods><methods><class-id>BackendKeyDataMessage</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Process ID: ', self processID printString; cr.	aStream nextPutAll: 'Secret Key: ', self secretKey printString; cr.	^self</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbeEditor</class-id> <category>actions</category><body package="Debugger-Probes" selector="selectWindowID">selectWindowID	| entries list |	entries := OrderedCollection new.	list := OrderedCollection new.	PDPManager windowHolders associationsDo:		[:ac|		entries add: ac key.		list add: '&lt;' , ac key printString , '&gt; ' , ac value label asString].	list isEmpty		ifTrue:			[Dialog warn: (#ThereAreNoWindowsAvailable &lt;&lt; #pdp &gt;&gt; 'There are no windows available.').			^nil].	^Dialog 		choose: (#SelectWindowIDWindow &lt;&lt; #pdp &gt;&gt; 'Select Window&lt;ID&gt;		Window') 		fromList: list		values: entries 		lines: 20		cancel: []</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>private</category><body package="Debugger-Probes" selector="nextWindowID">nextWindowID	| id |	lastID := lastID + 1.	id := lastID printString asSymbol.	watchWindows at: id put: self newWatchWindow.	^id"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorRecord</class-id> <category>initialize-release</category><body package="Debugger-Process Monitor" selector="basicOn:withTag:">basicOn: aProcess withTag: aTag	self initializeNameForProcess: aProcess.	priority := aProcess priority.	underDebug := aProcess isUnderDebug.	state := underDebug ifTrue: ['d ' ] ifFalse: ['  '].	state := state , aProcess processState asString.	topContext := aProcess suspendedContext.	(topContext notNil and: [topContext method == (Semaphore compiledMethodAt: #wait)])		ifTrue: [topContext := topContext sender].	topContext := topContext printString.	type := aProcess isSystemProcess.	type isNil ifTrue: [type := false].	processHash := aProcess identityHash.	processTag := aTag</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorRecord</class-id> <category>initialize-release</category><body package="Debugger-Process Monitor" selector="onWindow:withTag:">onWindow: aWindow withTag: aTag	windowLabel := aWindow label.	windowLabel := windowLabel isNil		ifTrue: [aWindow printString]		ifFalse: [windowLabel asString].	self basicOn: aWindow windowProcess withTag: aTag</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id> <category>reporting</category><body package="Debugger-Probes" selector="report:">report: basicType		| reportStream |	reportStream := WriteStream on: (String new: 200).	reportStream nextPutAll: (self reportStringFor: basicType).	instrumentationRequest == #instrumentSimpleWatch		ifTrue:			[reportStream				nextPutAll: ' &lt;';				nextPutAll: iVarName;				nextPut: $&gt;].	reportStream		nextPutAll:				(#OnMessageReceivedForC &lt;&lt; #pdp &gt;&gt; ' on message received for:') asString;		cr.	instrumentationRecords		do:			[:rec | 			reportStream				cr;				nextPutAll: rec printString].	ComposedTextView		open: reportStream contents asText asValue		label:			#ProbeOnMessageReceivedReport &lt;&lt; #pdp &gt;&gt; 'Probe on Message Received Report'		extent: 500 @ 300</body></methods><methods><class-id>CraftedSmalltalk.StackInspector</class-id> <category>field list</category><body package="Debugger-StackInspector" selector="fieldList">fieldList	| argumentCount size index tempNames |	object == nil ifTrue:		[properties at: #tempNames put: Array new.		^super fieldList].	size := object stackP - object method numLocals.	size &gt; 0		ifFalse:			[^properties at: #tempNames put: Array new].	tempNames := Array new: size.	index := 1.	(isTopContext and:		[object atEnd not and:			[object pdpWillSend and:				[argumentCount := object peekForSelector numArgs.				object sendsAdd1					ifTrue: [argumentCount := argumentCount - 1].				argumentCount &lt; 100]]])		ifTrue:			[[argumentCount &gt; 0]				whileTrue:					[tempNames at: index put: 'a', argumentCount printString, ': ', (self stackStringAt: index).					argumentCount := argumentCount - 1.					index := index + 1].			object hasReceiverOnStackForSend				ifTrue: [tempNames at: index put: 'r: ', (self stackStringAt: index)]				ifFalse: [index := index - 1]]		ifFalse: [tempNames at: index put: (self stackStringAt: index)].	index := index + 1.	index to: size do:		[:j | tempNames at: j put:  (self stackStringAt: j)].	^properties at: #tempNames put: tempNames</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorClient</class-id> <category>private</category><body package="Debugger-Process Monitor" selector="numOfSystemProcesses">numOfSystemProcesses	^(processRecords inject: 0 into: [:s :p | s + (p isSystemProcess ifTrue: [1] ifFalse: [0])]) printString</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorClient</class-id> <category>private</category><body package="Debugger-Process Monitor" selector="numOfUserProcesses">numOfUserProcesses	^(processRecords inject: 0 into: [:s :p | s + (p isSystemProcess ifTrue: [0] ifFalse: [1])]) printString</body></methods><methods><class-id>CraftedSmalltalk.ProcessMonitorClient</class-id> <category>actions</category><body package="Debugger-Process Monitor" selector="changeProcessPriority">changeProcessPriority	| answer |	self hasSelection		ifFalse: [^self].	answer := Dialog request: (#EnterNewPriority &lt;&lt; #pdp &gt;&gt; 'Enter new priority') initialAnswer: self selectedProcessRecord priority printString.	answer isEmpty		ifTrue: [^self].	answer := answer asNumber rounded.	(answer &lt; 1 or: [answer &gt; (Processor highestPriority - 1)])		ifTrue: [^self].	displayList selections do: [:rec | service changeProcessTagged: rec processTag priorityTo: answer]</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarRefInstrumenterGUIModel</class-id> <category>operation</category><body package="Debugger-Probes" selector="updateList">updateList		| classes iVarIndex |	iVarIndex := instrumenter iVarIndex.	classes := subclassModel value		ifTrue: [classUnderTest withAllSubclasses]		ifFalse: [Array with: classUnderTest].	methods := SortedCollection		sortBlock: [:aa :b | aa nameString &lt; b nameString].	classes		do:			[:cl | 			cl				selectorsAndMethodsDo:					[:sel :meth | 					| activity |					activity := 0.					(readModel value and: [meth readsField: iVarIndex])						ifTrue: [activity := 1].					(writeModel value and: [meth writesField: iVarIndex])						ifTrue: [activity := 3 - activity].					meth isProbeable ifFalse: [activity := 0].					activity ~= 0						ifTrue:							[methods add: (MethodActionRecord action: activity class: cl selector: sel)]]].	panelList list: (methods collect: [:aRecord | aRecord printString])</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="createLabelString">createLabelString	labelString value: ((#BreakIn1sAt2s &lt;&lt; #pdp &gt;&gt; 'Break in &lt;1s&gt; at &lt;2s&gt;')			expandMacrosWith: self methodString			with: self characterIndex printString).</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>doIt/accept/explain</category><body package="Debugger-UI" selector="printItCompleted:on:">printItCompleted: result on: aTextController	aTextController		insertAndSelect: (' ' , result printString) 		at: aTextController selectionStopIndex</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicy</class-id> <category>list management</category><body package="Debugger-UI" selector="outputPackageOrParcelStringOn:for:selector:">outputPackageOrParcelStringOn: stream for: aMethod selector: selector	| packages |	#{Store.Registry} ifDefinedDo: 			[:registry |			^selector				ifNil: 					[(aMethod definition ifNotNil: #package)						ifNotNil: 							[:package |							stream								nextPutAll: '$P$';								nextPutAll: package printString]]				ifNotNil: 					[packages := registry allContainingPackagesForSelector: selector								class: aMethod mclass.					packages isEmpty						ifFalse: 							[stream								nextPutAll: '$P$';								nextPutAll: packages last printString]]]</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicy</class-id> <category>list management</category><body package="Debugger-UI" selector="filterStack">filterStack	filteredStack := OrderedCollection new.	patterns isEmpty		ifTrue:			[1 to: stack size do: 				[:i | filteredStack add: (Array with: (stack at: i) printString with: i with: nil).].			^filteredStack].	1 to: stack size do:		[:i | | context componentString match id |		context := stack at: i.		componentString := self componentStringFor: context method homeMethod.		context isBlockContext ifTrue:			[componentString := '$B$', componentString].		match := patterns detect: [:pat | pat pattern perform: matchSymbol with: componentString] ifNone: [nil].		id := match notNil			ifTrue: [match name]			ifFalse: [nil].		(id notNil or: [i &lt;= displayAllLimit])			ifTrue: [filteredStack add: (Array with: context printString with: i with: id)]].	^filteredStack</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id> <category>reporting</category><body package="Debugger-Probes" selector="report:">report: basicType		| reportStream |	reportStream := WriteStream on: (String new: 200).	reportStream		nextPutAll: (self reportStringFor: basicType);		nextPutAll:				(#OnInstanceVariable &lt;&lt; #pdp &gt;&gt; ' on instance variable &lt;') asString;		nextPutAll: iVarName;		nextPutAll: (#ReferencesForC &lt;&lt; #pdp &gt;&gt; '&gt; references for:') asString;		cr.	instrumentationRecords		do:			[:rec | 			reportStream				cr;				nextPutAll: rec printString].	ComposedTextView		open: reportStream contents asText asValue		label:			#ProbeOnIVarRefsReport &lt;&lt; #pdp &gt;&gt;					'Probe on Instance Variable References Report'		extent: 500 @ 300</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>tags</category><body package="Debugger-Support" selector="isTagged:">isTagged: aString	tags detect: [:c | c printString = aString] ifNone: [^false].	^true</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>tags</category><body package="Debugger-Support" selector="selectTag:">selectTag: aString	| ctx |	ctx := tags detect: [:c | c printString = aString] ifNone: [^self].	self selectContext: ctx.	self scheduleContextListSelectionUpdate.	self processEvents.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>accessing</category><body package="Debugger-Support" selector="text">text	| theText meth |	currentContext isNil		ifTrue: [^Text new].	^[theText := currentContext sourceCode asText.	currentContext method homeMethod usuallyHasSelector		ifTrue: [theText makeSelectorBoldIn: currentContext mclass].	(meth := self selectedMethod) isProbed		ifTrue: [meth highlightProbesIn: theText].	theText] 		on: MethodDictionary keyNotFoundSignal		do:  [:ex |			((#noSourceCodeFor1s &lt;&lt; #pdp &gt;&gt; 'no source code for &lt;1s&gt;')			expandMacrosWith: currentContext printString) asText emphasizeAllWith: #italic;				yourself].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>tags</category><body package="Debugger-Support" selector="tagMenuList">tagMenuList	| col |	col := tags asSortedCollection: [:a :b | a hasSender: b].	col := col reject: [:ctx | ctx hasExited].	tags := PDPWeakCollection withAll: col.	^col collect: [:ctx | ctx printString].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>utility</category><body package="Debugger-Support" selector="shortStackFor:ofSize:">shortStackFor: aContext ofSize: anInteger	"Answer a string with the simple descriptions of anInteger number of	non-nil stackframes starting with aContext"	| shortStackStream ctx |	shortStackStream := WriteStream on: (String new: 400).	ctx := aContext.	anInteger timesRepeat: 		[ctx isNil ifFalse:			[shortStackStream nextPutAll: (ctx printString contractTo: 50); cr.			ctx := ctx sender]].	shortStackStream position &gt; 0 ifTrue: [shortStackStream skip: -1].	^shortStackStream contents</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>recompiling</category><body package="Debugger-Probes" selector="reportOnFailedProbes:">reportOnFailedProbes: probesInError	| writeStream |	probesInError isEmpty		ifTrue: [^self].	writeStream := WriteStream on: (String new: 200).	writeStream nextPutAll: (#TheFollowingProbesFailedToRecompile &lt;&lt; #pdp &gt;&gt; 'The following probes failed to recompile correctly.') asString.	probesInError do: [:aProbe |		writeStream nextPutAll: aProbe methodString;			nextPutAll: ((#SpProbeAt1pDash2s &lt;&lt; #pdp &gt;&gt; ' probe at &lt;1p&gt; - &lt;2s&gt;&lt;n&gt;') 				expandMacrosWith: aProbe characterIndex printString				with: aProbe reportString)].	[ComposedTextView		open: writeStream contents asText asValue		label: (#FailedProbeRecompileReport &lt;&lt; #pdp &gt;&gt; 'Failed probe recompile report')] fork"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>Tools.ColorValueSetting</class-id> <category>accessing</category><body package="Tools-Settings" selector="toXML:">toXML: aColorValue	self validate: aColorValue.	^Element		tag: self xmlTag		attributes: (Array 			with: (Attribute name: 'red' value: aColorValue red printString)			with: (Attribute name: 'green' value: aColorValue green printString)			with: (Attribute name: 'blue' value: aColorValue blue printString))		elements: nil</body></methods><methods><class-id>Tools.AbstractPropertyComparisonRollupView</class-id> <category>private</category><body package="Store-Code Comparison" selector="printProperty:">printProperty: aPropertyObject	"The default is to use printString (unless it is already a string). But before we use the default, we check to see if we have any tagged methods whose tag is #printProperty: and paramter matches my propertyKey. If we do, we defer to that method to produce a stringified representation of the argument."	(Pragma		allNamed: #printProperty:		from: self class		to: AbstractComparisonRollupView) do: 				[:each |				(each argumentAt: 1) == self propertyKey					ifTrue: [^self perform: each selector with: aPropertyObject]].	^aPropertyObject isCharacters		ifTrue: [aPropertyObject]		ifFalse: [aPropertyObject printString]</body></methods><methods><class-id>Tools.BooleanSetting</class-id> <category>accessing</category><body package="Tools-Settings" selector="toXML:">toXML: anObject	self validate: anObject.	^Element		tag: self xmlTag		elements: (Array with: (XML.Text text: anObject printString))</body></methods><methods><class-id>Tools.PoolDictionaryInspector</class-id> <category>initialize-release</category><body package="Tools-Inspector" selector="viewLabel">viewLabel	"Answer an appropriate label for a view of the receiver.	 This is the name of the receiver's object appended by PoolDictionary."	^self object allowsSelfDefinition		ifTrue: [((#x1sNameSpace &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; NameSpace')			expandMacrosWith: self object printString)]		ifFalse: [((#x1sPoolDictionary &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; PoolDictionary')			expandMacrosWith: (Smalltalk keyAtIdentityValue: self object ifAbsent: [^super viewLabel]))]</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>private</category><body package="Tools-Parcel Manager" selector="descriptionOfGroups:">descriptionOfGroups: groupCollection	groupCollection isEmpty ifTrue: [^(#NoSelection &lt;&lt; #dialogs &gt;&gt; 'No selection')].	groupCollection size = 1 ifTrue: [^groupCollection first description].	^((#x1sGroupsSelected &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; groups selected')			expandMacrosWith: groupCollection size printString)</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>private</category><body package="Tools-Parcel Manager" selector="descriptionOfParcels:">descriptionOfParcels: parcelCollection	parcelCollection size = 1 ifTrue: [^self descriptionOfParcel: parcelCollection first].	^((#x1sParcelsSelected &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; parcels selected')			expandMacrosWith: parcelCollection size printString)</body></methods><methods><class-id>Tools.SettingsDomain class</class-id> <category>notifications</category><body package="Tools-Settings" selector="classMethodsChanged">classMethodsChanged	"Class methods containing pragmas--that is, methods defining settings and pages--	have changed. Do the necessary updates. For robustness, only allow exception	to happen if there is an outer handler; meaning someone intends to handle it.	Otherwise, report to the transcipt but muffle.	Run the following code to force a notifier to come up for debugging."	"[self classMethodsChanged] on: Error do: [:ex | ex pass]"	[self unsafeUpdatePragmaDependents]		on: Error		do:			[:ex | 			ex isNested				ifTrue: [ex pass]				ifFalse:					[Transcript						cr;						show:								(#ErrorUpdatingSettingsInClass &lt;&lt; #dialogs										&gt;&gt;											'Exception while updating &lt;1s&gt;: &lt;2p&gt; in &lt;3p&gt;. To debug, evaluate the following expression: "[&lt;4s&gt; classMethodsChanged] on: Error do: [:ex | ex pass]".'										expandMacrosWith: self class name										with: ex										with: ex initialContext sender										with: self printString).					ex exit]]</body></methods><methods><class-id>Tools.CompiledCodeInspector</class-id> <category>private-text</category><body package="Tools-Inspector" selector="sourceCodeText">sourceCodeText	"Answer the source code text representing the inspected object's home method."	| aString |	aString := self sourceCode.	aString isNil		ifTrue: [aString := object printString].	^aString asText</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>private</category><body package="Tools-Misc" selector="infoText">infoText	"Returns aText with proper emphasis information 	 from the file system information on fileName"	| fn dates stream mod acc |	fn := fileName asFilename.	dates := fn dates.	mod := dates at: #modified.	mod == nil		ifFalse: [mod := self formatTime: mod].	acc := dates at: #accessed.	acc == nil		ifFalse: [acc := self formatTime: acc].	stream := TextStream on: String new.	stream emphasis: #italic;		nextPutAll: (#isFile &lt;&lt; #dialogs &gt;&gt; '- file -  Select ''Get contents'' to view contents. ') asString;		cr; cr; emphasis: #bold;		nextPutAll: (#fileSize &lt;&lt; #dialogs &gt;&gt; 'Size:     ') asString;		emphasis: nil;		nextPutAll: fn fileSize printString;		cr.	mod == nil		ifFalse:			[stream					emphasis: #bold;				nextPutAll: (#fileModifiedTime &lt;&lt; #dialogs &gt;&gt; 'Last modified:     ') asString;				emphasis: nil;				nextPutAll: mod;				cr].	acc == nil		ifFalse:			[stream					emphasis: #bold;				nextPutAll: (#fileAccessTime &lt;&lt; #dialogs &gt;&gt; 'Last accessed:     ') asString;				emphasis: nil;				nextPutAll: acc;				cr].	((fileName includes: $.)	and: [(fileName copyFrom: (fileName lastIndexOf: $.) to: fileName size) asLowercase = Parcel fileExtension]) ifTrue:		[| codeReader info timestamp prereqs |		stream cr.		codeReader := CodeReader new.		[info := codeReader readInfoFromFileNamed: fileName]			on: CodeReader fileFormatSignal			do:				[:ex|				info := Dictionary new.				codeReader fileFormat notNil ifTrue: [info at: #format put: codeReader fileFormat]].		stream			emphasis: #bold; nextPutAll: (#parcelName &lt;&lt; #dialogs &gt;&gt; 'Parcel:	') asString; emphasis: nil;			nextPutAll: (info at: #parcel ifAbsent: ['?']) asString; cr.		stream			emphasis: #bold; nextPutAll: (#parcelVersion1 &lt;&lt; #dialogs &gt;&gt; 'Version:	') asString; emphasis: nil;			nextPutAll: (info at: #version ifAbsent: ['?']) asString; cr.		(timestamp := info at: #timestamp ifAbsent: nil) notNil ifTrue:			[stream				emphasis: #bold; nextPutAll: (#parcelSavedDate &lt;&lt; #dialogs &gt;&gt; 'Written:	') asString; emphasis: nil;				nextPutAll: (self formatTime: (Array with: timestamp asDate with: timestamp asTime)); cr].		stream			emphasis: #bold; nextPutAll: (#parcelFormat &lt;&lt; #dialogs &gt;&gt; 'Format:	') asString; emphasis: nil;			nextPutAll: (info at: #format ifAbsent: ['?']) printString asString;			tab; emphasis: #italic;			nextPutAll: ((#currentParcelFormat &lt;&lt; #dialogs &gt;&gt; '(current &lt;1p&gt;)') expandMacrosWith: CodeWriter fileFormat);			emphasis: nil; cr.		(info includesKey: #space) ifTrue:			[stream				emphasis: #bold; nextPutAll: (#parcelNumberObjects &lt;&lt; #dialogs &gt;&gt; 'Objects:	') asString; emphasis: nil;				nextPutAll: ((info at: #space) at: 1); cr;				emphasis: #bold; nextPutAll: (#parcelBytes &lt;&lt; #dialogs &gt;&gt; 'Bytes:	') asString; emphasis: nil;				nextPutAll: ((info at: #space) at: 2); cr].		stream			emphasis: #bold; nextPutAll: (#parcelPrereqs &lt;&lt; #dialogs &gt;&gt; 'Prerequisites:') asString; emphasis: nil.		prereqs := info at: #prerequisiteParcels ifAbsent: [Array with: (Array with: (#unknown &lt;&lt; #dialogs &gt;&gt; 'unknown') asString with: '')].		prereqs isEmpty			ifTrue: [stream emphasis: #italic; tab; nextPutAll: (#noParcelPrereqs &lt;&lt; #dialogs &gt;&gt; 'none') asString; emphasis: nil]			ifFalse:				[prereqs do:					[:prereq|					stream tab; nextPutAll: prereq first.					(prereq at: 2) size &gt; 0 ifTrue:						[stream							emphasis: #italic; space; nextPut: $V; space;							nextPutAll: (prereq at: 2); emphasis: nil]]].		stream cr.		(info includesKey: #comment) ifTrue:			[stream				emphasis: #bold; nextPutAll: (#parcelComment &lt;&lt; #dialogs &gt;&gt; 'Comment:	') asString; emphasis: nil;				nextPutAll: ((info at: #comment) at: 1); cr]].	^stream contents</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-look and feel</category><body package="Tools-Settings-VW" selector="lookAndFeel10lookSelection">lookAndFeel10lookSelection	&lt;setting: #(lookAndFeel defaultLook)&gt;	| choices names keys |	names := OrderedCollection new.	choices := OrderedCollection new.	names add: #AutoSelect &lt;&lt; #labels &gt;&gt; 'Auto Select'.	choices add: #AutoSelect.	UILookPolicy allSubclasses do: 		[:look | | lookName |		(lookName := look settingsMenuName) notNil ifTrue:			[names add: lookName.			choices add: look fullyQualifiedReference]].	keys := choices collect: [:each | each printString asSymbol].	^((EnumerationSetting keys: keys choices: choices labels: names)			onUISetting: #defaultLookSelector)		default: #'#AutoSelect';		label: #UserInterfaceLook &lt;&lt; #labels &gt;&gt; 'User interface look';		helpText: #UserInterfaceLookHelpText &lt;&lt; #dialogs &gt;&gt; 'Selects the default appearance and behavior of buttons, scroll bars, etc.  The new look will apply to any canvas or tool window that you open subsequently.  Use "Auto Select" to let VisualWorks adopt the look that is most appropriate for your operating environment.  To affect the look of a single canvas while you''re editing it, use the "Look" menu of the GUI Painter Tool.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-look and feel</category><body package="Tools-Settings-VW" selector="lookAndFeel15feelSelection">lookAndFeel15feelSelection	&lt;setting: #(lookAndFeel defaultFeel)&gt;	| choices names keys |	names := OrderedCollection new.	choices := OrderedCollection new.	names add: #AutoSelect &lt;&lt; #labels &gt;&gt; 'Auto Select'.	choices add: #AutoSelect.	UIFeelPolicy allSubclasses do: 		[:look | | lookName |		(lookName := look settingsMenuName) notNil ifTrue:			[names add: lookName.			choices add: look fullyQualifiedReference]].	keys := choices collect: [:each | each printString asSymbol].	^((EnumerationSetting keys: keys choices: choices labels: names)			 onUISetting: #feelSelection)		default: #'#AutoSelect';		label: #UserInterfaceFeel &lt;&lt; #labels &gt;&gt; 'User interface feel';		helpText: #UserInterfaceFeelHelpText &lt;&lt; #dialogs &gt;&gt; 'Select the platform feel that you want text editors (including browsers) to have. You may add your own Feels by subclassing from UIFeelPolicy and providing your own keyboard bindings in the class. On the class side of the custom UIFeelPolicy class, one must provide a method called "menuName" that returns a string that names the custom feel policy, e.g., ''Windows 4.0''.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="storePrerequisitesBlessingLevel">storePrerequisitesBlessingLevel	&lt;setting: #(#store #prerequisites #blessingLevel ) position: 10  &gt;	| levels choices labels keys |	levels := Store.Policies blessingPolicy blessings asSortedCollection.	choices := levels collect: [:each | each level].	labels := levels collect: [:each | each name].	keys := levels collect: [:each | each level printString asSymbol].	^((EnumerationSetting		keys: keys		choices: choices		labels: labels)		on: Store.Policies prerequisitePolicy aspect: #blessingLevel)		label: #WithBlessingLevelAtLeast &lt;&lt; #store &gt;&gt; '...with blessing level at least'</body></methods><methods><class-id>Tools.ChangeEditor</class-id> <category>private</category><body package="Tools-Changes" selector="textForChangeSet">textForChangeSet	| comment |	^(comment := source value comment) isNil		ifTrue: [			source value isEmpty				ifTrue: [source value printString]				ifFalse: [(#ThisChangeSetHasNoComment &lt;&lt; #dialogs &gt;&gt; 'This ChangeSet has no comment') asString]]		ifFalse: [			(comment size &gt; 0 and: [comment first = $"])				ifTrue:					[comment := comment copyFrom: 2 to: comment size].			(comment size &gt; 0 and: [comment last = $"])				ifTrue:					[comment := comment copyFrom: 1 to: comment size - 1].			comment]</body></methods><methods><class-id>Tools.FileDialog</class-id> <category>private</category><body package="Tools-Dialogs" selector="styledFilesize:">styledFilesize: aFilename 	^self text: aFilename fileSize printString styledFor: aFilename</body></methods><methods><class-id>Tools.FileDialog</class-id> <category>private</category><body package="Tools-Dialogs" selector="styledTimestamp:">styledTimestamp: aFilename	| ts |	ts := [aFilename modificationTimestamp] on: OSErrorHolder errorSignal				do: [:ex | ex return: Timestamp zero].	^self text: ts printString styledFor: aFilename</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>private</category><body package="System-Changes" selector="commentAndTimeStamp">commentAndTimeStamp	"Return my comment and time stamp."	| stream stream2 |	stream := (String new: comment size + 100) writeStream.	changeSetName notNil ifTrue:		[stream			nextPutAll: (#ChangesInChangeSet &lt;&lt; #dialogs &gt;&gt; '"Changes in change set &lt;1s&gt;"'				expandMacrosWith: changeSetName);			cr].	comment notNil ifTrue:		[stream nextPutAll: comment; cr].	stream2 := WriteStream on: (String new: 16).	SystemUtils timeStamp: stream2.	stream nextPutAll: stream2 contents printString.	^stream contents</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>private</category><body package="UIPainter" selector="referUserToSpecBearingParent">referUserToSpecBearingParent	| totalNumberOfSpecs specBearingParent soleSpec canvases cls |	totalNumberOfSpecs := 0.	canvases := Dictionary new.	(cls := self selectedClassOrDo: [^self classGone]) class allSuperclasses		do: 			[:sc | 			| specCount specs |			specCount := (specs := sc organization listAtCategoryNamed: #'interface specs') size.			specCount &gt; 0				ifTrue: 					[specBearingParent := sc instanceBehavior.					canvases at: specBearingParent put: specs].			totalNumberOfSpecs := totalNumberOfSpecs + specCount.			specs isEmpty not ifTrue: [soleSpec := specs first]].	totalNumberOfSpecs == 1		ifTrue: [(Dialog				choose: ((#GenKey92 &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; inherits a canvas from&lt;n&gt;&lt;2s&gt;.&lt;n&gt;Edit this canvas?')			expandMacrosWith: cls printString asString			with: specBearingParent name)				labels: (Array with: (#Edit &lt;&lt; #UIPainter &gt;&gt; 'Edit') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))				values: #(true false )				default: true				for: builder window)				ifTrue: [UIPainter new openOnClass: specBearingParent andSelector: soleSpec]]		ifFalse: [totalNumberOfSpecs == 0				ifTrue: [Dialog warn: ((#x1sHasNoCanvases &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; has no canvases')			expandMacrosWith: cls printString) for: builder window]				ifFalse: [self class openInheritedCanvasDialogOn: cls name with: canvases]]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>commands</category><body package="UIPainter" selector="newImageFromFile">newImageFromFile	|cl aFilename newSelector|	cl := self selectedClassOrDo: [^self classGone].	(aFilename := Dialog 		requestFileName: (#NameOfBitmapFile &lt;&lt; #UIPainter &gt;&gt; 'Name of bitmap file') asString		default: '*.bmp') isEmpty  ifTrue: [^self].	(newSelector := Dialog request: (#GenKey91 &lt;&lt; #UIPainter &gt;&gt; 'Supply the name of the new method to be created:')) isEmpty		ifTrue: [^self].	(cl class includesSelector: newSelector asSymbol) 		ifTrue: 			[(Dialog 				confirm: ((#GenKey90 &lt;&lt; #UIPainter &gt;&gt; '#&lt;1s&gt; already exists in class &lt;2s&gt;!Are you sure you want to replace it?') expandMacrosWith: newSelector with: cl printString))				ifFalse: [^self]].	ImageReader 		imageFromFile: aFilename		toClass: cl  		selector: newSelector asSymbol.	"Force a refresh on the list we care about"	self changedClassName</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>private</category><body package="UIPainter" selector="removeClass:">removeClass: aClass 	(Dialog confirm: ((#GenKey94 &lt;&lt; #UIPainter &gt;&gt; 'Are you certain that you want to remove&lt;n&gt;class &lt;1s&gt; from the system?')			expandMacrosWith: aClass printString) for: builder window)		ifFalse: [^self].	(aClass subclasses size == 0 or: [Dialog confirm: ((#GenKey93 &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; has subclasses&lt;n&gt;Proceed with removal?')			expandMacrosWith: aClass name) for: builder window])		ifTrue: 			[aClass removeFromSystem.			self removeClassAndAdjustSets: aClass fullyQualifiedReference.			UIFinderVW2 changed: #specBearers]</body></methods><methods><class-id>Tools.FileTools.FileInformationViewer</class-id> <category>accessing</category><body package="Tools-File Browser" selector="timestampStringAt:in:">timestampStringAt: aSymbol in: aDictionary	| array |	array := aDictionary at: aSymbol.	^array first printString, ' ', array last printString</body></methods><methods><class-id>Tools.FileTools.FileInformationViewer</class-id> <category>accessing</category><body package="Tools-File Browser" selector="printBlurbFor:on:">printBlurbFor: aFilename on: stream	self		print: (#Path &lt;&lt; #labels &gt;&gt; 'Path') value: [aFilename asString] on: stream;		print: (#Size &lt;&lt; #labels &gt;&gt; 'Size') value: [aFilename fileSize printString] on: stream;		print: (#Created &lt;&lt; #labels &gt;&gt; 'Created') value: [self timestampStringAt: #created in: aFilename dates] on: stream;		print: (#LastModified &lt;&lt; #labels &gt;&gt; 'Last modified') value: [self timestampStringAt: #modified in: aFilename dates] on: stream;		print: (#LastAccessed &lt;&lt; #labels &gt;&gt; 'Last accessed') value: [self timestampStringAt: #accessed in: aFilename dates] on: stream</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>miscellaneous</category><body package="Tools-File Browser" selector="fileSizeString:">fileSizeString: anInteger	anInteger &lt; 1024 ifTrue:		[^((#x1sBytes &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; bytes')			expandMacrosWith: anInteger printString)].	anInteger &lt; 1048576 ifTrue:		[^((#x1sKB &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; KB')			expandMacrosWith: (anInteger // 1024) printString)].	^((#x1sMB &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; MB')			expandMacrosWith: (anInteger // 1048576) printString)</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>miscellaneous</category><body package="Tools-File Browser" selector="updateStatusBarForFolderSelection">updateStatusBarForFolderSelection	| filename |	filename := self selectedDirectory asFilename.	self statusTextLeftHolder value: filename asString.	self statusTextRightHolder value: ((#x1sFiles &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; files')			expandMacrosWith: self fileListHolder list size printString)</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>system information</category><body package="Tools-Misc" selector="printBasicSystemInformationon:">printBasicSystemInformationon: aStream	&lt;systemInformation: 0&gt;	| patches |	aStream		emphasis: #bold; 		nextPutAll: (#versionID &lt;&lt; #dialogs &gt;&gt; 'Version Id:') asString; 		emphasis: nil;		crtab; 		nextPutAll: ObjectMemory versionId printString;		cr; 		emphasis: #bold; 		nextPutAll: (#patches &lt;&lt; #dialogs &gt;&gt; 'Patches:') asString; 		emphasis: nil.	patches := ChangeSet patches asSortedStrings.	patches isEmpty		ifTrue: [aStream crtab; nextPutAll: (#none &lt;&lt; #dialogs &gt;&gt; '(none)') asString]		ifFalse: [patches do: [:str | aStream crtab; nextPutAll: str]].	aStream cr</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>private</category><body package="Tools-Misc" selector="createPage:">createPage: aSelector	^[self perform: aSelector]		on: Error		do: [:ex |			self new				label: aSelector printString				text: ((#ErrorInPage &lt;&lt; #dialogs &gt;&gt; 'Error in page generation: &lt;1s&gt;')			expandMacrosWith: ex description)]</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="detailHintGraphics">detailHintGraphics	| icons addedMethodCount changedMethodCount removedMethodCount changedCategoryCount changedPackageCount |	icons := super detailHintGraphics.	addedMethodCount := changedMethodCount := removedMethodCount := changedCategoryCount := changedPackageCount := 0.	self		enumerateOrderedMethodAdditions: [addedMethodCount := addedMethodCount + 1]		removals: [removedMethodCount := removedMethodCount + 1]		changes: 			[:a :b |			a source = b source				ifFalse: [changedMethodCount := changedMethodCount + 1].			a category = b category				ifFalse: [changedCategoryCount := changedCategoryCount + 1].			a packageName = b packageName				ifFalse: [changedPackageCount := changedPackageCount + 1]].	changedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons modify						with: (Label with: '' , changedMethodCount printString))].	changedPackageCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons movePackage						with: (Label with: '' , changedPackageCount printString))].	changedCategoryCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons moveCategory						with: (Label with: '' , changedCategoryCount printString))].	addedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons add						with: (Label with: '' , addedMethodCount printString))].	removedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons remove						with: (Label with: '' , removedMethodCount printString))].	^icons</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison" selector="attributesComparisonRow">attributesComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyClassAttributes		name: 'Attributes'		leftText: leftBlueprint attributes printString		rightText: rightBlueprint attributes printString</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison" selector="attributesSingularRow">attributesSingularRow	^self singularBlueprint attributes isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self						annotateIconWithDisposition: ComparisonIcons modifyClassAttributes)				name: 'Attributes'				text: self singularBlueprint attributes printString]</body></methods><methods><class-id>Tools.PrimitiveObjectInspector</class-id> <category>field list</category><body package="Tools-Inspector" selector="fieldList">fieldList	"Answer an Array consisting of 'self' and the instance variable 	names of the inspected object. Up to 40 indices are given for 	variable length objects."	| max |	max := self _objectSize: object.	^((Array with: 'self') ,		(self _objectClass: object) allInstVarNames,		(((showAllFields or: [max &lt;= DefaultNumberOfFields])			ifTrue: [1 to: max]			ifFalse: [(1 to: 30) , (max - 10 to: max)])				collect: [:i | i printString]))</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>grid actions</category><body package="UIPainter" selector="gridSizeDialog">gridSizeDialog	| sz szInt |	sz := SimpleDialog new		request: (#GridSize &lt;&lt; #UIPainter &gt;&gt; 'Grid Size?')		initialAnswer: controller gridStep value printString		onCancel: [^self]		for: builder window.	szInt := Integer readFromString: sz.	szInt &lt; 1	ifTrue: [ Dialog warn: (#GenKey140 &lt;&lt; #UIPainter &gt;&gt; 'The grid size must be greater than 0.') for: builder window ]	ifFalse: [ controller gridStep value: szInt ]</body></methods><methods><class-id>Tools.CommandBindingsEditor.BindingEditor</class-id> <category>actions</category><body package="Tools-Settings-Commands" selector="temporaryFilenameWithPrefix:suffix:">temporaryFilenameWithPrefix: prefix suffix: suffix	"TODO: replace this with a core supported temporary filename facility"	"I copied this from WebVelocity. SUnit tools does something similar"	| dirname filename |	"Presume this is ok for all unices"	dirname := '/tmp'.	('*win*' match: OSHandle platformMoniker)		ifTrue: [ dirname := SystemUtils getEnvironmentVariable: 'TEMP' ifAbsent: [ SystemUtils getEnvironmentVariable: 'TMP' ifAbsent: [ 'c:\temp\' ] ] ].	('*mac*' match: OSHandle platformMoniker)		ifTrue: [ dirname := SystemUtils getEnvironmentVariable: 'TMPDIR' ifAbsent: [ '/tmp' ] ].	dirname := dirname asFilename.	(dirname definitelyExists and: [ dirname isDirectory ])		ifFalse: [ ^nil ].	filename := dirname / (prefix , '-' , Time microsecondClock printString , '-' , suffix).	^filename asAbsoluteFilename</body></methods><methods><class-id>Tools.SequenceableCollectionInspector</class-id> <category>field list</category><body package="Tools-Inspector" selector="fieldList">fieldList	^(Array with: 'self') , ((1 to: object size) collect: [:i | i printString])</body></methods><methods><class-id>Tools.SequenceableCollectionInspector class</class-id> <category>view creation</category><body package="Tools-Inspector" selector="openOn:">openOn: anObject	"If anObject size is very large, then ask the user whether to open	the inspector, or open a simple inspector (that only shows 'self')	or abort."	| whatToDo |	anObject size &gt; 500		ifFalse: [^self open: (self inspect: anObject)].	whatToDo :=  Dialog						choose: ((#InspectedObjectIsHuge &lt;&lt; #dialogs &gt;&gt; 'The object you want to inspect is large, &lt;1s&gt; elements.')			expandMacrosWith: anObject size printString)						labels: (Array with: (#showAllFields &lt;&lt; #dialogs &gt;&gt; 'show all fields') with: (#showSomeFields &lt;&lt; #dialogs &gt;&gt; 'show some fields'))						values: #(#full #simple)						default: #simple.	whatToDo == #simple		ifTrue: [^Inspector openOn: anObject].	^self open: (self inspect: anObject)</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="fetchMethodBodyForDataFormDetail:on:">fetchMethodBodyForDataFormDetail: detailSlot on: aStream	| spec |	aStream 		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll: ' isNil';		cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: spec clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']);		cr; tab; tab; tab; tab.	(spec := detailSlot value) sourceType == #query		ifTrue:			[aStream				nextPutAll: '(self row value isNil';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifTrue: [Array new]';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifFalse: ['.			spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]'].				aStream nextPutAll: '])]']		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value]']				ifFalse:					[aStream nextPutAll: 'Array new]']]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="fetchMethodBodyForTopDetail:on:">fetchMethodBodyForTopDetail: detailSlot on: aStream	| spec |	aStream 		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll: ' isNil';		cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: spec clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']);		cr; tab; tab; tab; tab.	(spec := detailSlot value) sourceType == #query		ifTrue:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values])]']				ifFalse:					[aStream						nextPutAll: '(Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values])]']]		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value]']				ifFalse:					[aStream nextPutAll: 'Array new]']]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="finishFetchExpressionForTopDetail:on:">finishFetchExpressionForTopDetail: detailSlot on: aStream	| spec |	(spec := detailSlot value) sourceType == #query		ifTrue:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]']]		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value']				ifFalse:					[aStream nextPutAll: 'Array new']]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="writeFontLoadingMethod:">writeFontLoadingMethod: aString	| codeStream |	codeStream := String new writeStream.	self writePrivateMethodHeaderOn: codeStream.	codeStream 		nextPutAll: 'loadNamedFonts';		cr; tab;		nextPutAll: '"This method is created by the UIDefiner';		cr; tab;		nextPutAll: 'Any edits made here may be lost whenever named fonts are re-saved"';		cr; cr; tab;		nextPutAll: 'self loadNamedFontsFromFile: ';		nextPutAll: aString printString;		nextPut: $!.	codeStream contents readStream fileIn.</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="writeAutoOpenMethod:on:">writeAutoOpenMethod: autoOpenSlots on: aStream		aStream		cr; cr;		nextPutAll: 'autoOpenChildren';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."'; cr.	autoOpenSlots isEmpty		ifFalse:			[autoOpenSlots				do:					[:assn |					| spec cnv |					aStream						cr; tab;						nextPutAll: 'self openChild: self ';						nextPutAll: (spec := assn value) clientKey;						nextPutAll: ' with: ';						nextPutAll:							((cnv := spec minorKey) isNil								ifTrue: ['#windowSpec']								ifFalse: [cnv printString]);						nextPut: $.]].	aStream cr; tab; nextPutAll: 'super autoOpenChildren'.	aStream nextPut: $!</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="writeSynchronizeMethod:on:">writeSynchronizeMethod: synchroSlots on: aStream	aStream		cr; cr;		nextPutAll: 'synchronize: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."'; cr.	synchroSlots isEmpty		ifTrue:			[aStream cr; tab; nextPutAll: '^self']		ifFalse:			[synchroSlots do:				[:slt |				| spec |				aStream					cr; tab;					nextPutAll: 'aChild == self ';					nextPutAll: (spec := slt) clientKey;					cr; tab; tab;					nextPutAll: ' ifTrue:';					cr; tab; tab; tab;					nextPutAll: '[self row '.				spec fetchAction isNil					ifTrue:						[aStream							nextPutAll: 'compute:';							cr; tab; tab; tab; tab;							nextPutAll: '[:v |';							cr; tab; tab; tab; tab.						self fetchExpressionForClientDetail: slt on: aStream.						aStream							nextPut:$];							cr; tab;tab;tab;							nextPutAll: 'for: aChild']					ifFalse:						[aStream							nextPutAll: 'onChangeSend: ';							nextPutAll: spec fetchAction printString;							nextPutAll: ' to: self for: aChild'].				aStream nextPutAll: '].']].	aStream nextPut: $!</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="writeOpenActions:on:">writeOpenActions: detailSlots on: aStream	"If there is any detailSlot with an openAction defined, add the 	definition of the method to aStream for each such detailSlot"	(detailSlots isEmpty or:			[(detailSlots detect: [:assn |  assn value openAction notNil] ifNone: []) isNil])		ifTrue: [^self].	detailSlots		do:			[:assn |			| cnv spec |			(spec := assn value) openAction notNil				ifTrue:					[aStream						cr; cr;						nextPutAll: spec openAction;						cr; tab;						nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."';						cr; cr; tab;						nextPutAll: 'self openChild: self ';						nextPutAll: spec clientKey;						nextPutAll: ' with: ';						nextPutAll:							((cnv := spec minorKey) isNil								ifTrue: ['#windowSpec']								ifFalse: [cnv printString]);						nextPut: $!]]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="finishFetchExpressionForDataFormDetail:on:">finishFetchExpressionForDataFormDetail: detailSlot on: aStream	| spec |	(spec := detailSlot value) sourceType == #query		ifTrue:			[aStream				nextPutAll: '(self row value isNil';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifTrue: [Array new]';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifFalse: ['.			spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]'].				aStream nextPutAll: '])']		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value']				ifFalse:					[aStream nextPutAll: 'Array new']]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter" selector="initStringForClientDetail:on:">initStringForClientDetail: detailSlot on: aStream	| spec |	aStream		nextPutAll: (spec := detailSlot value) majorKey asString;		space;		nextPutAll: 'new'.	spec lockPolicy ~~ #current		ifTrue:			[aStream				cr; tab; tab; tab; tab;				nextPutAll: 'lockPolicy: ';				nextPutAll: spec lockPolicy printString; nextPut: $;;				cr; tab; tab; tab; tab;				nextPutAll: 'yourself']</body></methods><methods><class-id>Tools.StateMachineState</class-id> <category>printing</category><body package="Tools-State Machine" selector="printOn:">printOn: aStream	super printOn: aStream.	name ifNotNil: [ aStream nextPut: $(; nextPutAll: name printString; nextPut: $) ].</body></methods><methods><class-id>Tools.Explainer</class-id> <category>browsing</category><body package="Tools-Programming" selector="browseBindingReference:">browseBindingReference: aReference	^'Tools.SmalltalkWorkbench browseBindingReference: ', aReference printString</body></methods><methods><class-id>Tools.Explainer</class-id> <category>private-explaining</category><body package="Tools-Programming" selector="explainInstanceVariable:">explainInstanceVariable: aString 	"Is string an instance variable of this class?"	| classes definingClass |	class == nil ifTrue: [^nil].	"no class is selected"	classes := class withAllSuperclasses.	definingClass := classes detect: 					[:each | 					(each instVarNames detect: [:name | name = aString] ifNone: []) notNil]				ifNone: [^nil].	^Array with: 		(self explanationForInstanceVariable: aString definedIn: definingClass) 				-&gt; (self browseInstVar: aString in: definingClass printString)</body></methods><methods><class-id>Tools.Explainer</class-id> <category>private-explaining</category><body package="Tools-Programming" selector="explainNumber:">explainNumber: aString 	"Is the string a Number?"	| stream char number |	(char := aString at: 1) isDigit ifFalse: [(char = $- and: [aString size &gt; 1])			ifFalse: [^nil]].	stream := ReadStream on: aString.	number := Number readFrom: stream.	stream atEnd ifFalse: [^nil].	^self wrapMessage: (number printString = aString		ifTrue: [#explainer1PisA2S &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is a &lt;2s&gt;.' 			expandMacrosWith: number with: number class name]		ifFalse: [#explainer1PequalTo2PIsA3S &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; (= &lt;2p&gt;) is a &lt;3s&gt;.' 			expandMacrosWith: aString with: number with: number class name])</body></methods><methods><class-id>Tools.DictionaryInspector</class-id> <category>private-menu messages</category><body package="Tools-Inspector" selector="removeField">removeField	(Dialog confirm: ((#ConfirmRemovalOf1s &lt;&lt; #dialogs &gt;&gt; 'Confirm removal of &lt;1s&gt;')			expandMacrosWith: field printString) for: self interfaceWindow) ifFalse: [^self].	object removeKey: field.	field := nil.	self resetFields</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>private</category><body package="Tools-Workspace" selector="importSummary">importSummary	^importAll		ifTrue: [(#All &lt;&lt; #labels &gt;&gt; 'All') asString]		ifFalse: [specificImports size printString]</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>private</category><body package="Tools-Workspace" selector="makeVariableName:uniqueIn:">makeVariableName: aString uniqueIn: aDictionary	"Accept a string that can be anything and answer another string that can safely be used as a legal Smalltalk variable name. The answer can be the same as the argument if it was OK to begin with. Make sure there is no name clash with keys of aDictionary.  Append 2, 3, and so on to the original name until the clash if resolved. The dictionary keys may be strings or symbols."	| namesTaken baseName name suffix |	namesTaken := (aDictionary keys collect: [:each | each asString]) asSet.	baseName := self makeVariableName: aString.	name := baseName.	suffix := 2.	[namesTaken includes: name] whileTrue:		[name := baseName, suffix printString.		suffix := suffix + 1].	^name</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private</category><body package="Debugger-Tools-Modifications" selector="resetFieldsForDebugger">resetFieldsForDebugger	| list |	list := self fieldList.	self printItems ifTrue: [list := list collect: [:e | e printString]].	list := list asList.	list = fieldList list		ifTrue: [^self resetText].	fieldList list: list asList</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private</category><body package="Tools-Inspector" selector="resetFields">resetFields		| list |	list := self fieldList.	self printItems ifTrue: [list := list collect: [:e | e printString]].	fieldList list: list asList</body></methods><methods><class-id>Tools.Inspector</class-id> <category>field list</category><body package="Tools-Inspector" selector="fieldList">fieldList	"Answer an Array consisting of 'self' and the instance variable 	names of the inspected object. Up to 40 indices are given for 	variable length objects."	| max |	max := object basicSize.	^((Array with: 'self') ,		object class allInstVarNames,		(((showAllFields or: [max &lt;= DefaultNumberOfFields])			ifTrue: [1 to: max]			ifFalse: [(1 to: 30) , (max - 10 to: max)])				collect: [:i | i printString]))</body></methods><methods><class-id>Tools.Inspector</class-id> <category>text</category><body package="Debugger-Tools-Modifications" selector="text">text	"Answer the text displayed by the receiver."	| string |	field == nil ifTrue: [^Text new].	string := [5 seconds				toFinish: [field = 'self'						ifTrue: [self fieldValue inspectString]						ifFalse: [self fieldValue printString]]				orElse: [self basicObjectPrintString: self fieldValue]]				on: Error , BreakInterrupt				do: [:ex | self protectedBasicObjectPrintString: self fieldValue].	^string asText</body></methods><methods><class-id>Tools.GeneralMethodDefinition</class-id> <category>comparing</category><body package="Tools-Programming" selector="&lt;">&lt; anObject	"Answer whether the receiver is less than the argument.	 Order GeneralMethodDefinitions by inheriting class name, nonMeta/meta and selector."	| n1 n2 sel |	n1 := self objectName.	n2 := anObject objectName.	^n1 = n2		ifTrue:			[(self selector isString					ifTrue: [self selector]					ifFalse: [self selector printString])				&lt; ((sel := anObject selector) isString						ifTrue: [sel]						ifFalse: [sel printString])]		ifFalse: [n1 &lt; n2]</body></methods><methods><class-id>Tools.Trippy.Part</class-id> <category>accessing</category><body package="Tools-Trippy" selector="text">text	^[self value printString] toolSafeIn: 2 seconds		else: 			[:ex |			#ErrorPrintingObject &lt;&lt; #dialogs &gt;&gt; '[Error printing the object: &lt;1s&gt;]'				expandMacrosWith: ex description]</body></methods><methods><class-id>Tools.Trippy.KeyedElement</class-id> <category>accessing</category><body package="Tools-Trippy" selector="partName">partName	^key printString</body></methods><methods><class-id>Tools.Trippy.KeyedElement</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^key isString		ifTrue: [key]		ifFalse: [key isSymbol			ifTrue: [key asString]			ifFalse: [key isInteger				ifTrue: ['at', key printString]				ifFalse: [(Inspector safeDisplayStringOf: key) copyWithout: Character space]]]</body></methods><methods><class-id>Tools.Trippy.CStructureTypeInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="members">members	| type memberParts |	type := object type.	type isPointer ifTrue: 		[type := type referentType].	memberParts := OrderedCollection new. 	type baseType keysAndValuesDo: 		[:name :assoc |		memberParts add: (TextAttribute 			label: name 			text: ('Type: &lt;1s&gt; offset: &lt;2s&gt;'			expandMacrosWith: assoc value printString			with: assoc key printString))].	^memberParts</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>private</category><body package="Tools-Trippy" selector="formattedResultOf:">formattedResultOf: aBlock	| result |	result := aBlock		on: Error		do: [:ex | ^(#errorC1s &lt;&lt; #dialogs &gt;&gt; '[error: &lt;1s&gt;]') expandMacrosWith: ex description].	^result printString asText allBold</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>private-menus</category><body package="Tools-Trippy" selector="buildHistorySubmenu">buildHistorySubmenu	| menu item |	menu := Menu new.	trail keysAndValuesDo:		[:index :navigator | | label |		label := index &lt; 10			ifTrue: ['&amp;', index printString, '. ', navigator visit displayString]			ifFalse: [navigator visit displayString].		item := MenuItem labeled: label.		item value: [self goTo: index].		index = current ifTrue: [item beOn].		menu addItem: item].	^menu</body></methods><methods><class-id>Tools.Trippy.IndexedVariable</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^'at', index printString</body></methods><methods><class-id>Tools.Trippy.IndexedVariable</class-id> <category>accessing</category><body package="Tools-Trippy" selector="partName">partName	^index printString</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="sendAndDive">sendAndDive	"Send the message and dive into the result."	| selector result |	selector := self selectedMethod selector.	selector numArgs ~= 0 ifTrue: [^self].	result := self doItReceiver perform: selector.	self container diveInto: 		(DerivedAttribute 			label: ((#x1sCSent2s &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;: sent &lt;2s&gt;')				expandMacrosWith: Time now printString				with: selector printString)			value: result)</body></methods><methods><class-id>Tools.Trippy.Inspector class</class-id> <category>utilities-printing</category><body package="Tools-Trippy" selector="safeLabelStringOf:">safeLabelStringOf: anObject	"Answer a string representation of anObject short enough and line break-free,	for use in contexts such as a list view. Unlike safeDisplayString, favor the	programmer perspective (that is, printString) and try hard to give a useful	answer by falling back to basic print string if printString fails."	^[ | string |	string := anObject printString.	(string size &gt; 40 or: [string trimBlanks isEmpty or: [(string includes: Character cr) or: [string includes: Character lf]]])		ifTrue: [anObject basicPrintString]		ifFalse: [string]	]		on: Error, BreakInterrupt		do: [:ex | ex return: (self safeBasicPrintStringOf: anObject)]</body></methods><methods><class-id>Tools.Trippy.Inspector class</class-id> <category>utilities-printing</category><body package="Tools-Trippy" selector="safePrintStringOf:">safePrintStringOf: anObject	^[anObject printString]		on: self safePrintingErrors		do:			[:ex | 			ex				return:					(#ErrorPrintingObject &lt;&lt; #dialogs &gt;&gt; '[Error printing the object: &lt;1s&gt;]'						expandMacrosWith: ex description)]</body></methods><methods><class-id>Tools.NotifierView class</class-id> <category>private</category><body package="Tools-Programming" selector="shortStackFor:ofSize:">shortStackFor: aContext ofSize: anInteger	"Answer a string with the simple descriptions of anInteger number of	non-nil stackframes starting with aContext"	| shortStackStream ctx |	shortStackStream := WriteStream on: (String new: 400).	ctx := aContext.	anInteger timesRepeat: 		[ctx isNil ifFalse:			[shortStackStream nextPutAll: (ctx printString contractTo: 50); cr.			ctx := ctx sender]].	shortStackStream position &gt; 0 ifTrue: [shortStackStream skip: -1].	^shortStackStream contents</body></methods><methods><class-id>Tools.NumberSetting</class-id> <category>accessing</category><body package="Tools-Settings" selector="toXML:">toXML: anObject	self validate: anObject.	^Element		tag: self xmlTag		elements: (Array with: (XML.Text text: anObject printString))</body></methods><methods><class-id>Tools.Workbook</class-id> <category>private</category><body package="Tools-Workspace" selector="pickUniquePageLabel">pickUniquePageLabel	| labels suffix label |	labels := self pages collect: [:each | each displayString].	suffix := 1.	[label := ((#Page1s &lt;&lt; #dialogs &gt;&gt; 'Page &lt;1s&gt;')			expandMacrosWith: suffix printString).	labels includes: label] 		whileTrue: [suffix := suffix + 1].	^label</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>private</category><body package="UIPainter" selector="menuFromSlicesList">menuFromSlicesList	| mb |	mb := MenuBuilder new.	slicesList do: [ :slice |		mb add: slice selector printString -&gt; slice	]. 	^mb menu</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>private</category><body package="UIPainter" selector="edittedSelector">edittedSelector	| mi menuButton |	mi := ((self builder menuAt: #sliceMenu) value menuItemWithValue: currentSlice ifNone: nil).	mi isNil ifTrue: [^self].	mi label: currentSlice selector printString.	menuButton := (self builder componentAt: #sliceMenu) widget.	menuButton setLabel: menuButton currentChoice.	menuButton invalidate.	hotRegions regionsSelectors at: currentSlice index put: currentSlice selector</body></methods><methods><class-id>Tools.MethodFilterReference</class-id> <category>printing</category><body package="Tools-Programming" selector="valueString">valueString	^value isSymbol		ifTrue: [value printString]		ifFalse: [value displayString]</body></methods><methods><class-id>External.CScalarType</class-id> <category>printing</category><body package="External-Types" selector="printOn:forName:indent:">printOn: aStream forName: varName indent: numTabs	aStream nextPutAll:		(printName isString			ifTrue: [printName]			ifFalse: [self class printString, '?']).	self printName: varName on: aStream wrap: false</body></methods><methods><class-id>External.ExternalInterface</class-id> <category>accessing</category><body package="External-Interface" selector="externalAccessFailedWith:">externalAccessFailedWith: errorCode	"Raise the signal that indicates something went wrong with an external access	 -- use the receiver as the signal's parameter."	| errorString |	errorCode isError		ifTrue:			[				errorCode name == #'io error' ifTrue: [^errorCode handleErrorFor: self].				errorString := errorCode parameter == nil					ifTrue: [errorCode name]					ifFalse: [errorCode name, ' ', errorCode parameter printString]			].	^self externalAccessFailedSignal		raiseRequestWith: self		errorString: errorString</body></methods><methods><class-id>External.CMacroDefinition</class-id> <category>printing</category><body package="External-Types" selector="printOn:">printOn: aStream	"Print a representation of the receiver onto the argument."	super printOn: aStream.	aStream		space;		nextPutAll: (name isString ifTrue: [name] ifFalse: [name printString]);		nextPutAll: ' &lt;'.	self printValueOn: aStream.	aStream nextPut: $&gt;</body></methods><methods><class-id>Refactory.CodeHighlighter.BlockVariables</class-id> <category>variables</category><body package="RBCodeHighlighting" selector="variable:argument:">variable: aVariable argument: formatCode	"Answer a suitable structure for the variable and format code."	^formatCode -&gt; (aVariable , '.arg.' , id printString)</body></methods><methods><class-id>Refactory.CodeHighlighter.BlockVariables</class-id> <category>variables</category><body package="RBCodeHighlighting" selector="variable:temporary:">variable: aVariable temporary: formatCode	"Answer a suitable structure for the variable and format code."	^formatCode -&gt; (aVariable , '.tmp.' , id printString)</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper class</class-id> <category>private</category><body package="Method Wrapper Base" selector="codeStringFor:">codeStringFor: numArgs 	| nameString tempsString |	nameString := 'value'.	tempsString := numArgs == 0 				ifTrue: ['t := #()']				ifFalse: ['(t := #Array new: ' , numArgs printString , ') '].	1 to: numArgs		do: 			[:i | 			nameString := nameString , 'value: t' , i printString , ' '.			tempsString := tempsString , (i == 1 ifTrue: [''] ifFalse: [';']) 						, ' at: ' , i printString 						, ' put: t' , i printString].	^nameString , '	| t |	' , tempsString , '.	^' 		, self methodWrapperSymbol printString 			, ' valueWithReceiver: self arguments: t'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>printing</category><body package="SmaCC Runtime" selector="printOn:">printOn: aStream	aStream		nextPut: ${;		nextPutAll: self value;		nextPut: $(;		nextPutAll: self startPosition printString;		nextPut: $,;		nextPutAll: self stopPosition printString;		nextPut: $,;		nextPutAll: self ids printString;		nextPutAll: ')}'</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#RenameProtocol1sTo2sIn3s &lt;&lt; #browser &gt;&gt; 'Rename protocol, &lt;1s&gt;, to &lt;2s&gt; in &lt;3s&gt;')			expandMacrosWith: self protocol			with: self newProtocol			with: self protocolObject printString)</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="primitiveExecute">primitiveExecute	(self protocolObject renameCategory: self protocol		to: self newProtocol) 			ifTrue: 				[self 					logProtocolChange: self protocolObject printString 							, ' organization renameCategory: ' , self protocol printString 							, ' to: ' , self newProtocol printString].	isUndo ifTrue: [self resetToPriorState]</body></methods><methods><class-id>Refactory.Browser.RBMethod</class-id> <category>testing</category><body package="Browser-Refactorings" selector="refersToSymbol:">refersToSymbol: aSymbol 	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: aSymbol printString do: [:node :answer | true];		matches: '`#literal'			do: [:node :answer | answer or: [self literal: node value containsReferenceTo: aSymbol]].	(RBScanner isSelector: aSymbol) 		ifTrue: 			[searcher 				matches: '`@object ' , (ParseTreeSearcher buildSelectorString: aSymbol)				do: [:node :answer | true]].	^searcher executeTree: self parseTree initialAnswer: false</body></methods><methods><class-id>Refactory.Browser.InlineMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="renameConflictingTemporary:">renameConflictingTemporary: aName 	| allNames newName index seqNode |	allNames := (Set new)				addAll: inlineParseTree allDefinedVariables;				yourself.	allNames remove: aName ifAbsent: [].	seqNode := sourceMessage.	[seqNode isSequence] whileFalse: [seqNode := seqNode parent].	allNames addAll: seqNode allDefinedVariables.	"Add those variables defined in blocks. This might cause a few 													variables to be renamed that don't need to be, but this should be safe."	newName := aName.	index := 0.		[(sourceMessage whoDefines: newName) notNil or: 			[(class hierarchyDefinesVariable: newName) or: [allNames includes: newName]]] 			whileTrue: 				[index := index + 1.				newName := aName , index printString].	newName = aName ifFalse: [self renameTemporary: aName to: newName].	^newName</body></methods><methods><class-id>Refactory.Browser.CodeComponentInspectorField</class-id> <category>accessing</category><body package="Browser-BrowserUI" selector="partName">partName	^key printString</body></methods><methods><class-id>Refactory.Browser.PrimitiveIndexGlobCriterion</class-id> <category>testing</category><body package="RBPrimitivesBrowsing" selector="matches:">matches: aPrimitiveIndex	^self pattern match: aPrimitiveIndex printString</body></methods><methods><class-id>Refactory.Browser.RBSharedVariable</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="definitionString">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineSharedVariable: #';		nextPutAll: self name;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: isPrivate printString;		cr;		tab;		nextPutAll: 'constant: ';		nextPutAll: constant printString;		cr;		tab;		nextPutAll: 'category: ';		nextPutAll: self category asString printString;		cr;		tab;		nextPutAll: 'initializer: '.	initializer isNil 		ifTrue: [definitionStream nextPutAll: 'nil']		ifFalse: [definitionStream nextPutAll: initializer asString printString].	^definitionStream contents</body></methods><methods><class-id>Refactory.Browser.RemoveProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="primitiveExecute">primitiveExecute	self protocolObject organization removeCategory: self protocol.	self 		logProtocolChange: self protocolObject printString 				, ' organization removeCategory: ' 					, self protocol storeString.	self protocolObject reorganize</body></methods><methods><class-id>Refactory.Browser.RemoveProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#GenKey5 &lt;&lt; #browser &gt;&gt; 'Remove protocol, &lt;1s&gt;, from &lt;2s&gt;')			expandMacrosWith: self protocol			with: self protocolObject printString)</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="referencesTo:in:">referencesTo: aLiteral in: anEnvironment 	| classDict literalPrintString specialIndex variables |	literalPrintString := aLiteral isVariableBinding 				ifTrue: [aLiteral key asString]				ifFalse: 					[aLiteral isString ifTrue: [aLiteral] ifFalse: [aLiteral printString]].	specialIndex := CompiledCode specialSelectorIndexFor: aLiteral.	classDict := Dictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := (class whichSelectorsReferTo: aLiteral) 						select: [:aSelector | anEnvironment includesSelector: aSelector in: class].			selectors notEmpty ifTrue: [classDict at: class put: selectors]].	variables := OrderedCollection new.	anEnvironment sharedVariableReferencesDo: 			[:each | 			| binding init method |			binding := each bindingOrNil.			binding notNil 				ifTrue: 					[init := binding initializer.					init notNil 						ifTrue: 							[method := init method.							((method refersToLiteral: aLiteral) or: 									[(specialIndex &gt; 0 and: [method sendsSpecialSelector: specialIndex]) 										or: [method refersToSpecialLiteral: aLiteral]]) 								ifTrue: [variables add: each]]]].	^(self onEnvironment: anEnvironment)		on: classDict;		initializers: variables;		label: ((#ReferencesTo1s &lt;&lt; #browser &gt;&gt; 'References to: &lt;1s&gt;')			expandMacrosWith: literalPrintString);		searchStrings: (Array with: literalPrintString);		yourself</body></methods><methods><class-id>Refactory.Browser.AbstractRefactoringBrowser</class-id> <category>menu</category><body package="Browser-BrowserUI" selector="bufferMenuSpecifications">bufferMenuSpecifications	^(1 to: (self toolsets size min: 9))		collect:			[:i | 			(self currentToolset == (self toolsets at: i)				ifTrue: [RBCheckedCommand]				ifFalse: [RBCommand])				named:					(self						menuNameFor:							('&amp;&lt;1s&gt; &lt;2s&gt;'								expandMacrosWith: i printString								with: (self toolsets at: i) printString))				description: #SelectBuffer &lt;&lt; #browser &gt;&gt; 'Select Buffer'				action: [self switchToBuffer: i]				receiver: #yourself]</body></methods><methods><class-id>Refactory.Browser.MethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="safeVariableNameFor:temporaries:basedOn:">safeVariableNameFor: aClass temporaries: allTempVars basedOn: aString	| baseString i newString |	newString := baseString := aString.	i := 0.		[(allTempVars includes: newString) 		or: [aClass definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString</body></methods><methods><class-id>Refactory.Browser.MethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="buildSelectorString:withPermuteMap:">buildSelectorString: aSelector withPermuteMap: anIntegerCollection 	| stream keywords |	aSelector numArgs == 0 ifTrue: [^aSelector asString].	stream := WriteStream on: String new.	keywords := aSelector keywords.	keywords with: anIntegerCollection		do: 			[:each :i | 			stream				nextPutAll: each;				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>removal-methods</category><body package="Browser-BrowserUI" selector="validateMethodRemovalChange:">validateMethodRemovalChange: aCompositeChange	"Determine if any of the method removals have senders else where in the system. If they do, have a dialog with the user about what to do about it (cancel, proceed, or browse them), return true/false based on whether the change should be allowed to proceed."	"First step is to extract the removals (there may be override adjustments in there too), and then build a map of removals to reference environments."	| ws definitionPrintSelector removals referenceEnvironments filteredDefinitions |	removals := aCompositeChange changes				select: [:each | each isKindOf: RemoveMethodChange].	referenceEnvironments := Dictionary new.	self showWaitCursorWhile: 			[removals do: 					[:each |					each methodDefinition hasSuperImplementor						ifFalse: 							[referenceEnvironments at: each selector								ifAbsentPut: [each referenceEnvironment]]]].	"Filter out any cases where the only reference is self referential (i.e. a recursive method)"	referenceEnvironments := referenceEnvironments reject: 					[:each |					each isEmpty or: 							[each numberSelectors = 1 and: 									[each methodDefinitions any selector										= (referenceEnvironments keyAtIdentityValue: each)]]].	referenceEnvironments isEmpty ifTrue: [^true].	ws := String new writeStream.	ws		nextPutAll: (#MethodRemovalsReferencedElsewhereC &lt;&lt; #browser					&gt;&gt; 'Some of the methods to be removed are referenced elsewhere in the system:')						asString;		cr.	"Determine how rich to print the method definitions of the removal. If they're all in the same class (usually the case), then contextually, just printing the selector is enough."	filteredDefinitions := (removals collect: #methodDefinition)				select: [:each | referenceEnvironments includesKey: each selector].	definitionPrintSelector := (filteredDefinitions				collect: #implementingClass) size				= 1 ifTrue: [#selector] ifFalse: [#printString].	self showWaitCursorWhile: 			[filteredDefinitions asSortedCollection do: 					[:each |					ws						cr;						tab;						nextPutAll: (each perform: definitionPrintSelector);						nextPutAll: ' -- ';						nextPutAll: ((referenceEnvironments at: each selector)									dispositionToMethodRemoval: each) asString]].	^self confirmRemoval: ws contents references: referenceEnvironments</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private-selector</category><body package="Browser-BrowserUI" selector="addParameterTo:in:">addParameterTo: aSelector in: aClass		| initializer newSelector newArgument tree args dialog newArgs map argRoot argSuffix candidateSelector |	tree := aClass parseTreeFor: aSelector.	tree		ifNil:			[^self				warn: #CouldNotParseTheMethod &lt;&lt; #IDE &gt;&gt; 'Could not parse the method'].	argRoot := 'anObject'.	argSuffix := 0.	[newArgument := argRoot		,			(argSuffix isZero				ifTrue: ['']				ifFalse: [argSuffix printString]).	tree allDefinedVariables includes: newArgument]		whileTrue: [argSuffix := argSuffix + 1].	args := tree argumentNames copyWith: newArgument.	candidateSelector := (aSelector numArgs == 0		ifTrue: [aSelector , ':']		ifFalse: [aSelector]) asSymbol.	dialog := (MethodNameAndInitialValueDialog new)		arguments: args;		selector: candidateSelector;		initialValue: 'nil'.	dialog open ifFalse: [^nil].	initializer := dialog initialValue.	newSelector := dialog selector.	newArgs := dialog arguments asOrderedCollection.	map := (1 to: args size) collect: [:i | args indexOf: (newArgs at: i)].	^self		handleError:			[self				performRefactoring:					(AddParameterRefactoring addParameterToMethod: aSelector in: aClass						newSelector: newSelector initializer: initializer newArgName:							newArgument permutation: map).			newSelector]</body></methods><methods><class-id>Refactory.Browser.BundleStructureView</class-id> <category>view construction</category><body package="Browser-BrowserUI" selector="addSubcomponentRows:">addSubcomponentRows: aCodeComponentSequence	| clicker maxWidth sampleLabels labelHeight index |	aCodeComponentSequence isEmpty ifTrue: [^self].	sampleLabels := (0 to: 9) collect: [:n | Label with: n printString].	maxWidth := ((sampleLabels collect: #width) fold: [:a :b | a max: b])				* (self bundleItems size log truncated + 1).	labelHeight := sampleLabels first height.	aCodeComponentSequence do: 			[:eachSubcomponent |			| row indexGraphic |			index := self nextListIndex.			row := Panel new beRow: 0.5 gap: 5.			row propertyAt: #subcomponent put: eachSubcomponent.			row propertyAt: #index put: index.			row add: (PixelSpace width: 3).			indexGraphic := VisualBlock block: 							[:gc :box |							| label |							label := Label with: (row propertyAt: #index) printString.							label displayOn: gc at: (box width - label width) @ 0]						extent: maxWidth @ labelHeight.			row add: indexGraphic.			row add: eachSubcomponent toolListIcon.			row add: (Label with: eachSubcomponent name).			clicker := self clickerToRemove: eachSubcomponent.			row add: clicker.			row add: (PixelSpace width: 3).			self add: row].	self scrollBy: self children size * self lineGrid</body></methods><methods><class-id>Refactory.Browser.RemoveOverrideChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#RemoveOverrideFor1s &lt;&lt; #browser &gt;&gt; 'Remove Override for &lt;1s&gt;')			expandMacrosWith: override printString)</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher class</class-id> <category>private</category><body package="Browser-Parser" selector="buildSelectorString:">buildSelectorString: aSelector 	| stream keywords |	aSelector numArgs = 0 ifTrue: [^aSelector].	stream := WriteStream on: String new.	keywords := aSelector keywords.	1 to: keywords size		do: 			[:i | 			stream				nextPutAll: (keywords at: i);				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.MethodCallAnalysis</class-id> <category>private</category><body package="RBDynamicRefactorings" selector="warnOfPolymorphs:">warnOfPolymorphs: classes	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'I must also rename implementors of #';		nextPutAll: selector;		nextPutAll: ' in the following classes:'; cr.	classes do: [:each | stream tab; nextPutAll: each printString; cr].	stream		nextPutAll: 'since they share call sites with the one(s) you wish to rename.'.	self refactoringWarning: stream contents.</body></methods><methods><class-id>Refactory.Browser.MethodCallAnalysis</class-id> <category>private</category><body package="RBDynamicRefactorings" selector="warnOfUnwrappables:">warnOfUnwrappables: classes	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'It is forbidden to install a wrapper on method #';		nextPutAll: selector;		nextPutAll: ' in the following classes:';		cr.	classes do: [:each | stream tab; nextPutAll: each printString; cr].	stream		nextPutAll: 'If none of the above are called by code that also calls the #' , selector , ' implementor(s) that you intend'; cr;		nextPutAll: 'to rename, then it is safe to proceed.  Otherwise abort, or check the result of applying the refactorings.'.	self refactoringWarning: stream contents.</body></methods><methods><class-id>Refactory.Browser.AddOverrideChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#AddOverrideFor1s &lt;&lt; #browser &gt;&gt; 'Add Override for &lt;1s&gt;')			expandMacrosWith: override printString)</body></methods><methods><class-id>Refactory.Browser.BrowserTextTool</class-id> <category>compiling methods</category><body package="Browser-BrowserUI" selector="compileMethodText:from:">compileMethodText: aText from: aController	| basicChange targetClass adjustedChange textToCompile |	(targetClass := self compileIntoClass) ifNil: [^self].	textToCompile := aText.	basicChange := AddMethodChange				compile: textToCompile				in: targetClass				classified: self protocol				for: aController.	basicChange inheritProtocol.	adjustedChange := self changeWithPackageAndParcelInformation: basicChange.	adjustedChange ifNil: [^self].	_.BrowserCodeTool.SaveAutoFormat == true		ifTrue: ["If we go down this path, we have to compile it up front to give the interactive handler a chance to change the text in the controller, and then use the editor's latest text"			targetClass compilerClass new				compile: textToCompile				in: nil				allowReceiver: true				class: targetClass				environment: basicChange environment				noPattern: false				notifying: aController				ifFail: [^self].			[basicChange				source: (RBParser parseMethod: aController text) printString]				on: Error				do: [:ex | ]].	self performChange: adjustedChange.	basicChange definedSelector		ifNotNil: [:selector | codeModel setSelector: selector]</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="copyDownMethod:">copyDownMethod: aSelector 	| oldSource superclassDefiner subclasses refactoring |	superclassDefiner := class superclass whoDefinesMethod: aSelector.	superclassDefiner isNil ifTrue: [^self].	oldSource := superclassDefiner sourceCodeFor: aSelector.	oldSource isNil 		ifTrue: 			[self 				refactoringError: ((#SourceFor1sSuperNA &lt;&lt; #browser &gt;&gt; 'Source code for &lt;1s&gt; superclass method not available') 						expandMacrosWith: aSelector)].	subclasses := class superclass subclasses 				reject: [:each | each directlyDefinesMethod: aSelector].	subclasses isEmpty ifTrue: [^self].	((superclassDefiner parseTreeFor: aSelector) superMessages 		anySatisfy: [:each | superclassDefiner directlyDefinesMethod: each]) 			ifTrue: 				[self 					refactoringError: ((#CannotPushUp1sMustCopyDownAndSuperOverridden &lt;&lt; #browser &gt;&gt; 'Cannot push up &lt;1s&gt; since we must copy down the superclass method in &lt;2p&gt;&lt;n&gt;to the other subclasses, and the superclass method sends a super message which is overridden.') 							expandMacrosWith: aSelector							with: superclassDefiner)].	self 		refactoringWarning: ((#CopyDownSuperMethod1s &lt;&lt; #browser &gt;&gt; 'Do you want to copy down the superclass method to the classes that don''t define &lt;1s&gt;')			expandMacrosWith: aSelector).	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: (superclassDefiner parseTreeFor: aSelector)				fromClass: superclassDefiner				toClasses: subclasses.	self performComponentRefactoring: refactoring.	subclasses do: 			[:each | 			each compile: refactoring parseTree printString				withAttributesFrom: (superclassDefiner methodFor: aSelector)]</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="pushUp:">pushUp: aSelector 	| refactoring source |	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: (class parseTreeFor: aSelector)				fromClass: class				toClasses: (Array with: class superclass).	self performComponentRefactoring: refactoring.	source := refactoring parseTree = (class parseTreeFor: aSelector) 				ifTrue: [class sourceCodeFor: aSelector]				ifFalse: [refactoring parseTree printString].	class superclass compile: source		withAttributesFrom: (class methodFor: aSelector)</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChangeInspector</class-id> <category>changing</category><body package="Browser-RefactoringUI" selector="changedChange">changedChange	| selectedChange changeText originalText originalFragments changeFragments |	selectedChange := self changeTree selection.	self dialogEnable: #executeAllButton.	selectedChange isNil		ifTrue: 			[changeDescription value: '' asText.			originalCode value: '' asText.			self disableMenu: self changesMenu except: #('Execute All').			^self].	changeText := selectedChange printString asText.	originalText := self originalCodeForChange asText.	originalFragments := originalText smalltalkOrWordAndWhitespaceFragments.	changeFragments := changeText smalltalkOrWordAndWhitespaceFragments.	(originalFragments differences: changeFragments)		do: #applyAnyDifferenceTextEmphases.	changeDescription value: changeText.	originalCode value: originalText.	self enableMenu: self changesMenu except: #('Accept' 'Cancel')</body></methods><methods><class-id>Refactory.Browser.RefactoringBrowser</class-id> <category>actions</category><body package="Browser-BrowserUI" selector="setUndoCount">setUndoCount	"Don't like the isKindOf:, but don't have a portable way to determine if something is a number."	| undoString undoTree |	undoString := self request: (#EnterUndoStackSizeC &lt;&lt; #browser &gt;&gt; 'Enter undo stack size:')				initialAnswer: RefactoryChangeManager undoSize printString.	undoString isEmpty ifTrue: [^self].	undoTree := RBParser parseExpression: undoString				onError: [:str :pos | ^self].	(undoTree isLiteralNode and: [undoTree value respondsToArithmetic]) 		ifFalse: [^self].	RefactoryChangeManager undoSize: undoTree value asInteger</body></methods><methods><class-id>Refactory.Browser.CodeToolSelectionPolicy class</class-id> <category>conversion support</category><body package="Browser-BrowserUI" selector="generateTabNameMethodSource">generateTabNameMethodSource	^(RBParser parseMethod: (self compiledMethodAt: #name) getSource)		selector: #tabName;		printString</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="isAbstractClass:">isAbstractClass: aClass 	^self new 		type: (Array with: #IsAbstractClass with: aClass)		block: [aClass isAbstract]		errorString: ((#x1sIsQnotQAbstract &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;an abstract class')			expandMacrosWith: aClass printString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hasSuperclass:">hasSuperclass: aClass 	^self new 		type: (Array with: #hasSuperclass with: aClass)		block: [aClass superclass isNil not]		errorString: ((#x1sHasQnoQsuperclass &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; has %&lt;1?a:no%&gt; superclass')			expandMacrosWith: aClass printString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hierarchyOf:definesVariable:">hierarchyOf: aClass definesVariable: aString 	^self new 		type: (Array 				with: #hierarchyDefinesInstVar				with: aClass				with: aString)		block: [aClass hierarchyDefinesVariable: aString]		errorString: ((#x1sOrSubclassDoesNotDefineVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; or one of its subclasses %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="definesSelector:in:">definesSelector: aSelector in: aClass 	^(self new)		type: (Array 					with: #definesSelector					with: aClass					with: aSelector)			block: [aClass directlyDefinesMethod: aSelector]			errorString: ((#x1sQdoesnotdefineQ2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aSelector printString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="definesInstanceVariable:in:">definesInstanceVariable: aString in: aClass 	^self new 		type: (Array 				with: #definesInstVar				with: aClass				with: aString)		block: [aClass definesInstanceVariable: aString]		errorString: ((#x1sQdefinesQInstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="directlyDefinesInstanceVariable:in:">directlyDefinesInstanceVariable: aString in: aClass 	^(self new)		type: (Array 					with: #directlyDefinesInstanceVariable					with: aClass					with: aString)			block: [aClass directlyDefinesInstanceVariable: aString]			errorString: ((#x1sQdoesnotdirectlydefineQinstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;directly define%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hierarchyOf:canUnderstand:">hierarchyOf: aClass canUnderstand: aSelector 	^(self new)		type: (Array 					with: #hierarchyUnderstandsSelector					with: aClass					with: aSelector)			block: [aClass hierarchyDefinesMethod: aSelector]			errorString: ((#x1sQorsubclassORallsubclassesQdoNotUnderstand2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?or a subclass:and all subclasses do not%&gt; understand%&lt;1?s:%&gt; &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aSelector printString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hierarchyOf:referencesInstanceVariable:">hierarchyOf: aClass referencesInstanceVariable: aString 	^self new 		type: (Array 				with: #hierarchyReferencesInstVar				with: aClass				with: aString)		block: 			[aClass withAllSubclasses 				anySatisfy: [:each | (each whichSelectorsReferToInstanceVariable: aString) notEmpty]]		errorString: ((#x1sOrSubclassQdoesnotQreferenceInstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; or subclass %&lt;1?:does not %&gt;reference%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="isMetaclass:">isMetaclass: anObject 	^(self new)		type: (Array with: #IsMetaclass with: anObject)			block: [anObject isMeta]			errorString: ((#x1sIsQnotQAMetaclass &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;a metaclass')			expandMacrosWith: anObject printString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="isImmediateSubclass:of:">isImmediateSubclass: subclass of: superClass 	^(self new)		type: (Array 					with: #immediateSubclass					with: superClass					with: subclass)			block: [subclass superclass = superClass]			errorString: ((#x1sIsQnotQimmediateSubclassOf2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;an immediate subclass of &lt;2s&gt;')			expandMacrosWith: subclass printString			with: superClass printString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="hierarchyOf:canAccessVariableNamed:">hierarchyOf: aClass canAccessVariableNamed: aString 	^self new 		type: (Array 				with: #hierarchyCanAccessVariable				with: aClass				with: aString)		block: [aClass hierarchyCanAccessVariableNamed: aString]		errorString: ((#x1sOrSubclassDoesNotDefineVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; or one of its subclasses %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="referencesInstanceVariable:in:">referencesInstanceVariable: aString in: aClass 	^(self new)		type: (Array 					with: #referencesInstVar					with: aClass					with: aString)			block: [(aClass whichSelectorsReferToInstanceVariable: aString) notEmpty]			errorString: ((#x1s1doesNotReferenceInstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;reference%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="isValidMethodName:for:">isValidMethodName: aString for: aClass 	^(self new)		type: (Array 					with: #validMethodName					with: aString					with: aClass)			block: [self checkMethodName: aString in: aClass]			errorString: ((#x1sIsNotValidMethodName &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;a valid method name')			expandMacrosWith: aString printString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="subclassesOf:referToSelector:">subclassesOf: aClass referToSelector: aSelector 	^self new 		type: (Array 				with: #subclassReferences				with: aClass				with: aSelector)		block: 			[aClass subclasses anySatisfy: 					[:each | 					each selectors anySatisfy: 							[:sel | 							| tree |							tree := each parseTreeFor: sel.							tree notNil and: [tree superMessages includes: aSelector]]]]		errorString: ((#x1noORaSubclassRefersTo2s &lt;&lt; #browser &gt;&gt; '%&lt;1?:no:a%&gt; subclass of &lt;1s&gt; refers to &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aSelector printString)</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="canUnderstand:in:">canUnderstand: aSelector in: aClass 	^(self new)		type: (Array 					with: #understandsSelector					with: aClass					with: aSelector)			block: [aClass definesMethod: aSelector]			errorString: ((#x1sQundestandsQ2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;understand%&lt;1?s:%&gt; &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aSelector printString);		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings" selector="definesVariable:in:">definesVariable: aString in: aClass 	^(self new)		type: (Array 					with: #definesVar					with: aClass					with: aString)			block: [aClass definesVariable: aString]			errorString: ((#x1sQdoesnotdefineQVariable2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString);		yourself</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="model">model	^model isNil 		ifTrue: 			[model := (RBRootNameSpace new)						description: self printString;						yourself]		ifFalse: [model]</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>utilities</category><body package="Browser-Refactorings" selector="safeMethodNameFor:basedOn:">safeMethodNameFor: aClass basedOn: aString 	"Creates an unused method name containing aString"	| baseString newString hasParam i |	baseString := aString copyOld.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	hasParam := newString last = $:.	hasParam 		ifTrue: [baseString := newString copyFrom: 1 to: newString size - 1].	i := 0.	[aClass hierarchyDefinesMethod: newString asSymbol] whileTrue: 			[i := i + 1.			newString := baseString , i printString 						, (hasParam ifTrue: [':'] ifFalse: [''])].	^newString asSymbol</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="uniqueMethodNameFor:">uniqueMethodNameFor: anInteger 	| before after index name |	before := 'a'.	after := ''.	anInteger timesRepeat: [after := after , 'z:'].	index := 0.		[name := before , index printString , after.	(Symbol findInterned: name) notNil] 			whileTrue: [index := index + 1].	^name asSymbol</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings" selector="refactorings:">refactorings: aCollection 	| oldName |	oldName := self printString.	refactorings := aCollection.	(model notNil and: [model description = oldName]) 		ifTrue: [model description: self printString]</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>changing</category><body package="Browser-BrowserUI" selector="updateWindowLabel">updateWindowLabel	| window |	self builder isNil ifTrue: [^self].	window := self builder window.	window isNil ifTrue: [^self].	(windowLabel = window label or: [window label asString isEmpty]) 		ifFalse: [self environment label: window label].	windowLabel := self state hasSelection 				ifTrue: 					[windowLabel := self environment label.					windowLabel asString notEmpty ifTrue: [windowLabel := windowLabel asString , ' - '].					windowLabel asString , self state printString]				ifFalse: [self defaultWindowLabel].	window label: windowLabel</body></methods><methods><class-id>Refactory.Browser.AddClassRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings" selector="printOn:">printOn: aStream 	aStream		nextPutAll: 'Add class, ';		nextPutAll: className;		nextPutAll: ', as subclass of ';		nextPutAll: superclass printString;		nextPutAll: ' refactoring'</body></methods><methods><class-id>Refactory.Browser.RestoreOverrideChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#RestoreOverrideFor1s &lt;&lt; #browser &gt;&gt; 'Restore Override for &lt;1s&gt;')			expandMacrosWith: override printString)</body></methods><methods><class-id>Refactory.Browser.RenameMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings" selector="myConditions">myConditions	^Condition withBlock: [oldSelector numArgs = newSelector numArgs]		errorString: ((#x1sDoesNotHaveCorrectArgNum &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; doesn''t have the correct number of arguments.')			expandMacrosWith: newSelector printString)</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>private</category><body package="Browser-BrowserUI" selector="newMethodPatternFrom:">newMethodPatternFrom: node	| argName ws |	ws := String new writeStream.	argName := 'anObject'.	node selectorPartsDo: [:selectorPart | ws nextPutAll: selectorPart value]		argumentsDo: [:argument |			ws space.			argument isVariable				ifTrue: [ws nextPutAll: argument name]				ifFalse: [ws nextPutAll: argName.					(argName anySatisfy: #isDigit)						ifTrue: [argName := (argName reject: #isDigit)										, ((argName select: #isDigit) asNumber + 1) printString]						ifFalse: [argName := 'anObject2']].			ws space].	^self formattedText: ws contents</body></methods><methods><class-id>Refactory.Browser.AddProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="primitiveExecute">primitiveExecute	self protocolObject organization addCategory: self protocol.	self 		logProtocolChange: self protocolObject printString 				, ' organization addCategory: ' , self protocol printString.	self protocolObject reorganize</body></methods><methods><class-id>Refactory.Browser.AddProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#AddProtocol1sTo2s &lt;&lt; #browser &gt;&gt; 'Add protocol, &lt;1s&gt;, to &lt;2s&gt;')			expandMacrosWith: self protocol			with: self protocolObject printString)</body></methods><methods><class-id>Refactory.Browser.RBNameSpace</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="definitionString">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineNameSpace: #';		nextPutAll: self name;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: isPrivate printString;		cr;		tab;		nextPutAll: 'imports: '''.	self imports do: [:each | each printDefinitionOn: definitionStream]		separatedBy: 			[definitionStream				cr;				tab].	definitionStream		nextPutAll: '''';		cr;		tab;		nextPutAll: 'category: '''''.	^definitionStream contents</body></methods><methods><class-id>Refactory.Browser.ClassBlendChange</class-id> <category>private</category><body package="ClassCloning" selector="isLostSuper:">isLostSuper: aMethod		| selector behavior output |	selector := aMethod selector.	behavior := aMethod mclass isMeta		ifTrue: [originalSubclass classBehavior]		ifFalse: [originalSubclass].	output := String new writeStream.	output nextPutAll: 'super'.	selector last = $:		ifTrue:			[selector keywords				keysAndValuesDo:					[:index :word | 					output						space;						nextPutAll: word;						space;						nextPutAll: '``@arg' , index printString]]		ifFalse:			[output				space;				nextPutAll: selector].	^(behavior includesSelector: selector)		and:			[(ParseTreeSearcher				treeMatching: output contents				in: (behavior parseTreeFor: selector)) notNil]</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="safeVariableNameBasedOn:">safeVariableNameBasedOn: aString 	"Creates an unused variable name containing aString"	| baseString newString i allTempVars |	allTempVars := inlineParseTree allTemporaryVariables.	baseString := aString copyOld.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	i := 0.		[(allTempVars includes: newString) 		or: [class definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="newNameForSelf">newNameForSelf	| variableName index originalName nonMetaClass |	nonMetaClass := inlineClass nonMetaclass.	variableName := originalName := 		((nonMetaClass name first isVowel 			ifTrue: [(#an &lt;&lt; #browser &gt;&gt; 'an')]			ifFalse: [(#a &lt;&lt; #browser &gt;&gt; 'a')])) asString, nonMetaClass name.	index := 1.		[variableName := self safeVariableNameBasedOn: variableName.	inlineParseTree allDefinedVariables includes: variableName] 			whileTrue: 				[variableName := originalName , index printString.				index := index + 1].	^variableName</body></methods><methods><class-id>Refactory.Browser.CompareCodeTool</class-id> <category>private</category><body package="Browser-BrowserUI" selector="definitionFromString:">definitionFromString: aString	^self definitions detect: [:x | x printString = aString ] ifNone: [nil]</body></methods><methods><class-id>Refactory.Browser.CompareCodeTool</class-id> <category>private</category><body package="Browser-BrowserUI" selector="definitionToString:">definitionToString: aDefinition	^aDefinition printString</body></methods><methods><class-id>Refactory.Browser.CompareCodeTool</class-id> <category>menus</category><body package="Browser-BrowserUI" selector="makeDefinitionsList">makeDefinitionsList	^self definitions 		asSortedCollection: [:a :b | a printString &lt;= b printString]</body></methods><methods><class-id>Refactory.Browser.SelectorProtocolNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI" selector="iconFor:">iconFor: aMethodCategory	"Return a graphic that shows the count of methods in this category. It's back coloring is based on whether all, none, or some of the methods are currently visible in the browser. As is the number count text color."	"The back 'shape' is actually a series of rectangles, we get a cleaner looking ovoid this way since it stays balanced, whereas arc/wedge drawings aliases really bad."	"The bit with style gridding, pure dart throwing until I found an algorithm that positioned it correctly on all 3 display systems."		| totalCount hereCount countStyle listView label countTextColor |	navigator selectedClass ifNil: [^nil].	totalCount := self totalMethodCountIn: aMethodCategory.	hereCount := self visibleMethodCountIn: aMethodCategory.	listView := self widgetAt: #objectList.	countStyle := listView textStyle copyOld.	countStyle gridForFont: #small withTopLead: 0 bottomLead: 0.	countTextColor := (hereCount		between: 1		and: totalCount - 1)		ifTrue: [ColorValue black]		ifFalse: [ColorValue white].	label := Label		with:			(totalCount printString asText				emphasizeAllWith:					(Array						with: #small						with: #color -&gt; countTextColor))		attributes: countStyle.	^VisualStack		with:			((totalCount isZero not and: [hereCount = totalCount])				ifTrue: [GeneralIcons darkMethodCountBackground]				ifFalse: [GeneralIcons lightMethodCountBackground])		with: label</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="primitiveExecute">primitiveExecute	self includesProtocol ifTrue: [super primitiveExecute].	self protocolObject classifySymbol: symbol under: self protocol.	self 		logProtocolChange: self protocolObject printString 				, ' classifySymbol: ' , symbol printString 				, ' under: ' , self protocol printString.	isUndo ifTrue: [self resetToPriorState]</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects" selector="changeString">changeString	^((#Move1sTo2sIn3s &lt;&lt; #browser &gt;&gt; 'Move &lt;1s&gt;, to &lt;2s&gt; in &lt;3s&gt;')			expandMacrosWith: symbol			with: self protocol			with: self protocolObject printString)</body></methods><methods><class-id>Refactory.Browser.CodeComponentBlockTool</class-id> <category>accepting</category><body package="Browser-BrowserUI" selector="accept:from:">accept: aText from: aController 	| block codeComponent |	codeComponent := self codeComponent.	codeComponent isNil ifTrue: [^self].	block := self class compilerClass new 				evaluate: aText				in: nil				allowReceiver: false				receiver: nil				environment: Smalltalk				notifying: aController				ifFail: [^self].	(block isKindOf: BlockClosure) 		ifFalse: [^self warn: (#DidNotEvaluateToABlock &lt;&lt; #browser &gt;&gt; 'Did not evaluate to a block')].	block numArgs ~= argumentCount 		ifTrue: 			[^self 				warn: ((#BlockDoesNotHaveCorrectNumArgs1s &lt;&lt; #browser &gt;&gt; 'Block does not have the correct number of arguments (&lt;1s&gt;)')			expandMacrosWith: argumentCount printString)].	codeComponent perform: ((#x1sC &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;:')			expandMacrosWith: property) asSymbol		with: (CodeComponent asActionBlock: aText).	self updateContents</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockNode</class-id> <category>matching</category><body package="Browser-Parser" selector="addArgumentWithNameBasedOn:to:">addArgumentWithNameBasedOn: aString to: aRBBlockNode 	| name index vars |	name := aString.	vars := aRBBlockNode allDefinedVariables.	index := 0.	[vars includes: name] whileTrue: 			[index := index + 1.			name := name , index printString].	aRBBlockNode 		arguments: (aRBBlockNode arguments copyWith: (RBVariableNode named: name))</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="renameSourceCodeReferences">renameSourceCodeReferences	| replacer |	replacer := self parseTreeRewriter.	self model allReferencesToObject: object		do: 			[:method | 			(method modelClass isClassObject and: 					[(method modelClass hierarchyDefinesVariable: newName) and: 							[(object environment isClassObject 								and: [method modelClass nonMetaclass includesClass: object environment]) 									not]]) 				ifTrue: 					[self refactoringError: ((#x1sAlreadyDefinedInHierarchyOf2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is already defined in hierarchy of &lt;2s&gt;')			expandMacrosWith: newName			with: method modelClass printString)].			self convertMethod: method using: replacer]</body></methods><methods><class-id>Refactory.Browser.PushDownMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="pushDown:">pushDown: aSelector 	| code refactoring |	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: (class parseTreeFor: aSelector)				fromClass: class				toClasses: class subclasses.	self performComponentRefactoring: refactoring.	code := refactoring parseTree printString.	class subclasses do: 			[:each | 			(each directlyDefinesMethod: aSelector) 				ifFalse: [each compile: code withAttributesFrom: (class methodFor: aSelector)]]</body></methods><methods><class-id>Refactory.Browser.AddParameterRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings" selector="myConditions">myConditions	^Condition withBlock: 			[oldSelector numArgs + 1 = newSelector numArgs 				ifFalse: 					[self refactoringError: ((#x1sDoesNotHaveProperArgNum &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; doesn''t have the proper number of arguments.')			expandMacrosWith: newSelector printString)].			self verifyInitializationExpression.			true]</body></methods><methods><class-id>Refactory.Browser.AddParameterRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="newSelectorString">newSelectorString	| stream keywords |	stream := WriteStream on: String new.	keywords := newSelector keywords.	1 to: keywords size		do: 			[:i | 			stream nextPutAll: (keywords at: i).			(permutation at: i) == keywords size				ifTrue: 					[stream						nextPut: $(;						nextPutAll: initializer;						nextPut: $)]				ifFalse: 					[stream						nextPutAll: ' ``@arg';						nextPutAll: (permutation at: i) printString].			stream nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.RBClass</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="definitionString">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineClass: #';		nextPutAll: self name;		cr;		tab;		nextPutAll: 'superclass: ';		print: (self superclass isNil 					ifTrue: [nil]					ifFalse: [self superclass asReference makeUnambiguous]);		cr;		tab;		nextPutAll: 'indexedType: #';		nextPutAll: indexedType;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: isPrivate printString;		cr;		tab;		nextPutAll: 'instanceVariableNames: '''.	self instanceVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream		nextPutAll: '''';		cr;		tab;		nextPutAll: 'classInstanceVariableNames: '''.	self metaclass instanceVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream		nextPutAll: '''';		cr;		tab;		nextPutAll: 'imports: '''.	self imports do: 			[:each | 			definitionStream				cr;				next: 3 put: Character tab.			each printDefinitionOn: definitionStream].	definitionStream		cr;		next: 3 put: Character tab;		nextPutAll: '''';		cr;		tab;		nextPutAll: 'category: '''''.	^definitionStream contents</body></methods><methods><class-id>RowDescriptionMessage</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. In addition to information printed by my superclass, I print 	out the number of fields and the field descriptions."	super printOn: aStream.	aStream nextPutAll: 'Number of fields: ' , self numberOfFields printString; cr.	fieldDescriptions		do: 			[:aFieldDescription | 			aFieldDescription printOn: aStream.			aStream cr].	^self</body></methods><methods><class-id>PostgreSQLRuntimeParameter</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream	aStream		nextPutAll: self name printString;		nextPutAll: ' set to: ';		nextPutAll: self setting printString;		nextPutAll: ' (';		nextPutAll: self description;		nextPutAll: ')';		yourself.	^self</body></methods><methods><class-id>SpIPAddress</class-id> <category>printing</category><body package="SpSockets" selector="hostAddressString">hostAddressString	| targetStream |	targetStream := String new writeStream.	targetStream		nextPutAll: (self hostAddress at: 1) printString;		nextPut: $.;		nextPutAll: (self hostAddress at: 2) printString;		nextPut: $.;		nextPutAll: (self hostAddress at: 3) printString;		nextPut: $.;		nextPutAll: (self hostAddress at: 4) printString.	^targetStream contents</body></methods><methods><class-id>Graphics.Printer class</class-id> <category>examples</category><body package="Examples" selector="exampleFontSizes">exampleFontSizes	"Printer exampleFontSizes."	| text document font |	document := Document new.	document		doFooter: true		footerString: 'Printer exampleFontSizes'		doPageNumbers: true.	text := (#reallyLongText &lt;&lt; #examples &gt;&gt; 'The lazy brown dog jumped over the quick fox''s back, but since the fox was quick, he managed to catch up to the dog later and eat it.  The moral of this story is always to eat your Wheaties.') asText.	font := FontDescription new family: 'times'; boldness: 0.5; italic: false.	#(6 10 14 18 )		do: 			[:size |			| style |			font pixelSize: size.			style := TextAttributes defaultFontQuery: font copyOld.			style baseline: size.			style lineGrid: size * 12 // 10.			document startParagraph.			document addText: font pixelSize printString under: (TextAttributes styleNamed: #default).			document startParagraph.			document addText: text under: style copyOld].	document toPrinter</body></methods><methods><class-id>Graphics.MacOSXFont class</class-id> <category>utilities</category><body package="Graphics-Fonts" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen 	"Answer an instance of the receiver that best represents the argument, 	 concreteFontDescription, given the font it is most closely to resemble, 	 requestedFontDescription.  The argument, aScreen, is the current Screen 	 object the font should be associated with.  PostScriptFonts are independent 	 of the Screen argument."	| size fontName encoding fontDescription boldValue isItalic screenFont |	encoding := self encoderNamed: self defaultEncodingName.	fontDescription := concreteFontDescription copyOld.	size := concreteFontDescription specifiesPixelSize 				ifTrue: [concreteFontDescription pixelSize]				ifFalse: [requestedFontDescription pixelSize].	fontName := concreteFontDescription family.	"'HelveticaNeue' matches 'helv*', which doesn't work here."	(fontName = 'Helvetica Neue' or: [fontName = 'HelveticaNeue']) 		ifTrue: [fontName := 'Helvetica'].	boldValue := requestedFontDescription specifiesBoldness 				ifTrue: [requestedFontDescription boldness]				ifFalse: 					[requestedFontDescription name isString 						ifTrue: 							[(self boldnessDescription: requestedFontDescription name) 								ifNil: [concreteFontDescription boldness]]						ifFalse: [concreteFontDescription boldness]].	isItalic := requestedFontDescription specifiesItalic 				ifTrue: [requestedFontDescription italic]				ifFalse: 					[requestedFontDescription name isString 						ifTrue: 							[(self italicDescription: requestedFontDescription name) 								ifNil: [concreteFontDescription italic]]						ifFalse: [concreteFontDescription italic]].	fontName := fontName , ' ' , size printString , ' ' 				, boldValue printString , ' ' 				, (isItalic ifTrue: ['1'] ifFalse: ['0']) , ' ' 				, requestedFontDescription setWidth printString.	screenFont := aScreen 		fontNamed: fontName		fromClass: self		encoding: encoding.	screenFont setDescription: fontDescription.	concreteFontDescription family = 'Lucida_Grande' ifTrue: [screenFont tuneWidthsOn: aScreen].	^screenFont.</body></methods><methods><class-id>Graphics.PostScriptPrinterFont</class-id> <category>initialize-release</category><body package="Graphics-Printing-PostScript" selector="name:size:">name: nm size: sz	fontBody := PostScriptFontBody named: nm.	size := sz.	ascent := fontBody ascent * size.	descent := fontBody descent * size.	name := nm,'~',size printString.	encoder := fontBody encoder.	simpleWidthTable := nil.</body></methods><methods><class-id>Graphics.PostScriptPrinterFont class</class-id> <category>utilities</category><body package="Graphics-Printing-PostScript" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen	| fontName fd |	fd := concreteFontDescription copyOld.	fontName := concreteFontDescription name, '~', requestedFontDescription pixelSize printString.	fd pixelSize: requestedFontDescription pixelSize.	fd name: fontName.	^(aScreen			fontNamed: fontName			fromClass: self)		setDescription: fd</body></methods><methods><class-id>Graphics.DocumentRenderer</class-id> <category>private</category><body package="System-Printing" selector="endPage">endPage	"Advance to the next page."	| footerY t ta ca |	page := page+1.	x := self deviceMargins left.	y := self deviceMargins top.	footerY := output clippingBounds height-(self deviceMargins bottom//2).	t := Text new.	(footer at: 3)   "pageNumber"		ifTrue:			[t := t, (Text string: (page printString,'    ')					emphasis: (Array								with: #family-&gt;'times*'								with: #pixelSize-&gt;10))].	(footer at: 1)   "footer"		ifTrue:			[t := t, (Text string: (footer at: 2)					emphasis: (Array								with: #family-&gt;'times*'								with: #italic								with: #pixelSize-&gt;10))].	t isEmpty ifTrue: [^self].	ca := VariableCharacterAttributes newWithDefaultAttributes.	ca noScaling.	ca setDefaultQuery: (FontDescription new family: 'times*'; pixelSize: 10).	ta := TextAttributes characterAttributes: ca.	ta baseline: 10; lineGrid: 13.	t := ComposedText			withText: t			style: ta			compositionWidth: output clippingBounds width						- self deviceMargins left						- self deviceMargins right.	t displayOn: output at: x@(footerY-(t height/2)).	contentOnPage := false.</body></methods><methods><class-id>Graphics.JPEGImageReader</class-id> <category>marker parsing</category><body package="ImageReaders" selector="parseHuffmanTable">parseHuffmanTable	| length markerStart |	markerStart := ioStream position.	length := self nextWord.	[ioStream position - markerStart &lt; length] whileTrue: 			[| index isACTable bits count hTable |			index := ioStream next.			isACTable := (index bitAnd: 16r10) ~= 0.			index := (index bitAnd: 16rF) + 1.			index &gt; HuffmanTableSize 				ifTrue: 					[self 						formatError: (#ImageCorruptTableSize &lt;&lt; #dialogs 								&gt;&gt; 'Image incomplete or partially corrupted. Image has more than &lt;1s&gt; quantization tables' 									expandMacrosWith: HuffmanTableSize printString)].			bits := ioStream next: 16.			count := bits inject: 0 into: [:sum :each | sum + each].			(count &gt; 256 or: [count &gt; (length - (ioStream position - markerStart))]) 				ifTrue: 					[self formatError: (#ImageCorruptHuffmanCount &lt;&lt; #dialogs 								&gt;&gt; 'Image incomplete or partially corrupted. Huffman Table count is incorrect')].			hTable := (JPEGHuffmanTable new)						bits: bits;						values: (ioStream next: count);						yourself.			(isACTable ifTrue: [self hACTable] ifFalse: [self hDCTable]) at: index				put: hTable]</body></methods><methods><class-id>Graphics.JPEGImageReader</class-id> <category>marker parsing</category><body package="ImageReaders" selector="parseQuantizationTable">parseQuantizationTable	| length markerStart |	markerStart := ioStream position.	length := self nextWord.	[ioStream position - markerStart &lt; length] whileTrue: 			[| qTablePosition prec value table |			value := ioStream next.			prec := (value bitShift: -4) &gt; 0.			qTablePosition := (value bitAnd: 16r0F) + 1.			qTablePosition &gt; QuantizationTableSize 				ifTrue: 					[self 						formatError: (#ImageCorruptTableSize &lt;&lt; #dialogs 								&gt;&gt; 'Image incomplete or partially corrupted. Image has more than &lt;1s&gt; quantization tables' 									expandMacrosWith: QuantizationTableSize printString)].			table := Array new: DCTSize2.			1 to: DCTSize2				do: 					[:i | 					value := prec ifTrue: [self nextWord] ifFalse: [ioStream next].					table at: (JPEGNaturalOrder at: i) put: value].			self class useFloatingPoint ifTrue: [self scaleQuantizationTable: table].			self qTable at: qTablePosition put: table]</body></methods><methods><class-id>Graphics.JPEGImageReader</class-id> <category>marker parsing</category><body package="ImageReaders" selector="parseStartOfFile">parseStartOfFile	| length markerStart componentLength |	markerStart := ioStream position.	length := self nextWord.	dataPrecision := ioStream next.	dataPrecision = 8 		ifFalse: 			[self 				formatError: (#CannotHandle1sBits &lt;&lt; #dialogs 						&gt;&gt; 'Cannot handle &lt;1s&gt;-bit components' 							expandMacrosWith: dataPrecision printString)].	height := self nextWord.	width := self nextWord.	componentLength := ioStream next.	height = 0 | (width = 0) | (componentLength = 0) 		ifTrue: 			[self formatError: #ImageIncompleteOrEmpty &lt;&lt; #dialogs 						&gt;&gt; 'Image incomplete or empty'].	length - (ioStream position - markerStart) = (componentLength * 3) 		ifFalse: 			[self formatError: #ImageCorruptComponentLength &lt;&lt; #dialogs 						&gt;&gt; 'Image incomplete or partially corrupted. Component length is incorrect'].	components := (1 to: componentLength) collect: 					[:each | |value|					(JPEGColorComponent new)						id: ioStream next;						widthInBlocks: (((value := ioStream next) bitShift: -4) bitAnd: 16r0F);						heightInBlocks: (value bitAnd: 16r0F);						qTableIndex: ioStream next + 1]</body></methods><methods><class-id>PostgreSQLEXDIByteArrayValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	ByteArrays can be stored in PostgreSQL fields of type bytea, but they must be Base 64 encoded 	first. This encoding makes the byte array about 30% longer but in return it means that the data can 	be stored on the target row rather than in a separate BLOB."	| writeStream |	writeStream := Base64EncodingWriteStream on: (String new: ((self object size) * (3 / 2)) rounded).	writeStream disableLineBreaks.	writeStream nextPutAll: self object.	writeStream close.	^writeStream contents printString</body></methods><methods><class-id>FunctionCallPacket</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Function: '.	self function printOn: aStream.	aStream cr.	self arguments inject: 1		into: 			[:argumentNumber :anArgument | 			aStream nextPutAll: 'Field #' , argumentNumber printString , ': '.			anArgument bytes printOn: aStream.			aStream cr.			argumentNumber + 1].	^self</body></methods><methods><class-id>ProtoObject</class-id> <category>overrides</category><body package="GlorpVWPort" selector="inspectorString">inspectorString	"For Object Studio compatibility"	^self printString.</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>printing</category><body package="Protocols-Common" selector="basicPrintOn:">basicPrintOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."        | title |        title := self class printString.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>printing</category><body package="Protocols-Common" selector="printOn:">printOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."        | title |        title := self class printString.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>error handling</category><body package="Protocols-Common" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	^MessageNotUnderstood new		parameter: aMessage;		messageText: [| selectorString |			selectorString :=				[aMessage selector printString]					on: Error					do: [:ex |						ex return:							(#errSelectorNotPrintable &lt;&lt; #dialogs &gt;&gt; '** unprintable selector **')							expandMacros asString].			(#errNotUnderstood &lt;&lt; #dialogs &gt;&gt; 'Message not understood: &lt;1s&gt;')				expandMacrosWith: selectorString];		raiseSignal.</body></methods><methods><class-id>Protocols.CircularBuffer</class-id> <category>printing</category><body package="Protocols-Common" selector="printDetailsOn:">printDetailsOn: aStream	| stream show back forward |	show := 5. "how many elements around current position to show"	stream := (cache species new: 2*show) writeStream.	back := self skipBack: show.	forward := (self next: show + back into: stream) - show.	self skipBack: forward.	"Here we rely on pretty printing capability of internal streams, so that we don't need to reimplement it"	stream := stream printString readStream.	stream skipThrough: $[.	aStream		nextPutAll: '[ ';		nextPutAll: (stream through: $[);		nextPut: $-;		print: self unread;		nextPut: $];		nextPutAll: (stream through: $]; upTo: $]);		nextPut: $]</body></methods><methods><class-id>PostgreSQLEXDINumberValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String	I return a PostgreSQL-friendly string representation of my numerical, non-integer object.  Print non-Fractions normally with intermediate $d mapped to $e and terminating non-digit discarded (a number will have either one or the other or neither, never both).  Convert Fractions to FixedPoints (more robust over the whole possible range than either asFloat or asDouble) with up to 6 digits of scale beyond their first or second significant digit (similar to Float)."	| obj vwPrintString |	obj := self object.	obj class == Fraction ifTrue:		[obj := obj reduced.		obj := obj asFixedPoint: (((obj denominator highBit - obj numerator highBit) max: 0) * 0.301) floor + 6].	^(vwPrintString := obj printString) last isDigit		ifFalse: [vwPrintString allButLast: 1]		ifTrue: [vwPrintString collect: [:char | char = $d ifFalse: [char] ifTrue: [$e]]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printString ]			].</body></methods><methods><class-id>Store.SQLAssistPostgreSQLServer</class-id> <category>special</category><body package="StoreForPostgreSQL" selector="recordsWithSourcesIn:butNotIn:">recordsWithSourcesIn:  aPrimaryKey butNotIn: bPrimaryKey 	"Postgresql likes it much better if we use an except clause rather than a primary key not in test"	self selectAll;		where;		column: #packageRef equalTo: aPrimaryKey printString;		except;		beginClause;		addString:			( tableClass newSQL selectAll;			where;			column: #packageRef equalTo: bPrimaryKey printString;			endClause			);		yourself.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="PackageCategories" selector="doUnloadFromImage">doUnloadFromImage	"Remove content of a package from the image.  Answer true if the operation has succeeded."	SystemUtils modifySystem: [		Transcript cr; show: ((#UnloadingPackageC1s &lt;&lt; #packages &gt;&gt; 'Unloading package: &lt;1s&gt;')				expandMacrosWith: self name printString).		self doUnloadExtensionsFromImage.		self doUnloadDefinitionsFromImage.		self release.		Smalltalk organization removeEmptyCategories.		Override removeOverridesForComponent: self.		Override cleanseLists.		self runPostUnload.		self cleanseRelatedParcel.		self unloadSourceSafely.		ChangeSet unloadPundle: self].	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-file out</category><body package="PackageCategories" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry packageNamedOrCreate: ', self name printString, ' ) '.</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>private</category><body package="Store-UI" selector="currentProgressIcon">currentProgressIcon	^SpinnerIcons perform: ('spin' , (progressIndex ) printString) asSymbol</body></methods><methods><class-id>Store.PackageOwnerElement</class-id> <category>relationships</category><body package="Store-UI-Graphs" selector="elementRelatedBy:">elementRelatedBy: relToken 	"Answer a collection of related elements."	Transcript		cr;		show: ((#PackageElementToken1sElement2p &lt;&lt; #store &gt;&gt; 'PackageElement token: &lt;1s&gt; element: &lt;2p&gt;') 					expandMacrosWith: relToken					with: element).	Transcript		cr;		show: (element relatedBy: relToken) printString.	^element relatedBy: relToken</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>private</category><body package="Store-UI" selector="validateSourcesIn:">validateSourcesIn: aCollection	"Validate that we're not publishing decompiled code from the image."	| invalid |	"If any of these aren't the image versions, then we're probably republishing or otherwise doing database operations where decompiled source isn't possible."	(aCollection anySatisfy: [:each | each getImagePundle ~~ each]) ifTrue: [^true].	aCollection		anySatisfy:			[:each | 			each changeSet modifiedMethodDescriptors				anySatisfy:					[:eachMethodDescriptor | 					| methodIsInvalid |					methodIsInvalid := eachMethodDescriptor compiledMethod getSource isNil.					methodIsInvalid ifTrue: [invalid := eachMethodDescriptor].					methodIsInvalid]].	invalid isNil		ifTrue: [^true]		ifFalse:			[^Dialog				confirm:					(#x1saboutToPublishDecompiled &lt;&lt; #store &gt;&gt;							'Some code, including &lt;1s&gt; is about to publish as decompiled (missing sources).&lt;n&gt;Proceed with publish?'						expandMacrosWith: invalid printString)]</body></methods><methods><class-id>Store.BranchingVersionPolicy</class-id> <category>private</category><body package="Store-User Management" selector="increment:">increment: aString	"Given a string, increment the last digit sequence. If 'aString' does not end 	with a digit, returns 'aString'"		| lastNonDigit incrementedVersionNumber numberPortion newVersionString |	lastNonDigit := aString findLast: [:char | char isDigit not].	lastNonDigit = aString size ifTrue: [^aString].	numberPortion := aString copyFrom: lastNonDigit + 1 to: aString size.	incrementedVersionNumber :=  numberPortion asNumber + 1.	newVersionString := incrementedVersionNumber printString.	[numberPortion size &gt; newVersionString size] whileTrue: [newVersionString := '0' , newVersionString].	^(aString copyFrom: 1 to: lastNonDigit) , newVersionString</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="name">name	^'&lt;1s&gt; propertyAt: &lt;2s&gt;' 		expandMacrosWith: symbol		with: self property printString</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>converting</category><body package="Store-Change Management" selector="convertValue:">convertValue: value	^value isString		ifTrue: [ value ]		ifFalse: 			[ ( value isKindOf: BlockClosure )				ifTrue: [ CodeComponent stringFromAction: value ] 				ifFalse: [ value printString ]			].</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>special</category><body package="Store-Broker-Obsolete" selector="classNamesInPackages:">classNamesInPackages: pkgIds	^self 	  selectDistinct: #( #className );	  where;	   column: #packageRef equalToArray: 		( pkgIds collect: [ :pkg | pkg primaryKey printString ] );	sqlString</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="loadIntoPackage:from:">loadIntoPackage: imgPackage from: dbPackage	"Make sure that modification goes to the proper package."	( imgPackage == nil ) | ( dbPackage == nil )		ifTrue: 			[ Dialog warn: ( (#_1sCannotBeLoadedAckageIsNotLoaded &lt;&lt; #store &gt;&gt; '&lt;1s&gt; cannot be loaded since the package is not loaded.') 				expandMacrosWith: self printString ).			^false 			].	self applyDefinitionFrom: dbPackage into: imgPackage.	^true</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"set new blessings and comments...."	self newGlobalState.	Announcements announce: (StorePrePublish for: self specifications: self specList).	self specList publishBlessing.	Announcements announce: (StorePostPublish for: self specifications: self specList).	self specList do:		[:each | each dbPundle blessingLevel: each blessing printString].	self setDetailState.	dialog accept; closeRequest</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="PackageCategories" selector="checkForClassesAndMethodsInZeroOrMultiplePackagesOn:">checkForClassesAndMethodsInZeroOrMultiplePackagesOn: aStream 	Root allClasses do: 		[ :class | 		( self containingPackageForClass: class ) == nil			ifTrue: [ class isMeta ifFalse: [ aStream nextPutAll: ((#x1sUnpackaged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; - Unpackaged')						expandMacrosWith: class printString); cr ] ]			ifFalse: 				[ | cms |				cms := self extensionClassModelsForClassSymbol: class absoluteSymbol.				cms size &gt;= 2 ifTrue: 					[ class selectors do: 						[ :selector |   | pkgs |						pkgs := OrderedCollection new.						cms do: 							[ :cm | 							( cm includesSelector: selector meta: class isMeta )								ifTrue: [ pkgs add: cm package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1s2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: class printString								with: selector asString								with: pkgs asArray printString); cr ]						]					].					class dataKeys do:						[ :key |  | pkgs |						pkgs := OrderedCollection new.						cms do: 							[ :cm | 							( cm includesDataKey: key )								ifTrue: [ pkgs add: cm package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1sDot2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: class printString								with: key asString								with: pkgs asArray printString); cr ]						]				]		]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>parcel support</category><body package="PackageCategories" selector="parcel:added:to:">parcel: aParcel added: aThing to: aPackage	"aThing has been changed - reflect the update in aPackage."	aThing isNameSpace		ifTrue: [ ^XChangeSet current moveWholeNameSpace: aThing toPackage: aPackage ].	aThing isBehavior		ifTrue: [ ^XChangeSet current moveWholeClass: aThing toPackage: aPackage ].	aThing isVariableBinding		ifTrue: 			[ aParcel definedBindings keysAndValuesDo:				[ :env :keySet |				( ( keySet includes: aThing key ) and:						[ ( env asNameSpace bindingFor: aThing key ) = aThing ] )					ifTrue: [ ^XChangeSet current addBinding: aThing in: env  ].				]			].	aThing class == MethodInstallationRecord		ifTrue: [ ^XChangeSet current 					addSelector: aThing selector					class: aThing implementingClass					toPackage: aPackage				].	Dialog warn: ( (#UnknownParcelChange &lt;&lt; #packages &gt;&gt; 'Unknown parcel change (&lt;1s&gt;)&lt;n&gt; in &lt;2s&gt;')					expandMacrosWith: aThing printString 					with: aPackage name ).</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="PackageCategories" selector="checkForNameSpaceAndDataInZeroOrMultiplePackagesOn:">checkForNameSpaceAndDataInZeroOrMultiplePackagesOn: aStream 	Root allNameSpaces do: 		[ :ns | 		( self containingPackageForNameSpace: ns ) == nil			ifTrue: [ aStream nextPutAll: ((#x1sUnpackaged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; - Unpackaged')							expandMacrosWith: ns printString); cr ]			ifFalse: 				[ | models |				models := self extensionModelsForSymbol: ns absoluteSymbol.				models size &gt;= 2 ifTrue: 					[ ns dataKeys do:						[ :key |  | pkgs |						pkgs := OrderedCollection new.						models do: 							[ :model | 							( model includesDataKey: key )								ifTrue: [ pkgs add: model package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1sDot2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: ns printString								with: key asString								with: ns asArray printString); cr ]						]					]				]		]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>parcel support</category><body package="PackageCategories" selector="parcel:change:to:">parcel: aParcel change: aThing to: aPackage	"aThing has been changed - reflect the update in aPackage."	aThing isNameSpace		ifTrue: [ ^XChangeSet current changeNameSpace: aThing toPackage: aPackage ].	aThing isBehavior		ifTrue: [ ^XChangeSet current changeClass: aThing toPackage: aPackage ].	aThing isVariableBinding		ifTrue: 			[ ^aParcel definedBindings keysAndValuesDo:				[ :env :keySet |				( keySet includes: aThing key )					ifTrue: [ XChangeSet current changeBinding: ( env asNameSpace bindingFor: aThing key ) in: env  ].				]			].	aThing class == MethodInstallationRecord		ifTrue: [ ^XChangeSet current 					changeSelector: aThing selector					class: aThing implementingClass					toPackage: aPackage				].	Dialog warn: ( (#UnknownParcelChange &lt;&lt; #packages &gt;&gt; 'Unknown parcel change (&lt;1s&gt;)&lt;n&gt; in &lt;2s&gt;')					expandMacrosWith: aThing printString 					with: aPackage name ).</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>utility</category><body package="PackageCategories" selector="repairForMethodsInZeroOrMultiplePackages">repairForMethodsInZeroOrMultiplePackages	"Registry repairForMethodsInZeroOrMultiplePackages"	Transcript cr; show: (#CheckingMultiplePackagesOrNone &lt;&lt; #packages &gt;&gt; 'Checking/repairing methods in multiple packages or no package').	Object allSubclassesDo: [:class | class selectors			do: 				[:selector | 				| pkgs cnt |				cnt := 0.				pkgs := self whatPackagesContainSelector: selector class: class.				pkgs size &gt; 1					ifTrue: [Transcript show: class printString , '&gt;&gt;' , selector asString , ' --&gt; ' , pkgs asArray printString; cr]					ifFalse: [(pkgs size &lt; 1 or: [pkgs first name = '(none)'])							ifTrue: 								[cnt := cnt + 1.								XChangeSet current									moveSelector: selector									class: class									toPackage: (self containingPackageForClass: class)]].				cnt &gt; 0 ifTrue: [Transcript cr; show: ((#MovingMethodsToNewPackage &lt;&lt; #packages &gt;&gt; 'Moved &lt;1s&gt; methods in class &lt;2s&gt; to &lt;3s&gt;')								expandMacrosWith: cnt printString								with: class printString								with: (self containingPackageForClass: class) name)]]].	Transcript cr; show: (#Done &lt;&lt; #packages &gt;&gt; 'Done.'); cr.</body></methods><methods><class-id>Store.MismatchedDatabaseError</class-id> <category>printing</category><body package="Store-Base" selector="defaultMessageText">defaultMessageText	| databasesString |	^parameter isNil 		ifTrue: 			[(#TheImageIsNotReconTheCurrentDatabase &lt;&lt; #store &gt;&gt; 'The image is not reconciled with the current database.') asString]		ifFalse: 			[databasesString := parameter allDatabases isEmpty				ifTrue: [(#noDatabase &lt;&lt; #store &gt;&gt; 'no database') asString]				ifFalse: [parameter allDatabases printString].			#_1sIsReconciledTo2sTheEntDatabaseIs3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is reconciled to (&lt;2s&gt;). The current database is &lt;3s&gt;.' 					expandMacrosWith: parameter name					with: databasesString					with: DbRegistry databaseIdentifier]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>public-change set access</category><body package="PackageCategories" selector="inspectChangeSet">inspectChangeSet	"Attempt to describe the changes to the bundle at a	high level."	"Could do better."	| stream |	stream := WriteStream on: String new.	self hasBeenModified		ifFalse: [stream nextPutAll: (#BundleHasNotBeenChanged &lt;&lt; #packages &gt;&gt; 'There are no changes to this bundle or its components') asString]		ifTrue: 			[| modPuns |			modPuns := OrderedCollection new.			self contentDescriptions do: 				[ :descrip | descrip hasBeenModified 					ifTrue: [ modPuns add: descrip component ]				].			modPuns size &gt; 0				ifTrue: 					[stream nextPutAll: (#SomeBundleComponentsHaveChanged &lt;&lt; #packages &gt;&gt; 'The following bundle components have been&lt;n&gt;modified (see component for details):') expandMacros; cr.					modPuns do: [:item | stream tab; nextPutAll: item name; cr].					stream cr].			self isChangeSetEmpty ifFalse: [stream nextPutAll: self changeSet printString]].	Dialog warn: stream contents</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-file out</category><body package="PackageCategories" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry bundleNamedOrCreate: ', self name printString, '  ) '.</body></methods><methods><class-id>Store.BasicVersionPolicy</class-id> <category>private</category><body package="Store-User Management" selector="increment:">increment: aString 	"Given a string, increment the last digit sequence. If 'aString' does not end 	with a digit, returns 'aString'"	| lastNonDigit incrementedVersionNumber | 	lastNonDigit := aString findLast: [ :char | char isDigit not ]. 	lastNonDigit = aString size ifTrue: [ ^aString ]. 	incrementedVersionNumber := ( aString copyFrom: lastNonDigit + 1 to: aString size ) asNumber + 1. 	^( aString copyFrom: 1 to: lastNonDigit ) 		, incrementedVersionNumber printString</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="loadIntoPackage:from:">loadIntoPackage: aPackage from: aRecord 	"Make sure that modification goes to the proper package."	self canLoad		ifFalse: 			[ Dialog warn: ( (#DefinitionFor1sCaE2sIsNotLoaded &lt;&lt; #store &gt;&gt; 'Definition for &lt;1s&gt; cannot be loaded since &lt;2s&gt; is not loaded.') expandMacrosWith: self printString with: symbol ).			^false 			].	Policies packagePolicy forcePackage: aPackage while: 		[ ^aRecord == nil			ifTrue: 				[ self existsInImage 					ifTrue: [ self removeFromSystemTolerant: false fromPackage: aPackage ].				true				]			ifFalse: [ self applyDefinitionFrom: aRecord ]		].</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>queries</category><body package="Store-Broker-Obsolete" selector="alterTableFor:pctIncreaseBy:">alterTableFor: aClass  pctIncreaseBy: aNumber	| sql |	sql :=  (self newSQLFor: aClass)			alterPstincrease: aNumber printString.	self process: sql.	Transcript cr; show: sql, '-- Done!'.</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>private</category><body package="Store-Change Management" selector="formatStructure:">formatStructure: structure	"Answers a formatted print string for the bundle structure."		| stream |	stream := (String new: 256) writeStream.	structure do:		[ :array |		stream 			nextPutAll: array first printString; tab; tab;			nextPutAll: array last; cr		].	^stream contents</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>printing</category><body package="Store-Change Management" selector="version">version	^databaseId, ': ', primaryKey printString</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>accessing</category><body package="Store-Change Management" selector="systemVersion:">systemVersion: aCodeComponent	"Answer an appropiate version string for aCodeComponent."	^aCodeComponent databaseId 		ifNil: [ (#NotInConnectedDatabase &lt;&lt; #store &gt;&gt; 'Not in Connected Database') asString ]		ifNotNil: [ :id | id , ': ' , aCodeComponent primaryKey printString ]</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>error handling</category><body package="StoreForGlorpBrowserUI" selector="handleGlorpError:">handleGlorpError: anAnnouncement	"Don't let anything hang us up here.	 The repository connection has terminated unexpectedly and we need to clean up the non-revivable browsers."	| session |	session := self navigator environment glorpSession.	session accessor connection = (anAnnouncement session ifNotNil: [:value | value accessor connection]) ifFalse: [^self].	[anAnnouncement wasUsed ifFalse: [Dialog warn: (#DatabaseInfoObsolete &lt;&lt; #store				&gt;&gt; 'The image is disconnected from the database,&lt;n&gt;and the version information is obsolete.&lt;n&gt;The window will now close.')						expandMacros].	self terminateBrowser]			on: Error			do: 				[Transcript show: ('Failed to terminate &lt;1s&gt; on Glorp Database Error.'							expandMacrosWith: self printString)].	anAnnouncement wasUsed: true.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>instantiating</category><body package="Store-Database Model" selector="instantiateAllOfBundle:">instantiateAllOfBundle: aBundle	"Traverse everything in the bundle, making sure we've got no proxies left, so we have everything we need to write to the other side. Note that for sub-packages we only bring in enough to be able to print them, because we may not end up replicating them if they already exist in the target database"	aBundle bundles do: [:each | self instantiateAllOf: each].	aBundle packages do: [:each | each printString].	aBundle blessings do: [:each | self followSourceFor: each].	self followCommentFor: aBundle.	aBundle propertiesRecordDictionary yourSelf isNil ifFalse: [		aBundle propertiesRecordDictionary do: [:each | self followSourceFor: each]].	aBundle propertiesBlob yourSelf.	aBundle files do: [:each | self followSourceFor: each ].</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;">&lt; aStoreMethod	| n1 n2 sel |	n1 := self classNameWithMeta.	n2 := aStoreMethod classNameWithMeta.	^n1 = n2		ifTrue:			[(self selector isString					ifTrue: [self selector]					ifFalse: [self selector printString])				&lt; ((sel := aStoreMethod selector) isString						ifTrue: [sel]						ifFalse: [sel printString])]		ifFalse: [n1 &lt; n2]</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName	| storeObject |	storeObject := ((base notNil and: [base isRemovalResolution]) ifTrue: [base base] ifFalse: [base ifNil: [original ifNil: [proposed]]]).	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value key printString</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="longListName">longListName	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [nil].	^(alternative isNil		ifTrue: ['Unkown']		ifFalse: [alternative package name]) , (#SpaceBracketPropertyBracketSpace &lt;&lt; #store &gt;&gt; ' [Property] ') asString, self propertyKey printString, self applyableString.</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		| target |	anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	anAlternative isUserInputResolution ifTrue: [^anAlternative value].	^anAlternative value isString		ifTrue: [anAlternative value]		ifFalse: 			[(anAlternative value value isKindOf: CompiledMethod)				ifFalse: 					[(target := anAlternative value value) isString 						ifTrue: [target]						ifFalse: [target printString]]				ifTrue: [anAlternative value value method getSource]]</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>accessing</category><body package="Store-Database Model" selector="versionString">versionString	^(#definitionObjectVersionString &lt;&lt; #store &gt;&gt; ' &lt;1s&gt;, &lt;2s&gt; ' expandMacrosWith: self timestamp printString with: self userName)</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>accessing</category><body package="Store-Database Model" selector="defaultParcelName">defaultParcelName	"This method is used to return a name that can be used in the creation	of a temporary source file (*.pst) when loading a parcel from a Store	database.  Currently only uses [name][primaryKey].pst but will need to	also have some way of identifying the database being accessed since	two different ParcelRecords in two different databases could have the	same name and the same primary key."	self needsMoreWork.	^self name, self primaryKey printString</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>private</category><body package="Store-Database Model" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver		startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineClass:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'super' value: (self convertVariableNodeToXML: (data at: 'superclass:')).	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'indexed-type' value: (data at: 'indexedType:') value asString.	self sax: driver tag: 'inst-vars' value: (data at: 'instanceVariableNames:') value.	self sax: driver tag: 'class-inst-vars' value: (data at: 'classInstanceVariableNames:') value.	self sax: driver tag: 'imports' value: (data at: 'imports:') value asString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	(data includesKey: 'attributes:') ifTrue:		[driver startElement: 'attributes' atts: nil.		(data at: 'attributes:') value do: [:attr |			(attr last isKindOf: Array)				ifTrue:					[driver startElement: attr first atts: nil.					attr last do: [:s | self sax: driver tag: 'item' value: s].					driver endElement]				ifFalse: [self sax: driver tag: attr first value: attr last displayString]].		driver endElement].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>private</category><body package="Store-Database Model" selector="convertToXML:">convertToXML: aString	| parse driver data sName eName init |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'shared-variable' atts: nil.	sName := (data at: 'defineSharedVariable:' ifAbsent: [data at: 'defineStatic:']) value asString.	self sax: driver tag: 'name' value: sName.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'constant' value: (data at: 'constant:') value printString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	init := ( init := (data at: 'initializer:' ) value ) == nil		ifFalse: [ self sax: driver tag: 'initializer' value: init asString ].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>accessing</category><body package="Store-Database Model" selector="bracketedVersionString">bracketedVersionString	^'(&lt;1s&gt;, &lt;2s&gt;)' expandMacrosWith: self timestamp printString with: self definition userName</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>accessing</category><body package="Store-Database Model" selector="versionString">versionString	^(#definitionObjectVersionString &lt;&lt; #store &gt;&gt; ' &lt;1s&gt;, &lt;2s&gt; ' expandMacrosWith: self timestamp printString with: self definition userName)</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="Store-Database Model" selector="versionComment">versionComment	^self blessings inject: String new into: [:sum :each | sum, each printString].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printString ]			].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="Store-Database Model" selector="textForItem">textForItem	^self printString</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="blessingLevel">blessingLevel	^self blessingLevelNumber printString</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>load utilities</category><body package="Store-Database Model" selector="reloadPundle:id:fromDatabase:">reloadPundle: aString id: anInteger fromDatabase: aSymbol	"Loads a pundle based on the primary key."	"Note: must be sent to a subclass, not the abstract Pundle class."		| choice |	(DbRegistry databaseIdentifier = aSymbol or: [DbRegistry databaseIdentifier asSymbol printString = aSymbol printString]) ifFalse:		[^Dialog warn:			(#CannotLoad1sFrom2sNotLoggedOn &lt;&lt; #store &gt;&gt; 'Cannot load &lt;1s&gt; from &lt;2s&gt; - not logged on' expandMacrosWith: aString with: aSymbol printString)].	choice := Dialog		choose: (#_1s2sWasLoadedOrPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2s&gt; was loaded or published.' expandMacrosWith: self instanceBehavior name with: aString)		labels:			(Array				with: (#ReloadFromTheDatabase &lt;&lt; #store &gt;&gt; 'Reload From the Database') asString				with: (#SetTheParent &lt;&lt; #store &gt;&gt; 'Set the Parent') asString				with: (#DoNothing &lt;&lt; #store &gt;&gt; 'Do Nothing') asString)		values: #(#reload #reset #cancel)		default: #reset.	choice == #cancel ifTrue: [^self].	choice == #reload 		ifTrue: [self loadPundleId: anInteger] 		ifFalse: [self resetPundleId: anInteger]</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		| stream |	anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	stream := WriteStream on: String new.	anAlternative isNoOpResolution		ifTrue: [stream nextPutAll: anAlternative value]		ifFalse: 			[anAlternative value 				do: 					[:each | 					stream 						nextPutAll: each first;						nextPutAll: ': ';						nextPutAll: each last printString] 					separatedBy: [stream cr]].	^stream contents</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>accessing</category><body package="Store-Database Model" selector="blessingName">blessingName	^((Dialect smalltalkAt: #Store ifAbsent: [^blessingLevel printString])		at: #Policies		ifAbsent: [blessingLevel printString]) blessingPolicy		blessingName: blessingLevel.</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>private</category><body package="Store-Database Model" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'name-space' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineNameSpace:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'imports' value: (data at: 'imports:') value.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>error handling</category><body package="Store-UI" selector="handleGlorpError:">handleGlorpError: anAnnouncement	"Don't let anything hang us up here.	 The repository connection has terminated unexpectedly and we need to clean up the non-revivable browsers."	| session |	session := self glorpSession ifNil: [^self].	"We can have multiple store sessions with the same underlying connection. Make sure that we close our browsers if there's an error on any of them."	session accessor connection = (anAnnouncement session ifNotNil: [:value | value accessor connection]) ifFalse: [^self].	[anAnnouncement wasUsed ifFalse: [Dialog warn:( #DatabaseInfoObsolete &lt;&lt; #store				&gt;&gt; 'The image is disconnected from the database,&lt;n&gt;and the version information is obsolete.&lt;n&gt;The window will now close.')						expandMacros].	self terminateBrowser]			on: Error			do: 				[Transcript show: ('Failed to terminate &lt;1s&gt; on Glorp Database Error.'							expandMacrosWith: self printString)].	anAnnouncement wasUsed: true.</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>printing</category><body package="Store-User Management" selector="printOn:">printOn: aStream	aStream nextPutAll: name.	type == nil		ifFalse: [ aStream nextPut: $-; nextPutAll: type ].	aStream 		nextPut: $(;		nextPutAll: level printString;		nextPut: $).</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	"What to do when the exception is unhandled."	Dialog warn:		( self definitionRecord isForMethod			ifTrue: [  ( #DefIsNotLoadable &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is not loadable.' ) expandMacrosWith: self definitionRecord printString ]			ifFalse: [ ( #DefIsNotLoadable &lt;&lt; #store &gt;&gt;  '&lt;1s&gt; is not loadable.' ) expandMacrosWith: self definitionRecord name ]		)</body></methods><methods><class-id>Store.TextModification</class-id> <category>actions</category><body package="Store-Change Management" selector="apply">apply	"Apply a modification to the image."	"| imPkg | 	imPkg := TT_Registry packageNamed: packageName.	imPkg isNil ifTrue: [self error: 'Package ' , packageName , ' not found.'].	tag existsInImage		ifTrue: 			[| oldPkg |			oldPkg := tag containingPackage.			oldPkg isNil ifTrue: [self error: 'No containing package for: ' , tag printString].			oldPkg = imPkg ifFalse: [self halt]]."	self notify: tag printString</body></methods><methods><class-id>XML.ElementContext</class-id> <category>accessing</category><body package="XML" selector="followSetDescription">followSetDescription	| types |	types := IdentitySet new.	self types do: [:tp |		types addAll: tp followSet].	^types asArray printString</body></methods><methods><class-id>XML.Pattern</class-id> <category>coercing</category><body package="XML" selector="normalizeFor:">normalizeFor: aParser	| list done t r result |	list := OrderedCollection			with: (result := InitialPattern new addFollow: self)			with: self			with: TerminalPattern new.	self addFollow: list last.	done := OrderedCollection new.	[list isEmpty]		whileFalse:			[t := list removeFirst.			r := t pushDownFollowSet.			done add: t.			r == nil				ifFalse: [list addAll: r]].	done do: [:nd || replacements |		replacements := nd alternateHeads.		(replacements size = 1 and: [replacements first == nd])			ifFalse: [done do: [:nd2 |				nd2 replaceFollowSet: nd with: replacements]]].	done := IdentitySet new.	list := OrderedCollection with: result.	[list isEmpty]		whileFalse:			[t := list removeLast.			t isSimple				ifFalse: [aParser malformed: (#incompleteNormalizationOfPattern							&lt;&lt; #xml &gt;&gt; 'Incomplete translation')].			(self duplicatesNeedTested and: [t hasDuplicatesInFollowSet])				ifTrue: [aParser warn: (#nondeterministicContentModel							&lt;&lt; #xml &gt;&gt; 'Nondeterministic content model &lt;1s&gt;'								expandMacrosWith: self printString)].			done add: t.			t followSet do: [:t1 |				(done includes: t1) ifFalse: [list add: t1]]].	^result</body></methods><methods><class-id>XML.Node</class-id> <category>printing</category><body package="XML" selector="simpleDescription">simpleDescription	^self printString</body></methods><methods><class-id>XML.ConcretePattern</class-id> <category>accessing</category><body package="XML" selector="followSetDescription">followSetDescription	| s |	s := (String new: 32) writeStream.	s nextPut: $(.	followSet do: [:n | s nextPutAll: n printString]		separatedBy: [s space].	s nextPut: $).	^s contents</body></methods><methods><class-id>XML.InitialPattern</class-id> <category>accessing</category><body package="XML" selector="description">description	^(followSet asArray collect: [:i | i description]) printString</body></methods><methods><class-id>PostgreSQLEXDIBLOBValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	My string value is the string form of the integer which is the oid of the BLOB I represent. This is a 	non-trivial matter. I must submit several fuction calls to the PostgreSQL back end which create &amp; 	update the blob. By myself, I can't see the database; I need to get hold of the database connection. 	To acieve this, I throw an exception which is caught by the session. The session in turn then sends 	me the &gt;&gt;callFunctionInTheContextOf: with itself as the argument. This enables me to get hold of 	the connection and call the appropriate blob functions on the back end.  I then return control to 	the session, which in turn resumes the exception returning control here. Finally I take the oid of the 	blob and return it's value as a string. Phew!! 	NOTE: This way of handling blobs results in a new BLOB for every update. It is very important that 	database triggers are used to remove old blobs from the database when a row containing BLOB 	references is updated or deleted."	PostgreSQLEXDIFieldValueFunctionCallRequest signalWith: self.	^self oid printString</body></methods><methods><class-id>FunctionResponse</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. In addition to information 	printed by my superclass ..."	super printOn: aStream.	aStream nextPutAll: 'Result value: ' , self value bytes printString; cr.	^self</body></methods><methods><class-id>FieldDescription</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. ."	aStream nextPutAll: 'Field description.  Name: ' , self name.	aStream nextPutAll: '.  Object ID: ' , self objectID printString.	aStream nextPutAll: '.  Type size: ' , self typeSize printString.	aStream nextPutAll: '.  Type modifier: ' , self typeModifier printString.	^self</body></methods><methods><class-id>AsciiRowMessage</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I write a representation of myself to aStream. In addition to 	information printed by my superclass, I write details of my fields."	super printOn: aStream.	self fields inject: 1		into: 			[:fieldNumber :aField | 			aStream nextPutAll: 'Field #' , fieldNumber printString , ': '.			aField printOn: aStream.			aStream cr.			fieldNumber + 1].	^self</body></methods><methods><class-id>Core.Time</class-id> <category>printing</category><body package="GlorpExtensions" selector="glorpPadToTwoDigits:">glorpPadToTwoDigits: anInteger	| string |	string := anInteger truncated printString.	^string size = 1 ifTrue: ['0', string] ifFalse: [string].</body></methods><methods><class-id>Core.Time class</class-id> <category>general inquiries</category><body package="Magnitude-General" selector="aTimeString:">aTimeString: theSeconds 	"Answer a String of the date and time where the argument, theSeconds,  	represents the number of seconds since 1901 began."	^TimeZone default 		convertGMT: theSeconds 		do: [:date :seconds | 			date printString , ' ' , (Time fromSeconds: seconds) printString]</body></methods><methods><class-id>Core.IllegalCharacterStreamErrorPolicy</class-id> <category>errors</category><body package="Collections-Streams" selector="noEncodingFor:in:">noEncodingFor: aCharacter in: aStream 	(UnsupportedCharacterError new)		messageText: (#errNoCharacter &lt;&lt; #dialogs &gt;&gt; 'No character available') 					asString , ' for character value ' 					, aCharacter asInteger printString;		character: aCharacter;		raiseSignal.	^Character illegalCode asCharacter</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Debugger-Support" selector="debugString">debugString	^self printString</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Kernel-Objects" selector="displayString">displayString	"Allows any Object to be used as the basis for a Label, although the 	purpose of displayString is to provide something more suitable than 	printString, primarily for use in SequenceViews."	^self printString</body></methods><methods><class-id>Core.Object</class-id> <category>tt-utilities</category><body package="Store-Base" selector="textRepresentation">textRepresentation	^self printString.</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Kernel-Objects" selector="printOn:">printOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."        | title |        title := self class printString.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="Kernel-Objects" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	"The default behavior is to create a Notifier containing the 	appropriate message and to allow the user to open a Debugger. 	Subclasses can override this message in order to modify this behavior."	| excpt resumeValue |	excpt := Object messageNotUnderstoodSignal newException.	excpt		searchFrom: thisContext;		parameter: aMessage;		messageText: [| selectorString |			selectorString :=				[aMessage selector printString]					on: Error					do: [:ex |						ex return:							(#errSelectorNotPrintable &lt;&lt; #dialogs &gt;&gt; '** unprintable selector **')							expandMacros asString].			(#errNotUnderstood &lt;&lt; #dialogs &gt;&gt; 'Message not understood: &lt;1s&gt;')				expandMacrosWith: selectorString];		originator: self;		makeSureResumable.	resumeValue := excpt raiseSignal.	^excpt reachedDefaultHandler		ifTrue: [self perform: aMessage selector withArguments: aMessage arguments]		ifFalse: [resumeValue]	"3 zork."</body></methods><methods><class-id>Core.BehaviorShell</class-id> <category>printing</category><body package="Kernel-Classes" selector="printOn:">printOn: aStream 	"Append to the argument aStream a statement of which	superclass the receiver descends from."	aStream nextPutAll: (#aDescendentOf1s &lt;&lt; #dialogs &gt;&gt; 'a descendent of &lt;1s&gt;'		expandMacrosWith: self superclass printString).</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="GlorpExtensions" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	"Print the date in ISO format. 'yyyy-mm-dd'  Don't rely on any dialect-specific formatting or padding mechanisms"	| monthString dayString |	aCommand 		nextPut: $';		print: self year;		nextPut: $-.	monthString := self monthIndex printString.	monthString size = 1 ifTrue: [aCommand nextPut: $0 ].	aCommand nextPutAll: monthString.	aCommand nextPut: $-.	dayString := self dayOfMonth printString.	dayString size = 1 ifTrue: [aCommand nextPut: $0 ].	aCommand nextPutAll: dayString.	aCommand nextPut: $'.</body></methods><methods><class-id>Core.Integer</class-id> <category>printing</category><body package="Tools-Trippy" selector="asShortSizeInBytes">asShortSizeInBytes	| baseOneKilobyte sizeUnits toGo leadingDigitIndex answer |	sizeUnits := #('' 'B' 'K' 'M' 'G' 'T').	self &lt; 0 ifTrue: [^'-', self negated asShortSizeInBytes].	self = 0 ifTrue: [^self printString, (sizeUnits at: 2)]. 	baseOneKilobyte := Array new: sizeUnits size.	baseOneKilobyte at: 1 put: 0.	toGo := self.	2 to: sizeUnits size do:		[:each |			baseOneKilobyte at: each put: (toGo bitAnd: 1023).			toGo := toGo bitShift: -10		].	toGo &gt; 0 ifTrue: [baseOneKilobyte at: sizeUnits size put: toGo * 1024 + (baseOneKilobyte at: sizeUnits size)].	leadingDigitIndex := baseOneKilobyte findLast: [:one | one &gt; 0].	leadingDigitIndex = 0 ifTrue: [leadingDigitIndex := baseOneKilobyte size].	answer := String new writeStream.	(baseOneKilobyte at: leadingDigitIndex) printOn: answer.	leadingDigitIndex &gt; 2 ifTrue:		[			answer nextPut: $..			((baseOneKilobyte at: leadingDigitIndex - 1) * 100 // 1024)				printOn: answer paddedWith: $0 to: 2 base: 10		].	answer nextPutAll: (sizeUnits at: leadingDigitIndex).	^answer contents</body></methods><methods><class-id>Core.TimestampPrintPolicy</class-id> <category>accessing</category><body package="Internationalization" selector="tokenProcessingDispatchTable">tokenProcessingDispatchTable	"set up the code blocks to be executed in order to process tokens"	tokenProcessingDispatchTable == nil		ifFalse: [^tokenProcessingDispatchTable].	tokenProcessingDispatchTable := IdentityDictionary new.	tokenProcessingDispatchTable		at: $y			put: 				[:out :timestamp :token |				| yearString |				yearString := timestamp year printString.				token numericModifier = 2					ifFalse: 						[NumberPrintPolicy							print: yearString asNumber							on: out							using: (token padding ifTrue: ['???0'] ifFalse: ['###0'])]					ifTrue: 						[yearString := yearString									copyFrom: yearString size - token numericModifier + 1									to: yearString size.						NumberPrintPolicy							print: yearString asNumber							on: out							using: '00']];		at: $b			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp month					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $B			put: 				[:out :timestamp :token |				| monthFormatMapping |				monthFormatMapping := #(2 1 3).	"Order of month formats accessed by allMonthNames, mapped to format modifiers"				out					nextPutAll: ((self allMonthNames							at: (monthFormatMapping at: token numericModifier)) at: timestamp month)];		at: $d			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp day					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $A			put: 				[:out :timestamp :token |				out nextPutAll: ((self allWeekdayNames at: token numericModifier)							at: timestamp asDate weekdayIndex)];		at: $h			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp hours					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $m			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp minutes					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $s			put: 				[:out :timestamp :token |				NumberPrintPolicy					print: timestamp seconds					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $n			put: 				[:out :timestamp :token |				| millisecondFormat |				token padding					ifTrue: 						[millisecondFormat := String new: token numericModifier + 2 withAll: $?]					ifFalse: 						[millisecondFormat := String new: token numericModifier + 2 withAll: $0].				millisecondFormat at: 2 put: $..				out					nextPutAll: ((NumberPrintPolicy print: timestamp milliseconds / 1000							using: millisecondFormat) copyFrom: 3 to: millisecondFormat size)];		at: $p			put: 				[:out :timestamp :token |				"AM/PM"				timestamp hours &gt; 11					ifTrue: [out nextPutAll: (longAmPm at: 2)]					ifFalse: [out nextPutAll: (longAmPm at: 1)]];		at: $j			put: 				[:out :timestamp :token |				"day of year"				NumberPrintPolicy					print: timestamp dayOfYear					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $i			put: 				[:out :timestamp :token |				"hour (1 to 12)"				| iHour |				iHour := timestamp hours.				timestamp hours &gt; 12					ifTrue: [iHour := timestamp hours - 12]					ifFalse: [timestamp hours = 0 ifTrue: [iHour := 12]].				NumberPrintPolicy					print: iHour					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $k			put: 				[:out :timestamp :token |				"hour (0 to 11)"				| kHour |				kHour := timestamp hours.				timestamp hours &gt; 11 ifTrue: [kHour := timestamp hours - 12].				NumberPrintPolicy					print: kHour					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $l			put: 				[:out :timestamp :token |				"hour (1 to 24)"				| lHour |				lHour := timestamp hours.				timestamp hours = 0 ifTrue: [lHour := 24].				NumberPrintPolicy					print: lHour					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $Z			put: 				[:out :timestamp :token |				"Format code currently unsupported."				];		at: $Y			put: 				[:out :timestamp :token |				"year of week of year (ISO) - currently not supported"				];		at: $w			put: 				[:out :timestamp :token |				"week of year"				NumberPrintPolicy					print: (self weekOfYear: timestamp)					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $f			put: 				[:out :timestamp :token |				"week of month - not yet supported"				out error: #noWeekOfMonth &lt;&lt; #dialogs &gt;&gt; 'week of month is not supported'];		at: $a			put: 				[:out :timestamp :token |				"weekday (numeric)"				| dayOfWeek |				dayOfWeek := timestamp asDate weekdayIndex.	"Date class: Monday =1 Sunday=7"	"Convert to Sunday=1 ... Saturday=7 scheme."				dayOfWeek = 7					ifTrue: [dayOfWeek := 1]					ifFalse: [dayOfWeek := dayOfWeek - 1].				dayOfWeek = 0 ifTrue: [dayOfWeek := 1].				NumberPrintPolicy					print: dayOfWeek					on: out					using: (String new: token numericModifier							withAll: (token padding ifTrue: [$?] ifFalse: [$0]))];		at: $c			put: 				[:out :timestamp :token |				"milliseconds in day"				(timestamp isKindOf: Timestamp)					ifTrue: 						["Not supported for Dates or Times, which do not contain enough information to resolve to milliseconds."						NumberPrintPolicy							print: timestamp asMilliseconds							on: out							using: (String new: token numericModifier									withAll: (token padding ifTrue: [$?] ifFalse: [$0]))]];		at: $z			put: 				[:out :timestamp :token |				"time zone - currently not supported"				];		at: $G			put: 				[:out :timestamp :token |				"Era - currently not supported"				];		at: $g			put: 				[:out :timestamp :token |				"Modified Julian day - Currently not supported"				];		at: $u			put: 				[:out :timestamp :token |				"currently not supported"				];		at: $r			put: 				[:out :timestamp :token |				"time zone (RFC822) - currently not supported"				].	^tokenProcessingDispatchTable</body></methods><methods><class-id>Core.Number</class-id> <category>printing</category><body package="GlorpVWPort" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	"VisualWorks has this unpleasant habit of appending characters to anything float-like that's not actually an instance of Float, 	which happens way down in the guts of the printing, so it's hard to avoid. 	This seems to be the only reasonable way to work around it without resorting to inefficient and non-portable print policies.	In addition, the exponent character, d, is more universally understood as e."	| basic real |	basic := self printString.	real := basic last isDigit				ifTrue: [basic]				ifFalse: [basic copyFrom: 1 to: basic size - 1].	real := real asLowercase copyReplaceAll: 'd' with: 'e'.	aCommand nextPutAll: real</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>checking head</category><body package="Headless" selector="dumpStackToTranscriptUsingRTPDumper:label:">dumpStackToTranscriptUsingRTPDumper: aContext label: aString	"Dump a stack trace to the Transcript starting at aContext using the Runtime Packager's runtime facilities. Refer to them using a string so that we don't encourage the tracing mechanism to include them if it wouldn't otherwise do so."	| rtpDumper dumper |	rtpDumper := Smalltalk at: 'RuntimePackager.RuntimeFullDumper' ifAbsent: [^false].	self stackDumpStream cr; show: aString printString.	[dumper := rtpDumper new.	dumper dumpStream: self stackDumpStream.	dumper dumpExceptionReport: nil context: aContext]		on: Error do: [:ex | self dumpStackToTranscriptBasic: ex initialContext label: 'error printing stack: ', ex description asString. ^false].	^true.</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>checking head</category><body package="Headless" selector="dumpStackToTranscriptBasic:label:">dumpStackToTranscriptBasic: aContext label: aString	"Dump a stack trace to the Transcript starting at aContext."	self stackDumpStream 		cr;		nextPutAll: '---------------------------------------------------'; cr;		nextPutAll: aString printString;		cr;		nextPutAll: aContext printStack;		nextPutAll: '---------------------------------------------------'; cr;		flush</body></methods><methods><class-id>Core.Stream</class-id> <category>fileOut</category><body package="Collections-Streams" selector="timeStamp">timeStamp	"Append the current time to the receiver as a chunk."	| aStream |	aStream := WriteStream on: (String new: 16).	SystemUtils timeStamp: aStream.	self nextChunkPut: aStream contents printString.	"double quotes and !s"	self cr; cr</body></methods><methods><class-id>Core.Exception class</class-id> <category>private-examples</category><body package="Examples" selector="clientB:">clientB: index	| hc |	hc := HandlerList new.	hc on: Object indexNotFoundSignal 		handle: [:ex | Transcript cr; show: 'index: ', ex parameter printString.				ex pass].	hc on: Dictionary keyNotFoundSignal		handle: [:ex | Transcript cr; show: 'key: ', ex parameter printString.				ex pass].	hc handleDo: [ ^self clientC: index ]</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleDivideByZeroAbort">exampleDivideByZeroAbort	"Exception exampleDivideByZeroAbort"	-2.0 to: 2.0 do: 		[ :i |		[ 10.0 / i. Transcript cr; show: i printString ]			on: Number divisionByZeroSignal do:				[ :ex | Transcript cr; show: (#divideByZeroAbort &lt;&lt; #examples &gt;&gt; 'divideByZero abort'). 				ex return ]		].</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleSignalCollection">exampleSignalCollection	"Signal sig1 and sig2 are caught by the handler,	but signal sig3 is not caught and a Notifier view 	shows up." 	"Exception exampleSignalCollection"	| sig1 sig2 sig3 sc |	sig1 := Signal new notifierString: (#sig1 &lt;&lt; #examples &gt;&gt; 'sig1').	sig2 := Signal new notifierString: (#sig2 &lt;&lt; #examples &gt;&gt; 'sig2').	sig3 := Signal new notifierString: (#sig3 &lt;&lt; #examples &gt;&gt; 'sig3').	sc := SignalCollection new.	sc add: sig1; add: sig2.	[sig1 raise] 		on: sc 		do: [:ex | Transcript cr; show: ex signal printString].	[sig2 raise]		on: sc 		do: [:ex | Transcript cr; show: ex signal printString].	[sig3 raise]		on: sc 		do: [:ex | Transcript cr; show: ex signal printString].</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleStreamPositionOutOfBounds">exampleStreamPositionOutOfBounds	"Signal when you set position out of bounds of the stream. 	The handler resets position to half the size of the position."	"Exception exampleStreamPositionOutOfBounds"	| stream pos |	stream := ReadStream with: #(ua ba twa jal klm).	pos := 24.	[stream position: pos]		on: stream class positionOutOfBoundsSignal 		do: [:ex | pos := ex parameter. pos := pos // 2. 				Transcript cr; show: pos printString.				ex retry].	Transcript cr; show: stream next</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleStreamNextPastEnd">exampleStreamNextPastEnd	"Signal reading past the end of the stream.	Exception handling removes checking for EOF every time 	in the main loop as in the following conventional code:		[fileStream atEnd] whileFalse:		[Transcript show: fileStream next printString].or 	[(char := fileStream next) == nil] whileFalse:		[Transcript show: char printString]"	"Exception exampleStreamNextPastEnd"	| fileStream fileName |	fileStream := (fileName := Filename named: 'tempFile') writeStream.	fileStream nextPutAll: 'ua jal twa ba klm'.	fileStream close.	fileStream := fileName readStream.	[[Transcript show: fileStream next printString] repeat]		on: fileStream class endOfStreamSignal		do: [:ex | fileStream close.				ex return].	fileName delete</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleCollectionAt">exampleCollectionAt	"Access a collection out-of-bounds and catch the error."	"Exception exampleCollectionAt"	| collection var |	collection := OrderedCollection new.	1 to: 10 do: [:i | collection add: i].	 [ 1 to: 20 do: 		[ :i | 		var := collection at: i.		Transcript space; show: var printString		]	] on: Collection indexNotFoundSignal do:		[:ex | 		Transcript cr; show: (#ExceededCollectionSize &lt;&lt; #examples &gt;&gt; 'Exceeded collection size').		ex return		].</body></methods><methods><class-id>Core.Exception class</class-id> <category>private-examples</category><body package="Examples" selector="clientA">clientA	| v |	#('2' 7 5.5 -4 'abc' '1.5 ') do:		[:index | 		[v := self clientB: index.		Transcript cr; show: v printString]			on: Object notFoundSignal			do: [:ex | 				Transcript show: (#NotFound &lt;&lt; #examples &gt;&gt; ' not found.').				ex return]]</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleDictionaryAt">exampleDictionaryAt	"Signal reading at non-existing key. The handler creates the key	and restarts to read at the key."	"Exception exampleDictionaryAt"	| aDictionary value |	aDictionary := Dictionary new.	aDictionary at: #C put: $c.	[value := aDictionary at: #A] on: Dictionary keyNotFoundSignal		do: [ :ex | aDictionary at: #A put: $a. ex retry ].	Transcript cr; show: ((#x1sIn2s &lt;&lt; #examples &gt;&gt; '&lt;1s&gt; in &lt;2s&gt;')			expandMacrosWith: value printString			with: aDictionary printString)</body></methods><methods><class-id>Core.Exception class</class-id> <category>examples</category><body package="Examples" selector="exampleUserInterruptSignal">exampleUserInterruptSignal	"Control-Y causes a pause for one second."	"Exception exampleUserInterruptSignal"	[1 to: 100 do: 				[:i | Transcript show: ' ', i printString]]		on: Object userInterruptSignal		do: [:ex | (Delay forSeconds: 1) wait.						ex resume]</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="Kernel-Classes" selector="printSubclassesWithStaticsOn:level:">printSubclassesWithStaticsOn: aStream level: level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| subs |	aStream crtab: level.	aStream print: self.	aStream space; nextPut: $(.	self asNameSpace keys		do: [:aName | aStream print: aName]		separatedBy: [aStream space].	aStream nextPut: $).	subs := self subclasses.	self == Class ifTrue:		[aStream crtab: level+1; nextPutAll: (#AllTheMetaclasses &lt;&lt; #dialogs &gt;&gt; '... all the Metaclasses ...') asString.		subs := subs reject: [:sub | sub isMeta]].	"Print subclasses in alphabetical order"	(subs asSortedStrings:			[:p :x :y | | collation |			(collation := p collate: x name to: y name) &lt; 0			or: [collation = 0				and: [x == y or: [(p collate: x printString to: y printString) &lt;= 0]]]]) do:		[:sub |		sub printSubclassesWithStaticsOn: aStream level: level + 1]</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="Kernel-Classes" selector="printSubclassesOn:level:">printSubclassesOn: aStream level: level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| subs |	aStream crtab: level.	aStream print: self.	aStream space; nextPut: $(.	self instVarNames		do: [:aName | aStream print: aName]		separatedBy: [aStream space].	aStream nextPut: $).	subs := self subclasses.	self == Class ifTrue:		[aStream crtab: level+1; nextPutAll: (#AllTheMetaclasses &lt;&lt; #dialogs &gt;&gt; '... all the Metaclasses ...') asString.		subs := subs reject: [:sub | sub isMeta]].	"Print subclasses in alphabetical order"	(subs asSortedStrings:			[:p :x :y | | collation |			(collation := p collate: x name to: y name) &lt; 0			or: [collation = 0				and: [x == y or: [(p collate: x printString to: y printString) &lt;= 0]]]]) do:		[:sub |		sub printSubclassesOn: aStream level: level + 1]</body></methods><methods><class-id>Core.Behavior</class-id> <category>printing</category><body package="Kernel-Classes" selector="printOn:">printOn: aStream 	"Append to the argument aStream a statement of which	superclass the receiver descends from."	aStream nextPutAll: (#aDescendentOf1s &lt;&lt; #dialogs &gt;&gt; 'a descendent of &lt;1s&gt;'		expandMacrosWith: superclass printString).</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing instances and variables</category><body package="Kernel-Classes" selector="instVarNames">instVarNames	"Answer an Array of the instance variable names.  Behaviors must make up fake	local instance variable names because Behaviors have instance variables for the	purpose of compiling methods, but these are not named instance variables.  "	| mySize superSize |	mySize := self instSize.	superSize := 		superclass == nil			ifTrue: [0]			ifFalse: [superclass instSize].	mySize = superSize ifTrue: [^#()].		^(superSize + 1 to: mySize) collect: [:i | 'inst' , i printString]</body></methods><methods><class-id>Core.Behavior class</class-id> <category>class creation</category><body package="Kernel-Classes" selector="illegalBehaviorType">illegalBehaviorType	"Raise an error for an invalid behavior type"	self error: ((#ClassTypeMustConform &lt;&lt; #dialogs &gt;&gt; 'Class type must be one of &lt;1s&gt;')			expandMacrosWith: (LegalSubclassTypeMap keys asArray printString						copyReplaceAll: '#(' with: '('))</body></methods><methods><class-id>Core.Behavior class</class-id> <category>class creation</category><body package="Kernel-Classes" selector="formatFromType:super:instVars:">formatFromType: classBehaviorType super: superclassOfNew instVars: instVars	"Answer the value of the format word for a class with the	 given behavior type, instance variables and superclass."	| superclassBehaviorType behaviorType formatInteger vars |	superclassBehaviorType := superclassOfNew == nil										ifTrue: [#none]										ifFalse: [superclassOfNew behaviorType].	behaviorType := (self isType: classBehaviorType						legalSubclassTypeForSuperclassType: superclassBehaviorType)			ifTrue: [classBehaviorType]			ifFalse: [(self isType: classBehaviorType					promotableSubclassTypeForSuperclassType: superclassBehaviorType)				ifTrue: [superclassBehaviorType]				ifFalse: [self error: (#InvalidSubclassType &lt;&lt; #dialogs &gt;&gt; 'Invalid subclass behavior type for this superclass')]].	formatInteger := behaviorType = #none ifTrue: [PointersMask]			ifFalse: [behaviorType = #objects ifTrue: [PointersMask+IndexableMask]			ifFalse: [behaviorType = #bytes ifTrue: [IndexableMask]			ifFalse: [behaviorType = #weak ifTrue: [PointersMask+IndexableMask+WeakMask]			ifFalse: [behaviorType = #ephemeron ifTrue: [PointersMask+EphemeronMask]			ifFalse: [behaviorType = #immediate ifTrue: [0]			ifFalse: [self illegalBehaviorType]]]]]].	vars := superclassOfNew == nil			ifTrue: [#()]			ifFalse: [superclassOfNew allInstVarNames].	vars := vars, instVars.	((formatInteger noMask: PointersMask) and: [vars size &gt; 0]) ifTrue:		[self error: ((#InstVarsNotPermittedHere &lt;&lt; #dialogs &gt;&gt; 'A Class of type &lt;1s&gt; cannot have instance variables.')			expandMacrosWith: behaviorType)].	((formatInteger anyMask: EphemeronMask) and: [vars size = 0]) ifTrue:		[self error: ((#RequireAnInstVar &lt;&lt; #dialogs &gt;&gt; 'A Class of type &lt;1s&gt; must have at least one instance variable.')			expandMacrosWith: behaviorType)].	vars size &gt; FixedFieldsMask ifTrue:		[self error: ((#TooManyInstVars &lt;&lt; #dialogs &gt;&gt; 'A Class cannot have a total of more than &lt;1s&gt; instance variables.')			expandMacrosWith: FixedFieldsMask printString)].	^formatInteger + vars size</body></methods><methods><class-id>Core.Signal</class-id> <category>accessing</category><body package="Kernel-Exception Handling" selector="errorStringExtra:with:">errorStringExtra: extraString with: parameter	"Answer the string for a Notifier, including the parameter if relevant. "	| errorString |	errorString := self errorStringExtra: extraString.	^(errorString notNil and: [errorString isEmpty not and: [errorString last = Character space]])		ifTrue: [errorString , parameter printString]		ifFalse: [errorString]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>organization</category><body package="Kernel-Classes" selector="logOrganizationChange">logOrganizationChange	"Record that the receiver is being reorganized on the changes file."	SourceFileManager default logChange:			self storeString,			' reorganizeFromString: ',			self organization printString storeString</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>copying</category><body package="Kernel-Classes" selector="copy:from:classified:">copy: sel from: class classified: cat 	"Install the method associated with the first argument, sel, a message selector,	found in the method dictionary of the second argument, class, as one of the	receiver's methods.  Classify the message under the third argument, cat."	| code category |	"Useful when modifying an existing class"	code := class sourceMethodAt: sel.	code == nil		ifFalse: 			[cat == nil				ifTrue: [category := class organization categoryOfElement: sel]				ifFalse: [category := cat].			(methodDict includesKey: sel)				ifTrue: [code asString = (self sourceMethodAt: sel) asString 							ifFalse: [self notify: ((#MethodWillBeRedefined &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; &lt;2s&gt; will be redefined if you proceed.')			expandMacrosWith: self printString			with: sel)]].			self compile: code classified: category]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>binary storage</category><body package="BOSS" selector="binaryReaderBlockForVersion:format:">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones.	The block's return value will be ignored.  The block	should use some means like #become: or #changeClassToThatOf:	to change the identity of the block's argument to an instance	of the class"	" By default, classes do not know how to do this. "	self error: 'Attempt to read incompatible version ', oldVersion printString, ' with format = ', oldFormat printString, ' of ', self printString.	^[:oldObj | self error: 'Attempt to create instance of old version!'.  self new]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>binary storage</category><body package="Kernel-Classes" selector="shapeChangeFrom:for:">shapeChangeFrom: importMap for: aCodeReader	"The receiver has changed shape on loading from a parcel file.	 Attempt to update its format (and soleInstance) appropriately.	 There are three formats to handle...		a) the original pre-version 6 formats have no shape-change info.  Just fail.		b) formats 6 though 9 have shape-change info after the book-keeping info		c) formats 10 onwards have the info before book-keeping.	 We assume that book-keeping has read-in valid inst var contents into	 a class that possibly has too many inst vars.  So no re-arrangement	 has to be done.  However, we may have to shorten the instance."	| storedInstVars newClass |	(aCodeReader fileFormat &lt; 6	or: [instanceVariables size &gt; 0		and: [| scivs | 			scivs :=  superclass allInstVarNames.			instanceVariables contains: [:ivn| scivs includes: ivn]]]) ifTrue:		[^CodeReader invalidClassFormatSignal			raiseWith: self fullName			errorString: ((#incompatible2s1sClassFormatForSystem &lt;&lt; #dialogs &gt;&gt; 'While Loading Parcel &lt;2s&gt;, the format of the class &lt;1s&gt; was found to be incompatible with its format in the system.')				expandMacrosWith: self printString				with: aCodeReader parcelName)].	storedInstVars := importMap at: 2.	storedInstVars size &gt; self instSize ifTrue:		[newClass := self basicNew.		1 to: self instSize do:			[:i| newClass instVarAt: i put: (thisClass instVarAt: i)].		newClass become: thisClass]</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="Store-Image Objects" selector="textRepresentationDataAt:">textRepresentationDataAt: aDataKey	"Answer text for aDataKey"		^(self dataAt: aDataKey ifAbsent: [^(#twoStarUnresolvedTwoStar &lt;&lt; #store &gt;&gt; '**Unresolved**') asText]) printString asText</body></methods><methods><class-id>Core.Class</class-id> <category>fileIn/Out</category><body package="XML-source" selector="xmlDefinition:onto:">xmlDefinition: anXMLFormatter onto: aStream	| extra |	^anXMLFormatter		on: aStream 		tag: 'class' 		do: 			[:xmlFormatter :stream | 			| superclassName private |			xmlFormatter on: stream cr tag: 'name' value: self name.			xmlFormatter on: stream cr tag: 'environment' value: self environment fullName.			superclassName := self superclass isNil				ifTrue: ['']				ifFalse: [(self isAbsentClass ifTrue: [self absentSuperclass] ifFalse: [self superclass]) fullName].			xmlFormatter on: stream cr tag: 'super' value: superclassName.			private := self environment bindingFor: self name.			private := private isNil ifTrue: [false] ifFalse: [private isPrivate].			xmlFormatter on: stream cr tag: 'private' value: private printString.			xmlFormatter on: stream cr tag: 'indexed-type' value: self behaviorType.			xmlFormatter on: stream cr tag: 'inst-vars' value: self instanceVariablesString.			xmlFormatter on: stream cr tag: 'class-inst-vars' value: self class instanceVariablesString.			xmlFormatter on: stream cr tag: 'imports' value: self asNameSpace importString.			xmlFormatter on: stream cr tag: 'category' value: self category asString.			extra := self extraAttributesForDefinition.			extra isEmpty ifFalse: 				[xmlFormatter on: stream cr tag: 'attributes' do: 					[:innerXMLFormatter :innerStream |					extra do: 						[:each |						(each last isKindOf: Array)							ifTrue: [innerXMLFormatter on: innerStream cr tag: each first do: 								[:extraItemsXMLFormatter :extraItemsStream |								each last do: [:eachItems | extraItemsXMLFormatter on: extraItemsStream tag: 'item' encodeLiteral: eachItems] separatedBy: [extraItemsStream space]]]							ifFalse: [innerXMLFormatter on: innerStream cr tag: each first value: each last displayString]].						stream cr]].			stream cr]</body></methods><methods><class-id>Core.Class</class-id> <category>class name</category><body package="Kernel-Classes" selector="renameReferencesFrom:">renameReferencesFrom: oldNameString	"The old name of the receiver is the argument, oldNameString.	Change all references in the system from the old name	to the new (current) one."	| oldName ref |	oldName := oldNameString asSymbol.	ref := self environment bindingFor: oldName.	ref == nil ifTrue: [ref := self environment bindingFor: self name].	SystemUtils allBehaviorsDo:		[:b | | meths |		meths := b whichSelectorsReferTo: ref.		meths size &gt; 0			ifTrue: [meths do:						[:sel | | s cat pos |						s :=  b sourceCodeAt: sel.						cat := b whichCategoryIncludesSelector: sel.						Transcript cr; show: b printString , ' (' , cat , ') ' , '&gt;&gt; ' , sel.						pos := Compiler preferredParserClass new							scanPositionsFor: oldName							inString: s.						pos reverseDo:							[:p |							s := s copyReplaceFrom: p								to: p + oldName size - 1								with: name].						b compile: s classified: cat]]].</body></methods><methods><class-id>Core.Class</class-id> <category>pool variables</category><body package="Kernel-Classes" selector="removeSharedPool:">removeSharedPool: aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool dictionaries.	Create an error if the dictionary is not one of the pools."	| satisfiedSet |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: (#RemovedImportNotPresent &lt;&lt; #dialogs &gt;&gt; 'the dictionary is not in my pool')].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet := Set with: self with: self class.	satisfiedSet do: 		[:sub | 		aDictionary bindingsDo: 			[:aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: ((#ImportedVariableStillUsed &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; is still used in code of class &lt;2s&gt;')			expandMacrosWith: aGlobal key			with: sub printString)]]].	self setSharedPools: (self sharedPools remove: aDictionary; yourself).</body></methods><methods><class-id>Core.Class</class-id> <category>binary storage</category><body package="Kernel-Classes" selector="shapeChangeFrom:for:">shapeChangeFrom: importMap for: aCodeReader	"The receiver has changed shape on loading from a parcel file.	 Attempt to update its format appropriately."	(self isBits	or: [instanceVariables size &gt; 0		and: [| scivs | 			scivs :=  superclass allInstVarNames.			instanceVariables contains: [:ivn| scivs includes: ivn]]]) ifTrue:		[CodeReader invalidClassFormatSignal			raiseWith: self fullName			errorString: ((#incompatible2s1sClassFormatForSystem &lt;&lt; #dialogs &gt;&gt; 'While Loading Parcel &lt;2s&gt;, the format of the class &lt;1s&gt; was found to be incompatible with its format in the system.')				expandMacrosWith: self printString				with: aCodeReader parcelName)].	format := (format bitAnd: FixedFieldsMask bitInvert)				bitOr: self allInstVarNames size</body></methods><methods><class-id>Core.Message</class-id> <category>compilation</category><body package="Debugger-Support" selector="methodStubSource">methodStubSource	"Return a String of a method body for the message which contains a single self halt statement."	"nil zork" "nil zork: 1" "nil zork: 1 zork: $1" "nil zork: 1 zork: 1 zork: 1"	| str na |	str := (String new: 1024) writeStream.	(na := args size) = 0		ifTrue: [str nextPutAll: selector]		ifFalse:			[| argNames |			argNames := OrderedCollection new: na.			args				with: selector keywords				do:	[:arg :keyword| | argName |					argName := ((arg isBehavior											ifTrue: ['a', arg basicPrintString]											ifFalse: [arg basicPrintString]) copyWithout: Character space) copyWithout: $. .					(argNames includes: argName) ifTrue:						[| newName n |						n := 2.						[newName := argName, n printString.						argNames includes: newName]							whileTrue: [n := n + 1].						argName := newName].					argNames add: argName.					str nextPutAll: keyword; space; nextPutAll: argName.					str space]].	str crtab; nextPutAll: 'self halt'.	^str contents	"(Message			selector: #with:with:			arguments: (Array with: Store.PackageModel with: Store.PackageModel)) methodStubSource"</body></methods><methods><class-id>Core.VariableBinding</class-id> <category>printing</category><body package="PackageCategories" selector="definitionString">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineSharedVariable: #';		nextPutAll: self key;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: self isPrivate printString;		cr;		tab;		nextPutAll: 'constant: ';		nextPutAll: self isConstant printString;		cr;		tab;		nextPutAll: 'category: ';		nextPutAll: self category asString printString;		cr;		tab;		nextPutAll: 'initializer: '.	self method isNil 		ifTrue: [definitionStream nextPutAll: 'nil']		ifFalse: [definitionStream nextPutAll: self method getSource printString].	^definitionStream contents</body></methods><methods><class-id>Core.ConstantAccessor</class-id> <category>printing</category><body package="System-Dependency Events" selector="printOn:">printOn: aStream	"Append the ASCII representation of the receiver to &lt;aStream&gt;."	self class printOn: aStream.	aStream nextPutAll: ' (', object printString, ')'</body></methods><methods><class-id>Core.ErrorDumper</class-id> <category>dumping-support</category><body package="ErrorNotifier" selector="dumpValue:maxSize:">dumpValue: aValue maxSize: aNumber	"Write a description of a value onto the dump"	| valueString |	" Get the printString with some error protection"	[ valueString := aValue printString ]		on: Error		do: [ :ex |			valueString := '--Error printing object of class ', aValue class printString. ].	" Trim the size of the printString to something reasonable"	valueString size &gt; aNumber ifTrue: [		valueString := ( valueString copyFrom: 1 to: aNumber - 3 ), '...' ].	dumpStream		nextPutAll: '(id=';		print: aValue identityHash;		nextPutAll: ') ';		nextPutAll: valueString.</body></methods><methods><class-id>Core.ErrorDumper</class-id> <category>dumping-support</category><body package="ErrorNotifier" selector="saveDateTimeStrings">saveDateTimeStrings	"Save the current date and time for printing.	Date/time printString is avoided due to	the potential impact of internationalization.	Hopefully no one is tinkering with printString."	"self contained date conversion (once again)"	| now dateNow timeNow |	now := Date dateAndTimeNow.	dateNow := now at: 1.	timeNow := now at: 2.	dumpDate := dateNow year printString, '/',		dateNow monthIndex printString, '/',		dateNow dayOfMonth printString.	dumpTime := timeNow hours printString, ':',		( timeNow minutes &lt; 10			ifTrue: [ '0', timeNow minutes printString ]			ifFalse: [ timeNow minutes printString ] ), ':',		( timeNow seconds &lt; 10			ifTrue: [ '0', timeNow seconds printString ]			ifFalse: [ timeNow seconds printString ] )</body></methods><methods><class-id>Core.EncodedStream class</class-id> <category>testing</category><body package="Collections-Streams" selector="readWriteTestWith:">readWriteTestWith: aStreamEncoder	"Test EncodedStream with aStreamEncoder by reading and writing	 ``/s/st/src/converters/jis-unicode.map'' file."	| mapFile tmpFile si ucode jcode |	mapFile := '/s/st/src/converters/jis-unicode.map' asFilename withEncoding: #JapaneseEUC.	tmpFile := 'jis-unicode.tmp' asFilename withEncoding: aStreamEncoder streamEncodingType.	"copy mapFile to tmpFile in different encoding"	Transcript cr; show: ((#CopyingWith1s &lt;&lt; #dialogs &gt;&gt; 'Copying with &lt;1s&gt;...')			expandMacrosWith: aStreamEncoder printString).	mapFile copyTo: tmpFile.	Transcript show: (#done &lt;&lt; #dialogs &gt;&gt; 'done').	"read again and check character"	Transcript cr; show: ((#CheckingWith1s &lt;&lt; #dialogs &gt;&gt; 'Checking with &lt;1s&gt;...')			expandMacrosWith: aStreamEncoder printString).	si := tmpFile readStream.	[(ucode := self nextHexa: si) isNil]		whileFalse: [			jcode := self nextHexa: si.			jcode notNil ifTrue: [				si next asInteger == ucode					ifFalse: [Transcript show: (#failed &lt;&lt; #dialogs &gt;&gt; 'failed.').						    ^false]]].	Transcript show: (#ok &lt;&lt; #dialogs &gt;&gt; 'ok').	"skip: -1 test"	Transcript show: ((#SkipTestWith1s &lt;&lt; #dialogs &gt;&gt; 'Skip Test with &lt;1s&gt;...')			expandMacrosWith: aStreamEncoder printString).	si reset.	[(ucode := si next) isNil]		whileFalse: [			si skip: -1.			si next == ucode				ifFalse: [Transcript show: (#failed &lt;&lt; #dialogs &gt;&gt; 'failed.'); cr.					    ^false]].	si close.	Transcript show: (#ok &lt;&lt; #dialogs &gt;&gt; 'ok'); cr.	tmpFile delete.	^true</body></methods><methods><class-id>Core.CollectionAccessor</class-id> <category>printing</category><body package="System-Dependency Events" selector="printOn:">printOn: aStream	"Append the ASCII representation of the receiver to aStream."	self class printOn: aStream.	aStream nextPutAll: ' (', elementName printString, ')'</body></methods><methods><class-id>Core.NumberPrintPolicy</class-id> <category>private-printing</category><body package="Internationalization" selector="print:on:using:">print: number on: outputStream using: tokens	"Print the argument, number, according to the rules described in the format tokens. Answer the receiver. Consult the class comments for details on the contents of tokens."	| commaScalingFactor fractionLength decimalFieldWidth decimal float index fraction decimalPower doingFraction useThousandsSeparator exponentShift exponentLength shiftedNumber zero zeroCh allOptional |	(tokens == nil or: [tokens isEmpty]) ifTrue: [^String new].	zero := self zeroCode.	zeroCh := Character value: zero.	fractionLength := self fractionLengthFor: tokens.	decimalFieldWidth := self decimalFieldWidthFor: tokens.	useThousandsSeparator := self includesThousandsSeparatorFor: tokens.	commaScalingFactor := self commaScalingFactorFor: tokens.	shiftedNumber := number / commaScalingFactor.	doingFraction := false.	index := 1.	exponentShift := 0.	exponentLength := self exponentLengthFor: tokens.	(exponentLength ~~ nil and: [shiftedNumber isZero not])		ifTrue: 			[exponentShift := decimalFieldWidth - shiftedNumber abs log floor - 1.			shiftedNumber := shiftedNumber asDouble * (10 raisedTo: exponentShift)].	(tokens includes: #%) ifTrue: [shiftedNumber := shiftedNumber * 100].	float := shiftedNumber roundTo: (10 raisedTo: fractionLength negated).	decimal := float abs truncated.	fraction := float abs \\ 1.	decimalPower := decimal = 0				ifTrue: [0]				ifFalse: [0 max: decimal printString size - 1].	[index &lt;= tokens size] whileTrue: 			[| token |			token := tokens at: index.			(token == #'#' or: [token == #'0' or: [token == #?]])				ifTrue: 					[decimalPower + 1 &lt; decimalFieldWidth						ifTrue: 							[token == #? ifTrue: [outputStream nextPut: Character space].							token == #'0' ifTrue: [outputStream nextPut: zeroCh].							index := index + 1.							decimalFieldWidth := decimalFieldWidth - 1.							(useThousandsSeparator								and: [decimalFieldWidth \\ groupingSize = 0 and: [token == #'0']])									ifTrue: [outputStream nextPut: self thousandsSeparator]]						ifFalse: 							[| num digit tmp |							doingFraction								ifTrue: 									[fraction := fraction * 10.									digit := fraction truncated.									fraction := fraction - digit.									index := index + 1.									(fraction == 0 and: [digit == 0])										ifTrue: 											[token == #'0' ifTrue: [outputStream nextPut: zeroCh].											token == #? ifTrue: [outputStream nextPut: Character space]]										ifFalse: [outputStream nextPut: (Character value: zero + digit)]]								ifFalse: 									[num := decimal // (10 raisedTo: decimalPower).									decimalPower := decimalPower - 1.									tmp := num // 10.									digit := num - (tmp * 10).									decimalPower + 1 &gt;= decimalFieldWidth										ifFalse: 											[index := index + 1.											decimalFieldWidth := decimalFieldWidth - 1].									(digit == 0 and: [decimal &lt;= 0 and: [(token == #'0') not]])										ifFalse: [outputStream nextPut: (Character value: zero + digit)]].							(useThousandsSeparator								and: [(decimalPower + 1) \\ groupingSize = 0 and: [decimalPower &gt; 0]])									ifTrue: [outputStream nextPut: self thousandsSeparator]]]				ifFalse: 					[token == #'.'						ifTrue: 							[index := index + 1.							(allOptional := fraction isZero)								ifTrue: 									[index to: index + fractionLength - 1										do: [:idx | (tokens at: idx) == #'#' ifFalse: [allOptional := false]]].							allOptional ifFalse: [outputStream nextPut: self decimalPoint].							doingFraction := true]						ifFalse: 							[token == #,								ifTrue: [index := index + 1]								ifFalse: 									[(token == #d or: [token == #e])										ifTrue: 											[decimalFieldWidth := exponentLength.											doingFraction := false.											decimal := exponentShift abs.											fraction := 0.											decimalPower := decimal = 0														ifTrue: [0]														ifFalse: [0 max: decimal printString size - 1].											outputStream nextPut: token first.											(exponentShift isZero not and: [exponentShift positive])												ifTrue: [outputStream nextPut: $-].											index := index + 1]										ifFalse: 											[self printToken: token on: outputStream.											index := index + 1]]]]]</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-spin button</category><body package="Collections-Text" selector="decrementBy:boundedBy:">decrementBy: intervalValue boundedBy: aBlock	^(aBlock value: (self asNumber - intervalValue)) printString</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-spin button</category><body package="UIBasics-Support" selector="spinBy:boundedBy:">spinBy: aNumber boundedBy: aBlock	"This API is used by spin box widgets to produce a new value adjusted by aNumber. The receiver is interpreted as if it were a number and then coerced back to a string. aBlock is a single arg block which can be used to condition/filter the (numerical) result."		^(aBlock value: self asNumber + aNumber) printString</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-spin button</category><body package="Collections-Text" selector="incrementBy:boundedBy:">incrementBy: intervalValue boundedBy: aBlock	^(aBlock value: (self asNumber + intervalValue)) printString</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private-dataset</category><body package="Database" selector="columnWidthsFromData:">columnWidthsFromData: rows	"Update the space needed for each column of data	by finding the longest entry of all rows for that column."	| datum maxColumnWidths |	maxColumnWidths := Array new: (rows first size) withAll: 0.	rows do: 			[:rowData |			1 to: rowData size				do: 					[:col |					| len |					datum := (rowData at: col) printString trimBlanks.					len := datum asComposedText width + 10.					len &gt; (maxColumnWidths at: col) ifTrue: [maxColumnWidths at: col put: len]]].	^maxColumnWidths</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private-dataset</category><body package="Database" selector="addColumnLabel:width:">addColumnLabel: aString width: aNumber	"Add a column to the dataset view. To go into effect, send &gt;&gt;invalidate to the dataset."	| columnCollection newColumn dataset columnSpec newColumnNumber aspectSymbol |	dataset := self datasetWidget.	columnCollection := dataset columnDescriptors asOrderedCollection.	columnSpec := columnCollection first description copyOld.	newColumnNumber := columnCollection size + 1.	aspectSymbol := ('selectedRow ', newColumnNumber printString) asSymbol.	columnSpec				label: aString;				model: aspectSymbol;				width: aNumber.	newColumn := columnSpec columnWithBuilder: self builder.	columnCollection add: newColumn.	dataset columnDescriptors: columnCollection.</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>accessing</category><body package="Database" selector="turnOnOEMEncoding">turnOnOEMEncoding	self encoding: OSSystemSupport concreteClass new GetOEMCP printString asSymbol</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>accessing</category><body package="Database" selector="turnOffOEMEncoding">turnOffOEMEncoding	encoding == OSSystemSupport concreteClass new GetOEMCP printString asSymbol ifTrue: [		self encoding: nil.		self encoding.	]</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>tracing</category><body package="Database" selector="trace:">trace: aStringOrNil	"Emit the standard trace header followed by aString (if not nil) into the trace log."	| header when sender depth |	TraceCollector == nil ifTrue: [ ^self ].	header := WriteStream on: (String new: 64).	when := Time dateAndTimeNow.	sender := thisContext sender.	depth := TraceLevel &gt; 4 ifTrue: [ TraceLevel - 4 ] ifFalse: [ 1 ].	"Emit a timestamp"	header		nextPutAll: '{';		"print: (when at: 1);"  nextPutAll: ((when at: 1) printFormat: #(1 2 3 $ 2 2));		nextPutAll: ' ';		print: (when at: 2);		nextPutAll: '} 	'.		"curly-brace, space and a tab"	"Emit a stack trace"	[ depth &gt; 0 ] whileTrue:		[ header			nextPutAll: sender mclass printString;			nextPutAll: '&gt;&gt;';			nextPutAll: sender selector asString.		sender := sender sender.		(depth := depth - 1) &gt; 0 ifTrue:			[ header cr; tab: 6 ] ].	TraceSequencer critical:		[ TraceCollector nextPutAll: header contents; cr.		( aStringOrNil size &gt; 0 ) ifTrue:			[ TraceCollector tab; nextPutAll: aStringOrNil; cr ].		TraceCollector flush ]</body></methods><methods><class-id>Glorp.GlorpInvalidTypeError</class-id> <category>accessing</category><body package="GlorpMisc" selector="defaultMessageText">defaultMessageText	^'Object being written does not match the type of the attribute: ''', self object printString,  ''' ~= ''' , self expectedType printString, ''''.</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>fields</category><body package="GlorpDatabase" selector="addForeignKeyFrom:to:suffixExpression:">addForeignKeyFrom: sourceField to: targetField suffixExpression: suffixExpression	| newFK |	newFK := ForeignKeyConstraint					sourceField: sourceField					targetField: targetField					suffixExpression: suffixExpression.	newFK name: (newFK name , (foreignKeyConstraints size + 1) printString).	foreignKeyConstraints add: newFK.	^newFK.</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>fields</category><body package="GlorpDatabase" selector="addForeignKeyFromAll:toAll:suffixExpression:">addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: suffixExpression	| newFK |	newFK := ForeignKeyConstraint					sourceFields: sourceFields					targetFields: targetFields					suffixExpression: suffixExpression.	newFK name: (newFK name , (foreignKeyConstraints size + 1) printString).	^foreignKeyConstraints add: newFK.</body></methods><methods><class-id>Glorp.FixedSizeQueue</class-id> <category>printing</category><body package="GlorpCore" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	aStream nextPutAll: items size printString.	aStream nextPut: $/.	aStream nextPutAll: maximumSize printString.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>accessing</category><body package="GlorpQueries" selector="initializeQuery">initializeQuery	query := Query		read: localBase descriptor describedClass		where: rightChild.	query tablePrefix: ('s', localBase ultimateBaseExpression availableSubSelectNumber printString, 't')."	query baseExpression: localBase."	query session: localBase descriptor session.	localBase descriptor tables do: [:eachTable |		eachTable primaryKeyFields do: [:each | query retrieve: [:base | base getField: each]]].</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	| w |	platform supportsVariableSizedNumerics ifFalse: [^typeString].	w := WriteStream on: String new.	w nextPutAll: typeString.	precision isNil 		ifFalse: 			[w nextPutAll: '(' , precision printString.			scale isNil ifFalse: [w nextPutAll: ',' , scale printString].			w nextPutAll: ')'].	^w contents</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	^self typeName, '(', width printString, ')'.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>creating mappings</category><body package="GlorpMappings" selector="directMappingFor:">directMappingFor: attributeName	"Create a direct mapping from the attribute of this name to the field in the table with a matching name. For convenience when there's a good correspondence between the field and instance variable names."	| field |	self tables do: [:each |		field := each fieldNamed: attributeName ifAbsent: [nil] caseSensitive: false].	field isNil ifTrue: [self error: 'Cannot find field named ', attributeName printString].	^self directMapping from: attributeName to: field.</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>converting</category><body package="GlorpQueries" selector="nullFieldFor:">nullFieldFor: eachField	self platform requiresCastsForNullsInUnions ifFalse: [^(ConstantExpression for: nil) alias: eachField table name, 'nullField', eachField position printString].	^FunctionExpression		for: #cast:		withArguments: (Array with: (ConstantExpression for: eachField type))		basedOn: (ConstantExpression for: nil).</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>accessing</category><body package="GlorpMisc" selector="getVisualAgeMessageText">getVisualAgeMessageText		| tempTag |	tempTag := self basicTag.	^tempTag isNil ifTrue: [self printString] ifFalse: [tempTag errorText].</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>accessing</category><body package="GlorpMisc" selector="getMessageText">getMessageText	"This is horribly ugly. Not only are dialects inconsistent, but behaviour between types of exceptions is inconsistent within dialects"		Dialect isVisualWorks ifTrue: [^self getVisualWorksMessageText].	Dialect isVisualAge ifTrue: [^self getVisualAgeMessageText].	Dialect isSqueak ifTrue: [^self databaseError].	^self printString.</body></methods><methods><class-id>Glorp.PGSequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select nextval('.			self qualifiedName printOn: stream.			stream nextPutAll: ') from ' , aTable name.			stream nextPutAll: ' limit '.			stream nextPutAll: (aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.NoTableFound</class-id> <category>accessing</category><body package="GlorpMisc" selector="messageText">messageText	messageText ifNotNil: [^messageText].	self model isString ifTrue: [^'No table &lt;1s&gt; found' expandMacrosWith: self model].	^'No table found for &lt;1s&gt;, expected to see one of  &lt;2s&gt;' expandMacrosWith: self model name with: self expectedTables printString</body></methods><methods><class-id>Glorp.GlorpDatabaseType class</class-id> <category>printing</category><body package="GlorpDatabaseTypes" selector="padToThreeDigits:">padToThreeDigits: anInteger	| string |	string := anInteger truncated printString.	string size = 3 ifTrue: [^string].	string size = 2 ifTrue: [^'0', string].	string size = 1 ifTrue: [^'00', string].</body></methods><methods><class-id>Glorp.GlorpDatabaseType class</class-id> <category>printing</category><body package="GlorpDatabaseTypes" selector="padToTwoDigits:">padToTwoDigits: anInteger	| string |	string := anInteger truncated printString.	^string size = 1 ifTrue: ['0', string] ifFalse: [string].</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions" selector="printValue:on:">printValue: value on: aCommand	| type |	type := [self leftChild type] on: Dialect error do: [:ex | self error: 'Invalid comparison operation: ', self printString].	(self useBindingFor: value to: type in: aCommand) ifTrue: [^aCommand nextPutAll: '?'].	self expectsCollectionArgument		ifTrue:			[type				printCollection: value				on: aCommand]		ifFalse:			[type				print: value				on: aCommand].</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="connectionClassForLogin:">connectionClassForLogin: aLogin 	aLogin database isDB2Platform ifTrue: [^ Smalltalk at: #AbtIbmCliDatabaseManager].	aLogin database class == OraclePlatform 		ifTrue: [^Smalltalk at: #AbtOracle10DatabaseManager].	aLogin database isODBCPlatform 		ifTrue: [^Smalltalk at: #AbtOdbcDatabaseManager].	aLogin database isPostgreSQLPlatform 		ifTrue: [self error: 'PostgreSQL is not yet supported under VA'].	self error: 'Unknown database platform' , aLogin database printString</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="loginIfError:">loginIfError: aBlock 	"		This method creates a NEW database connection.	"	| dbMgrClass anAbtDatabaseLogonSpec anAbtDatabaseConnectionSpec aliasNameString baseAliasName |	self log: 'Login'.	self logOnly ifTrue: [^self].	aliasNameString := baseAliasName := currentLogin connectString.	"		We try to generate a unique alias name to get a new connection and to 		prevent the normal VAST behaviour to reuse a connection	"		[((Smalltalk at: #AbtDbmSystem) 		activeDatabaseConnectionWithAlias: aliasNameString) notNil] 			whileTrue: 				[aliasNameString := baseAliasName , Time millisecondClockValue printString].	"		Get the native VA class responsible for doing the work against the		three special connections available in VA	"	dbMgrClass := self connectionClass.	"		Get the logon specification for the database ... do not use		any server information	"	anAbtDatabaseLogonSpec := (Smalltalk at: #AbtDatabaseLogonSpec) 				id: currentLogin username				password: currentLogin password				server: self serverName.	"			Get the specification for the connection ...    "	anAbtDatabaseConnectionSpec := (Smalltalk at: #AbtDatabaseConnectionSpec) 				forDbmClass: dbMgrClass				dataSourceName: self databaseName.	connection := anAbtDatabaseConnectionSpec 				connectUsingAlias: aliasNameString				logonSpec: anAbtDatabaseLogonSpec				ifError: 					[:error | 					"throw away the connection ..."					connection := nil.					aBlock value: error].	connection isNil ifFalse: [		connection databaseMgr errorBlock: [:err | self externalDatabaseErrorSignal signalWith: err]].</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	typeString isNil		ifTrue:			[typeString := self typeName.			width isNil				ifFalse: [typeString := typeString , '(' , width printString , ')']].	^typeString.</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="name">name	"This can get called when we're masquering as a class, for purposes of indexing descriptors, so just print something useful"	^self printString.</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>private</category><body package="GlorpCore" selector="backupReserveCommand:in:">backupReserveCommand: anInteger in: aSession	| command stream |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select '.	stream nextPutAll: self qualifiedName.	stream nextPutAll: '.nextval from SYS.ALL_OBJECTS '.	stream nextPutAll: ' WHERE rownum &lt;= '.	stream		nextPutAll:			(aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select '.			stream nextPutAll: self qualifiedName.			stream nextPutAll: '.nextval from '.			stream nextPutAll: aTable name.			stream nextPutAll: ' WHERE rownum &lt;= '.			stream nextPutAll: (aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand blockFactor: anInteger.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>public</category><body package="GlorpDatabase" selector="creationString">creationString	^self sequenceIncrement &gt; 1		ifFalse: ['create sequence ', self qualifiedName]		ifTrue: ['create sequence ', self qualifiedName, ' increment by ', self sequenceIncrement printString]</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services columns</category><body package="GlorpDatabase" selector="printSqlStatementToPopulateColumn:with:on:">printSqlStatementToPopulateColumn: aDatabaseField with: aValue on: aStream	| converter dbValue |	converter := aDatabaseField converterForStType: aValue class.	dbValue := converter		convert: aValue		toDatabaseRepresentationAs: aDatabaseField type.	aStream		nextPutAll: 'UPDATE ';		nextPutAll: (self ddlTableNameFor: aDatabaseField table);		nextPutAll: ' SET ';		nextPutAll: (self nameForColumn: aDatabaseField name);		nextPutAll: ' = ';		nextPutAll: dbValue printString;		nextPutAll: ' WHERE (';		nextPutAll: ( self nameForColumn: aDatabaseField name);		nextPutAll: ' IS NULL OR ';		nextPutAll: (self nameForColumn: aDatabaseField name);		nextPutAll: ' &lt;&gt; ';		nextPutAll: dbValue printString;		nextPutAll: ')'</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestamp on: aStream for: aType	aTimestamp isNil ifTrue: [aTimestamp glorpPrintSQLOn: aStream. ^self].	aStream nextPut: $'; nextPutAll: aTimestamp printString; nextPut: $'.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="integerToString:for:">integerToString: anInteger for: aType	anInteger isNil ifTrue: [^nil].	^self padString: anInteger printString for: aType.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>printing</category><body package="GlorpMappings" selector="printOn:">printOn: aStream	aStream nextPutAll: self classModel printString, '&gt;&gt;', self name.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>private</category><body package="GlorpMappings" selector="raiseInvalidAttributeError">raiseInvalidAttributeError	self error: 'Invalid attribute: ', classModel printString, '&gt;&gt;', name printString.</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	"Don't bind the number in the fetch first nn clause."	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select next value for '.			stream nextPutAll: self qualifiedName.			stream nextPutAll: ' from '.			stream nextPutAll: aTable name.			stream nextPutAll: ' fetch first '.			stream nextPutAll: anInteger printString.			stream nextPutAll: ' rows only'.			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand blockFactor: anInteger.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>private</category><body package="GlorpCore" selector="backupReserveCommand:in:">backupReserveCommand: anInteger in: aSession	"syscat.tables is a public view of all the tables.	Don't bind the number in the fetch first nn clause."	| command stream |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select next value for '.	stream nextPutAll: self qualifiedName.	stream nextPutAll: ' from SYSCAT.TABLES'.	stream nextPutAll: ' fetch first '.	stream nextPutAll: anInteger printString.	stream nextPutAll: ' rows only'.	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>logging</category><body package="GlorpDatabase" selector="logError:">logError: anErrorObject 	self log: anErrorObject printString</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>logging</category><body package="GlorpDatabase" selector="logTime:">logTime: aTimeOrBlock	| time |	self logOnly ifTrue: [^self].	self changed: #time: with: aTimeOrBlock.	self logging ifFalse: [^self].	time := (Dialect isBlock: aTimeOrBlock)		ifTrue: [aTimeOrBlock value]		ifFalse: [aTimeOrBlock].	self logString: '(' , (time / 1000.0) printString , ' s)'.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase" selector="dropSequences:">dropSequences: anArray	anArray do:		[:each |		self			dropSequence: each			ifAbsent:				[:ex | 				self log: (ex messageText ifNil: [ex printString]).				ex return: nil]].</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>logging</category><body package="GlorpDatabase" selector="logCommand:bound:">logCommand: aDatabaseCommand bound: aBoolean	"Log the execution of a command"	| string |	self changed: #command: with: aDatabaseCommand.	self logging ifFalse: [^self].	string := aDatabaseCommand sqlString. 	aBoolean ifTrue: [string := string , '  ' , aDatabaseCommand bindings printString].	self logString: string.</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>accessing</category><body package="GlorpMappings" selector="addMember:">addMember: aDescriptor	members isNil ifTrue: [members := OrderedCollection new].	(members includes: aDescriptor)		ifFalse: [members add: aDescriptor]		ifTrue: [Transcript cr; show: ('Your system does a duplicate registration of ', aDescriptor printString, ' in ', self printString)]</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printTime:for:">printTime: aTimeString for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form 10:20:23."	aTimeString isNil ifTrue: [^'NULL'].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aTimeString class = Time ifTrue: [self error: 'SQLite does not support time types;  this should have been a String'].	^aTimeString printString</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printDate:for:">printDate: aDateString for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form '1959-09-30'."	aDateString isNil ifTrue: [^'NULL'].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aDateString class = Date ifTrue: [self error: 'SQLite does not support date types;  this should have been a String'].	^aDateString printString</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	| targetClassModel |	super validate.	(self collectionType = GlorpCursoredStream and: [self shouldUseFilteredRead]) ifTrue: [self error: 'Filtered mappings can cause duplicates and so cannot return cursors'].	(shouldWriteTheOrderField and: [orderBy isNil]) ifTrue: [self error: 'Mapping tries to write the collection order to a field, but has no order by field specified'].	(shouldWriteTheOrderField &amp; usesLinkTable)		ifTrue: [ | targetTable |			targetTable := (self linkTableJoin allTargetFields collect: [:each | each table]) first.			targetTable primaryKeyFields isEmpty ifTrue: [self error: 'A mapping with a link table and which writes the order field must define primary key fields and must not include the order field as a primary key']].		orderBy isNil ifTrue: [^self].	targetClassModel := self system classModelFor: attribute type.	"Note that this will only validate when the orderBy is a symbol - not a block, expression, or field"	orderBy do: [:attributeName |		attributeName isSymbol ifTrue: [			(targetClassModel hasAttributeNamed: attributeName) ifFalse: [				self error: attribute printString, ' is attempting to order by #', attributeName, ' which is not a mapped attribute of ', targetClassModel describedClass name]]].</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	"Since tableSelectCommand was never nilled, a second pundle version reusing this sequence used to get an SQL string embedding the first's integer value.  If it was a version of a different pundle, its integer probably differed;  when a call to reserve e.g. 1233 returns a maximum got by reusing the prior version's call to reserve e.g. 85, the result is 1148 duplicate keys.  If #insertOnly was set,  replication failed on an illegal command.  If we reached one of the fix-up states where it was not, then our cache assured us we were updating and we happily overwrote e.g. the blob for a class definition with that for a method definition (as I experienced :-/).  As sequences are set in the descriptor system and reused, this persisted until the session was discarded or its system was revised.  We now check the integer."	| stream useBinding |	"Binding into this doesn't seem to work"	useBinding := false.	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:		[stream := WriteStream on: (String new: 200).		stream nextPutAll: 'select gen_id('.		stream nextPutAll: self qualifiedName.		stream nextPut: $,.		stream nextPutAll: (useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).		stream nextPutAll: ') from rdb$database'.		tableSelectCommand := SQLStringSelectCommand new.		tableSelectCommand parameters: (Array with: anInteger).		tableSelectCommand setSQLString: stream contents.		tableSelectCommand session: aSession].	^tableSelectCommand</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>validation</category><body package="GlorpMappings" selector="noTableInitializerFound:">noTableInitializerFound: aDatabaseTable	self error: 'No table initializer found for ', aDatabaseTable printString.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>validation</category><body package="GlorpMappings" selector="noDescriptorInitializerFound:">noDescriptorInitializerFound: aDescriptor	self error: 'No descriptor initializer found for ', aDescriptor printString.</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="typeString">typeString		^self typeName,   ( width ifNil: [''] ifNotNil: [ :w |'(', w printString, ')'])</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="validate">validate	self mappingFromMeOrSubclasses isNil ifTrue: [self error: 'no mapping for ', self printString].</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	aStream		print: base;		nextPut: $.;		nextPutAll: (name isString ifTrue: [name] ifFalse: [name printString])</body></methods><methods><class-id>Glorp.MultipleMappingsForInstanceVariable</class-id> <category>accessing</category><body package="GlorpMisc" selector="messageText">messageText	^'Multiple readable mappings for one instance variable:&lt;1s&gt;' expandMacrosWith: self readableMappings  printString</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>debugging</category><body package="GlorpQueries" selector="basicPrintString">basicPrintString	^self printString.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>debugging</category><body package="GlorpQueries" selector="printOn:">printOn: aStream	aStream nextPutAll: self printString.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>converting</category><body package="GlorpMappings" selector="asGlorpExpressionOn:">asGlorpExpressionOn: anExpression	"If we're being converted into an expression, that means we're a subselect inside an expression block. We don't actually have any relationship to anExpression, so create our own base and make a pseudo-mapping with no join to describe the relationship. Don't even give it a string-name, just use ourselves as the key"		| expression localBase phantomMapping phantomExpression |	phantomMapping := OneToOneMapping new		referenceClass: self resultClass;		attributeName: #temporaryAttributeFromSubselect;		join: Join new;		descriptor: (anExpression system descriptorFor: self resultClass).	phantomExpression := anExpression getMapping: phantomMapping named: self.	expression := GeneralSubSelectExpression 		basedOn: phantomExpression.	expression query: self.	localBase := SubSelectBaseExpression on: phantomExpression.	self baseExpression: localBase.	self tablePrefix: ('s', anExpression ultimateBaseExpression availableSubSelectNumber printString, 't').	^expression.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>fields</category><body package="GlorpExpressions" selector="findFieldNamed:">findFieldNamed: aString	| fields |	fields := OrderedCollection new: 1.	self tables do: [:each |		| field |		field := each fieldNamed: aString ifAbsent: [nil].		field isNil ifFalse: [fields add: field]].	fields isEmpty ifTrue: [self error: 'No field named ', aString, ' in ', self printString].	fields size &gt; 1 ifTrue: [self error: 'Ambiguous field ', aString, ' in ', self printString].	^fields at: 1.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="assignTableAliasesStartingAt:prefix:">assignTableAliasesStartingAt: anInteger prefix: aString	| tableNumber prefix |	self controlsTables ifFalse: [^anInteger].	self hasTableAliases ifTrue: [^anInteger].	tableNumber := anInteger.	prefix := aString isNil ifTrue: ['t'] ifFalse: [aString].	self tables		do:			[:each | 			self aliasTable: each to: prefix , tableNumber printString.			tableNumber := tableNumber + 1].	^tableNumber.</body></methods><methods><class-id>Text2.FlowLine</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayLineNumberOn:">displayLineNumberOn: aGraphicsContext	"Draw the line number of the line to the left of its margin."	| lineNumberString lineNumberWidth |	(aGraphicsContext clientDataAt: #showLineNumbers ifAbsent: [false]) ifFalse: [^self].	(aGraphicsContext clientDataAt: #showLineNumbersStyle ifAbsent: [^self]) installOn: aGraphicsContext.	lineNumberString := number printString.	lineNumberWidth := (lineNumberString measureWithFont: aGraphicsContext font from: 1 to: lineNumberString size) x.	aGraphicsContext displayString: lineNumberString at: (-5 - lineNumberWidth) @ baseline</body></methods><methods><class-id>Text2.DocumentListItem class</class-id> <category>private</category><body package="Graphics-Text2-Document" selector="remapBase10:with:">remapBase10: anInteger with: base10characters	^anInteger printString collect: [:character | (base10characters at: character codePoint - $0 codePoint + 1) asCharacter]</body></methods><methods><class-id>Text2.DocumentListItem class</class-id> <category>types - numeric</category><body package="Graphics-Text2-Document" selector="decimal">decimal	&lt;type&gt;	^[:number | number printString]</body></methods><methods><class-id>Text2.Flow</class-id> <category>private - lines</category><body package="Graphics-Text2-Flow" selector="validate">validate	"Debugging: Determine if the internal structures have become inconsistent. By default this is disabled, but if something isn't working properly, it might help to enable it."	| debug |	debug := false.	debug ifFalse: [^self].	(linesByNumber allButLast: 1) with: (linesByNumber allButFirst: 1) do: [:a :b |		a stop &lt;= b start ifFalse: [self error: 'contiguity of lines lost'].		a bottom = b top ifFalse: [self error: 'lines not touching?'].		a bottom &lt;= b top ifFalse: [self error: 'overlapping lines?']].	linesByNumber keysAndValuesDo: [:index :line |		| paragraphLinesNode paragraphLines |		line height &gt; 0 ifFalse: [self error: 'line ', index printString, ' has no height'].		paragraphLinesNode := self lineNodesByParagraphStart: line start ifAbsent: [self error: 'lineNodesByParagraphStart ', index printString, ' is inconsistent'].		paragraphLinesNode value isSequenceable			ifTrue: [paragraphLines := paragraphLinesNode value]			ifFalse: [paragraphLines := Array with: paragraphLinesNode value].		paragraphLines detect: [:each | each start = line start] ifNone: [self error: 'lineNodesByParagraphStart ', index printString, ' is inconsistent'].		linesByTop at: line top ifAbsent: [self error: 'linesByTop ', index printString, ' is inconsistent'].		linesByWidth at: line width ceiling ifAbsent: [self error: 'linesByWidth ', index printString, ' is inconsistent']]</body></methods><methods><class-id>Kernel.CodeReader class</class-id> <category>private</category><body package="System-Code Storage" selector="checkFormatOf:against:">checkFormatOf: aBehavior against: storedFormat	"Check that the stored format for aBehavior is compatible with its current format."	| ignoredMask |	ignoredMask := FixedFieldsMask + WeakMask + EphemeronMask.	((storedFormat bitXor: aBehavior format) bitOr: ignoredMask) = ignoredMask ifFalse:		[self invalidClassFormatSignal			raiseWith: aBehavior fullName			errorString: ' : ', aBehavior printString]</body></methods><methods><class-id>Kernel.CodeReader class</class-id> <category>private</category><body package="System-Code Storage" selector="checkFormatOf:against:inParcel:">checkFormatOf: aBehavior against: storedFormat inParcel: parcelName	"Check that the stored format for aBehavior is compatible with its current format."	| ignoredMask |	ignoredMask := FixedFieldsMask + WeakMask + EphemeronMask.	((storedFormat bitXor: aBehavior format) bitOr: ignoredMask) = ignoredMask ifFalse:		[self invalidClassFormatSignal			raiseWith: aBehavior fullName			errorString: ((#incompatible2s1sClassFormatForSystem &lt;&lt; #dialogs &gt;&gt; 'While Loading Parcel &lt;2s&gt;, the format of the class &lt;1s&gt; was found to be incompatible with its format in the system.')				expandMacrosWith: aBehavior printString				with: parcelName)]</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="Store-Image Objects" selector="textRepresentationDataAt:">textRepresentationDataAt: aDataKey	"Answer text for aDataKey"		^(self definitionOf: aDataKey ifAbsent: [^(#twoStarUnresolvedTwoStar &lt;&lt; #store &gt;&gt; '**Unresolved**') asText]) printString asText</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>actions</category><body package="Kernel-Support" selector="reorganize:on:">reorganize: object on: aStream	aStream cr; cr; nextChunkPut:				object storeString ,				' reorganizeFromString: ' ,				object organization printString storeString</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>actions</category><body package="Kernel-Support" selector="reorganizeNameSpace:on:">reorganizeNameSpace: object on: aStream	aStream cr; cr; nextChunkPut:				object storeString ,				' asNameSpace reorganizeFromString: ' ,				object asNameSpace organization printString storeString</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>actions</category><body package="Kernel-Support" selector="timeStamp:">timeStamp: aStream	| tempStream |	tempStream := WriteStream on: (String new: 16).	SystemUtils timeStamp: tempStream.	aStream nextChunkPut: tempStream contents printString.	"double quotes and !s"	aStream cr</body></methods><methods><class-id>Kernel.NameSpaceOrganizer</class-id> <category>accessing</category><body package="System-Name Spaces" selector="changeFromString:">changeFromString: aString 	"Parse the string and make this be the receiver's structure.  Categories	or elements not found are not affected.  New elements are ignored."	| scanner newCat bind |	self environment checkInstalled.	scanner := Compiler preferredParserClass new scanTokens: aString.	scanner do: [:cat |		newCat := (cat at: 1) asSymbol.		2 to: cat size do: [:i |			bind := self environment bindingFor: (cat at: i).			bind == nil ifFalse: [bind category: newCat]]].	SourceFileManager default logChange:					self environment namedReferent fullName,					' asNameSpace reorganizeFromString: ',					self printString storeString.</body></methods><methods><class-id>Kernel.NameSpaceOrganizer class</class-id> <category>class initialization</category><body package="System-Name Spaces" selector="initializeSmalltalk">initializeSmalltalk	"NameSpaceOrganizer initializeSmalltalk"	| org |	org := self new.	org environment: Smalltalk.	org changeFromString: Smalltalk organization printString.	Smalltalk organization: org</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>initialize-release</category><body package="System-Compiler-Names and Scopes" selector="generateNames:">generateNames: count	"Generate a collection of unique temporary names,	but do not bind them.  The client is responsible for	calling addTemporaries: to actually bind the variables.	Note that the names generated here are not	syntactically legal: this is deliberate, so they can be	hidden by the debugger."	| name index |	index := variables size.	^(1 to: count) collect:		[:i |		[index := index + 1.		name := '.t', nesting printString, 'i', index printString.		(self variableAt: name from: nil) notNil]			whileTrue.		name]</body></methods><methods><class-id>Kernel.AbsentClassImport</class-id> <category>printing</category><body package="System-Code Storage" selector="convertToXML">convertToXML		| driver |	driver := XML.DOM_SAXDriver new.	driver		startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: self name asString.	self sax: driver tag: 'environment' value: self name asQualifiedReference environment fullName.	self sax: driver tag: 'super' value: Object fullName.	self sax: driver tag: 'private' value: false printString.	self sax: driver tag: 'indexed-type' value: (self class behaviorTypeForFormat: format) asString.	self sax: driver tag: 'inst-vars' value: self instVarNames.	self sax: driver tag: 'class-inst-vars' value: ''.	self sax: driver tag: 'imports' value: '' asString.	self sax: driver tag: 'category' value: 'As yet unclassified' asString.	driver		endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>file-in/out</category><body package="System-Name Spaces" selector="xmlDefinition:onto:">xmlDefinition: anXMLFormatter onto: aStream	self binding isForGeneral		ifFalse: [^self value				xmlDefinition: anXMLFormatter				onto: aStream].	^anXMLFormatter		on: aStream tag: 'shared-variable' do: [:xml :str |			xml on: str cr tag: 'name' value: self simpleName.			xml on: str cr tag: 'environment' value: self environment fullName.			xml on: str cr tag: 'private' value: self binding isPrivate printString.			xml on: str cr tag: 'constant' value: self binding isConstant printString.			xml on: str cr tag: 'category' value: (self environment asNameSpace organization categoryOfItem: self simpleName).			self binding sourceCode == nil				ifFalse: [xml on: str cr tag: 'initializer' value: self binding sourceCode].			str cr]</body></methods><methods><class-id>Kernel.CodeComponent class</class-id> <category>signal handlers</category><body package="System-Code Components" selector="handleCodeReaderSignalsDo:for:">handleCodeReaderSignalsDo: aBlock for: componentSource	"Catch signals from CodeReader and reraise them as Parcel signals"	|  acceptAbsentClassImports componentName |	componentName := componentSource asString.	acceptAbsentClassImports := false.	^aBlock		on: CodeReader codeReaderSignal		do: [:ex |			ex creator = CodeReader prerequisiteSignal ifTrue:				[ex resume: (self handlePrerequisite: ex parameter)].			ex creator = CodeReader fileFormatSignal ifTrue:				[self fileFormatSignal					raiseWith: componentName 					errorString: ((#errParcelOnFile &lt;&lt; #dialogs &gt;&gt; ' on file : &lt;1s&gt;') expandMacrosWith: componentName )].			ex creator = CodeReader missingNamespaceSignal ifTrue:				[self missingNamespaceSignal					raiseWith: (Array with: ex parameter with: componentName)					errorString: ((#parcelRequiresNamespace &lt;&lt; #dialogs &gt;&gt; 'Parcel requires namespace ''&lt;1s&gt;'' to be present in the image.') expandMacrosWith: ex parameter)].			ex creator = CodeReader classAlreadyLoadedSignal ifTrue:				[self classAlreadyLoadedSignal					raiseWith: (Array with: ex parameter with: componentName )					errorString: ((#errParcelFromFile &lt;&lt; #dialogs &gt;&gt; ' : &lt;1s&gt;  from file : &lt;2s&gt;') expandMacrosWith: ex parameter with: componentName )].			ex creator = CodeReader dependentClassSignal ifTrue:				[acceptAbsentClassImports ifFalse:					[CodeReader requestWarningSuppressionSignal raiseRequest == true ifTrue:						[acceptAbsentClassImports := true]].				acceptAbsentClassImports ifTrue:					[Transcript cr; show: ((#codeInAnotherParcel2 &lt;&lt; #dialogs &gt;&gt; 'Extended class &lt;1s&gt; does not exist; extensions will be installed when the class is loaded.') expandMacrosWith: ex parameter)].				ex resume: true].			ex creator = CodeReader invalidClassFormatSignal ifTrue:				[self invalidClassFormatSignal					raiseWith: (Array with: ex parameter with: componentName )					errorString: ((#incompatible2s1sClassFormatForSystem &lt;&lt; #dialogs &gt;&gt; 'While Loading Parcel &lt;2s&gt;, the format of the class &lt;1s&gt; was found to be incompatible with its format in the system.') 						expandMacrosWith: ex parameter printString						with: componentName )].			ex creator = CodeReader noSourceFileSignal ifTrue:				[self handleNoSourceSignal: ex name: componentName].			ex creator = CodeReader actionFailedSignal ifTrue:				[self abortLoadingSignal					raiseWith: (Array with: nil with: componentName )					errorString: ((#errLoadActionFailed &lt;&lt; #dialogs &gt;&gt; 'Load action failed  : &lt;1s&gt;  from file : &lt;2s&gt;') expandMacrosWith: ex parameter with: componentName )].			"The CodeReader raised a signal we don't know about"			self error: (#unknownError &lt;&lt; #dialogs &gt;&gt; 'Unknown error').			]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>utilities</category><body package="Kernel-Support" selector="condenseFile:">condenseFile: index	"Move all the changes onto a compacted sources file.	Because this gets the changes file out of synch with any stored image	file, the user is asked whether to snapshot now."		"SourceFileManager default condenseFile: 2."	| changesFile new home newFile |	(changesFile := names at: index) == nil		ifTrue:	[^self].	self backup: changesFile withExtension: Filename backupExtension.	new := self class new.	home := changesFile head asFilename.	newFile := home construct:			(OSHandle currentProcessID printString, Filename changeExtension).	new file: index name: newFile writable: true.	new target: index.	new timeStamp.	new copyAllMessagesResidingOn: index.	self close: index.	ExternalStream closeOpenStreamsNamed: changesFile.	changesFile delete.	newFile renameTo: changesFile.	self file: index name: changesFile writable: changesFile isWritable</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>private - invalid source files</category><body package="Kernel-Support" selector="printInvalidFileOn:withFileIndex:">printInvalidFileOn: textStreamwithFileIndex: fileIndex	| fileName longForm |	textStream cr; crtab; emphasis: #large.	textStream nextPutAll: 'SourceFileManager default '.	fileName := (names at: fileIndex) asLogicalFileSpecification.	(fileIndex == self changesIndex and: [fileName exists and: [fileName isWritable]])		ifTrue:			[				textStream crtab: 3; nextPutAll: 'changesFileName: '.				longForm := false			]		ifFalse:			[				(fileIndex == self sourcesIndex and: [fileName exists and: [fileName isWritable not]])					ifTrue:						[							textStream crtab: 3; nextPutAll: 'sourcesFileName: '.							longForm := false						]					ifFalse:						[							textStream nextPutAll: 'file: ',fileIndex printString.							textStream crtab: 3; nextPutAll: 'name: '.							longForm := true						]			].	textStream emphasis: #(#large #bold).	textStream store: (self nameStringAt: fileIndex); emphasis: #large.	longForm ifTrue:		[			textStream crtab: 3; nextPutAll: 'writable: '.			textStream print: (fileName exists and: [fileName isWritable])		].	textStream cr; cr</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="Kernel-Support" selector="fileOutMessages:for:logging:">fileOutMessages: aSet for: aClass logging: logging	"File a description of the messages of aClass whose selectors are in aSet onto the	target file.  If updateSourcePointers is true, then set the methods' sourcePointers in	order to indicate where to find the source code."	| org sels |	(org := aClass organization) categories do: 		[:cat | 		sels := (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels size &gt; 0			ifTrue: 				[logging ifTrue: [Transcript cr; show: aClass printString , '&gt;' , cat].				self printCategoryChunk: cat for: aClass.				sels do: [:sel | self printMethodChunk: sel for: aClass].				self closeMethodGroup]]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>utilities</category><body package="Kernel-Support" selector="copyChangesTo:">copyChangesTo: newFileName	"If the file name supplied is different than the current changes 	file name, copy the changes file and install the new copy as the 	changes file."	| oldFile newFile |	(oldFile := self nameAt: currentTarget) == nil ifTrue: [^self].	(newFile := newFileName asFilename asAbsoluteFilename) = oldFile asAbsoluteFilename ifFalse: 		[self close: currentTarget.		oldFile exists ifTrue:			[Transcript cr; show: ((#copyingChanges &lt;&lt; #dialogs &gt;&gt; 'Copying &lt;1s&gt;  to &lt;2s&gt;...') expandMacrosWith: oldFile asString with: newFile asString).			Cursor write showWhile:				[| tempName tempFile |				tempName := OSHandle currentProcessID printString,									Filename changeExtension.				tempFile := newFile directory construct: tempName.				tempFile exists ifTrue: [tempFile delete].				oldFile copyTo: tempFile.				tempFile setWritable: true.				[newFile delete]					on: OSErrorHolder nonexistentSignal					do: 						[:ex | ex return].				tempFile renameTo: newFile].			Transcript show: (#copyDone &lt;&lt; #dialogs &gt;&gt; ' done') asString; cr].		self file: currentTarget name: newFile writable: true]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="PackageCategories" selector="fileOutData:for:logging:">fileOutData: aSet for: aNameSpace logging: logging 	"File a description of the data of aNameSpace whose keys are in aSet onto the	target file."	aSet do: 			[:key | 			(aNameSpace asNameSpace includesKey: key) 				ifTrue: 					[self storeObjectDefinition: (aNameSpace asNameSpace 								fullyQualifiedReferenceOf: key).					logging 						ifTrue: 							[Transcript								cr;								show: aNameSpace printString;								show: '.';								show: key]]				ifFalse: 					[Dialog 						warn: ((#_1p2sIsNotDefined &lt;&lt; #store &gt;&gt; '&lt;1p&gt;.&lt;2s&gt; is not defined.') expandMacrosWith: aNameSpace with: key)]]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="Kernel-Support" selector="fileOutOverriddenMethod:for:logging:">fileOutOverriddenMethod: anOverriddenMethod for: aClass logging: logging	"File a description of the method in &lt;anOverriddenMethod&gt; of &lt;aClass&gt; into the	target file.  If updateSourcePointers is true, then set the methods' sourcePointers in	order to indicate where to find the source code."	|protocol|	protocol := anOverriddenMethod protocol.	logging ifTrue: [Transcript cr; show: aClass printString , '&gt;' , protocol].	self printCategoryChunk: protocol for: aClass.	self printOverriddenMethodChunk: anOverriddenMethod for: aClass.	self closeMethodGroup</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="Kernel-Support" selector="fileOutSharedVariables:for:logging:">fileOutSharedVariables: aSet for: aClassOrNamespace logging: logging	"File a description of the shared variables of aClassOrNamespace whose selectors	 are in aSet onto the target file."	| org sels |	(org := aClassOrNamespace asNameSpace organization) categories do: 		[:cat | 		sels := (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels notEmpty ifTrue: 			[logging ifTrue: [Transcript cr; show: aClassOrNamespace printString , '&gt;' , cat].			sels do: [:sel| self storeObjectDefinition: (aClassOrNamespace asNameSpace fullyQualifiedReferenceOf: sel)]]]</body></methods><methods><class-id>Kernel.ChangeSet</class-id> <category>converting</category><body package="System-Changes" selector="asSortedCollection">asSortedCollection	"Answer a new instance of SortedCollection whose elements are Strings describing the changes represented by the receiver."	| summary |	summary := SortedCollection forStrings.	self objectChanges keysAndValuesDo: 		[:clName :chGrp | 		chGrp changes do: 			[:changeType | summary add: clName, ' - ', changeType].		chGrp methodChanges keysAndValuesDo: 			[:mSel :mChange | summary add: clName, ' ', mSel, ' - ', mChange]].	self objectRemoves keysAndValuesDo:		[:name :type | summary add: ((#x1sRemove &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; - remove')			expandMacrosWith: name)].	specialDoIts isEmpty not ifTrue:		[summary add: ((#SpecialDoIts1s &lt;&lt; #dialogs &gt;&gt; 'SpecialDoIts - (&lt;1s&gt;)')			expandMacrosWith: specialDoIts size printString)].	self componentChangesDo: 		[ :change | summary addChange: change description ].	^summary</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>fileout</category><body package="System-Overrides" selector="convertToXML">convertToXML	| driver |	driver := XML.DOM_SAXDriver new.	driver startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: self name asString.	self sax: driver tag: 'environment' value: self environment fullName.	self sax: driver tag: 'super' value: ( self argumentForKeyWord: 'superclass'  ) fullName.	self sax: driver tag: 'private' value: ( self argumentForKeyWord: 'private' ) printString.	self sax: driver tag: 'indexed-type' value: ( self argumentForKeyWord: 'indexedType' ) asString.	self sax: driver tag: 'inst-vars' value: ( self argumentForKeyWord: 'instanceVariableNames' ).	self sax: driver tag: 'class-inst-vars' value: ( self argumentForKeyWord: 'classInstanceVariableNames' ).	self sax: driver tag: 'imports' value: ( self argumentForKeyWord: 'imports' ) asString.	self sax: driver tag: 'category' value: ( self argumentForKeyWord: 'category' ) asString.	( self argumentForKeyWord: 'attributes' ) == nil 		ifFalse:			[ driver startElement: 'attributes' atts: nil.			( self argumentForKeyWord: 'attributes' ) do: 				[ :attr |				( attr last isKindOf: Array )					ifTrue:						[ driver startElement: attr first atts: nil.						attr last do: [ :s | self sax: driver tag: 'item' value: s ].						driver endElement						]					ifFalse: [ self sax: driver tag: attr first value: attr last displayString ]				].			driver endElement			].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Kernel.SystemOrganizer</class-id> <category>accessing</category><body package="Kernel-Support" selector="changeFromString:">changeFromString: aString	"Intercept to notify the system change set of the system reorganization."	self environment checkInstalled.	super changeFromString: aString.	SourceFileManager default logChange:					self environment namedReferent fullName,					' asNameSpace reorganizeFromString: ',					self printString storeString.</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>storage</category><body package="System-Code Storage" selector="storeStringCollection:">storeStringCollection: anArrayOfStringsOrSymbols		anArrayOfStringsOrSymbols isNil		ifTrue: [stream storeLength: 0]		ifFalse:			[stream storeLength: anArrayOfStringsOrSymbols size.			anArrayOfStringsOrSymbols do: [:each | stream storeString: (each isSymbol ifTrue: [each printString] ifFalse: [each])]]</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>private</category><body package="System-Code Storage" selector="createTemporaryStreamsFor:and:">createTemporaryStreamsFor: parcelFileName and: sourceFilenameOrNil	| destDir tempParcelName tempSourceName |	destDir := parcelFileName asLogicalFileSpecification head asFilename.	tempParcelName := 't', OSHandle currentProcessID printString.	tempSourceName := destDir constructString: tempParcelName, Parcel sourceExtension.	self checkWritabilityOfAll: (Array with: parcelFileName with: sourceFilenameOrNil with: tempSourceName)		errorMessage: (#cantWriteFiles &lt;&lt; #dialogs &gt;&gt; 'can''t write files').	self deleteIfExists: tempSourceName.	stream := InternalCodeWriterStream on: (BinaryStorageBytes new: 0).	sourceFilenameOrNil notNil ifTrue:		[self createSourceStreamFromFileNamed: tempSourceName].</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>private storage</category><body package="System-Code Storage" selector="storeSourceHeader">storeSourceHeader	"Store human-readable header information to the Parcel's source file.	 Arrange that the first two fields in the header are the Parcel's name	 followed by its notice (if any)."	| s |	sourceStream isNil ifTrue: [^self].	s := (String new: 1024) writeStream.	(properties keys asSortedCollection asOrderedCollection		remove: #postUnloadBlock ifAbsent: nil;		remove: #preLoadBlock ifAbsent: nil;		remove: #postLoadBlock ifAbsent: nil;		remove: #preUnloadBlock ifAbsent: nil;		remove: #preSaveBlock ifAbsent: nil;		remove: #loadOrderedClasses ifAbsent: nil;		remove: #timestamp ifAbsent: nil;		remove: #notice ifAbsent: nil;		remove: #recompile ifAbsent: nil;		remove: #name;		addFirst: #notice;		addFirst: #name;		yourself) do:		[:key| | value |		(properties includesKey: key) ifTrue:			[value := properties at: key.			value isString ifFalse: [value := value printString].			s	cr;				nextPut: key first asUppercase;				nextPutAll: (key copyFrom: 2 to: key size);				nextPut: $:;				space;				nextPutAll: value]].	Parcel binaryActions do:		[:key| | label |		(properties at: key ifAbsent: nil) notNil ifTrue:			[label := key asString.			 label at: 1 put: label first asUppercase.			 s cr.			1 to: key size do:				[:i| "Map e.g. #preLoadBlock to 'Pre-load block', etc"				i = 1					ifTrue: [s nextPut: (key at: i) asUppercase]					ifFalse:						[(key at: i) isUppercase ifTrue:							[s nextPut: (i &lt;= 5 ifTrue: [$-] ifFalse: [$ ])].						s nextPut: (key at: i)]].			s nextPutAll: ': '; crtab.			s nextPutAll: ((CodeComponent stringFromAction: (properties at: key))							copyReplaceAll: '"' with: '''''')]].	s	cr; nextPutAll: (#DateC &lt;&lt; #dialogs &gt;&gt; 'Date: ') asString; nextPutAll: timeString; space; nextPutAll: dateString.	s	cr.	sourceStream addComment: s contents.	sourceStream timeStamp.	sourceStream storeExpression: '(Dialog confirm: ''You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?'' withCRs) ifFalse: [self error: ''Parcel file-in abandoned.  Choose terminate or close.'']'.</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>private</category><body package="System-Code Storage" selector="computePrerequisites">computePrerequisites	"We compute the prerequisites array here because its logically part of the header.	 The number of prerequisite strings _is_ stored in the header, but the strings themselves	 get written immediately following. i.e. the prerequisite strings do not contribute to the	 header size.  This is all backwards-compatibility nonsense; we beseech your indulgence."	| s prereqs comment bytes tempStr |	s := Array new writeStream.	#(preReadBlock versionSelectionBlock warningSuppressionBlock) do:		[:actionBlockName | | actionBlockString |		actionBlockString := properties at: actionBlockName ifAbsent: nil.		nil ~~ actionBlockString ifTrue:			[s				nextPut: actionBlockName asString;				nextPut: actionBlockString;				nextPut: '']].	prereqs := properties at: #prerequisiteParcels ifAbsent: nil.	nil ~~ prereqs ifTrue:		[prereqs do:			[:parcelNameStringVersionNumberPair|			s				nextPut: 'parcel';				nextPut: parcelNameStringVersionNumberPair first;				nextPut: parcelNameStringVersionNumberPair last]].	nil ~~ (comment := properties at: #comment ifAbsent: nil) ifTrue:		[s			nextPut: 'comment';			nextPut: comment;			nextPut: ''].	s		nextPut: 'space';		nextPut: analysisTracer numberOfObjects printString;		nextPut: (bytes := analysisTracer numberOfBytes) printString.	prerequisites := s contents.	stream likelyLength: (bytes / 1.1) asInteger.	tempStr := (String new: 32) writeStream.	(Locale named: #C) timePolicy print: Date today on: tempStr.	dateString := tempStr contents.	tempStr reset.	(Locale named: #C) timePolicy print: Time now on: tempStr.	timeString := tempStr contents.	"Here's some code to estimate the scale factor for stream size"	"| d |	d := Dictionary new.	[Parcel setFileCachesTo: [Dictionary new].	Parcel searchPathModel value do:		[:dir|		Parcel cachedParcelFileInfoIn: dir for: nil do:			[:info :fileName| | len space |			len := fileName asFilename fileSize asFloat.			space := info at: #space.			(d includesKey: (info at: #parcel)) ifFalse:				[d					at: (info at: #parcel)					put: (Array							with: len asInteger							with: (Integer readFrom: space first readStream) / len							with: (Integer readFrom: space last readStream) / len)]]]]		ensure: [Parcel setFileCachesTo: [nil]].	d"</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>fileIn/Out</category><body package="System-Support" selector="timeStamp:">timeStamp: aStream 	"Write the system version and current time on stream aStream."	| dateTime |	dateTime := Time dateAndTimeNow.	aStream nextPutAll: ((#From1sOn2sAt3s &lt;&lt; #dialogs &gt;&gt; 'From &lt;1s&gt; on &lt;2s&gt; at &lt;3s&gt;')			expandMacrosWith: self version			with: (dateTime at: 1) printString			with: (dateTime at: 2) printString)</body></methods><methods><class-id>Kernel.Override</class-id> <category>printing</category><body package="System-Overrides" selector="text">text	"Answers a string that represents the definition."	| stream tokens tokenStream |	stream := ( String new: 100 ) writeStream.	tokens := definition selector tokensBasedOn: $:.	tokens removeLast.		"Removes trailing empty string"	stream nextPutAll: definition receiver unambiguousName; space.	tokenStream := tokens readStream.	definition arguments 		do: 			[:arg|			stream 				nextPutAll: tokenStream next;				nextPutAll: ': ';				nextPutAll: arg printString]		separatedBy: 			[stream cr;tab].	^stream contents</body></methods><methods><class-id>Kernel.CompiledMethod class</class-id> <category>instance creation</category><body package="Kernel-Methods" selector="withPrimitive:numArgs:ifFail:">withPrimitive: index numArgs: numArgs ifFail: failBlock	" Answer a CompiledMethod that invokes the given primitive.	If the primitive fails, the method evaluates failBlock,	with the primitive error code as the argument. "	" Ordinarily we would do this using the compiler's code generator,	but we want it to work even in a system with no compiler.	The code isn't the most efficient possible, but it works. "	^AssemblerCodeStream new		class: Object;		forMethod: ((1 to: numArgs) collect: [:i | 't',i printString]);		addTemporaries: #('_err');		methodPrimitive: index;		storePopLocal: '_err';		pushConstant: failBlock;		pushLocal: '_err';		send: #value: numArgs: 1;		putLocalReturn;		generateMethod</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>accessing</category><body package="Kernel-Processes" selector="highestPriority:">highestPriority: newHighestPriority	"Change the number of priority levels currently available for use."	| newProcessLists |	(quiescentProcessLists size &gt; newHighestPriority		and: [self anyProcessesAbove: newHighestPriority])			ifTrue: [self error: ((#ProcessPrioritiesTooHigh &lt;&lt; #dialogs &gt;&gt; 'There are processes with priority higher than &lt;1s&gt;')			expandMacrosWith: newHighestPriority printString)].	newProcessLists := Array new: newHighestPriority.	1 to: ((quiescentProcessLists size) min: (newProcessLists size)) do: 		[:priority | newProcessLists at: priority put: (quiescentProcessLists at: priority)].	quiescentProcessLists size to: newProcessLists size do: 		[:priority | newProcessLists at: priority put: LinkedList new].	quiescentProcessLists become: newProcessLists</body></methods><methods><class-id>Kernel.ClassCategoryReader</class-id> <category>fileIn/Out</category><body package="Kernel-Support" selector="scanFrom:using:">scanFrom: aStream using: aFormatter	"Files in methods from the stream, aStream.  Prints the name and	category of the methods in the transcript view."	| string |	Transcript cr; nextPutAll: class printString; nextPut: $&lt;; nextPutAll: category; endEntry.	[string := aFormatter methodBodyFrom: aStream.	string size &gt; 0]						"done when double terminators"		whileTrue: [class compile: string classified: category]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>load/unload</category><body package="System-Code Components" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Parcel createParcelNamed: ', self name printString, ' ) '.</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>printing</category><body package="System-Code Components" selector="putStatsOn:">putStatsOn: stream 	"Write a human-readable description of all the code in the receiver, including uninstalled code."	| added extended uninstalled prereqs |	self isEmpty ifTrue: [stream nextPutAll: (#anEmptyParcel &lt;&lt; #dialogs &gt;&gt; 'an Empty Parcel') asString. ^self].	(added := self definedObjects) isEmpty ifFalse: 		[stream nextPutAll: (#DefinedNameSpacesColon &lt;&lt; #dialogs &gt;&gt; 'Defined NameSpaces:') asString; cr.		(added asSortedCollection: [:ns1 :ns2| ns1 printString &lt; ns2 printString]) do:			[:nameSpace | stream tab; print: nameSpace; cr].		stream cr].	(added := self definedBindings) isEmpty ifFalse: 		[stream nextPutAll: (#DefinedBindingsColon &lt;&lt; #dialogs &gt;&gt; 'Defined Bindings:') asString; cr.		(added keys asSortedCollection: [:ns1 :ns2| ns1 printString &lt; ns2 printString]) do:			[:nameSpace |			(nameSpace isBehavior and: [definedClasses includes: nameSpace]) ifFalse:				[(added at: nameSpace) asSortedCollection do:					[:k|					stream						tab;						nextPutAll: (nameSpace asNameSpace								fullyQualifiedReferenceOf: k								from: Smalltalk) printString;						cr]]].		stream cr].	(added := self definedClasses) isEmpty ifFalse: 		[stream nextPutAll: (#DefinedClassesColon &lt;&lt; #dialogs &gt;&gt; 'Defined classes:') asString; cr.		(added asSortedCollection: [:c1 :c2| c1 printString &lt; c2 printString]) do:			[:class | stream tab; print: class; cr].		stream cr].	(extended := self extendedBehaviors) isEmpty ifFalse:		[stream nextPutAll: (#ExtendedClassesColon &lt;&lt; #dialogs &gt;&gt; 'Extended classes:') asString; cr.		(extended asSortedCollection: [:b1 :b2| b1 printString &lt; b2 printString]) do:			[:b |			stream tab; print: b; cr.			(self definedSelectorsFor: b) asSortedCollection do:				[:selector | stream tab; tab; nextPutAll: selector; cr].			stream cr]].	(uninstalled := properties at: #uninstalledClasses ifAbsent: nil) size &gt; 0 ifTrue:		[stream nextPutAll: (#UninstalledClassesColon &lt;&lt; #dialogs &gt;&gt; 'Uninstalled classes:') asString; cr.		stream emphasis: #italic.		(uninstalled collect: [:ea| ea fullName]) asSortedCollection do:			[:className|			stream tab; nextPutAll: className; cr].		stream emphasis: nil; cr].	(uninstalled := properties at: #uninstalledMethods ifAbsent: nil) size = 0 ifFalse:		[stream nextPutAll: (#UninstalledMethodsColon &lt;&lt; #dialogs &gt;&gt; 'Uninstalled methods:') asString; cr.		stream emphasis: #italic.		uninstalled asSortedCollection do:			[:mir| stream tab; print: mir; cr].			stream emphasis: nil].	(uninstalled := properties at: #uninstalledBindings ifAbsent: nil) size = 0 ifFalse:		[stream nextPutAll: (#UninstalledSharedVariablesColon &lt;&lt; #dialogs &gt;&gt; 'Uninstalled shared variables:') asString; cr.		stream emphasis: #italic.		uninstalled asSortedCollection do:			[:mir| stream tab; print: mir; cr].			stream emphasis: nil].	(prereqs := self prerequisiteParcels) size &gt; 0 ifTrue:		[stream nextPutAll: (#PrerequisiteParcelsColon &lt;&lt; #dialogs &gt;&gt; 'Prerequisite parcels:') asString.		prereqs do:			[:ea|			stream crtab; nextPutAll: (ea at: 1).			(ea at: 2) size &gt; 0 ifTrue: [stream tab; nextPutAll: 'version '; nextPutAll: (ea at: 2)]].		stream cr]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>Refactoring Browser</category><body package="Browser-BrowserUI" selector="textForItem">textForItem	^self printString</body></methods><methods><class-id>Kernel.DefineOpcodePool class</class-id> <category>private-initialization</category><body package="System-Compiler-Support" selector="vw40ExtendedSpecialSelectors">vw40ExtendedSpecialSelectors	"These are the most common selectors	(with at least 20 occurrences)	in the current license image"	^#(		#do: #cr #on: #nextPut: #bounds #x #y #isEmpty		#copyOld #name #with: #at:ifAbsent: #-&gt; #error: #first #bitShift:		#includes: #contents #key #asString #last #extent #componentAt: #printString		#bitAnd: #scaledRed:scaledGreen:scaledBlue: #view #rounded #window #/ #next #paint:		#yourself #space #asSymbol #controller #sensor #max: #height #isKindOf:		#subclassResponsibility #default #with:with: #asValue #collect: #tab #addLast: #print:		#initialize #builder #extent: #width #handle:do: #top #copyFrom:to: #negated		#widget #close #errorSignal #left #displayRectangle: #current #origin #layout		#perform: #asInteger #min: #black #selection #asPointerParameter #bottom #model		#removeLast #list #component #externalAccessFailedWith: #environment #raise #select: #extent:depth:bitsPerPixel:palette:usingBits:		#peekForTypeNoPush: #asFilename #asText #adapt:forAspect:channel: #showWhile: #tab: #organization #displayOn:at:		#primitiveFailed #release #notifierString: #writeStream #menuItemLabeled: #monoMaskPalette #atEnd #selector		#show: #addAll: #aspectAt:put: #nameClass:message: #model: #right #preferredBounds #emphasis:		#bindValue:to: #indexOf: #expected: #keyboard #disable #white #matchAt:put: #invalidate		#scale #replaceFrom:to:with:startingAt: #on:do: #to: #value:value: #fullName #readStream #valueNowOrOnUnwindDo:		#removeDependent: #byteAt: #onChangeSend:to: #asArray #asFloat #changed: #corner: #text		#labeled: #detect:ifNone: #warn: #name: #center #decodeAsLiteralArray #isSymbol #isString		#changed:with: #label: #position #printOn: #wait #\\ #keysAndValuesDo: #asValueReference		#preferenceFor: #includesKey: #abs #return #shouldNotImplement #returnWith: #critical: #list:		#displayBox #species #withCRs #replaceStackTop: #components #foregroundColor #with:with:with: #selection:		#bitOr: #label #parameter #string #lineGrid #backgroundColor #type #withColors:		#separator #palette #hash #graphicsContext #layout: #sender #open #enable		#remove:ifAbsent: #skip: #textStyle #| #scanToken #insetBy: #targetClass #selectionIndexHolder		#changeRequest #byteAt:put: #memberAt:put: #htmlEntity #wrapper #isEnabled #raiseWith: #displayOn:		#addDependent: #bounds: #perform:with: #x: #containsPoint: #preferenceModelFor: #numArgs #keyboardProcessor		#component: #cursorPoint #externalAccessFailedSignal #intersects: #origin:extent: #store: #zero #widgetState		#remove: #extent:depth:palette:bits:pad: #topComponent #memberAt: #fromBytes:	)</body></methods><methods><class-id>Kernel.Change</class-id> <category>file accessing</category><body package="System-Changes" selector="fileName">fileName	"Return the name of the receiver's stream"	^self isInSystem		ifTrue:			[| fileIndex |			(fileIndex := self systemFileIndex) == nil				ifTrue: [(#currentSystem &lt;&lt; #dialogs &gt;&gt; 'current system') asString]				ifFalse: [((#currentSystemFile1s &lt;&lt; #dialogs &gt;&gt; 'current system, source file &lt;1s&gt;')			expandMacrosWith: fileIndex printString)]]		ifFalse:			[| file |			(file := self file) == nil				ifTrue: [(#someLocalStream &lt;&lt; #dialogs &gt;&gt; 'some local stream') asString]				ifFalse: [file displayString]]</body></methods><methods><class-id>Kernel.ClassDefinitionChange</class-id> <category>fileIn/Out</category><body package="System-Changes" selector="xmlDefinition:onto:">xmlDefinition: anXMLFormatter onto: aStream	^anXMLFormatter		on: aStream tag: 'class' do: [:xml :str | | parameters  |			xml on: str cr tag: 'name' value: self shortName.			xml on: str cr tag: 'environment' value: nameSpaceName.			parameters := IdentityDictionary withAll: otherParameters.			parameters at: #superclass: 	ifPresent:[:value | xml on: str cr tag: 'super' value: value asString].			parameters at: #private: ifPresent:[:value | xml on: str cr tag: 'private' value: value printString].			parameters at: #indexedType: ifPresent:[:value | xml on: str cr tag: 'indexed-type' value: value].			parameters at: #instanceVariableNames: ifPresent:[:value | xml on: str cr tag: 'inst-vars' value: value].			parameters at: #classInstanceVariableNames: ifPresent:[:value | xml on: str cr tag: 'class-inst-vars' value: value].			parameters at: #imports: ifPresent:[:value | xml on: str cr tag: 'imports' value: value].			parameters at: #category: ifPresent:[:value | xml on: str cr tag: 'category' value: value].			parameters at: #attributes: ifPresent:[:values | 				xml on: str cr tag: 'attributes' do: [:xml1 :str1 |					values do: [:attr | 						xml1 on: str1 cr tag: attr first encodeLiteral: attr last].						str cr]].			str cr]</body></methods><methods><class-id>Kernel.ClassOtherChange</class-id> <category>accessing</category><body package="System-Changes" selector="systemText">systemText	"Return the system version of either a metaclass definition, a class	 reorganization or a class initialization.  If there is no system version	 of the receiver's class then return nil."	| classOrRef |	^nil ~~ (classOrRef := self targetObject) ifTrue: 		[type == #'class initialize' ifTrue:			[^(classOrRef isBindingReference				ifTrue: [classOrRef printString]				ifFalse: [className]) , ' initialize'].		type == #'class reorganize' ifTrue: [			^className , ' reorganizeFromString: ' ,						classOrRef organization printString storeString].		^classOrRef definition]</body></methods><methods><class-id>Kernel.OtherChange</class-id> <category>accessing</category><body package="System-Changes" selector="text">text	"Answer the text displayed by the receiver."	text == nil ifTrue: [text := super text].	^(type == nil or: [type == #comment])		ifTrue: [text]		ifFalse: [text asString printString]</body></methods><methods><class-id>Kernel.Decompiler</class-id> <category>private</category><body package="System-Compiler-Public Access" selector="expandBoxedTemporaries:">expandBoxedTemporaries: index	| newSlots oldVar |	newSlots := stack last value.   "There needs to be a pop later to get rid of it."	oldVar := localVars first at: index+1.	localVars first at: index+1		put: ((1 to: newSlots) collect: [:n |				builder declareVariableName: oldVar name, '.', n printString]).</body></methods><methods><class-id>Kernel.Decompiler</class-id> <category>private</category><body package="System-Compiler-Public Access" selector="renumber:startingWith:">renumber: list startingWith: savedTC	1 to: list size do:		[:i |		(list at: i) variable name: 't', (savedTC+i) printString].</body></methods><methods><class-id>Kernel.Decompiler</class-id> <category>private-initialize-release</category><body package="System-Compiler-Public Access" selector="newTemps:">newTemps: count	"Generate this many new temp names"	| temp |	^(1 to: count) collect:		[:i |		temp := tempCount value + 1.		tempCount value: temp.		builder declareVariableName: ('t', temp printString)]</body></methods><methods><class-id>Kernel.LiteralNode</class-id> <category>code generation</category><body package="System-Compiler-Program Objects" selector="emitStore:value:from:">emitStore: codeStream value: val from: var 	codeStream		error: ((#x1sIsReadonly &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; is read-only ')			expandMacrosWith: value printString)		from: var.	^self</body></methods><methods><class-id>Kernel.LiteralNode</class-id> <category>code generation</category><body package="System-Compiler-Program Objects" selector="emitStorePop:value:from:">emitStorePop: codeStream value: val from: var 	codeStream		error: ((#x1sIsReadonly &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; is read-only ')			expandMacrosWith: value printString)		from: var.	^self</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>private-initialize-release</category><body package="BOSS" selector="writeHeader">writeHeader	stream nextPutAll: (self headerMagicBytes, self streamFormatNumber printString , ' ') asByteArray.	platformDescription := ByteArray with: (self imageIsBigEndian ifTrue: [16r80] ifFalse: [0]).	stream		nextPut: platformDescription size;		nextPutAll: platformDescription.	initialPosition := stream position</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>actions</category><body package="XML-source" selector="reorganizeNameSpace:on:">reorganizeNameSpace: object on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'reorganize-data' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: object) value: object fullName.		str space.		xml on: str tag: 'organization' value: object organization printString.		str cr]</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="XML-source" selector="component:named:definitionName:meta:selector:change:on:">component: typeSymbol named: name definitionName: aString meta: isMeta selector: aSelector change: aSymbol on: aStream	"Add the addition/removal of a method from a CodeComponent event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component_selector_change' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'definitionName' value: aString.		str space.		xml on: str tag: 'meta' value: isMeta printString.		str space.		xml on: str tag: 'selector' value: aSelector.		str space.		xml on: str tag: 'definitionChange' value: aSymbol.		str cr		]</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>actions</category><body package="XML-source" selector="reorganize:on:">reorganize: object on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'reorganize' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: object) value: object fullName.		str space.		xml on: str tag: 'organization' value: object organization printString.		str cr]</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-simulation</category><body package="Debugger-Support" selector="send:receiver:class:super:numArgs:">send: selector receiver: rcvr class: rclass super: flag numArgs: na	"Don't simulate calls on error:."	(flag | self class doSend or: [self onlySlowSendsForClass: rclass selector: selector])		ifFalse: [^self sendFast: selector receiver: rcvr numArgs: na].	(self isSendLoop and: [(rclass includesBehavior: GenericException) and: [selector == #aboutToDebug]])		ifTrue: [^ContextEmergencyError signalWith: rcvr].	self findMethod: selector		class: rclass		ifFound:			[:meth :mclass |			flag ifTrue: [self pop].  "remove class for super"			^self runMethod: meth numArgs: na contextClass: MethodContext].	self findMethod: #doesNotUnderstand:		class:  (self _objectClass: rcvr)		ifFound:			[:meth :mclass |			| args |			flag ifTrue: [self pop].  "remove class for super"			args := Array new: na.			na to: 1 by: -1 do: [:i | args at: i put: self topPop].			self push: (Message selector: selector arguments: args).			^self runMethod: meth numArgs: 1 contextClass: MethodContext].	self error: ((#MessageNotFoundC1s &lt;&lt; #pdp &gt;&gt; 'Message not found: &lt;1s&gt;')			expandMacrosWith: selector printString).	"To continue, just return the receiver of the message."	flag ifTrue: [self pop].  "remove class for super"	stackp := stackp - na.	self localAt: stackp put: rcvr</body></methods><methods><class-id>Kernel.InstructionClient</class-id> <category>opcodes-undefined</category><body package="Kernel-Methods" selector="undefined:with:">undefined: byte with: x1	self error: ((#UndefinedOpcodeC1s2s &lt;&lt; #dialogs &gt;&gt; 'Undefined opcode: &lt;1s&gt; &lt;2s&gt;')			expandMacrosWith: byte printString			with: x1 printString)</body></methods><methods><class-id>Kernel.InstructionClient</class-id> <category>opcodes-undefined</category><body package="Kernel-Methods" selector="undefined:with:with:">undefined: byte with: x1 with: x2	self error: ((#UndefinedOpcodeC1s2s3s &lt;&lt; #dialogs &gt;&gt; 'Undefined opcode: &lt;1s&gt; &lt;2s&gt; &lt;3s&gt;')			expandMacrosWith: byte printString			with: x1 printString			with: x2 printString)</body></methods><methods><class-id>Kernel.InstructionClient</class-id> <category>opcodes-undefined</category><body package="Kernel-Methods" selector="undefined:">undefined: byte	self error: ((#UndefinedOpcodeC1s &lt;&lt; #dialogs &gt;&gt; 'Undefined opcode: &lt;1s&gt;')			expandMacrosWith: byte printString)</body></methods><methods><class-id>Kernel.SystemError class</class-id> <category>private</category><body package="Kernel-Support" selector="installSystemErrors">installSystemErrors	"Build the set of system errors."	| list |	list := Array new: 100.	list at:  1 put: (self named: #'generic error' parameter: nil).	list at:  2 put: (self named: #'allocation failed' parameter: nil).	list at:  3 put: (self named: #'C allocation failed' parameter: nil).	list at:  4 put: (self named: #'bad argument' parameter: nil).	list at:  5 put: (self named: #'invalid receiver state' parameter: nil).	list at:  6 put: (self named: #'inappropriate operation' parameter: nil).	list at:  7 put: (self named: #'invalid index' parameter: nil).	list at:  8 put: (self named: #'wrong number of arguments' parameter: nil).	list at:  9 put: (self named: #'translator error' parameter: nil).	list at: 10 put: (self named: #'io error' parameter: nil).	list at: 11 put: (self named: #'no match' parameter: nil).	list at: 12 put: (self named: #'threaded api error' parameter: nil).	list at: 13 put: (self named: #'unsupported operation' parameter: nil).	list at: 14 put: (self named: #'bad handle' parameter: nil).	list at: 15 put: (self named: #'no thread for process' parameter: nil).	list at: 16 put: (self named: #'process unattached to thread' parameter: nil).	list at: 17 put: (self named: #'out of threads' parameter: nil).	list at: 18 put: (self named: #'exception occured' parameter: nil).	list at: 19 put: (self named: #'hresult error' parameter: nil).	list at: 20 put: (self named: #'object engine internal error' parameter: nil).	list at: 21 put: (self named: #'failed to export object' parameter: nil).	list at: 22 put: (self named: #'failed to import object' parameter: nil).	list at: 23 put: (self named: #'platform error' parameter: nil).	list at: 24 put: (self named: #'no modification' parameter: nil).	list at: 25 put: (self named: #'uninitialized' parameter: nil).	list at: 26 put: (self named: #'invalid version' parameter: nil).	list at: 27 put: (self named: #'overflow' parameter: nil).	28 to: list size do: [:i |		list at: i put: (self named: ('error ',i printString) asSymbol parameter: nil)].	self setSystemErrors: list</body></methods><methods><class-id>Kernel.NonInteractiveCompilerErrorHandler</class-id> <category>private</category><body package="System-Compiler-Support" selector="nonInteractiveError:">nonInteractiveError: message	"We spit out whatever error to the Transcript, cr after, and make sure the Transcript is ready for more"		| classPrintString |	classPrintString := class printString.	selector ifNotNil: [classPrintString := classPrintString , ' ' , selector printString].	Transcript show: '(' , classPrintString , ' - ' , message , ')'.	Transcript cr.	Transcript endEntry</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>convenience</category><body package="System-Name Spaces" selector="logOrganizationChange">logOrganizationChange	"need to make this log the change to the change set"	SourceFileManager default logChange:			self storeString,			' reorganizeFromString: ',			self organization printString storeString</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>printing</category><body package="XML-source" selector="xmlDefinition:onto:">xmlDefinition: anXMLFormatter onto: aStream	^anXMLFormatter		on: aStream tag: 'name-space' do: [:xml :str | | nm private |			xml on: str cr tag: 'name' value: self name.			self environment == nil				ifTrue:					[nm := ''.					private := false]				ifFalse:					[nm := self environment fullName.					private := (self environment bindingFor: self name) isPrivate].			xml on: str cr tag: 'environment' value: nm.			xml on: str cr tag: 'private' value: private printString.			xml on: str cr tag: 'imports' value: self importString.			xml on: str cr tag: 'category' value: self category.			str cr]</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="definition">definition	"Answer a string that defines the receiver."	| aStream msg |	aStream := WriteStream on: (String new: 300).	msg := self definitionMessage.	aStream nextPutAll: (msg receiver == nil				ifTrue: [nil printString]				ifFalse: [msg receiver unambiguousName]).	msg selector keywords with: msg arguments do:		[:word :arg |		arg = self name			ifTrue: [aStream space]			ifFalse: [aStream cr; tab].		aStream nextPutAll: word; space; store: arg].	^aStream contents</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>fileout</category><body package="System-Overrides" selector="convertToXML">convertToXML	| driver |	Dictionary new.	driver := XML.DOM_SAXDriver new.	driver startDocumentFragment;		startElement: 'name-space' atts: nil.	self sax: driver tag: 'name' value: self name asString.	self sax: driver tag: 'environment' value: self environment fullName.	self sax: driver tag: 'private' value: ( self argumentForKeyWord: 'private' ) printString.	self sax: driver tag: 'imports' value: ( self argumentForKeyWord: 'imports' ).	self sax: driver tag: 'category' value: ( self argumentForKeyWord: 'category'  ) asString.	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>fileout</category><body package="System-Overrides" selector="convertToXML">convertToXML		| driver initializer |	driver := XML.DOM_SAXDriver new.	driver		startDocumentFragment;		startElement: 'shared-variable' atts: nil.	self sax: driver tag: 'name' value: self name asString.	self sax: driver tag: 'environment' value: self owner fullName.	self sax: driver tag: 'private' value: (self argumentForKeyWord: 'private') printString.	self sax: driver tag: 'constant' value: (self argumentForKeyWord: 'constant') printString.	self sax: driver tag: 'category' value: (self argumentForKeyWord: 'category') asString.	initializer := self argumentForKeyWord: 'initializer'.	initializer ifNotNil: [self sax: driver tag: 'initializer' value: initializer asString].	(self argumentForKeyWord: 'attributes') ifNotNil:		[driver startElement: 'attributes' atts: nil.		(self argumentForKeyWord: 'attributes') value do:			[:eachAttribute | 			(eachAttribute last isKindOf: Array)				ifTrue:					[driver startElement: eachAttribute first atts: nil.					eachAttribute last do: [:s | self sax: driver tag: 'item' value: s].					driver endElement]				ifFalse: [self sax: driver tag: eachAttribute first value: eachAttribute last displayString]].			driver endElement].	driver		endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Kernel.SpecialSelectorCounter class</class-id> <category>utilities</category><body package="System-Compiler-Support" selector="specialSelectors">specialSelectors	^#(#+ #- #&lt; #&gt; #&lt;= #&gt;= #= #~= #* #// #@ #, #not #isNil #notNil #basicAt: #at: #at:put: #size #~~ #basicNew #nextPutAll: #== #class #add: #value #value: #basicSize #new #new: #basicAt:put: #basicNew: #do: #cr #on: #nextPut: #bounds #x #y #isEmpty #copyOld #name #with: #at:ifAbsent: #-&gt; #error: #first #bitShift: #includes: #contents #key #asString #last #extent #componentAt: #printString #bitAnd: #scaledRed:scaledGreen:scaledBlue: #view #rounded #window #/ #next #paint: #yourself #space #asSymbol #controller #sensor #max: #height #isKindOf: #subclassResponsibility #default #with:with: #asValue #collect: #tab #addLast: #print: #initialize #builder #extent: #width #handle:do: #top #copyFrom:to: #negated #widget #close #errorSignal #left #displayRectangle: #current #origin #layout #perform: #asInteger #min: #black #selection #asPointerParameter #bottom #model #removeLast #list #component #externalAccessFailedWith: #environment #raise #select: #extent:depth:bitsPerPixel:palette:usingBits: #peekForTypeNoPush: #asFilename #asText #adapt:forAspect:channel: #showWhile: #tab: #organization #displayOn:at: #primitiveFailed #release #notifierString: #writeStream #menuItemLabeled: #monoMaskPalette #atEnd #selector #show: #addAll: #aspectAt:put: #nameClass:message: #model: #right #preferredBounds #emphasis: #bindValue:to: #indexOf: #expected: #keyboard #disable #white #matchAt:put: #invalidate #scale #replaceFrom:to:with:startingAt: #on:do: #to: #value:value: #fullName #readStream #valueNowOrOnUnwindDo: #removeDependent: #byteAt: #onChangeSend:to: #asArray #asFloat #changed: #corner: #text #labeled: #detect:ifNone: #warn: #name: #center #decodeAsLiteralArray #isSymbol #isString #changed:with: #label: #position #printOn: #wait #\\ #keysAndValuesDo: #asValueReference #preferenceFor: #includesKey: #abs #return #shouldNotImplement #returnWith: #critical: #list: #displayBox #species #withCRs #replaceStackTop: #components #foregroundColor #with:with:with: #selection: #bitOr: #label #parameter #string #lineGrid #backgroundColor #type #withColors: #separator #palette #hash #graphicsContext #layout: #sender #open #enable #remove:ifAbsent: #skip: #textStyle #| #scanToken #insetBy: #targetClass #selectionIndexHolder #changeRequest #byteAt:put: #memberAt:put: #htmlEntity #wrapper #isEnabled #raiseWith: #displayOn: #addDependent: #bounds: #perform:with: #x: #containsPoint: #preferenceModelFor: #numArgs #keyboardProcessor #component: #cursorPoint #externalAccessFailedSignal #intersects: #origin:extent: #store: #zero #widgetState #remove: #extent:depth:palette:bits:pad: #topComponent #memberAt: #fromBytes:)</body></methods><methods><class-id>Kernel.ObjectMemory</class-id> <category>utilities</category><body package="Tools-Trippy" selector="print:used:total:threshold:objects:on:">print: name used: used total: total threshold: threshold objects: objects on: aStream	"name:	used / total[ @ threshold][, objs]"	aStream		cr;		nextPutAll: name;		nextPutAll: ':	';		nextPutAll: used asShortSizeInBytes;		nextPutAll: ' / ';		nextPutAll: total asShortSizeInBytes.	threshold		ifNotNil: 			[aStream				nextPutAll: ' @ ';				nextPutAll: threshold asShortSizeInBytes].	objects		ifNotNil: 			[aStream				nextPutAll: ', ';				nextPutAll: objects printString]</body></methods><methods><class-id>Kernel.ProgramNodeBuilder</class-id> <category>node creation-composite-data</category><body package="System-Compiler-Program Objects" selector="newVariable">newVariable	^self newVariableName: 'var', Time millisecondClockValue printString</body></methods><methods><class-id>Kernel.UserPrimitiveMethod</class-id> <category>private</category><body package="Kernel-Methods" selector="moduleExtensionForCurrentPlatform">moduleExtensionForCurrentPlatform	(MacOSXSystemSupport matchesPlatform: ExternalInterface currentPlatform) ifTrue: [^'.dylib'].	OSHandle currentOS == #unix ifTrue: [^'.so'].	OSHandle currentOS == #win32 ifTrue: [^'.dll'].	self error: 'Don''t know what to do on platform ', ExternalInterface currentPlatform printString</body></methods><methods><class-id>Kernel.LoggingCompilerErrorHandler</class-id> <category>error handling</category><body package="System-Compiler-Support" selector="undeclared:in:from:">undeclared: binding in: node from: codeStream	binding key isSymbol		ifFalse: [binding key: binding key asSymbol].	SystemUtils undeclareNewBinding: binding.	logFile cr; nextPutAll: ((#x1s2sundeclared &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;  - &lt;2s&gt; : undeclared')			expandMacrosWith: class printString			with: binding key).	logFile == Transcript ifTrue: [logFile endEntry].</body></methods><methods><class-id>Kernel.LoggingCompilerErrorHandler</class-id> <category>error handling</category><body package="System-Compiler-Support" selector="undeclaredStore:in:from:">undeclaredStore: binding in: node from: codeStream	binding key isSymbol		ifFalse: [binding key: binding key asSymbol].	SystemUtils undeclareNewBinding: binding.	logFile cr; nextPutAll: ((#x1s2sundeclaredStore &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;  - &lt;2s&gt; : undeclaredStore')			expandMacrosWith: class printString			with: binding key).	logFile == Transcript ifTrue: [logFile endEntry].</body></methods><methods><class-id>Kernel.LoggingCompilerErrorHandler</class-id> <category>error handling</category><body package="System-Compiler-Support" selector="error:with:in:from:">error: type with: message in: node from: codeStream	"Possible values of type:		#error, message = error message		#warning, message = error message		#readBeforeWritten, message = var name		#neverRead, message = var name, node = assignment		#neverUsed, message = var name		#redeclared, message = var name		#redeclaredBlockArg, message = var name		#undeclared, message = var Association		#undeclaredStore, message = var Association, node = assignment		#undeclaredSoftLink, message = BindingReference		#noEffect, message = nil, node = statement		#notOptimized, message = argument index, node = message send."	| msg |	msg := message isVariableBinding		ifTrue: [message key, ' : ']		ifFalse: [message isString			ifTrue: [message, ' : ']			ifFalse: ['']].	logFile cr; nextPutAll: class printString , ' ' , "selector ," ' - ' , msg , type.	logFile == Transcript ifTrue: [logFile endEntry].	type == #error ifTrue: [^self abort]</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="description">description	^self printString</body></methods><methods><class-id>StartupPacket</class-id> <category>printing</category><body package="PostgreSQLDriver" selector="printOn:">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Packet size: ' , self packetSize value printString; cr.	aStream nextPutAll: 'Protocol version number: ' , self protocolVersionNumber bytes printString; cr.	aStream nextPutAll: 'Database name: ' , self databaseName value printString; cr.	aStream nextPutAll: 'User name: ' , self userName value printString; cr.	aStream nextPutAll: 'Additional arguments: ' , self additionalArguments value printString; cr.	aStream nextPutAll: 'Debugging TTY: ' , self debuggingTTY value printString; cr.	^self</body></methods><shared-variable><name>CharacterClasses</name><environment>XML</environment><private>false</private><constant>true</constant><category>XML-Parsing</category><initializer>| ch sets t pc |ch := CharacterTable new: 16r110000.sets := Array			with: (16r20 to: 16rD7FF)			with: (16rE000 to: 16rFFFD)			with: (16r10000 to: ch size - 1).pc := XMLParser.t := Time millisecondsToRun: 				[sets do: 						[:s |						| startS endS |						startS := s first.						endS := s last.						startS to: endS							do: 								[:i |								| n |								n := 1.								(pc isNameStartChar: i) ifTrue: [n := n bitOr: 6].								(pc isNameChar: i) ifTrue: [n := n bitOr: 2].								ch at: i + 1 put: n]]].ch at: 9 + 1 put: 1.ch at: 10 + 1 put: 1.ch at: 13 + 1 put: 1.ch at: $_ asInteger + 1 put: 7.ch at: $- asInteger + 1 put: 3.ch at: $. asInteger + 1 put: 3.Transcript	cr;	show: 'Time = ' , t printString.ch compress.ch</initializer><attributes><package>XML</package></attributes></shared-variable><remove-selector><class-id>Core.CompositeLocale</class-id> <selector>printStringOld</selector></remove-selector><remove-selector><class-id>Protocols.ProtoObject</class-id> <selector>printStringOld</selector></remove-selector><remove-selector><class-id>Core.Object</class-id> <selector>printStringOld</selector></remove-selector><remove-selector><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <selector>printStringOld</selector></remove-selector><remove-selector><class-id>Glorp.AbstractProxy</class-id> <selector>printStringOld</selector></remove-selector><remove-selector><class-id>Core.String</class-id> <selector>printStringOld</selector></remove-selector><remove-selector><class-id>Glorp.MessageArchiver</class-id> <selector>printStringOld</selector></remove-selector><methods><class-id>BST</class-id> <category>converting</category><body package="CS474" selector="asString">asString	^root notNil ifTrue: [root asString] ifFalse: ['{}']</body></methods><methods><class-id>BST</class-id> <category>converting</category><body package="CS474" selector="asString">asString	^root notNil ifTrue: ['{', root asString, '}'] ifFalse: ['{}']</body></methods><methods><class-id>BST</class-id> <category>converting</category><body package="CS474" selector="asString">asString	^root notNil ifTrue: ['{', root asString, '}'] ifFalse: ['']</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="=">= anotherBSTNode 	^self value = anotherBSTNode value</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>anotherBSTNode</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>anotherBSTNode</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="=">= anotherBSTNode	anotherBSTNode class = self class		ifTrue: [self value = anotherBSTNode value]		ifFalse: [^false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="=">= anotherBSTNode	^anotherBSTNode class = self class		ifTrue: [self value = anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&gt;=">&gt;= anotherBSTNode	^anotherBSTNode class = self class		ifTrue: [self value &gt;= anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&gt;">&gt; anotherBSTNode	^anotherBSTNode class = self class		ifTrue: [self value &gt; anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&gt;">&gt; anotherBSTNode	^anotherBSTNode class = self class		ifTrue: [self value &gt; anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&lt;=">&lt;= anotherBSTNode	^anotherBSTNode class = self class		ifTrue: [self value &lt;= anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&lt;">&lt; anotherBSTNode	^anotherBSTNode class = self class		ifTrue: [self value &lt; anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="~=">~= anotherBSTNode	^anotherBSTNode class = self class		ifTrue: [self value ~= anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="hasChildren">hasChildren		^left notNil  or: [right notNil]</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="contains:">contains: anObject	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	| contains |	contains := false.	value = anObject		ifTrue: [contains := true]		ifFalse: 			[(value &lt; anObject and: [left notNil]) ifTrue: [contains := left contains: anObject].			(value &gt; anObject and: [right notNil]) ifTrue: [contains := right contains: anObject]].	^contains</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="contains:">contains: anObject	| contains |	contains := false.	value = anObject		ifTrue: [contains := true]		ifFalse: 			[(value &lt; anObject and: [left notNil])				ifTrue: [contains := left contains: anObject].			(value &gt; anObject and: [right notNil])				ifTrue: [contains := right contains: anObject]].	^contains</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left">left	^left</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left:">left: anObject	left := anObject.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="max">max	^right isNil ifTrue: [value] ifFalse: [right max]</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="min">min	^left isNil ifTrue: [value] ifFalse: [left min]</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right">right	^right</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right:">right: anObject 	right := anObject.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="value">value	^value</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="value:">value: anObject	value := anObject.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="postCopy">postCopy	left notNil ifTrue: [left :=left copy].	right notNil ifTrue: [right := right copy].	^self</body></methods><methods><class-id>Glorp.Query</class-id> <category>copying</category><body package="GlorpQueries" selector="copy">copy	^self shallowCopy postCopy.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>copying</category><body package="Store-Database Model" selector="copy">copy	^self shallowCopy postCopy.</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copy">copy		^ BST new root: root copyOld.</body></methods><methods><class-id>Protocols.Struct</class-id> <category>copying</category><body package="Protocols-Common" selector="copy">copy	^self shallowCopy postCopy</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions" selector="copy">copy	| new |	new := super copyOld.	"We need to make sure we copy these before the base gets set. This is horribly ugly."	new selectListVersion: selectListVersion copyOld.	new whereClauseVersion: whereClauseVersion copyOld.	^new.</body></methods><methods><class-id>UI.AssociationTree</class-id> <category>copying</category><body package="UIBasics-Collections" selector="copy">copy	"Answer another instance just like the receiver, but with a copy of 	the receiver's value and a copy 	of each of the receiver's children."	| cpy tmpChildren |	tmpChildren := children.	children := nil.	cpy := self shallowCopy.	cpy value: value copyOld.	tmpChildren isNil ifFalse: [tmpChildren do: [:child | cpy addChild: child copyOld]].	children := tmpChildren.	^cpy</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>actions</category><body package="UIPainter" selector="copy">copy	| image r newMap |	r := Rectangle			fromUser: magnifiedBitView scale			phase: magnifiedBitView controller sensor globalOrigin.	r extent = (8@8) ifTrue: [^self].	(self apertureIntersectsWithScreenRectangle: r) ifFalse: [^self].	r := self modelRegionFromScreenRegion: r.	image := magnifiedBitView model.	newMap :=		Image			extent: r extent			depth: image depth			bitsPerPixel: image bitsPerPixel			palette: image palette.	newMap		copy: (Rectangle origin: 0 @ 0 corner: r extent)		from: r origin		in: image		rule: RasterOp paint.	self pasteBuffer: newMap</body></methods><methods><class-id>Core.Symbol</class-id> <category>copying</category><body package="Collections-Text" selector="copy">copy	"Answer the receiver, because Symbols are unique."	^self</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="copy">copy	"Prevent the baseTable and composeTable from being corrupted if	more than one DispatchTable are sharing them"	shared := true.	^super copyOld</body></methods><methods><class-id>Graphics.CharacterBlock</class-id> <category>copying</category><body package="Graphics-Text Support" selector="copy">copy	"Answer another instance just like the receiver."	^self shallowCopy</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>copying</category><body package="GlorpQueries" selector="copy">copy	^self shallowCopy postCopy.</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="Debugger-Probes" selector="copy">copy	^self class registerMethod: super copyOld.</body></methods><methods><class-id>Text2.Document</class-id> <category>copying</category><body package="Graphics-Text2-Document" selector="copy">copy	"Make a copy of the receiver."	^self copyBetween: 0 and: size</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>copying</category><body package="Store-Database Model" selector="copy">copy	^self glorpCopyIn: IdentityDictionary new.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>copying</category><body package="GlorpQueries" selector="copy">copy	^self shallowCopy postCopy.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>copying</category><body package="GlorpQueries" selector="copy">copy	^self shallowCopy postCopy.</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="Kernel-Objects" selector="copy">copy	" Answer another instance just like the receiver.	Subclasses normally override the postCopy	message, but some objects that should not be	copied override copy. "	^self shallowCopy postCopy</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>copying</category><body package="GlorpDatabase" selector="copy">copy	^self shallowCopy postCopy.</body></methods><methods><class-id>Security.HMAC</class-id> <category>services-basic</category><body package="HashesBase" selector="copy">copy"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self class new		setIHash: ihash copyOld		oHash: ohash copyOld		iPad: ipad copyOld		oPad: opad copyOld;		yourself</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>commands</category><body package="Debugger-UI" selector="copy">copy	buffer := selection value copyOld.</body></methods><methods><class-id>Security.MessageDigest</class-id> <category>services-basic</category><body package="HashesBase" selector="copy">copy"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self subclassResponsibility</body></methods><methods><class-id>Security.Hash</class-id> <category>services-basic</category><body package="HashesBase" selector="copy">copy"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	| new |	new := self class new.	new restoreRegisters: self backupRegisters.	new restoreBuffer: block total: total position: position.	^new</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>copying</category><body package="GlorpCore" selector="copy">copy	^self shallowCopy postCopy.</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>compiling</category><body package="Atomic Compiling and Loading" selector="compilerMethodInShadow:orRealClassDefinesCompiler:">compilerMethodInShadow: aShadowClassOrMetaClass orRealClassDefinesCompiler: aClassOrMetaClass	| compilerMethod |	aShadowClassOrMetaClass ifNotNil: 		[aShadowClassOrMetaClass instanceBehavior == Object ifFalse:			[compilerMethod := aShadowClassOrMetaClass isMeta				ifTrue: [(aShadowClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aShadowClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]				ifFalse: [(aShadowClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aShadowClassOrMetaClass class compiledMethodAt: #compilerClass) copy]]]].	compilerMethod ifNotNil: [^compilerMethod].	aClassOrMetaClass ifNil: [^nil].	^aClassOrMetaClass isMeta		ifTrue: [(aClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]		ifFalse: [(aClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aClassOrMetaClass class compiledMethodAt: #compilerClass) copy]].</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>compiling</category><body package="Atomic Compiling and Loading" selector="augment:usingBehaviorCompiler:">augment: shadowClass usingBehaviorCompiler: compiler		| newMethod |	newMethod := (Behavior compiledMethodAt: #compilerClass) copy.	newMethod		at: 1		put: (ValueHolder new value: compiler).	shadowClass replaceMethodAt: #compilerClass withMethod: newMethod</body></methods><methods><class-id>UI.LabeledBooleanView</class-id> <category>display box accessing</category><body package="UIBasics-Components" selector="preferredBounds">preferredBounds	"Compute the preferredBounds for the receiver"	| imageOff imageOn labelOff labelOn |	imageOff := offImage isNil ifTrue: [0@0] ifFalse: [offImage preferredBounds extent].	imageOn := onImage isNil ifTrue: [0@0] ifFalse: [onImage preferredBounds extent].	labelOff := (ComposedText withText: label style: LabelStyle) preferredBounds extent.	labelOn := (ComposedText withText: label asText copy allBold style: LabelStyle) preferredBounds extent.	^Rectangle		origin: 0 @ 0		corner:			(imageOff x + labelOff x max: imageOn x + labelOn x) + 4 @			((imageOff y max: labelOff y) max: (imageOn y max: labelOn y))</body></methods><methods><class-id>UI.MotifMenuView</class-id> <category>displaying-privileged</category><body package="UILooks-Motif" selector="displayBeveledBorderOn:in:">displayBeveledBorderOn: aGraphicsContext in: aRectangle	"Display a Motif style raised beveled border (XmSHADOW_OUT) on aGraphicsContext inside aRectangle using the appropriate colors."	| borderPart |	borderPart := aRectangle copy.	aGraphicsContext paint: self hiliteColor.	borderPart right: borderPart left + 2.	aGraphicsContext displayRectangle: borderPart.	borderPart right: aRectangle right.	borderPart bottom: borderPart top + 2.	aGraphicsContext displayRectangle: borderPart.	aGraphicsContext paint: self shadowColor.	borderPart top: borderPart bottom.	borderPart bottom: aRectangle bottom.	borderPart left: borderPart right - 2.	aGraphicsContext displayRectangle: borderPart.	borderPart top: borderPart top -1.	borderPart bottom: borderPart top + 1.	borderPart left: borderPart left + 1.	aGraphicsContext displayRectangle: borderPart.	borderPart right: borderPart left - 1.	borderPart left: aRectangle left + 2.	borderPart bottom: aRectangle bottom.	borderPart top: borderPart bottom - 2.	aGraphicsContext displayRectangle: borderPart.	borderPart left: borderPart left -1.	borderPart right: borderPart left + 1.	borderPart top: borderPart top + 1.	aGraphicsContext displayRectangle: borderPart</body></methods><methods><class-id>UI.InputFieldView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayedSizeOf:">displayedSizeOf: aText	"Answer the size of aText based on the current composed text information"	| composedText |	composedText := self displayContents copy text: aText.	^composedText width</body></methods><methods><class-id>UI.InputFieldView</class-id> <category>accessing</category><body package="UIBasics-Components" selector="editValue">editValue	"Sending this message will result in an error if the receiver contains 	invalid input that cannot be converted into an object of the required 	kind. The message hasEditValue can be sent beforehand to see 	whether or not the input can be converted, and if necessary the	message displayContents can then be sent to access the	text of any malformed input."	| v |	v := displayContents text copy.	converter notNil		ifTrue: [v := converter readValueFrom: v].	^v</body></methods><methods><class-id>UI.InputFieldView</class-id> <category>selection</category><body package="UIBasics-Components" selector="placeSelectionPointAt:">placeSelectionPointAt: characterIndex 	"Place the character before the character at position characterIndex.  Make	certain the selection is in the view but does not display any thing (ie. assumes 	no selection is showing).	This is used by the TextEditor during typing"	| delta |	startBlock := self characterBlockForIndex: characterIndex.	stopBlock := startBlock copy.	delta := self findSelectionDelta.	delta ~= Point zero		ifTrue: [self scrollBy: delta negated]		ifFalse: [self scrollTo: scrollOffset value].</body></methods><methods><class-id>UI.ComponentSpec</class-id> <category>accessing</category><body package="UIPainter" selector="savableSpecFor:">savableSpecFor: implementationComponent	^self copy</body></methods><methods><class-id>UI.ParcelPropertiesInspector</class-id> <category>initialize-release</category><body package="Tools-Misc" selector="inspect:">inspect: aDictionary	"Set anObject to be the object inspected by the receiver.  First remove all the illegal properties"	| acceptable |	acceptable := aDictionary copy.	self class illegalPropertyKeys do: 		[ :aKey | acceptable removeKey: aKey ifAbsent: nil ].	^super inspect: acceptable.</body></methods><methods><class-id>UI.InputEditor</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayLinesOn:">displayLinesOn: aGraphicsContext	| clippingBounds gc |	super displayLinesOn: aGraphicsContext.	document isEmpty ifFalse: [^self].	clippingBounds := aGraphicsContext clippingBounds.	gc := aGraphicsContext copy.	(Flow device: aGraphicsContext medium graphicsDevice document: self defaultDocument)		linesIntersecting: clippingBounds do: [:line |			gc translation: aGraphicsContext translation + (0 @ line top).			line displayOn: gc selectingBetween: 0 and: 0]</body></methods><methods><class-id>UI.Win98LookPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="menuName">menuName	^(#Win982k &lt;&lt; #menus &gt;&gt; 'Windows 98/2000') copy</body></methods><methods><class-id>UI.AlignmentOrigin</class-id> <category>converting</category><body package="UIBasics-Support" selector="reducedForm">reducedForm	"Answer the most reduced form for representing the receiver.  This	includes reducing floats to integers where possible."	| result |	(leftFraction = 0 and: [topFraction = 0])		ifTrue:			[(topAlignmentFraction = 0 and: [leftAlignmentFraction = 0])				ifTrue: [^Point x: left y: top]]		ifFalse:			[(topAlignmentFraction = 0 and: [leftAlignmentFraction = 0])				ifTrue:					[^LayoutOrigin new						leftOffset: left;						leftFraction:							(leftFraction = 0								ifTrue: [0]								ifFalse:									[leftFraction = 1										ifTrue: [1]										ifFalse: [leftFraction]]);						topOffset: top;						topFraction:							(topFraction = 0								ifTrue: [0]								ifFalse:									[topFraction = 1										ifTrue: [1]										ifFalse: [topFraction]]);						yourself]].	result := self copy.	leftFraction = 0	ifTrue: [result leftFraction: 0].	topFraction = 0	ifTrue: [result topFraction: 0].	leftAlignmentFraction = 0	ifTrue: [result leftAlignmentFraction: 0].	topAlignmentFraction = 0	ifTrue: [result topAlignmentFraction: 0].	leftFraction = 1	ifTrue: [result leftFraction: 1].	topFraction = 1	ifTrue: [result topFraction: 1].	leftAlignmentFraction = 1	ifTrue: [result leftAlignmentFraction: 1].	topAlignmentFraction = 1	ifTrue: [result topAlignmentFraction: 1].	^result</body></methods><methods><class-id>UI.UIFeelPolicy</class-id> <category>accessing</category><body package="UIBuilder-Support" selector="dispatchTable">dispatchTable	^self keyboard copy</body></methods><methods><class-id>UI.UIFeelPolicy</class-id> <category>keyboard Bindings</category><body package="UIBuilder-Support" selector="keyboardDispatchTable">keyboardDispatchTable	"Initialize the keyboard dispatch table."	| k |	k := self keyboard.	k defaultForCharacters: #normalCharacterKey:.	k defaultForNonCharacters: #ignoreInputKey:.	k bindValue: #deleteKey: to: Cut.	k bindValue: #deleteKey: to: #FwdDelete.	k bindValue: #pasteKey: to: Paste.	k bindValue: #backspaceKey: to: BS.	k bindValue: #backWordKey: toCommand: #legacyTextDeletePreviousWord.	self supportsCodeEditing ifTrue: [		k bindValue: #displayIfTrueKey: toCommand: #codeSnippetIfTrue.		k bindValue: #displayIfFalseKey: toCommand: #codeSnippetIfFalse.		k bindValue: #displayColonEqualKey: toCommand: #codeSnippetColonEqual.		k bindValue: #doItOrDisplayDateKey: toCommand: #doIt.		k bindValue: #printItKey: toCommand: #printIt.		k bindValue: #inspectItKey: toCommand: #inspectIt.		k bindValue: #debugItKey: toCommand: #debugIt.		k bindValue: #explainKey: toCommand: #explain	].	k bindValue: #findDialogKey: toCommand: #find.	k bindValue: #findAgainKey: toCommand: #findNext.	k bindValue: #findAgainKey: toCommand: #findPrevious.	k bindValue: #displayDateKey: toCommand: #codeSnippetInsertDate.	k bindValue: #acceptKey: toCommand: #accept.	k bindValue: #selectAllKey: toCommand: #selectAll.	k bindValue: #replaceKey: toCommand: #replace.	k bindValue: #replaceAgainKey: toCommand: #replaceNext.	k bindValue: #cutKey: toCommand: #cut.	k bindValue: #copyKey: toCommand: #copy.	k bindValue: #pasteKey: toCommand: #paste.	" WARNING: some implementations of undo overload it to mean redo when shift is down "	k bindValue: #undoKey: toCommand: #undo.	k bindValue: #redoKey: toCommand: #redo.	k bindValue: #selectCurrentTypeInKey: toCommand: #legacyTextSelectCurrentTypeIn.	k bindValue: #displayCRKey: to: #Enter.	k bindValue: #movePreviousByCharacterKey: toCommand: #movePreviousByCharacter.	k bindValue: #selectPreviousByCharacterKey: toCommand: #selectPreviousByCharacter.	k bindValue: #movePreviousByWordKey: toCommand: #movePreviousByWord.	k bindValue: #selectPreviousByWordKey: toCommand: #selectPreviousByWord.	k bindValue: #movePreviousByLineKey: toCommand: #movePreviousByLine.	k bindValue: #selectPreviousByLineKey: toCommand: #selectPreviousByLine.	k bindValue: #movePreviousByPageKey: toCommand: #movePreviousByPage.	k bindValue: #moveNextByCharacterKey: toCommand: #moveNextByCharacter.	k bindValue: #selectNextByCharacterKey: toCommand: #selectNextByCharacter.	k bindValue: #moveNextByWordKey: toCommand: #moveNextByWord.	k bindValue: #selectNextByWordKey: toCommand: #selectNextByWord.	k bindValue: #moveNextByLineKey: toCommand: #moveNextByLine.	k bindValue: #selectNextByLineKey: toCommand: #selectNextByLine.	k bindValue: #moveNextByPageKey: toCommand: #moveNextByPage.	k bindValue: #moveToStartOfLineKey: toCommand: #moveToStartOfLine.	k bindValue: #selectToStartOfLineKey: toCommand: #selectToStartOfLine.	k bindValue: #moveToEndOfLineKey: toCommand: #moveToEndOfLine.	k bindValue: #selectToEndOfLineKey: toCommand: #selectToEndOfLine.	k bindValue: #moveToStartOfDocumentKey: toCommand: #moveToStartOfDocument.	k bindValue: #selectToStartOfDocumentKey: toCommand: #selectToStartOfDocument.	k bindValue: #moveToEndOfDocumentKey: toCommand: #moveToEndOfDocument.	k bindValue: #selectToEndOfDocumentKey: toCommand: #selectToEndOfDocument.	'&lt;''"[{(' do: [:char | k bindValue: #encloseKey: to: ESC followedBy: char].	'sSuUbBiIx+-' do: [:char | k bindValue: #changeEmphasisKey: to: ESC followedBy: char].	self supportsCodeEditing ifTrue: [k bindValue: #miniFormatKey: to: ESC followedBy: $f].	k bindValue: #selectCurrentTypeInKey: to: ESC followedBy: Tab</body></methods><methods><class-id>UI.PluggableAdaptor</class-id> <category>private</category><body package="Interface-Support" selector="makeAdaptorForRenderingStoreLeafInto:">makeAdaptorForRenderingStoreLeafInto: pair	pair at: 1 put: self.	^(model isProtocolAdaptor)		ifTrue: [model := model copy.				model makeAdaptorForRenderingStoreLeafInto: pair]		ifFalse: [pair]</body></methods><methods><class-id>UI.PluggableAdaptor</class-id> <category>private</category><body package="Interface-Support" selector="renderingValueUsingSubject:">renderingValueUsingSubject: aSubject	| pair cpy cell |	model isProtocolAdaptor ifFalse: [^self valueUsingSubject: aSubject].	cpy := self copy.	pair := Array new: 2.	pair at: 2 put: cpy.	cell := cpy makeAdaptorForRenderingStoreLeafInto: pair.	cell first subjectChannel: aSubject asValue.	^cell last value</body></methods><methods><class-id>UI.Win95MenuFromMenuBarController</class-id> <category>events</category><body package="UILooks-MSWin" selector="viewHasCursorWithEvent:">viewHasCursorWithEvent: event	"Answer true if the cursor point of the receiver's sensor lies within 	the display box and border of the menu item dropdown.	This is farily unique to stacked menus, but it makes standard windows like behavior"	| localSensor adulteratedBounds |	view == nil ifTrue: [^false].	event hasPoint ifFalse: [^false].	localSensor := self sensor.	adulteratedBounds := view bounds copy		top: view bounds top - view container border top.	^adulteratedBounds containsPoint: (localSensor cursorPointFor: event)</body></methods><methods><class-id>UI.SequenceView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayNormalElement:on:forBounds:">displayNormalElement: index on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component childGC |	component := self visualComponentForElementIndex: index.	component ifNil: [^self].	component bounds: elementBounds.	childGC := aGraphicsContext copy.	childGC lineGrid: self lineGrid.	component displayOn: childGC</body></methods><methods><class-id>UI.SequenceView</class-id> <category>private</category><body package="UIBasics-Components" selector="displaySelectedElement:on:forBounds:">displaySelectedElement: index on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component childGC |	component := self selectedVisualComponentForElementIndex: index.	component ifNil: [^self].	component bounds: elementBounds.	childGC := aGraphicsContext copy.	childGC lineGrid: self lineGrid.	component displayOn: childGC</body></methods><methods><class-id>UI.WindowManager</class-id> <category>damage control</category><body package="Interface-Framework" selector="repairDamagesExcept:">repairDamagesExcept: obj	[outstandingMetaOrDamage]		whileTrue: 			[outstandingMetaOrDamage := false.			[windows copy do: [:w | w == obj ifFalse: [w checkForEvents]]]					on: ClosedWindowNotification					do: [:ex | ex retry]]</body></methods><methods><class-id>UI.WindowManager class</class-id> <category>accessing</category><body package="Interface-Framework" selector="managerRegistryDo:">managerRegistryDo: aBlock 	"We do a check for terminate to cleanup registry before we do aBlock."	self managerRegistry copy 		do: [:each | each ifNotNil: [each terminateIfEmpty]].	self managerRegistry do: [:each | each ifNotNil: aBlock]</body></methods><methods><class-id>UI.WindowManager class</class-id> <category>private</category><body package="Interface-Framework" selector="addToRegistry:">addToRegistry: aWindowManager	"Before I add a new one, I do a cleanup via checkForTerminate"	self managerRegistry copy do: [:each | each ifNotNil: [each terminateIfEmpty]].	self managerRegistry add: aWindowManager</body></methods><methods><class-id>UI.WindowManager class</class-id> <category>recovery</category><body package="Interface-Framework" selector="purgeDeadWindows">purgeDeadWindows	self managerRegistry copy do: [:each | each ifNotNil: [each purgeDeadWindows]]</body></methods><methods><class-id>UI.WindowManager class</class-id> <category>modal windows</category><body package="Interface-Framework" selector="modalWindowChain">modalWindowChain	"Answer a copy of the ordered collection of modal windows."	^ModalCollectionLock critical: [ModalWindowChain copy]</body></methods><methods><class-id>UI.Label</class-id> <category>printing</category><body package="UIBasics-Support" selector="displayLabel">displayLabel	^self copy</body></methods><methods><class-id>UI.Icon</class-id> <category>initialize-release</category><body package="Interface-Support" selector="cleanFigure">cleanFigure	"Window systems may behave oddly when the image has non-zero	pixels where the mask is transparent. This method 'cleans up' the	image to have only zero pixels where transparent. We make this operation      optional in case the odd behavior was really what the user wanted.      Note that we cannot guarantee the same odd behavior on all platforms.	To avoid conversion of the zero pixels to the corresponding color 	value of the mappedPalette when installing the icon, convert &lt;figure&gt; 	to an image with the color depth of the screen before setting pixels to zero."	| msk medium image |	"Figure must have ColorValue as paintBasis, thus the medium is a Pixmap."	medium := Pixmap new.	"Convert image copy to an image with the actual color depth."	image := medium graphicsContext paintPolicy 				representImage: figure asImage copy				forMedium: medium.	msk := shape asImage.	0 to: image width - 1		do: 			[:x | 			0 to: image height - 1				do: 					[:y | 					(msk valueAtPoint: x @ y) = CoverageValue transparent 						ifTrue: [image atPoint: x @ y put: 0]]].	figure := CachedImage on: image</body></methods><methods><class-id>UI.ToolBar</class-id> <category>displaying</category><body package="UIBasics-Components" selector="displayBackgroundOn:">displayBackgroundOn: aGraphicsContext	(aGraphicsContext copy)		paint: self backgroundColor;		displayRectangle: self bounds</body></methods><methods><class-id>UI.MotifLookPolicy class</class-id> <category>installation</category><body package="UILooks-Motif" selector="menuName">menuName	^(#OSFMotif &lt;&lt; #menus &gt;&gt; 'OSF Motif') copy</body></methods><methods><class-id>UI.DataSetScrollWrapper</class-id> <category>private - scrolling</category><body package="UIBasics-Datasets" selector="scrollHorizontallyBy:on:">scrollHorizontallyBy: anInteger on: aGraphicsContext	"Scroll the receiver horizontally by anInteger"	| clippingBox moveBox damageRectangles |	clippingBox := self clippingBounds intersect: aGraphicsContext clippingBounds.	clippingBox := clippingBox intersect: component hScrollBounds.	moveBox := clippingBox copy.	anInteger abs &gt;= clippingBox width ifTrue: [^self redisplayRectangle: clippingBox on: aGraphicsContext].	anInteger &lt; 0		ifTrue: [moveBox right: moveBox right + anInteger]		ifFalse: [moveBox left: moveBox left + anInteger].	aGraphicsContext intersectClip: clippingBox.	damageRectangles := aGraphicsContext		copyArea: moveBox		from: aGraphicsContext		sourceOffsetX: 0		y: 0		destinationOffsetX: anInteger negated		y: 0.	1 to: damageRectangles size do: 		[:index |		self 			redisplayRectangle: ((damageRectangles at: index) intersect: clippingBox)			on: aGraphicsContext].	anInteger &lt; 0		ifTrue: [moveBox right: moveBox left - anInteger]		ifFalse: [moveBox left: moveBox right - anInteger].	self redisplayRectangle: moveBox on: aGraphicsContext</body></methods><methods><class-id>UI.DataSetScrollWrapper</class-id> <category>private - scrolling</category><body package="UIBasics-Datasets" selector="scrollVerticallyBy:on:">scrollVerticallyBy: anInteger on: aGraphicsContext	"Scroll the receiver vertically by anInteger"	| clippingBox moveBox damageRectangles |	clippingBox := self clippingBounds intersect: aGraphicsContext clippingBounds.	clippingBox := clippingBox intersect: component vScrollBounds.	moveBox := clippingBox copy.	anInteger abs &gt;= clippingBox height ifTrue: [^self redisplayRectangle: clippingBox on: aGraphicsContext].	anInteger &lt; 0		ifTrue: [moveBox bottom: moveBox bottom + anInteger]		ifFalse: [moveBox top: moveBox top + anInteger].	aGraphicsContext intersectClip: clippingBox.	damageRectangles := aGraphicsContext		copyArea: moveBox		from: aGraphicsContext		sourceOffsetX: 0		y: 0		destinationOffsetX: 0		y: anInteger negated.	1 to: damageRectangles size do: 		[:index | 		self 			redisplayRectangle: ((damageRectangles at: index) intersect: clippingBox)			on: aGraphicsContext].	anInteger &lt; 0		ifTrue: [moveBox bottom: moveBox top - anInteger]		ifFalse: [moveBox top: moveBox bottom - anInteger].	self redisplayRectangle: moveBox on: aGraphicsContext</body></methods><methods><class-id>UI.DataSetView</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="displayVisualsOn:">displayVisualsOn: aGraphicsContext	"Display the RowVisuals visible in the receiver's bounds on 	GraphicsContext gc."	| currentSequence rect interval bounds rowVisual visibleRange scrollRange |	((currentSequence := self sequence) == nil or: [currentSequence size == 0])		ifTrue: [^self].	rect := aGraphicsContext clippingBounds.	bounds := self bounds.	interval := self visibleIntervalForBounds: (bounds intersect: rect).	visibleRange := self visibleXIndexRangeFor: bounds.	scrollRange := self scrollableXIndexRangeFor: bounds.	interval first to: (interval last + 1 min: currentSequence size)		do: 			[:index |			rowVisual := self columnRange: scrollRange rowIndex: index.			(useHiliteSelection and: [showingSelection and: [self isSelected: index]])				ifTrue: 					[| visibleBounds graphicsContext |					graphicsContext := aGraphicsContext copy.					visibleBounds := self boundsOfElementIndex: index inRange: visibleRange.					visibleBounds right: visibleBounds right - self leftOffsetForDisplay.					graphicsContext paintPreferencesMatchAt: SymbolicPaint foreground put: (graphicsContext paintPreferencesMatchAt: SymbolicPaint selectionBackground).					graphicsContext displayRectangle: visibleBounds.					graphicsContext paintPreferencesMatchAt: self foregroundColor put: (graphicsContext paintPreferencesMatchAt: SymbolicPaint selectionForeground).					rowVisual displayOn: graphicsContext]				ifFalse: [rowVisual displayOn: aGraphicsContext].			rowVisual releaseRenderers]</body></methods><methods><class-id>UI.DataSetView</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="displayOn:">displayOn: aGraphicsContext 	"Display the receiver's content on aGraphicsContext."	| graphicsContext visualOfLabels |	self displayBackgroundIfNeededOn: aGraphicsContext in: super bounds.	self setForegroundPaintOn: aGraphicsContext.	graphicsContext := aGraphicsContext copy.	graphicsContext intersectClip: (self tableProperBounds translatedBy: self bounds origin).	visualOfLabels := self labelsVisual.	visualOfLabels displayOn: graphicsContext.	graphicsContext := aGraphicsContext copy.	graphicsContext intersectClip: (self cellAreaBoundsForDisplay translatedBy: self bounds origin).	self displayVisualsOn: graphicsContext.	self displayGridLinesOn: aGraphicsContext.	editorWrapper notNil ifTrue: 		[ | box frozenColumnEdge |		box := self cellAreaBounds.		self editCell x &gt; self numFrozen 			ifTrue: 				[frozenColumnEdge := self frozenEdge.				frozenColumnEdge &gt; 0 ifTrue: [box left: frozenColumnEdge]]			ifFalse: 				[editorWrapper bounds: ((self 					boundsOfCellIndex: self editCell 					inBounds: self bounds) insetBy: (0 @ 0 corner: 1 @ 1))].			box := box translatedBy: self bounds origin.			(editorWrapper bounds intersects: box) ifTrue: 				[aGraphicsContext intersectClip: box.				editorWrapper displayOn: aGraphicsContext]]</body></methods><methods><class-id>UI.Win95MenuItemView</class-id> <category>displaying-private</category><body package="UILooks-MSWin" selector="computeComposedTexts">computeComposedTexts	"Compute the composed text object appropriate for the label of the receiver and for the 	shortcutKeyCharacter and cache it."	| theText textStyle theMenuItem |	theMenuItem := self menuItem.	textStyle := self lookPolicyClass systemMenuTextStyle.	theText := theMenuItem labelText.	theText := theText isNil ifTrue: [theMenuItem label asText] ifFalse: [theText copy].	composedLabel := Label with: theText attributes: textStyle.	menuView supportsKeyboard ifFalse: [^self].	accessCharacter := theMenuItem accessCharacterPosition.	accessCharacter isNil ifFalse: 			[| indicatorParameters |			indicatorParameters := self computeAccessIndicator.			indicatorParameters notNil ifTrue: 					[accessIndicator := indicatorParameters at: 1.					accessIndicatorThickness := indicatorParameters at: 2]].	theMenuItem hasSubmenu ifTrue: [^self].	theMenuItem hasShortcut ifTrue: [		composedCharacter := Label with: (theMenuItem shortcutModifierString, theMenuItem shortcutKeyString) asText attributes: textStyle	]</body></methods><methods><class-id>UI.Win95MenuItemView</class-id> <category>displaying-private</category><body package="UILooks-MSWin" selector="displayLabelOn:in:selected:">displayLabelOn: aGraphicsContext in: theMenuItemBox selected: isSelected 	"Display the label of the menu item on aGraphicsContext inside theMenuItemBox. isSelected 	indicates if the menu item is to be displayed in it's selected 'highlighted' state."	| theComposedLabel verticalPosition theLabelImage labelPosition labelGraphicsContext offset |	theLabelImage := model labelImage.	labelPosition := menuView commonTextIndent.	theLabelImage notNil ifTrue: 		[| imageBounds imageVerticalPosition |		imageBounds := theLabelImage bounds.		imageVerticalPosition := theMenuItemBox height - imageBounds height // 2.		theLabelImage			displayOn: aGraphicsContext			at: self defaultLabelIndent @ imageVerticalPosition].	theComposedLabel := self composedLabel.	verticalPosition := theMenuItemBox height - theComposedLabel height // 2.	offset := labelPosition @ verticalPosition.	labelGraphicsContext := aGraphicsContext copy translateBy: offset.	theComposedLabel		displayOn: labelGraphicsContext		at: 0 @ 0		enabled: self isEnabled.	accessIndicator isNil ifTrue: [^self].	labelGraphicsContext lineWidth: accessIndicatorThickness.	self isEnabled ifFalse: 		[| copyGC |		copyGC := labelGraphicsContext copy.		copyGC paint: SymbolicPaint hilite; translateBy: 1 @ 1.		accessIndicator displayStrokedOn: copyGC].	accessIndicator displayStrokedOn: labelGraphicsContext</body></methods><methods><class-id>UI.WidgetSpec</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	"Make sure the callbacksSpec is deep copied."	super postCopy.	callbacksSpec := callbacksSpec copy</body></methods><methods><class-id>UI.WidgetSpec</class-id> <category>accessing</category><body package="UIPainter" selector="savableSpecFor:">savableSpecFor: implementationComponent	| result |	result := super savableSpecFor: implementationComponent.	(self model isLiteral) ifFalse: [result model: nil].	callbacksSpec notNil ifTrue: [ result callbacksSpec: callbacksSpec copy].	^result</body></methods><methods><class-id>UI.HotRegions</class-id> <category>private</category><body package="UIBasics-Support" selector="compress">compress	"If possible, shrink the mappings image and selectors array"	| achievableBitDepth remapArray oldImage pix |		achievableBitDepth := (2 raisedTo: 		((((self numberOfSlices) highBit -1) max: 0) highBit)	).	achievableBitDepth &lt; regionsImage bitsPerPixel		ifFalse: [^self].	remapArray := regionsSelectors copy.	(1 to: remapArray size) inject: 1 into: [ :newVal :index | 		(remapArray at: index) notNil			ifTrue: [ | temp |					remapArray at: index put: newVal. 					temp := regionsSelectors at: index.					regionsSelectors at: index put: nil.					regionsSelectors at: newVal put: temp. 					newVal + 1]			ifFalse: [newVal].	].	oldImage := regionsImage. 	regionsImage := Image extent: oldImage extent depth: achievableBitDepth palette: (CoveragePalette maxPixelValue: (2 raisedTo: achievableBitDepth) -1).	oldImage pixelsDo: [ :x :y |		pix := oldImage atPoint: x@y.		regionsImage atPoint: x@y put: (pix = 0 ifTrue: [0] ifFalse: [remapArray at: pix]).	].	regionsSelectors := regionsSelectors copyFrom: 1 to: (2 raisedTo: achievableBitDepth) -1.</body></methods><methods><class-id>UI.HotRegions</class-id> <category>accessing</category><body package="UIBasics-Support" selector="regionsSelectors:">regionsSelectors: aValue	regionsSelectors := aValue copy</body></methods><methods><class-id>UI.Win95LookPolicy</class-id> <category>private</category><body package="UILooks-MSWin" selector="colorsWithButtonBackgroundFor:">colorsWithButtonBackgroundFor: colors 	"Private - Fix background color of all widgets, which shall have a white background."	^colors isNil		ifTrue: [LookPreferences new backgroundColor: SymbolicPaint buttonBackground]		ifFalse: [colors backgroundColor isNil				ifTrue: [colors copy backgroundColor: SymbolicPaint buttonBackground]				ifFalse: [colors]]</body></methods><methods><class-id>UI.Win95LookPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="menuName">menuName	^(#Win95NT &lt;&lt; #menus &gt;&gt; 'Windows 95/NT') copy</body></methods><methods><class-id>UI.DefaultLookPolicy class</class-id> <category>installation</category><body package="UILooks-Default" selector="menuName">menuName	^(#DefaultLook &lt;&lt; #menus &gt;&gt; 'Default Look') copy</body></methods><methods><class-id>UI.WidgetPolicy class</class-id> <category>accessing</category><body package="UIBuilder-Support" selector="defaultWidgetColorsOn:">defaultWidgetColorsOn: aGraphicsDevice 	"Answer the default set of widget color preferences for a graphics device, or nil 	to use the global look preferences."	| colors |	colors := (defaultWidgetColors at: (self indexParameterFor: aGraphicsDevice)) copy.	self installPlatformPreferencesFrom: aGraphicsDevice on: colors.	self installCalculatedPaintPreferencesFrom: aGraphicsDevice on: colors.	colors bindConstantCodeArray.	^colors</body></methods><methods><class-id>UI.MultiSelectionDataSetView</class-id> <category>private</category><body package="UIBasics-Datasets" selector="useSweepSelectionIndex:">useSweepSelectionIndex: anIndex	"If multiple selections are possible, add the	current selection and all indices from the	current selection to the previous selection,	to the list of selections."	| save delta list newList listHasChanged |	lastSelectionIndex = self zeroIndex		ifTrue:			[self retractAllSelections.			^self].	save := lastSelectionIndex.	selectionIndex := anIndex.	save &lt; anIndex		ifTrue: [delta := -1]		ifFalse: [delta := 1].	list := self selections copy.	newList := (anIndex to: save by: delta).	(list reject: [:each | newList includes: each]) do:		[:each |		selections remove: each ifAbsent: [].		self invalidateElementIndex: each].	(newList reject: [:each | list includes: each]) do:		[:each |		selections add: each.		self invalidateElementIndex: each].	lastSelectionIndex := save.	listHasChanged := ((list allSatisfy: [:each | newList includes: each]) and: [newList allSatisfy: [:each | list includes: each]]) not.	listHasChanged ifTrue: [self triggerEvent: #rowSelectionsChanging].	self selectionChannel value: selections.	listHasChanged ifTrue: [self triggerEvent: #rowSelectionsChanged].</body></methods><methods><class-id>UI.ColumnDraggingTracker</class-id> <category>dragging</category><body package="Interface-Events-Trackers" selector="setupForDraggingIndex:at:">setupForDraggingIndex: index at: aPoint 	| column visualBounds displayPoint |	startedDragging := true.	originalColumnIndex := columnIndex := index.	column := self view columnDescriptors at: index.	self view labelsAsButtons 		ifTrue: 			[visual := column labelAsButton.			"Ensure the column label button bounds appears topmost"			visualBounds := visual bounds.			visualBounds				top: 1;				height: visualBounds height]		ifFalse: 			[visual := column label.			visualBounds := visual bounds].	graphicsContext := self view graphicsContext copy clippingRectangle: nil.	dragDisplayOffset := startingPoint - visualBounds origin.	displayPoint := aPoint - dragDisplayOffset.	self createBasicBackingStoreAt: displayPoint from: visualBounds.	labelPixmap displayOn: graphicsContext at: displayPoint.	previousPoint := displayPoint</body></methods><methods><class-id>UI.RowLabelVisualComposite</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="displayOn:">displayOn: aGraphicsContext	| clippingBounds clippedGraphicsContext frozenColumn left right |	left := self bounds left + frozenTranslation.	clippingBounds := aGraphicsContext clippingBounds.	clippedGraphicsContext := aGraphicsContext copy.	frozen &gt; 0 ifTrue: [frozenColumn := descriptors at: frozen].	descriptors with: components		do: 			[:descriptor :visualComponent |			right := left + descriptor width.			inhibit ~~ descriptor				ifTrue: 					[| box elementBox |					elementBox := left @ bounds top corner: right @ bounds bottom.					box := elementBox insetBy: self cellInset.					visualComponent bounds: (box moveBy: descriptor offset).					visualComponent bounds left &lt; right						ifTrue: 							[| graphicsContext |							graphicsContext := clippedGraphicsContext copy.							graphicsContext intersectClip: elementBox.							visualComponent displayOn: graphicsContext.							self displayAdornment: visualComponent of: descriptor on: graphicsContext]].			left := right.			descriptor = frozenColumn				ifTrue: 					[clippingBounds left: (left max: clippingBounds left).					clippedGraphicsContext clippingRectangle: clippingBounds.					left := left - frozenTranslation]]</body></methods><methods><class-id>UI.Win95GroupBox</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayBorderOn:">displayBorderOn: aGraphicsContext 	| b |	b := self bounds copy.	b		 top: b top + (self labelHeight // 2);		 right: b right - 2;		 bottom: b bottom - 2.	b moveBy: 1 @ 1.	aGraphicsContext paint: SymbolicPaint pushButtonHilite; displayRectangularBorder: b.	b moveBy: -1 @ -1.	aGraphicsContext paint: SymbolicPaint pushButtonShadow; displayRectangularBorder: b</body></methods><methods><class-id>UI.MacOSXTabControlBarView</class-id> <category>private-displaying</category><body package="UILooks-MacOSX" selector="displayVisual:index:on:forBounds:">displayVisual: component index: i on: aGraphicsContext forBounds: elementBounds 	"Private - Display the receiver's content on aGraphicsContext and make sure it is pretty much centered"	| computedOffset |	computedOffset := component preferredBounds height &lt; elementBounds bottom		ifFalse: [0]		ifTrue: [((elementBounds bottom - component preferredBounds height) / 2) rounded - 1].	component bounds: (elementBounds insetBy: (6 @ computedOffset extent: -6 @ computedOffset negated)).	aGraphicsContext paint: self foregroundColor.	component displayOn: aGraphicsContext copy.</body></methods><methods><class-id>UI.MacOSXBeveledBorder</class-id> <category>displaying</category><body package="UILooks-MacOSX" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRectangle using: colorSource 	"Display the receiver's borders in the specified display box.	Be sure not to permanently side-effect the supplied GraphicsContext.	Only draw colors on the outside, and a full rectangle in black on the inside."	| insideRectangle clipRectangle paint oldPaint paintSet |	clipRectangle := aGraphicsContext clippingBounds.	((self insetDisplayBoxFor: aRectangle) contains: clipRectangle)		ifTrue: [^self].	oldPaint := aGraphicsContext paint.	insideRectangle := aRectangle copy extent: aRectangle extent - 1.	paint := self topPaintFor: colorSource.	paintSet := false.	(insideRectangle intersects: clipRectangle) ifTrue: 		[paintSet := true.		aGraphicsContext paint: paint; displayLineFrom: insideRectangle topLeft to: insideRectangle bottomLeft].	(insideRectangle intersects: clipRectangle) ifTrue: 		[paintSet ifFalse: [aGraphicsContext paint: paint].		aGraphicsContext displayLineFrom: insideRectangle topLeft to: insideRectangle topRight].	paint := ColorValue white.	paintSet := false.	(insideRectangle intersects: clipRectangle) ifTrue: 		[paintSet := true.		aGraphicsContext paint: paint; displayLineFrom: insideRectangle bottomLeft to: insideRectangle bottomRight].	(insideRectangle intersects: clipRectangle) ifTrue: 		[paintSet ifFalse: 			[paintSet := true.			aGraphicsContext paint: paint].		aGraphicsContext displayLineFrom: insideRectangle bottomRight to: insideRectangle topRight].	insideRectangle := insideRectangle insetBy: 1.	aGraphicsContext paint: ColorValue black.	aGraphicsContext displayRectangularBorder: insideRectangle.	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.DataSetColumnSpec</class-id> <category>private</category><body package="UIBuilder-Specifications" selector="capitalizeFirstLetterOn:">capitalizeFirstLetterOn: aString	| newString |	aString isEmpty ifTrue: [^aString].	newString := aString copy.	newString at: 1 put: ((aString at: 1) asUppercase).	^newString</body></methods><methods><class-id>UI.DataSetColumnSpec</class-id> <category>private</category><body package="UIBuilder-Specifications" selector="camelCase:">camelCase: aStringOrSymbol	| tokens result |	aStringOrSymbol isNil ifTrue: [^'_' copy].	aStringOrSymbol isEmpty ifTrue: [^aStringOrSymbol].	tokens := aStringOrSymbol asString tokensBasedOn: (Character space).	result := tokens inject: (String new) into: [:subTotal :next | subTotal,  (self capitalizeFirstLetterOn: next)].	result at: 1 put: (result at: 1) asLowercase.	^result</body></methods><methods><class-id>UI.DataSetColumnSpec</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	"width is a value holder, we want to copy it also"	super postCopy.	width := width copy</body></methods><methods><class-id>UI.DataSetSpec</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	"Take care of copying the columns also"	super postCopy.	columns notNil ifTrue: [columns := columns collect: [:col | col copy]]</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>private</category><body package="UIBasics-Components" selector="simpleRedisplay">simpleRedisplay	| gc |	state isVisible ifFalse: [^self].	state isOccluded ifTrue: [^self invalidateRectangle: self bounds repairNow: true].	self isOpen ifFalse:[^self].	gc := self graphicsContext.	gc medium supportsInvalidation ifFalse: [^self].	gc medium hasOutstandingDamage ifTrue: [^self invalidateRectangle: self bounds repairNow: true].	(state isOpaque or: [state hasBackgroundColor]) 		ifFalse: [gc copy				paint: self backgroundColor;				displayRectangle: self bounds].	self displayOn: gc</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayTextIn:on:">displayTextIn: aRectangle on: gc	"Display the receiver's text that intersects aRectangle on GraphicsContext gc.	Show all text whether selected or not in one pass."	| first last ss es x lineRange |	gc paint: self foregroundColor.	(self displaySelection not or: [selectionShowing not])		ifTrue: [^self displayObject displayOn: gc copy at: self displayOrigin].	displayContents numberOfLines = 0		ifTrue: [^self displayInsertionPointFor: self startBlock on: gc].	lineRange := displayContents				lineRangeFor: (aRectangle translatedBy: self displayOrigin negated).	first := (displayContents lineAt: lineRange first) first.	last := (displayContents lineAt: lineRange last) last.	x := self displayOrigin x.	ss := self startBlock stringIndex.	es := self stopBlock stringIndex.	((ss &gt; last or: [es &lt; first]) or: [ss = es])		ifTrue: 			[self displayObject displayOn: gc copy at: self displayOrigin.			^self displayInsertionPointFor: self startBlock on: gc].	ss &gt; first		ifTrue: 			[gc paint: self foregroundColor.			self displayFromCharacter: first to: ss - 1 startX: x on: gc.			first := ss.			x := self startBlock left].	self showSelectionBoxOn: gc within: aRectangle.	gc paint: self selectionForegroundColor.	last &lt; es		ifTrue: 			[self displayFromCharacter: first to: last startX: x on: gc]		ifFalse: 			[self displayFromCharacter: first to: es - 1 startX: x on: gc.			gc paint: self foregroundColor.			x := self stopBlock left.			self displayFromCharacter: es to: last startX: x on: gc]</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>private</category><body package="UIBasics-Components" selector="redisplayAfterReplacementAt:affectedLines:lineDelta:">redisplayAfterReplacementAt: startLine affectedLines: affectedLines lineDelta: lineDelta	"Redisplay the receiver after a change starting at startLine. 	The argument affectedLines is the number of lines that need to be redisplayed. 	The argument lineDelta has the change in total lines. 	This method uses scrolling and only works for tiled views."	| visibleRectangle  stopLine gc |	gc := self graphicsContext.	visibleRectangle := self clippingBox.	self displayObject numberOfLines = 0  ifTrue: [^self simpleRedisplay].	stopLine := startLine + affectedLines - 1.	lineDelta = 0		ifTrue:	[gc paint: self backgroundColor.				gc intersectClip: (visibleRectangle := self							visibleRectangleFrom: startLine							to: stopLine).				gc displayRectangle: visibleRectangle.				gc paint: self foregroundColor.				self displayOn: gc]		ifFalse: [ | obsoleteY newY moveRectangle gc2 rectList |				lineDelta &gt; 0					ifTrue: [obsoleteY := self displayObject topAtLineIndex: startLine+(affectedLines - lineDelta max: 0)]					ifFalse: [obsoleteY := self displayObject topAtLineIndex: startLine + lineDelta negated].				newY := obsoleteY + (self lineGrid * lineDelta).				moveRectangle := self computeMoveRectangleFor: visibleRectangle old: obsoleteY new: newY.				gc2 := gc copy.				gc2 intersectClip: visibleRectangle.				rectList := gc2					copyArea: moveRectangle					from: gc2					sourceOffsetX: 0 y: 0					destinationOffsetX: 0 y: ((newY max: visibleRectangle top) - moveRectangle top).					1 to: rectList size  do:						[:j | self redisplayRectangle: ((rectList at: j) intersect: visibleRectangle) on: gc2].	 			self redisplayRectangle: (self visibleRectangleFrom: startLine to: stopLine) on: gc.				lineDelta &lt; 0					ifTrue: [| rr|							rr := visibleRectangle left@((newY+ moveRectangle height) max: visibleRectangle top)									corner: visibleRectangle corner.							self redisplayRectangle: rr on: gc]]</body></methods><methods><class-id>UI.UISettings class</class-id> <category>user preferences</category><body package="Interface-Support" selector="addVWToolsSectionTo:development:runtime:">addVWToolsSectionTo: aDictionary development: devSpecs runtime: runtimeSpecs	"Add the core set of preferences and settings slices to the arguments."	"UISettings updateAllPreferences"	aDictionary		at: #fileOutType			put: (self preferenceModelFor: #fileOutType default: #ChunkSourceFileFormat);		at: #sources			put: List new asValue;		at: #sourcesEditing			put: List new asValue asValue;		at: #sourceAccept			put: [self sourceAccept];		at: #sourceReset			put: [self sourceReset];		at: #sourceDirs			put: List new asValue;		at: #sourceDirsEditing			put: List new asValue asValue;		at: #sourceDirsAccept			put: [self sourceDirsAccept];		at: #sourceDirsReset			put: [self sourceDirsReset];		at: #parcelPath			put: Parcel searchPathModel;		at: #parcelPathEditing			put: Parcel searchPathModel value copy asValue;		at: #parcelPathAccept			put: [self parcelPathAccept];		at: #parcelPathReset			put: [self parcelPathReset].	devSpecs		add: (#SourceFiles &lt;&lt; #labels &gt;&gt; 'Source Files')-&gt;#(#sourcesSpec #sourcesHelp);		add: (#SourceDirs &lt;&lt; #labels &gt;&gt; 'Source Dirs')-&gt;#(#sourceDirsSpec #sourceDirsHelp);		add: (#ParcelPath &lt;&lt; #labels &gt;&gt; 'Parcel Path')-&gt;#(#parcelPathSpec #parcelPathHelp);		add: (#Messages &lt;&lt; #labels &gt;&gt; 'Messages') -&gt; #(#messagesSpec #messagesHelp).	runtimeSpecs		add: (#Messages &lt;&lt; #labels &gt;&gt; 'Messages') -&gt; #(#messagesSpec #messagesHelp)</body></methods><methods><class-id>UI.UISettings class</class-id> <category>class initialization</category><body package="Interface-Support" selector="updateAllPreferences">updateAllPreferences	"Update the preferences and setting specs."	| devSpecs runSpecs |	PrevPreferences := UserPreferences copy.	TempPreferences := Dictionary new: 100.	devSpecs := OrderedCollection new: 50.	runSpecs := OrderedCollection new: 10.	PreferenceInitializers do: [:sel|		(self respondsTo: sel)			ifTrue:				[self perform: sel with: TempPreferences with: devSpecs with: runSpecs]			ifFalse:				[UserNotification raiseSignal: ((#noSuchMessageAs1s &lt;&lt; #dialogs &gt;&gt; 'no such message as &lt;1s&gt;')			expandMacrosWith: sel)]].	UserPreferences isNil ifTrue:		[UserPreferences := Dictionary new: TempPreferences size * 2].	"Update UserPreferences."	TempPreferences associationsDo: [:assoc| UserPreferences add: assoc].	"Now remove all the old preferences."	(UserPreferences keys reject: [:k| TempPreferences includesKey: k]) do:		[:k| UserPreferences removeKey: k].	"Now substitute the new spec lists"	DevelopmentSpecList := devSpecs asArray.	RuntimeSpecList := runSpecs asArray.	"and erase PrevPreferences and TempPreferences."	PrevPreferences := TempPreferences := nil	"UISettings updateAllPreferences"</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="Interface-Support" selector="sourceDirsReset">sourceDirsReset	| list |	list := (self preferenceModelFor: #sourceDirs) value.	list removeAllSuchThat: [:ign| true].	list addAll: (SourceFileManager default sourceFileDirectories collect: [:ea| ea asString]) asSortedStrings.	(self preferenceModelFor: #sourceDirsEditing) value: list copy</body></methods><methods><class-id>UI.DocumentView</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayOn:">displayOn: aGraphicsContext	"Draw the content background and foreground that is visible."	self isVisible ifFalse: [^self].	self displayBackgroundIfNeededOn: aGraphicsContext.	aGraphicsContext clientData: settings copy.	aGraphicsContext translateBy: margin topLeft.	self displayLineBackgroundsOn: aGraphicsContext.	self displaySelectionOn: aGraphicsContext.	self displayLinesOn: aGraphicsContext.	self displayCursorOn: aGraphicsContext</body></methods><methods><class-id>UI.DocumentView</class-id> <category>updating</category><body package="UIBasics-Text2" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender	aSender == model ifTrue: [		preferredX := 0.		inputCursor := anchorCursor := 0 @ 1.		currentEditState := nil.		document := model value copy asDocument.		flow document: document.		currentStyle := flow styleAtCursor: inputCursor ifAbsent: [DocumentStyle default].		self changedPreferredBounds: self preferredBounds.		self initializeHistory.		self invalidate].	super update: anAspectSymbol with: aParameter from: aSender</body></methods><methods><class-id>UI.DocumentView</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayLineBackgroundsOn:">displayLineBackgroundsOn: aGraphicsContext	"Draw the visible line backgrounds."	| clippingBounds gc showLineStriping |	showLineStriping := self showLineStriping.	clippingBounds := aGraphicsContext clippingBounds.	gc := aGraphicsContext copy.	flow linesIntersecting: clippingBounds do: [:line |		gc translation: aGraphicsContext translation + (0 @ line top).		(showLineStriping and: [line number even]) ifTrue: [			self showLineStripingColor installOn: gc.			gc displayRectangle: ((margin left negated @ 0) extent: ((self flow pageExtent x + margin left) @ line bounds height))].		line displayBackgroundOn: gc]</body></methods><methods><class-id>UI.DocumentView</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayBackgroundIfNeededOn:">displayBackgroundIfNeededOn: aGraphicsContext	| gc |	(widgetState isOpaque or: [settings includesKey: #backgroundColor]) ifFalse: [^self].	gc := aGraphicsContext copy.	gc paint: self backgroundColor.	gc displayRectangle: self bounds</body></methods><methods><class-id>UI.DocumentView</class-id> <category>private</category><body package="UIBasics-Text2" selector="setModel:">setModel: aModel	document := aModel value copy asDocument.	flow := Flow device: self graphicsDevice document: document pageExtent: self pageExtent.	inputCursor := anchorCursor := self defaultCursorPosition.	super setModel: aModel</body></methods><methods><class-id>UI.DocumentView</class-id> <category>actions - editing</category><body package="UIBasics-Text2" selector="cancel">cancel	"Copy the value model in to the widget, discarding the current changes."	self document: model value copy asDocument.	self forget</body></methods><methods><class-id>UI.DocumentView</class-id> <category>actions - clipboard</category><body package="UIBasics-Text2" selector="clipboardCopy">clipboardCopy	"Copy the current selection in to the clipboard."	&lt;state: #active command: #copy&gt;	&lt;state: #activeReadOnly command: #copy&gt;	flow isForPasswords ifTrue: [^self].	currentEditState := #copy.	Screen default putExternalSelection: self selection asString</body></methods><methods><class-id>UI.DocumentView</class-id> <category>actions - editing</category><body package="UIBasics-Text2" selector="accept">accept	"Copy the current document content in to the value model."	&lt;state: #active command: #accept&gt;	model == nil ifTrue: [^self].	model removeDependent: self.	model value: document copy.	model addDependent: self.</body></methods><methods><class-id>UI.DocumentView</class-id> <category>events - mouse</category><body package="UIBasics-Text2" selector="mouseRightDown:">mouseRightDown: event	"Open the right click popup menu."	&lt;state: #inactive event: #Button2Down&gt;	&lt;state: #active event: #Button2Down&gt;	&lt;state: #activeReadOnly event: #Button2Down&gt;	| menuView valueResult segment mergedMenu |	self hasFocus ifFalse: [self takeKeyboardFocus].	self invalidateSelectionWhile: [self selectContentUnderMenu: event].	segment := flow segmentAtPixel: (self globalPointToLocal: event point) ifAbsent: [nil].	self hasMenu		ifTrue: [			mergedMenu := self menu copy.			segment == nil ifFalse: [				segment menu menuItems do: [:each | mergedMenu addItem: each]]]		ifFalse: [			segment == nil ifTrue: [^self].			mergedMenu := segment menu].	mergedMenu menuItems isEmpty ifTrue: [^self].	self setDynamicPropertiesOn: mergedMenu.	menuView := self widgetPolicy menuViewForMenu: mergedMenu.	valueResult := menuView openFromView: self.	valueResult ifNotNil: [		self invalidateSelectionWhile: [			| performer |			performer := (valueResult truePerformerFor: self) ifNil: [controller menuMessageReceiver].			valueResult value cull: performer]]</body></methods><methods><class-id>UI.DocumentView</class-id> <category>displaying</category><body package="UIBasics-Text2" selector="displayLinesOn:">displayLinesOn: aGraphicsContext	"Draw the visible lines."		| clippingBounds gc selectionStartPosition selectionStopPosition nativeGUIPolicy |	selectionStartPosition := self selectionStartPosition.	selectionStopPosition := self selectionStopPosition.	clippingBounds := aGraphicsContext clippingBounds.	gc := aGraphicsContext copy.	"Determine if we must apply a selection foreground to our text when selected."	nativeGUIPolicy := flow device nativeGUIPolicy.	nativeGUIPolicy shouldUseSelectedTextForegroundColor ifTrue: [		gc clientDataAt: #selectionForegroundColor ifAbsent: [			gc clientDataAt: #selectionForegroundColor put: (nativeGUIPolicy selectedTextForegroundColorFocused: self isFocused)]].	flow linesIntersecting: clippingBounds do: [:line |		gc translation: aGraphicsContext translation + (0 @ line top).		line displayOn: gc selectingBetween: selectionStartPosition and: selectionStopPosition]</body></methods><methods><class-id>UI.DocumentView</class-id> <category>initialize-release</category><body package="UIBasics-Text2" selector="defaultShowLineNumbersStyle">defaultShowLineNumbersStyle	^DocumentStyle default copy		color: (ColorValue brightness: 0.33);		intern</body></methods><methods><class-id>UI.DocumentView class</class-id> <category>resources</category><body package="UIBasics-Text2" selector="standardViewMenu">standardViewMenu	"Tools.MenuEditor new openOnClass: self andSelector: #standardViewMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Copy' 				#nameKey: #copy 				#value: #clipboardCopy 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editCopy ) 				#command: #copy ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find...' 				#nameKey: #find 				#value: #find 				#command: #find ) ) #(1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.DocumentView class</class-id> <category>resources</category><body package="UIBasics-Text2" selector="standardEditMenu">standardEditMenu	"Tools.MenuEditor new openOnClass: self andSelector: #standardEditMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Accept' 				#nameKey: #accept 				#value: #accept 				#enablementSelector: #canAccept 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 'Undo' 				#nameKey: #undo 				#value: #undo 				#enablementSelector: #canUndo 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editUndo ) 				#command: #undo ) 			#(#{UI.MenuItem} 				#rawLabel: 'Redo' 				#nameKey: #redo 				#value: #redo 				#enablementSelector: #canRedo 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editRedo ) 				#command: #redo ) 			#(#{UI.MenuItem} 				#rawLabel: 'Cut' 				#nameKey: #cut 				#value: #clipboardCut 				#enablementSelector: #canCut 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editCut ) 				#command: #cut ) 			#(#{UI.MenuItem} 				#rawLabel: 'Copy' 				#nameKey: #copy 				#value: #clipboardCopy 				#enablementSelector: #canCopy 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editCopy ) 				#command: #copy ) 			#(#{UI.MenuItem} 				#rawLabel: 'Paste' 				#nameKey: #paste 				#value: #clipboardPaste 				#enablementSelector: #canEdit 				#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #editPaste ) 				#command: #paste ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find...' 				#nameKey: #find 				#value: #find 				#enablementSelector: #canFind 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 'Replace...' 				#nameKey: #replace 				#value: #findAndReplace 				#enablementSelector: #canReplace 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 'Cancel' 				#nameKey: #cancel 				#value: #cancel ) ) #(1 2 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.SpecCollection</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	| new |	super postCopy.	new := Array new: collection size.	1 to: collection size do:		[:i |		new at: i put: (collection at: i) copy].	collection := new</body></methods><methods><class-id>UI.WidgetWrapper</class-id> <category>visual properties</category><body package="UIBuilder-Support" selector="lookPreferences">lookPreferences	| lookPreferences |	(lookPreferences := self getLookPreferences) == nil ifFalse: 		[^widget sharesParentLookPreferences			ifTrue: [lookPreferences applyTo: super lookPreferences copy]			ifFalse: [lookPreferences]].	^super lookPreferences</body></methods><methods><class-id>UI.Win95VariableBorder</class-id> <category>private-displaying</category><body package="UILooks-MSWin" selector="displayFrameOn:in:paint1:paint2:">displayFrameOn: aGraphicsContext in: rect paint1: paint1 paint2: paint2 	"Private - Display a frame in rect using paint1 for left and top 	and paint2 for bottom and right sides of the frame."	aGraphicsContext paint: paint1.	self hasLeft ifTrue: [aGraphicsContext displayRectangle: (rect copy right: rect left + 1)].	self hasTop ifTrue: [aGraphicsContext displayRectangle: (rect copy bottom: rect top + 1)].	aGraphicsContext paint: paint2.	self hasBottom ifTrue: [aGraphicsContext displayRectangle: (rect copy top: rect bottom - 1)].	self hasRight ifTrue: [aGraphicsContext displayRectangle: (rect copy left: rect right - 1)]</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>event driven</category><body package="UIBasics-Support" selector="completeSelectionWithPrevStart:prevStop:pivotBlock:showingCaret:">completeSelectionWithPrevStart: prevStartBlock prevStop: prevStopBlock pivotBlock: pivotBlock showingCaret: showingCaret 	| strt gc word |	view isOpen ifFalse: [^self].	gc := view graphicsContext.	(strt := view startBlock) = view stopBlock 		ifTrue: 			[showingCaret ifFalse: [view displayInsertionPointFor: strt on: gc copy].			(prevStartBlock = prevStopBlock and: [prevStartBlock = strt]) 				ifTrue: 					["select a word or bracketed range"					word := self selectWord: pivotBlock stringIndex.					word first = word last 						ifFalse: 							[view hideInsertionPointFor: strt on: gc copy.							self selectionStartIndex: word first stopIndex: word last.							view 								displaySelectionFrom: view startBlock								to: view stopBlock								on: gc]]].	gc flush.	self setEmphasisHere.	self view updateSpot: #mouse</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>menu messages</category><body package="UIBasics-Support" selector="cut">cut	"Remove the current selection and, if non-empty, place it in the paste buffer"	| cur |	self resetTypein.	 self selectionStartIndex = self selectionStopIndex		ifTrue: [^self].	self deselect.	self replaceSelectionWith: Text new.	self selectAndScroll.	cur := self undoSelection copy.	self currentSelection: cur.</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>event driven</category><body package="UIBasics-Support" selector="setUpShiftDownSelectionAt:">setUpShiftDownSelectionAt: aPoint 	"Shift is down and there is a selection; extend it"	| gc prevStartBlock prevStopBlock currentBlock pivotBlock |	gc := view graphicsContext.	prevStartBlock := view startBlock.	prevStopBlock := view stopBlock.	currentBlock := view characterBlockAtPoint: aPoint.	self resetTypein.	prevStartBlock = prevStopBlock ifTrue: [view deselect].	pivotBlock := (currentBlock stringIndex - prevStartBlock stringIndex) abs &gt; (currentBlock stringIndex - prevStopBlock stringIndex) abs				ifTrue: ["extend the end of the selection closest to the current 					cursor position"					prevStartBlock]				ifFalse: [prevStopBlock].	self		updateSelectionWith: currentBlock		usingPivot: pivotBlock		on: gc copy.	anchorIndex := pivotBlock stringIndex.	view selectionShowing: true.	gc flush.	^pivotBlock</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>event driven</category><body package="UIBasics-Support" selector="trackSelectionFrom:to:pivotBlock:showingCaret:">trackSelectionFrom: currentBlock to: newPoint pivotBlock: pivotBlock showingCaret: aBoolean 	| showingCaret pt dy gc nextBlock |	showingCaret := aBoolean.	gc := view graphicsContext.	pt := newPoint.	(dy := self dyForPoint: pt) ~= 0		ifTrue: 			[dy := dy abs &lt; view lineGrid						ifTrue: [dy sign * view lineGrid]						ifFalse: [dy truncateTo: view lineGrid].			view scrollBy: 0 @ dy negated.			gc translateBy: 0 @ dy negated.			pt := dy &lt; 0						ifTrue: [view bounds topLeft]						ifFalse: [view bounds bottomLeft].			self checkForEvents].	nextBlock := view characterBlockAtPoint: pt.	nextBlock = currentBlock		ifFalse: 			[showingCaret				ifTrue: 					[view hideInsertionPointFor: pivotBlock on: gc copy.					showingCaret := false].			self				updateSelectionWith: nextBlock				usingPivot: pivotBlock				on: gc copy.			self selectionStartIndex = self selectionStopIndex				ifTrue: 					[view displayInsertionPointFor: pivotBlock on: gc copy.					showingCaret := true].			gc flush].	^showingCaret</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>event driven</category><body package="UIBasics-Support" selector="setUpSelectionAt:">setUpSelectionAt: aPoint 	| gc currentBlock pivotBlock |	gc := view graphicsContext.	currentBlock := view characterBlockAtPoint: aPoint.	view deselect.	self setSelectionStartAndResetTypein.	pivotBlock := currentBlock.	anchorIndex := pivotBlock stringIndex.	view startBlock: pivotBlock.	view stopBlock: pivotBlock.	view displayInsertionPointFor: pivotBlock on: gc copy.	view selectionShowing: true.	gc flush.	^pivotBlock</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>private</category><body package="UIBasics-Support" selector="silentCut">silentCut	"Remove the current selection and place it in the paste buffer.  Do not	affect visual selection."	| currentSelection |	self replaceSelectionWith: Text new.	currentSelection := self undoSelection copy.	self currentSelection: currentSelection.</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>menu messages</category><body package="UIBasics-Support" selector="cancel">cancel	"Restore the text of the paragraph to be the text saved since initialization or	the last accept."	self undoSelection: self text copy.	view updateDisplayContents</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>menu messages</category><body package="UIBasics-Support" selector="accept">accept	"Save the current text of the text being edited as the current acceptable	version for purposes of canceling."	self textHasChanged: false.	model value: self text copy</body></methods><methods><class-id>UI.ParagraphEditor class</class-id> <category>resources</category><body package="UIBasics-Support" selector="editGroup">editGroup	"Tools.MenuEditor new openOnClass: self andSelector: #editGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) 				#value: #cut				#command: #cut ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#value: #copySelection				#command: #copy ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) 				#value: #paste				#command: #paste ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#value: #find				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ReplaceDot 					#defaultString: 'Replace...' 					#catalogID: #menus ) 				#value: #replace				#command: #replace ) ) #(3 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.ParagraphEditor class</class-id> <category>resources</category><body package="UIBasics-Support" selector="readOnlyGroup">readOnlyGroup	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(#(#{UI.MenuItem}		#rawLabel: #(#{Kernel.UserMessage}			#key: #Copy			#defaultString: 'Copy'			#catalogID: #menus)		#nameKey: #copySelection		#value: #copySelection		#command: #copy		#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy)) #(#{UI.MenuItem}		#rawLabel: #(#{Kernel.UserMessage}			#key: #FindDot			#defaultString: 'Find...'			#catalogID: #menus)		#nameKey: #find		#value: #find #command: #find) #(#{UI.MenuItem}		#rawLabel: #(#{Kernel.UserMessage}			#key: #FindAgain			#defaultString: 'Find Again'			#catalogID: #menus)		#nameKey: #findNext		#value: #findNext #command: #findNext) #(#{UI.MenuItem}		#rawLabel: #(#{Kernel.UserMessage}			#key: #SelectAll			#defaultString: 'Select All'			#catalogID: #menus)		#nameKey: #selectEntireText		#value: #selectEntireText #command: #selectAll)) #(1 2 1) nil) decodeAsLiteralArray</body></methods><methods><class-id>UI.Menu</class-id> <category>copying</category><body package="Interface-Menus" selector="postCopy">postCopy	"Finish doing whatever is required, beyond a shallowCopy, to implement 'copy'."	adornment := adornment copy.	items := items collect: [:each | each copy].	groupSizes := groupSizes copy.	self values: self values copy</body></methods><methods><class-id>UI.Menu</class-id> <category>accessing</category><body package="Interface-Menus" selector="augmentFrom:to:menuName:for:">augmentFrom: startClass to: stopClass menuName: name for: definer	| tested class new generator bad oldSize err |	(startClass includesBehavior: stopClass)		ifFalse: 			[(MenuAugmentationError new)				isResumable: false;				messageText: #startStopClass &lt;&lt; #dialogs							&gt;&gt; 'startClass must be same as, or subclass of, stopClass';				raiseSignal].	generator := (MenuAutomaticGenerator new)				menuName: name;				menuDefiner: definer;				yourself.	tested := Set new.	class := startClass.	(items size &gt; 0 and: [items first position == nil])		ifTrue: [self assignBasePositions].	new := List new.	[class == stopClass superclass] whileFalse: 			[class selectorsAndMethodsDo: 					[:sel :meth |					(tested includes: sel)						ifFalse: 							[tested add: sel.							new addAll: (self										menuItems: meth attributeMessages										with: sel										forMenu: generator)]].			class := class superclass].	bad := OrderedCollection new.	oldSize := 0.	[new isEmpty or: [new size = oldSize]] whileFalse: 			[oldSize := new size.			new copy do: 					[:itm |					| mnu |					mnu := self.					(itm at: 2) do: 							[:key |							mnu == nil ifFalse: [mnu := mnu atNameKey: key].							mnu == nil ifFalse: [mnu := mnu submenu]].					mnu == nil						ifFalse: 							[new remove: itm.							[mnu addItem: (itm at: 1) atPosition: (itm at: 3)] on: Error								do: 									[:ex |									bad add: itm -&gt; ex.									nil]]]].	new isEmpty		ifFalse: 			[(err := MenuAugmentationError new)				messageText: #errNoSubmenu &lt;&lt; #dialogs &gt;&gt; 'intended submenu does not exist';				parameter: (new collect: [:itm | itm -&gt; err]);				raiseSignal].	bad isEmpty		ifFalse: 			[(MenuAugmentationError new)				parameter: bad;				raiseSignal].	definer notNil ifTrue: [self findGuiResourcesIn: definer]</body></methods><methods><class-id>UI.Menu class</class-id> <category>privileged</category><body package="Interface-Menus" selector="decodeFromLiteralArray:">decodeFromLiteralArray: anArray	"Return a menu based on the information encoded in anArray.  Sent from privileged senders outside the class."	| items values |	items := (anArray at: 2) collect: [:e | e decodeAsLiteralArray].	values := (anArray at: 4).	values ~~ nil ifTrue: [		values := values collect: [:e | e decodeAsLiteralArray]].	^self new menuItems: items menuItemGroups: (anArray at: 3) copy values: values</body></methods><methods><class-id>UI.UISpecification</class-id> <category>properties</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	super postCopy.	properties := properties copy</body></methods><methods><class-id>UI.UISpecification</class-id> <category>private-labels</category><body package="UIBuilder-Specifications" selector="defaultLabelIn:key:">defaultLabelIn: aBuilder key: aKey	aKey == nil ifTrue: [^nil].	^self hasCharacterOrientedLabel		ifTrue: [aKey copy]		ifFalse: [aBuilder visualAt: #emptyImage]</body></methods><methods><class-id>UI.MenuBar</class-id> <category>displaying</category><body package="UIBasics-Components" selector="displayBackgroundOn:">displayBackgroundOn: aGraphicsContext	aGraphicsContext copy		paint: self backgroundColor;		displayRectangle: self bounds.</body></methods><methods><class-id>UI.Win95BorderDecorationPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayDownButtonPressedOn:bounds:">displayDownButtonPressedOn: aGraphicsContext bounds: box	"Display a down button on aGraphicsContext."		self clearInsideOn: aGraphicsContext bounds: box.	(aGraphicsContext copy)		paint: SymbolicPaint pushButtonBorder;		displayInteriorRectangularBorder: box.	DownArrow		displayOn: aGraphicsContext		at: box center - (DownArrow bounds extent half) + (0 @ 1)</body></methods><methods><class-id>UI.Win95BorderDecorationPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayUpButtonPressedOn:bounds:">displayUpButtonPressedOn: aGraphicsContext bounds: box	"Display an up button on aGraphicsContext."		self clearInsideOn: aGraphicsContext bounds: box.	(aGraphicsContext copy)		paint: SymbolicPaint pushButtonBorder;		displayInteriorRectangularBorder: box.	UpArrow		displayOn: aGraphicsContext		at: box center - (UpArrow bounds extent half) + (0 @ 1)</body></methods><methods><class-id>UI.Win95BorderDecorationPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayRightButtonPressedOn:bounds:">displayRightButtonPressedOn: aGraphicsContext bounds: box	"Display a right button on aGraphicsContext."		self clearInsideOn: aGraphicsContext bounds: box.	(aGraphicsContext copy)		paint: SymbolicPaint pushButtonBorder;		displayInteriorRectangularBorder: box.	RightArrow		displayOn: aGraphicsContext		at: box center - (RightArrow bounds extent half) + (1 @ 0)</body></methods><methods><class-id>UI.Win95BorderDecorationPolicy class</class-id> <category>private</category><body package="UILooks-MSWin" selector="displayLeftButtonPressedOn:bounds:">displayLeftButtonPressedOn: aGraphicsContext bounds: box	"Display a left button on aGraphicsContext."		self clearInsideOn: aGraphicsContext bounds: box.	(aGraphicsContext copy)		paint: SymbolicPaint pushButtonBorder;		displayInteriorRectangularBorder: box.	LeftArrow		displayOn: aGraphicsContext		at: box center - (DownArrow bounds extent half) + (1 @ 0)</body></methods><methods><class-id>UI.TreeViewIndentedLabelAndIcon</class-id> <category>bounds accessing</category><body package="UIBasics-Support" selector="bounds">bounds	| b |	b := self preferredBounds copy.	b height: (boundsHeight max: b height).	^b</body></methods><methods><class-id>UI.MacOSXComboBoxButtonView class</class-id> <category>class initialization</category><body package="UILooks-MacOSX" selector="initialize">initialize	"MacOSXComboBoxButtonView  initialize."	| maskPalette mbImg |	maskPalette := CoveragePalette monoMaskPalette.	mbImg := Image				extent: 16 @ 12				depth: 1				palette: maskPalette				bits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 15 248 0 0 7 240 0 0 3 224 0 0 1 192 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0]				pad: 32.	MenuButtonMask := CachedImage on: mbImg.	self initializeMasks.	TopPart := Image				extent: 22 @ 16				depth: 15				bitsPerPixel: 16				palette: (Graphics.FixedPalette						redShift: 10						redMask: 31						greenShift: 5						greenMask: 31						blueShift: 0						blueMask: 31)				usingBits: (ByteArray						fromPackedString: 'BSDILP$1BSDILP$1BSDILP$1BSDILP$1BSDILP$1BSDILP$1BSE;7''/^^=9N6%L\T11SGEL\T11SGEL\T11SGEL\T11SGEL\T11SGF\9H[PQK0$1IP17/TJYU/)V&gt;%[:U/)V&gt;%[:U/)V&gt;%[:U/)V&gt;%[:U/)V&gt;%[:U/)+V"V8BODD,W/^O''!F7D[\Q-1F7D[\Q-1F7D[\Q-1F7D[\Q-1F7D[\Q-1F7D[\K%(MM@B0R%H.E#):N''(:^#):N''(:^#):N''(:^#):N''(:^#):N''(:^#):N''(.N1EV@KEJT"WTL%$2VSIYL%$2VSIYL%$2VSIYL%$2VSIYL%$2VSIYL%$2VRW9DU\D&lt;$)RI]T2^3Y;L'',6^3I;M'',2^3I;L'',2^3I;L'',2^3Y;L'',6^3I;G]$U&amp;@$TR%H)=S*=N+4:/S*=N+4:/S*=N+4:/S*=N+4:/S*=N+4:/S*=N+4"F!''YCSUJT"''6N+8:/S*&gt;N+4:/#*=N+8:/S*&gt;N+4:/#*=N+8:/S*&gt;N+4:/"X:H_$QU$)RL!\&gt;7#;^O-8&gt;7#;^O-8&gt;7#;^O-8&gt;7#;^O-8&gt;7#;^O-8&gt;7#;^J%(&amp;F!E7R%H6^T\_Q1=GG4\_Q1=GG4\_Q1=GG4\_Q1=GG4\_Q1=GG4\_Q1&lt;.^"XZF[!JT#*YR3=KO4,?R3=KO4,?R3=KO4,?R3=KO4,?R3=KO4,?R3=KO3Z&gt;K''4Y.D)RO+)OW4=_S5=OW4=_S5=OW4=_S5=OW4=_S5=OW4=_S5=OW4=_M+8.WA&amp;8R%H&gt;6$=?S7=O_4=?S7=O_4=?S7=O_4=?S7=O_4=?S7=O_4=?S7&lt;:73J^H_%JT$KZT9=S''5N_T9=S''5N_T9=S''5N_T9=S''5N_T9=S''5N_T9=S''3;?M+&lt;!&gt;T)RQ/)W/5^?U;=W/5^?U;=W/5^?U;=W/5^?U;=W/5^?U;=W/5^?O1&lt;6/17XR%Hb').	MiddlePart := Image				extent: 22 @ 1				depth: 15				bitsPerPixel: 16				palette: (Graphics.FixedPalette						redShift: 10						redMask: 31						greenShift: 5						greenMask: 31						blueShift: 0						blueMask: 31)				usingBits: #[71 26 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 87 223 67 63 54 191 29 216 74 82]						copy.	BottomPart := Image				extent: 22 @ 3				depth: 15				bitsPerPixel: 16				palette: (Graphics.FixedPalette						redShift: 10						redMask: 31						greenShift: 5						greenMask: 31						blueShift: 0						blueMask: 31)				usingBits: #[75 59 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 67 63 46 126 29 216 74 82 67 25 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 91 223 107 90 46 88 74 82 123 222 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 49 140 74 82 127 255 127 255]						copy.	#(#TopPart #MiddlePart #BottomPart) do: 			[:sym |			self asNameSpace at: sym				put: (Graphics.CachedImage on: (self asNameSpace at: sym) rendered: nil)].	self initializeCaches.	MacOSXMenuButtonView initializeCaches</body></methods><methods><class-id>UI.TreeView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayElement:on:forBounds:">displayElement: i on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component childGC |	component := (self isSelected: i)				ifTrue: [self selectedVisualComponentForElementIndex: i]				ifFalse: [self visualComponentForElementIndex: i].	"This is perverse, but now that we're actually going to display the component, 	 we need to fish back into the TreeNodeWrapper and set the cached lastLabel	 so we can detect clicks on the expand/contract icons."	component component treeNodeWrapper		ifNotNil: [:node | node lastLabel: component bottomComponent].	component bounds: elementBounds.	(targetIndex = i and: [self hasFocus])		ifTrue: [component component highlighted setValue: true].	self displayBackgroundOn: aGraphicsContext in: elementBounds.	displayingObject := sequence at: i.	childGC := aGraphicsContext copy.	childGC lineGrid: self lineGrid.	component displayOn: childGC.	displayingObject := nil</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>private - scrolling</category><body package="Interface-Support" selector="scrollBy:on:grid:">scrollBy: pointToMove on: aGraphicsContext grid: grid	"Scroll the receiver by pointToMove modulo the grid." 	| clippingBox moveBox copyGC rects t |	clippingBox := self clippingBounds intersect: aGraphicsContext clippingBounds.	moveBox := clippingBox copy.	(pointToMove x abs &gt;= clippingBox width or: [pointToMove y abs &gt;= clippingBox height])		ifTrue: [^self redisplayRectangle: self compositionBounds on: aGraphicsContext].	"Copy the display contents that have just shifted, reshowing only         part that is dragged into view."	"We assume that the post-scrolling clipping bounds can be	smaller than the pre-scrolling clipping bounds only at the	edge being scrolled in.  That is, if we're scrolling forwards,	only the end of the component's translated bounds can be	truncated.  If we're scrolling backwards, only the beginning	of the translated bounds can be truncated.  Because of that	assumption, we rule out the possibility that the move box	calculation (based on the post-scrolling clipping bounds) can	cause invalid display contents to be copied."	moveBox := (clippingBox translatedBy: pointToMove) intersect: clippingBox.	copyGC := aGraphicsContext copy.	copyGC intersectClip: clippingBox.	"Do no reporting of the damage cause by the following copyArea action."	t := self topComponent.	t isNil ifFalse: [t sensor skipNextDamage]. 	rects := copyGC				copyArea: moveBox				from: copyGC				sourceOffsetX: 0 y: 0				destinationOffsetX: pointToMove x negated y: pointToMove y negated.	1 to: rects size do:		[:i |		self redisplayRectangle: (rects at: i) on: copyGC].	"Display lines pulled into view."	rects := self compositionBounds areasOutside: (moveBox translatedBy: pointToMove negated).	1 to: rects size do:		[:i |		self redisplayRectangle: (rects at: i) on: aGraphicsContext].	"Restore the skipNextDamage flag."	t isNil ifFalse: [t sensor skipNextDamageNot]</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>private</category><body package="Interface-Support" selector="redisplayRectangle:on:">redisplayRectangle: aRectangle on: aGraphicsContext	"Redisplay the rectangle aRectangle in the receiver on aGraphicsContext."	| gc |	gc := aGraphicsContext copy.	gc intersectClip: aRectangle.	gc paint: self backgroundColor.	gc displayRectangle: aRectangle.	gc paint: self foregroundColor.	self displayOn: gc</body></methods><methods><class-id>UI.MultiSelectionTreeView</class-id> <category>private</category><body package="UIBasics-Components" selector="resetSelections">resetSelections	| oldSelections |  	oldSelections := selections copy.	oldSelections do: [:each| self retractSelectionIndex: each].	selectionIndex := self zeroIndex.</body></methods><methods><class-id>UI.NamedFontSelector</class-id> <category>private</category><body package="Interface-Support" selector="setUserFontSample">setUserFontSample	| view userFontLabel |	view := self widgetAt: #userTextField.	userFontLabel := self widgetAt: #userFontLabel.		[view textStyle: (self textAttributes copy alignment: 2).	view invalidate.	userFontLabel labelString: self textAttributes currentFont fontDescription family.	(self wrapperAt: #assignToNamedFont) enable]			on: FontPolicy noMatchingFontSignal			do: 				[:ex |				view textStyle: nil.				view flash.				userFontLabel labelString: #fontNotFound &lt;&lt; #dialogs &gt;&gt; 'No font match'.				(self wrapperAt: #assignToNamedFont) disable.				ex return]</body></methods><methods><class-id>UI.NamedFontSelector</class-id> <category>notification</category><body package="Interface-Support" selector="showNamedFontAttributes">showNamedFontAttributes	"Update font for text style selection."	| textStyle targetSelection |	textStyle := TextAttributes styleNamed: styleNames selection				ifAbsent: [^self disableNamedFontButtons].	self textAttributesHolder value: (textStyle copy 				setCharacterAttributes: textStyle characterAttributes copy).	self fontDescriptionHolder value: self fontDescription copy.	targetSelection := self allFonts list 				detect: [:each | each = self fontDescription family]				ifNone: [nil].	self allFonts selection: targetSelection.	self fontSizes 		value: (fontDictionary at: targetSelection ifAbsent: [1 to: 72]).	self setSystemFontSample.	self enableNamedFontButtons</body></methods><methods><class-id>UI.NamedFontSelector</class-id> <category>private</category><body package="Interface-Support" selector="unalteredFont">unalteredFont	^(self unalteredTextAttributes characterAttributes defaultQueryFor: nil) copy</body></methods><methods><class-id>UI.BorderDecorator</class-id> <category>accessing</category><body package="UIBasics-Support" selector="useLocalEdgeDecorationPolicy">useLocalEdgeDecorationPolicy	"We want to make local modifications to the receiver's policy.  Break sharing"	policy == nil		ifTrue:	[policy := self edgeDecorationPolicy copy].</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="borderColor:">borderColor: aColor	"Answer a copy of the receiver with a new border color."	^self copy at: #borderColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="hiliteColor:">hiliteColor: aColor	"Answer a copy of the receiver with a new hilite color."	^self copy at: #hiliteColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="selectionForegroundColor:">selectionForegroundColor: aColor	"Answer a copy of the receiver with a new selection foreground color."	^self copy at: #selectionForegroundColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="shadowColor:">shadowColor: aColor	"Answer a copy of the receiver with a new shadow color."	^self copy at: #shadowColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="selectionBackgroundColor:">selectionBackgroundColor: aColor	"Answer a copy of the receiver with a new selection background color."	^self copy at: #selectionBackgroundColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="foregroundColor:">foregroundColor: aColor	"Answer a copy of the receiver with a new foreground color."	^self copy at: #foregroundColor put: aColor</body></methods><methods><class-id>UI.ColorPreferencesCollection</class-id> <category>copying</category><body package="Interface-Support" selector="backgroundColor:">backgroundColor: aColor	"Answer a copy of the receiver with a new background color."	^self copy at: #backgroundColor put: aColor</body></methods><methods><class-id>UI.ArbitraryView</class-id> <category>accessing</category><body package="Interface-Support" selector="display:in:on:">display: aValue in: box on: aGraphicsContext	"Compatibility with Aragon's dataset."		aValue		displayOn: aGraphicsContext copy		at: box center - (aValue preferredBounds extent half)</body></methods><methods><class-id>UI.ColorPreferencesDictionary</class-id> <category>private</category><body package="Interface-Support" selector="postCopy">postCopy	preferences := preferences copy.	constantCodeArray := constantCodeArray copy</body></methods><methods><class-id>UI.MouseEvent</class-id> <category>accessing</category><body package="Interface-Events" selector="translatedBy:">translatedBy: aPoint	^self copy translateBy: aPoint</body></methods><methods><class-id>UI.MotifMenuBarButtonView</class-id> <category>displaying</category><body package="UILooks-Motif" selector="displayOn:">displayOn: aGraphicsContext	"Display the receiver according to	the current state of the model."		| box border offset newGraphicsContext |	self isVisible ifFalse: [^self].	self isInTransition		ifFalse: [^self displayUndecoratedOn: aGraphicsContext].	box := self bounds.	border := BeveledBorder raised.	offset := 0 @ 0.	border displayOn: aGraphicsContext forDisplayBox: box using: self.	box := border insetDisplayBoxFor: box.	label == nil ifTrue: [^self].	offset := box center - (label bounds extent half) + offset.	self setPaintOn: aGraphicsContext.	newGraphicsContext := aGraphicsContext copy intersectClip: box.	label displayOn: newGraphicsContext at: offset</body></methods><methods><class-id>UI.PropertyListDictionary</class-id> <category>copying</category><body package="UIBuilder-Support" selector="postCopy">postCopy	super postCopy.	valueArray keysAndValuesDo: 		[:index :value |		valueArray at: index put: (valueArray at: index) copy]</body></methods><methods><class-id>UI.IndentedTreeSelectionInList</class-id> <category>private</category><body package="UIBasics-Collections" selector="addChild:indentLevel:parent:">addChild: aChild indentLevel: indentLevel parent: parent	"Add aChild to the the receiver's indented list at indentLevel."	| assocTree children |	children := self childrenFor: aChild.	assocTree := (AssociationTreeWithParentWithIndents key: aChild value: indentLevel)		parent: parent ;		children: children asOrderedCollection.	aChild == self root ifFalse:		[assocTree displayableIndents: parent displayableIndents copy.		parent children isEmpty ifFalse:			[(aChild = parent children last ) ifFalse:				[assocTree displayableIndents add: indentLevel]].		self cachedObjects add: (assocTree).							self listHolder value add: (self nameFor: aChild indentLevel: indentLevel)].	(self isOpen: aChild) ifTrue: 		[children notNil ifTrue:			[children do: 				[:child | self addChild: child indentLevel: indentLevel + 1 parent: assocTree]]]</body></methods><methods><class-id>UI.LookPreferences class</class-id> <category>class initialization</category><body package="Interface-Support" selector="initializeBordersAndInsets">initializeBordersAndInsets	"LookPreferences initializeBordersAndInsets."	|  dmono |	dmono := Border new.	dmono setBorderColor: ColorValue white.	dmono setBorderWidth: 1.		dmono setBottomColor: ColorValue black.	dmono setRightColor: ColorValue black.	DefaultBorder := Array with: dmono with: dmono copy with: dmono copy.	DecoratedViewLayout := SmalltalkBorderDecorationPolicy new.	WidgetTypePolicy := SmalltalkWidgetPolicy new.</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - editing</category><body package="Interface-Commands" selector="copyCommand">copyCommand	&lt;command: #copy&gt;	^Command			label: (#Copy &lt;&lt; #labels &gt;&gt; 'Copy')			bindings: #(				#isMacOSX #(command C)				#isMSWindows #(ctrl C)				#isX11 #(ctrl C)			)</body></methods><methods><class-id>UI.MenuItem</class-id> <category>copying</category><body package="Interface-Menus" selector="postCopy">postCopy	"Finish doing whatever is required, beyond a shallowCopy, to implement 'copy'. Answer the receiver."	super postCopy.	adornment := adornment copy.	^self</body></methods><methods><class-id>UI.ReversingWrapper</class-id> <category>displaying</category><body package="UIBasics-Support" selector="displayOn:">displayOn: aGraphicsContext	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses."	reverse value		ifTrue: [|gc box |				box := container == nil					ifTrue: [self bounds]					ifFalse: [container compositionBoundsFor: self].				box left: box left + offset.				gc := aGraphicsContext copy.				self displayReversedBackgroundIn: box on: gc.				super displayOn: gc]		ifFalse: [super displayOn: aGraphicsContext]</body></methods><methods><class-id>UI.Notice</class-id> <category>aspects</category><body package="Interface-Support" selector="textView">textView	"Create a view for holding a mini-transcript of messages."	| tView fDescription tAttributes |	messages := TextCollector new.	messages onChangeSend: #changedMessages to: self.	tView := TextCollectorView new model: messages.	fDescription := tView textStyle defaultFont copy.	fDescription pixelSize: 13.	tAttributes := TextAttributes defaultFontQuery: fDescription.	tAttributes gridForFont: nil withLead: 2.	tView textStyle: tAttributes.	^tView</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>accessing</category><body package="TextHighlighting" selector="menu">menu	(selectable and: [readOnly and: [super menu = TextEditorYellowButtonMenu]])		ifTrue: [^self class readOnlyGroup].	^self highlighters inject: super menu copy into: [:menu :highlighter | highlighter modifyContextMenu: menu for: self]</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>private</category><body package="TextHighlighting" selector="startHighlighting:">startHighlighting: delay 	| uiPriority |	self stopHighlighting.	uiPriority := Processor activePriority.	highlightingProcess := 			[| win event localText |			(Delay forMilliseconds: delay) wait.			"Forked process highlights copied text.  Highlighting is placed			 in an error wrapper to avoid throwing exceptions."			localText := self highlighters asSortedCollection inject: self text into:							[:highlightedText :textHighlighter |							[textHighlighter highlight: highlightedText copy]								on:	Error								do:	[:ex |									self class ignoreErrors ifFalse: [ex pass].									Transcript show: (#HighlighterException1p2p &lt;&lt; #browser &gt;&gt; 'Highlighter Exception:  highlighter=&lt;1p&gt;, error=&lt;2p&gt;.&lt;n&gt;'															expandMacrosWith: textHighlighter with: ex messageText).									ex return: highlightedText]].			"WindowManager process moves result to UI"			event := 					[localText string = self text string 						ifTrue: 							[self displayWithHighlightedText: localText							"self text setString: self text string setRuns: localText runs.							self view resetSelections.							self view invalidateRectangle: self view bounds repairNow: true"]].						[win := view ifNotNil: [:v | v topComponent].			(win notNil and: [win isInvalid not and: [win isOpen and:[win windowManager notNil]]]) 				ifTrue: [event uiEventFor: win]] 					valueAtPriority: uiPriority	"so window cannot be closed during this block"] 					forkAt: uiPriority - 1</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>private</category><body package="TextHighlighting" selector="displayWithHighlightedText:">displayWithHighlightedText: localText 	| interval oldBounds newBounds selectionShowing start stop |	(selectionShowing := view selectionShowing) 		ifTrue: 			["if something is selected, remember what and deselect"			"NOTE! if no deselect happens, then the selection is displayed at a wrong offset,			so when the selection is drawn again at the end of the method, there may be some			strange text-fragment next to the new selection, which looks ugly"			start := self selectionStartIndex copy.			stop := self selectionStopIndex copy.			view deselect].	interval := self getIntervalForUpdateFromOriginal: self text				withNew: localText.	oldBounds := view boundsOfInterval: interval.	self text setString: self text string setRuns: localText runs.	newBounds := view boundsOfInterval: interval.	view invalidateRectangle: (oldBounds merge: newBounds) repairNow: true.	selectionShowing 		ifTrue: 			["if something has been selected, select it again and show that"			view selectFrom: start to: stop.			view selectAndScroll]		ifFalse: [view selectAt: self selectionStartIndex]</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="labelMessageSelector:">labelMessageSelector: aSymbol 	| labelThing |	self suppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifFalse: 			[labelThing := labeledValueHolder value label.			labeledValueHolder value 				label: ((labelThing isString or: [labelThing == nil]) 						ifTrue: 							[(UserMessage new)								defaultString: labelThing;								catalogID: aSymbol;								yourself]						ifFalse: [labelThing copy &lt;&lt; aSymbol])].	self changed: #value</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="labelKeyID:">labelKeyID: aSymbol 	| labelThing |	self suppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifTrue: [labeledValueHolder value label: self labelDefaultString]		ifFalse: 			[labelThing := labeledValueHolder value label.			labeledValueHolder value 				label: ((labelThing isString or: [labelThing == nil]) 						ifTrue: [aSymbol &gt;&gt; labelThing]						ifFalse: [labelThing copy key: aSymbol])].	self changed: #value</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="labelDefaultString:">labelDefaultString: aString 	| labelThing trimmed |	labelThing := labeledValueHolder value label.	trimmed := aString trimBlanks.	labeledValueHolder value 		label: ((labelThing isString or: [labelThing == nil]) 				ifTrue: 					[(parentBuilderBlock value aspectAt: #labelFromApplication) value 						ifTrue: [trimmed asSymbol]						ifFalse: [trimmed]]				ifFalse: [labelThing copy &gt;&gt; trimmed]).	self changed: #value</body></methods><methods><class-id>UI.Border</class-id> <category>display box accessing</category><body package="Interface-Support" selector="displayBoxFor:">displayBoxFor: anInnerRectangle	"Answer a display box for anInnerRectangle based on the receiver's	edge widths. This is the inverse of #insetDisplayBoxFor:"	| oBox |	oBox := anInnerRectangle copy.	oBox left: oBox left - self left.	oBox right: oBox right + self right.	oBox top: oBox top - self top.	oBox bottom: oBox bottom + self bottom.	^oBox</body></methods><methods><class-id>UI.Border</class-id> <category>displaying</category><body package="Interface-Support" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRectangle using: colorSource	"Display the receiver's borders in the specified display box.  If colorSource	is non-nil, it may be consulted for the values of the border colors using LookPreferences	accessing protocol (#hiliteColor, #shadowColor, etc.)."	"Be sure not to permanently side-effect the supplied GraphicsContext."	| dBox r clipRectangle paint oldPaint edge |	clipRectangle := aGraphicsContext clippingBounds.	((self insetDisplayBoxFor: aRectangle) contains: clipRectangle) ifTrue: [^self].	oldPaint := aGraphicsContext paint.	dBox := aRectangle.	r := dBox copy.	((edge := self top) == 0 or: [(paint := self topColor) == nil]) ifFalse: [		r bottom: dBox top + edge.		r left: r left + self left.		(r intersects: clipRectangle) ifTrue: [			aGraphicsContext paint: paint; displayRectangle: r].		r bottom: dBox bottom.		r left: dBox left].	((edge := self right) == 0 or: [(paint := self rightColor) == nil]) ifFalse: [		r left: dBox right - edge.		r top: r top + self top.		r bottom: r bottom - self bottom.		(r intersects: clipRectangle) ifTrue: [			aGraphicsContext paint: paint; displayRectangle: r].		r left: dBox left.		r top: dBox top.		r bottom: dBox bottom].	((edge := self bottom) == 0 or: [(paint := self bottomColor) == nil]) ifFalse: [		r top: dBox bottom - edge.		r left: r left + self left.		(r intersects: clipRectangle) ifTrue: [			aGraphicsContext paint: paint; displayRectangle: r].		r top: dBox top.		r left: dBox left].	((edge := self left) == 0 or: [(paint := self leftColor) == nil]) ifFalse: [		r right: dBox left + edge.		(r intersects: clipRectangle) ifTrue: [			aGraphicsContext paint: paint; displayRectangle: r]].	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.Border</class-id> <category>display box accessing</category><body package="Interface-Support" selector="insetDisplayBoxFor:">insetDisplayBoxFor: aRectangle	"Answer an inset display box for aRectangle based on the receiver's	edge widths."	| iBox |	iBox := aRectangle copy.	iBox left: iBox left + self left.	iBox right: iBox right - self right.	iBox top: iBox top + self top.	iBox bottom: iBox bottom - self bottom.	^iBox</body></methods><methods><class-id>UI.RowVisualComposite</class-id> <category>displaying</category><body package="UIBasics-Datasets" selector="displayOn:">displayOn: aGraphicsContext	"Display frozen columns (if any) from the left edge of aGraphicsContext. 	Then temporarily set the clipping bounds to the right edge of the last 	frozen column and display the remaining columns starting at position 	frozenTranslation. 	Skip display for the column descriptor set to inhibit"	| clippingBounds originalClippingBounds frozenColumn left right clipLeft |	frozen = 0		ifTrue: [left := self bounds left]		ifFalse: 			[left := container bounds left.			frozenColumn := descriptors at: frozen].	clippingBounds := aGraphicsContext clippingBounds.	originalClippingBounds := clippingBounds copy.	descriptors with: components		do: 			[:descriptor :visualComponent |			right := left + descriptor width.			inhibit ~~ descriptor				ifTrue: 					[| box elementBox |					elementBox := left @ bounds top corner: right @ bounds bottom.					box := elementBox insetBy: self cellInset.					visualComponent bounds: (box moveBy: descriptor offset).					visualComponent bounds left &lt; right						ifTrue: 							[| graphicsContext |							graphicsContext := aGraphicsContext copy.							graphicsContext clippingRectangle: clippingBounds.							graphicsContext intersectClip: elementBox.							visualComponent displayOn: graphicsContext.							self displayAdornment: visualComponent of: descriptor on: graphicsContext]].			left := right.			descriptor = frozenColumn				ifTrue: 					[clipLeft := (left max: clippingBounds left).					clippingBounds left: clipLeft.					aGraphicsContext clippingRectangle: clippingBounds.					left := self bounds left]].	aGraphicsContext clippingRectangle: originalClippingBounds</body></methods><methods><class-id>UI.InputState</class-id> <category>utilities</category><body package="OS-Window System" selector="hostEventFrom:">hostEventFrom: anEvent 	"Copy the host event field of anEvent. If we understand how to cast the event to 	a structure, do so"	^(anEvent at: 10) copy</body></methods><methods><class-id>UI.InputState</class-id> <category>utilities</category><body package="OS-Window System" selector="copyEvent:">copyEvent: anEvent 	"Copy the raw event sent up by the VM. Copy as well any fields whose values 	are mutable and would therefore be lost when the next event overwrites 	'anEvent'"	| copy |	copy := anEvent copy.	copy at: 10 put: (self hostEventFrom: anEvent).	^copy</body></methods><methods><class-id>UI.WinXPLookPolicy</class-id> <category>building</category><body package="UILooks-WinXP" selector="changeColor:forSpec:">changeColor: colors forSpec: spec	(spec isKindOf: TabControlSpec) ifFalse: [^super changeColor: colors forSpec: spec].	^colors isNil		ifTrue: [LookPreferences new backgroundColor: SymbolicPaint scrollbarBackground]		ifFalse: [colors backgroundColor isNil				ifTrue: [colors copy backgroundColor: SymbolicPaint scrollbarBackground]				ifFalse: [colors]]</body></methods><methods><class-id>UI.WinXPLookPolicy class</class-id> <category>private</category><body package="UILooks-WinXP" selector="menuName">menuName	^(#WinXP &lt;&lt; #menus &gt;&gt; 'Windows XP') copy</body></methods><methods><class-id>UI.TreeNodeWrapper</class-id> <category>private</category><body package="UIBasics-Support" selector="refreshChildrenInTreeModel:">refreshChildrenInTreeModel: aTreeModel 	"If we find old child which is still there. Reuse its opened state and if it's closed then discard its cached children"	| oldChildren |	oldChildren := children copy.	children := nil.	aTreeModel childrenNodesForNode: self.	(oldChildren isNil or: [oldChildren isEmpty]) ifTrue: [^self].	children do: 		[:each | 		| oldChild |		oldChild := oldChildren 			detect: [:eachChild | eachChild value = each value]			ifNone: [nil].		oldChild ifNotNil: 			[each openedChildren: oldChild openedChildren.			each children: oldChild children]]</body></methods><methods><class-id>UI.Win95Border</class-id> <category>private-displaying</category><body package="UILooks-MSWin" selector="displayFrameOn:in:paint1:paint2:">displayFrameOn: aGraphicsContext in: rect paint1: paint1 paint2: paint2 	"Private - Display a frame in rect using paint1 for left and top	and paint2 for bottom and right sides of the frame."	aGraphicsContext		paint: paint1;		displayRectangle: (rect copy right: rect left + 1);		displayRectangle: (rect copy bottom: rect top + 1);		paint: paint2;		displayRectangle: (rect copy top: rect bottom - 1);		displayRectangle: (rect copy left: rect right - 1)</body></methods><methods><class-id>UI.Win95Border</class-id> <category>displaying</category><body package="UILooks-MSWin" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRect using: colorSource 	"Display the receiver's borders in the specified display box. If colorSource 	is non-nil, it may be consulted for the values of the border colors using LookPreferences 	accessing protocol (#hiliteColor, #shadowColor, etc.). 	Be sure not to permanently side-effect the supplied GraphicsContext."	thickness = 0 ifTrue: [^self].	((self insetDisplayBoxFor: aRect)		contains: aGraphicsContext clippingBounds)		ifTrue: [^self].	type == #raised1 ifTrue: [^self			displayRaised1On: aGraphicsContext copy			forDisplayBox: aRect			using: colorSource].	type == #raised2 ifTrue: [^self			displayRaised2On: aGraphicsContext copy			forDisplayBox: aRect			using: colorSource].	type == #inset ifTrue: [^self			displayInsetOn: aGraphicsContext copy			forDisplayBox: aRect			using: colorSource].	type == #thinInset ifTrue: [^self			displayThinInsetOn: aGraphicsContext copy			forDisplayBox: aRect			using: colorSource].	type == #thinRaised ifTrue: [^self			displayThinRaisedOn: aGraphicsContext copy			forDisplayBox: aRect			using: colorSource]</body></methods><methods><class-id>UI.UIDispatcher class</class-id> <category>constants</category><body package="UIBasics-Support" selector="vacuousDispatcher">vacuousDispatcher	^VacuousTranslator copy</body></methods><methods><class-id>UI.MotifMenuItemView</class-id> <category>displaying-private</category><body package="UILooks-Motif" selector="displayLabelOn:in:selected:">displayLabelOn: aGraphicsContext in: theMenuItemBox selected: isSelected	"Display the label of the menu item on aGraphicsContext inside theMenuItemBox.  isSelected indicates if the menu item is to be displayed in it's selected 'highlighted' state."	| theComposedLabel verticalPosition theLabelImage labelGraphicsContext |	theLabelImage := model labelImage.	theLabelImage ~~ nil ifTrue: [		| imageBounds imageVerticalPosition |		imageBounds := theLabelImage bounds.		imageVerticalPosition := (theMenuItemBox height - imageBounds height) // 2.		theLabelImage			displayOn: aGraphicsContext 			at: self defaultLabelIndent @ imageVerticalPosition].	theComposedLabel := self composedLabel.	verticalPosition := (theMenuItemBox height - theComposedLabel height) // 2 + 1.	labelGraphicsContext := aGraphicsContext copy		translateBy: menuView commonTextIndent @ verticalPosition.	theComposedLabel displayOn: labelGraphicsContext.	accessIndicator == nil ifFalse: [		labelGraphicsContext lineWidth: accessIndicatorThickness.		accessIndicator displayStrokedOn: labelGraphicsContext].</body></methods><methods><class-id>UI.UIBuilder</class-id> <category>adding</category><body package="UIBuilder-Framework" selector="addCollection:">addCollection: aCollection	"Add all the specs in aCollection, embedding copies of them in the 	resulting SpecWrappers."	| wrappers |	wrappers := OrderedCollection new.	aCollection do:		[:s |		self add: s copy.		wrappers add: wrapper].	component := nil.	^wrappers</body></methods><methods><class-id>UI.ControlManager</class-id> <category>private</category><body package="Interface-Framework" selector="hasPendingEvents">hasPendingEvents	^(scheduledControllers copy 		detect:			[:each | 			[each sensor hasEvents]				on: self class closedWindowSignal				do: [:ex | ex return: false]]		ifNone: [nil]) notNil</body></methods><methods><class-id>UI.TreeNodeVisualWrapper</class-id> <category>displaying</category><body package="UIBasics-Support" selector="displayOn:">displayOn: aGraphicsContext 	"Display the receiver on aGraphicsContext. The receiver may alter 	aGraphicsContext in any way it chooses."	| box textBox oldPaint gc textWidth |	gc := aGraphicsContext copy.	gc intersectClip: self bounds.	gc translateBy: origin.	oldPaint := gc paint.	box := container isNil		ifTrue: [self bounds]		ifFalse: [container compositionBoundsFor: self].	textWidth := component measureTextOn: gc.	textBox := Rectangle origin: box left + self offset - 1 @ box top corner: textWidth + 1 @ box bottom.	selected value ifTrue: 		[gc paint: self selectionBackgroundColor.		component fullLineSelect			ifTrue: [gc displayRectangle: box ]			ifFalse: [gc displayRectangle: (textBox insetBy: 1)].		gc paint: self selectionForegroundColor].	highlighted value ifTrue: 		[gc paint: SymbolicPaint traversalHilite.		component fullLineSelect			ifTrue: [(box origin extent: box extent - 1) displayStrokedOn: gc]			ifFalse: [(textBox origin extent: textBox extent - 1) displayStrokedOn: gc].		gc paint: self selectionForegroundColor].	(highlighted value and: [selected value not]) ifTrue: 		[gc paint: oldPaint].	self component displayOn: gc</body></methods><methods><class-id>UI.BeveledBorder</class-id> <category>displaying</category><body package="UIBasics-Support" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRectangle using: colorSource	"Display the receiver's borders in the specified display box.  If colorSource	is non-nil, it may be consulted for the values of the border colors using LookPreferences	accessing protocol (#hiliteColor, #shadowColor, etc.)."	"Be sure not to permanently side-effect the supplied GraphicsContext."	| dBox r clipRectangle paint oldPaint  paintSet|	clipRectangle := aGraphicsContext clippingBounds.	((self insetDisplayBoxFor: aRectangle) contains: clipRectangle) ifTrue:		[^self].	oldPaint := aGraphicsContext paint.	dBox := aRectangle.	r := dBox copy.	paint := self topPaintFor: colorSource.	r right: r left + thickness.	paintSet := false.	(r intersects: clipRectangle) ifTrue:		[paintSet := true. aGraphicsContext paint: paint; displayRectangle: r].	r right: dBox right.	r bottom: r top + thickness.	(r intersects: clipRectangle) ifTrue:		[paintSet ifFalse: [aGraphicsContext paint: paint].		aGraphicsContext displayRectangle: r].	paint := self bottomPaintFor: colorSource.	paintSet := false.	r top: r bottom.	r bottom: dBox bottom.	r left: r right - thickness.	(r intersects: clipRectangle) ifTrue:		[paintSet := true.		aGraphicsContext paint: paint; displayRectangle: r].	r top: r top - 1.	r bottom: r top + 1.	r left: r left + 1.	(r intersects: clipRectangle) ifTrue:		[paintSet ifFalse:			[paintSet := true.			aGraphicsContext paint: paint].		aGraphicsContext displayRectangle: r].	r right: r left - 1.	r left: dBox left + thickness.	r bottom: dBox bottom.	r top: r bottom - thickness.	(r intersects: clipRectangle) ifTrue:		[paintSet ifFalse:			[paintSet := true.			aGraphicsContext paint: paint].		aGraphicsContext displayRectangle: r].	r left: r left - 1.	r right: r left + 1.	r top: r top + 1.	(r intersects: clipRectangle) ifTrue:		[paintSet ifFalse:			[paintSet := true.			aGraphicsContext paint: paint].		aGraphicsContext displayRectangle: r].	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.DocumentEditor</class-id> <category>actions - editing</category><body package="UIBasics-Text2" selector="insertParagraphSeparator">insertParagraphSeparator	&lt;state: #active key: #Enter&gt;	| node |	node := document nodeAtPositionBefore: self paragraphStartPosition ifAbsent: [		self insert: (String with: (Character codePoint: 16r2029)).		^self endCurrentEdit].	node value class = Text2.DocumentSpan ifFalse: [		self insertDocument: node value copy.		^self endCurrentEdit].	self insert: (String with: (Character codePoint: 16r2029)).	self endCurrentEdit</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>mouse tracking</category><body package="UIPainter" selector="mouseMovedTo:">mouseMovedTo: aPoint	"Selection continues at relative point aPoint."	| oldBounds newBounds redisplayBounds gc |	gc := self editMask graphicsContext.	geometricInProgress notNil ifTrue: [ 		oldBounds := geometricInProgress bounds copy.		newBounds := Rectangle vertex: originInProgress vertex: (self geometricConstrain: aPoint).		redisplayBounds := oldBounds merge: newBounds. 	].  	mode == #fill ifTrue: [^self]. 	mode == #rectangle ifTrue: [		geometricInProgress origin: newBounds origin corner: newBounds corner.		gc clear.		undoBuffer displayOn: gc.		gc paint: coveragePaint. 		geometricInProgress displayFilledOn: gc. 	].	mode == #ellipse ifTrue: [		geometricInProgress setBoundingBox: newBounds startAngle: 0 sweepAngle: 360. 		gc clear.		undoBuffer displayOn: gc.		gc paint: coveragePaint. 		geometricInProgress displayFilledOn: gc. 	].	mode == #brush ifTrue: [		| constrainedPoint |		gc paint: coveragePaint. 		constrainedPoint := self brushConstrain: aPoint. 		self brushStrokeOn: gc from: originInProgress to: constrainedPoint.		redisplayBounds := (originInProgress extent: brush extent) merge: (constrainedPoint extent: brush extent).		originInProgress := constrainedPoint. 	]. 	view simpleRedisplayIn: redisplayBounds colorBackgroundIfNeeded: (view backdrop isNil).</body></methods><methods><class-id>UI.InputBoxController</class-id> <category>accessing</category><body package="UIBasics-Controllers" selector="stringValue">stringValue	^self text string copy</body></methods><methods><class-id>UI.TableView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayNormalElement:on:forBounds:">displayNormalElement: index on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component |	component := self visualComponentForElementIndex: index.	component bounds: elementBounds.	component displayOn: aGraphicsContext copy</body></methods><methods><class-id>UI.TableView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayElement:on:forBounds:">displayElement: i on: aGraphicsContext forBounds: elementBounds	"Display the receiver's content on aGraphicsContext."	| component gc x y |	component := self visualComponentForElementIndex: i.	component bounds: elementBounds.	gc := aGraphicsContext copy.	(self isSelected: i)		ifTrue: [strokedSelection 					ifTrue: [	x := showCGrid ifTrue: [1] ifFalse: [0].							y := showRGrid ifTrue: [1] ifFalse: [0].							component displayOn: gc copy.							gc paint: SymbolicPaint foreground.							gc lineWidth: 2.							gc displayInteriorRectangularBorder: (elementBounds insetBy: (0@0 corner: x@y))]					ifFalse: [ self isOptimized							ifTrue: [ 								gc paint: self selectionBackgroundColor.								gc displayRectangle: elementBounds.								gc paint: self selectionForegroundColor.								component displayOn: gc]							ifFalse: [ 								gc paint: (self selectionBackgroundColorAtIndex: i).								gc displayRectangle: elementBounds.								gc paint: (self selectionForegroundColorAtIndex: i).								component displayOn: gc]]]		ifFalse: [self isOptimized ifFalse: [ gc paint: (self foregroundColorAtIndex: i)].				component displayOn: gc].</body></methods><methods><class-id>UI.TabControlBarView</class-id> <category>private-displaying</category><body package="UIBasics-Components" selector="displayBorderOn:bounds:index:">displayBorderOn: aGraphicsContext bounds: bounds index: index 	"Private - Display the border of label with index i on aGraphicsContext."	| box showLeftBorder |	box := bounds copy.	showLeftBorder := self selectionIndex + 1 ~= (tabOffset + 1 == index 		ifTrue: [0] 		ifFalse: [index]).	aGraphicsContext paint: SymbolicPaint hilite.	showLeftBorder ifTrue: 		[aGraphicsContext displayRectangle: (box topLeft + (0 @ 2) extent: 1 @ (box height - 3)).		aGraphicsContext displayRectangle: (box topLeft + (1 @ 1) extent: 1 @ 1)].	aGraphicsContext displayRectangle: (box topLeft + (2 @ 0) extent: (box width - 4) @ 1).	showLeftBorder ifTrue: [aGraphicsContext displayRectangle: (box topLeft + (1 @ 2) extent: 1 @ (box height - 3))].	aGraphicsContext displayRectangle: (box topLeft + (2 @ 1) extent: (box width - 4) @ 1).	aGraphicsContext paint: SymbolicPaint shadow.	aGraphicsContext displayRectangle: (box topRight + (-2 @ 2) extent: 1 @ (box height - 4)).	aGraphicsContext displayRectangle: (box topRight + (-2 @ 1) extent: 1 @ 1).	aGraphicsContext displayRectangle: (box topRight + (-1 @ 2) extent: 1 @ (box height - 4))</body></methods><methods><class-id>UI.TabControlBarView</class-id> <category>private-displaying</category><body package="UIBasics-Components" selector="displayVisual:index:on:forBounds:">displayVisual: component index: i on: aGraphicsContext forBounds: elementBounds 	"Private - Display the receiver's content on aGraphicsContext and make sure it is pretty much centered"	| isSelected computedOffset |	isSelected := i = self selectionIndex.	computedOffset := component preferredBounds height &lt; elementBounds bottom 				ifFalse: [0]				ifTrue: [((elementBounds bottom - component preferredBounds height) / 2) rounded - 1].	component bounds: (elementBounds insetBy: (6 @ computedOffset extent: -6 @ computedOffset negated)).	aGraphicsContext paint: self foregroundColor.	component displayOn: aGraphicsContext copy.	(self hasFocus and: [isSelected]) ifFalse: [^self].	self displayTravsersalHighlightIn: elementBounds on: aGraphicsContext</body></methods><methods><class-id>UI.WinXPGroupBox</class-id> <category>private</category><body package="UILooks-WinXP" selector="displayBorderOn:">displayBorderOn: aGraphicsContext	| borderRectangle |	borderRectangle := self  bounds copy.	borderRectangle top: borderRectangle top + (self labelHeight // 2).	borderRectangle right: borderRectangle right - 1.	borderRectangle bottom: borderRectangle bottom - 1.	self border displayOn: aGraphicsContext forDisplayBox: borderRectangle using: nil</body></methods><methods><class-id>UI.WindowEnterEvent</class-id> <category>accessing</category><body package="Interface-Events" selector="translatedBy:">translatedBy: aPoint	^self copy translateBy: aPoint</body></methods><methods><class-id>UI.MacOSXSliderView</class-id> <category>private</category><body package="UILooks-MacOSX" selector="displayBackgroundIfNeededOn:in:">displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle 	"Display the background of the window."	(aGraphicsContext copy) paint: aGraphicsContext paintPreferences backgroundColor; 				displayRectangle: aRectangle</body></methods><methods><class-id>UI.MenuItemAdornment</class-id> <category>copying</category><body package="Interface-Menus" selector="postCopy">postCopy	"Finish doing whatever is required, beyond a shallowCopy, to implement 'copy'. Answer the receiver."	super postCopy.	labelImage := labelImage copy.	submenu := submenu copy</body></methods><methods><class-id>UI.ProtocolAdaptor</class-id> <category>private</category><body package="Interface-Models" selector="makeAdaptorForRenderingStoreLeafInto:">makeAdaptorForRenderingStoreLeafInto: pair	pair at: 1 put: self.	self subjectChannel: nil.	^(subject isProtocolAdaptor)		ifTrue: [subject := subject copy.				subject makeAdaptorForRenderingStoreLeafInto: pair]		ifFalse: [pair]</body></methods><methods><class-id>UI.ProtocolAdaptor</class-id> <category>private</category><body package="Interface-Models" selector="renderingValueUsingSubject:">renderingValueUsingSubject: aSubject	| pair cpy cell |	subject isProtocolAdaptor ifFalse: [^self valueUsingSubject: aSubject].	cpy := self copy.	pair := Array new: 2.	pair at: 2 put: cpy.	cell := cpy makeAdaptorForRenderingStoreLeafInto: pair.	cell first subjectChannel: aSubject asValue.	^cell last value</body></methods><methods><class-id>UI.WinXPVariableBorder</class-id> <category>displaying</category><body package="UILooks-WinXP" selector="displayFrameOn:in:paint1:paint2:">displayFrameOn: aGraphicsContext in: rect paint1: paint1 paint2: paint2 	"Private - Display a frame in rect "	| oldPaint |	oldPaint := aGraphicsContext paint.	aGraphicsContext paint: SymbolicPaint textDataBorder.	self hasLeft ifTrue: [aGraphicsContext displayRectangle: (rect copy right: rect left + 1)].	self hasTop ifTrue: [aGraphicsContext displayRectangle: (rect copy bottom: rect top + 1)].	self hasBottom ifTrue: [aGraphicsContext displayRectangle: (rect copy top: rect bottom - 1)].	self hasRight ifTrue: [aGraphicsContext displayRectangle: (rect copy left: rect right - 1)].	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.Scrollbar</class-id> <category>marker accessing</category><body package="UIBasics-Components" selector="moveMarker:">moveMarker: anInteger	"Update the marker so that it is translated by an amount corresponding to	a distance of anInteger, constrained within the boundaries of the scroll bar."	| old |	old := self marker copy.	self translateMarkerBy: anInteger.	self invalidateRectangle: (old merge: self marker)</body></methods><methods><class-id>UI.CompositeSpec</class-id> <category>accessing</category><body package="UIPainter" selector="savableSpecFor:">savableSpecFor: aComposite	| csc |	csc := CompositeSpecCollection new.	csc compositeSpec: self copy.	csc fromCollection: aComposite components.	^csc</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>building</category><body package="UIBuilder-Support" selector="dataSetView:into:">dataSetView: spec into: builder	"Build a DataSetView into the builder. Extract from the model the listHolder, 	selectionChannel and currentRowHolder. Get the column descriptors from 	the spec"	| dataSetView model menu bc performer |	dataSetView := builder isEditing				ifTrue: [self paintedDataSetViewClass new]				ifFalse: 					[(spec multipleSelections						ifTrue: [self multiSelectionDataSetViewClass]						ifFalse: [self dataSetViewClass]) new].	dataSetView labelsAsButtons: spec labelsAsButtons.	model := spec modelInBuilder: builder.	dataSetView model: model listHolder.	dataSetView selectionChannel: model selectionIndexHolder.	builder isEditing		ifFalse: 			[spec multipleSelections				ifTrue: 					[dataSetView						controller: self compliantMultiSelectDataSetControllerClass new]				ifFalse: 					[dataSetView controller: self simpleMultiSelectDataSetControllerClass new]].	(menu := spec getMenuIn: builder) == nil		ifFalse: [dataSetView controller menuHolder: menu].	(performer := spec getPerformerIn: builder) == nil		ifFalse: [dataSetView controller performer: performer].	bc := builder copy.	bc setWindow: nil.	bc composite: CompositePart new.	dataSetView setColumnDescriptors: (spec columnsInBuilder: bc).	dataSetView horizontalPolicy: spec horizontalPolicy.	dataSetView verticalPolicy: spec verticalPolicy.	dataSetView showVerticalLines: spec showVerticalLines.	dataSetView showHorizontalLines: spec showHorizontalLines.	dataSetView showLineNumbers: spec showLineNumbers.	dataSetView rowLabelsAsButtons: spec rowLabelsAsButtons.	dataSetView allowSorting: spec allowSorting.	dataSetView allowColumnReordering: spec allowColumnReordering.	dataSetView allowColumnResizing: spec allowColumnResizing.	dataSetView lineGrid: spec rowSize.	self setDispatcherOf: dataSetView fromSpec: spec builder: builder.	spec tabable		ifTrue: [dataSetView widgetState isTabStop: true]		ifFalse: 			[spec labelsAsButtons				ifTrue: 					[dataSetView columnDescriptors do: [:col | col labelAsButtonSpec noTabbing]].			dataSetView widgetState canTakeFocus: true].	dataSetView widgetState isEnabled: spec initiallyEnabled.	builder isEditing		ifFalse: [dataSetView widgetState isVisible: spec initiallyVisible].	builder component: dataSetView.	self manufactureGeneralWrapperFor: spec into: builder.	builder applyLayout: spec layout.	builder wrapWith: (self				simpleWidgetWrapperOn: builder				spec: spec				state: dataSetView widgetState)</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>interface construction</category><body package="Interface-Dialogs" selector="addMessage:linesCentered:paragraphCentered:maxWidth:">addMessage: messageString linesCentered: linesCentered paragraphCentered: paragraphCentered maxWidth: width 	| composedText layout box spec messageText lookPolicyClass fraction |	box := builder window displayBox.	messageText := messageString asText.	(lookPolicyClass := builder policy class) useBoldInDialogText ifTrue: [messageText allBold].	composedText := ComposedText withText: messageText		style: (lookPolicyClass systemWidgetTextStyle copy alignment: (linesCentered ifTrue: [2] ifFalse: [0]))		compositionWidth: width.	fraction := paragraphCentered ifTrue: [0.5] ifFalse: [0]. 	layout := AlignmentOrigin new		leftFraction: fraction;		topOffset: box height;		leftAlignmentFraction: fraction.	spec := LabelSpec layout: layout.	spec hasCharacterOrientedLabel: false.	spec setLabel: composedText.	builder add: spec.	self addGap: composedText bounds height.	self minWidth: composedText bounds width + 20.	^builder wrapper</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>interface construction</category><body package="Interface-Dialogs" selector="addMessage:linesCentered:paragraphCentered:">addMessage: messageString linesCentered: linesCentered paragraphCentered: paragraphCentered	| composedText layout box spec messageText lookPolicyClass fraction | 	box := builder window displayBox.	messageText := messageString asText.	(lookPolicyClass := builder policy class) useBoldInDialogText ifTrue: [messageText allBold].	composedText := ComposedText		withText: messageText		style: (lookPolicyClass systemWidgetTextStyle copy alignment: (linesCentered			ifTrue: [2]			ifFalse: [0])).	fraction := paragraphCentered ifTrue: [0.5] ifFalse: [0].	layout := AlignmentOrigin new		leftFraction: fraction;		topOffset: box height;		leftOffset: (paragraphCentered ifTrue: [0] ifFalse: [10]);		leftAlignmentFraction: fraction.	spec := LabelSpec layout: layout.	spec hasCharacterOrientedLabel: false.	spec setLabel: composedText.	builder add: spec.	self addGap: (composedText bounds height min: (Screen default bounds height - 100)).	self minWidth: (composedText bounds width + 20 min: (Screen default bounds width - 30)).	^builder wrapper</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>private</category><body package="Interface-Dialogs" selector="computeExtentAndSetLabel:">computeExtentAndSetLabel: aString 	| label composedText textExtent displayExtent labelExtent height width messageText lookPolicyClass |	label := builder componentAt: #label.	aString isString		ifTrue: [messageText := aString asText]		ifFalse: [messageText := aString].	(lookPolicyClass := builder policy class) useBoldInDialogText ifTrue: [messageText allBold].	composedText := ComposedText 		withText: messageText 		style: (lookPolicyClass systemWidgetTextStyle copy alignment: 2).	textExtent := composedText preferredBounds extent.	displayExtent := builder window displayBox extent.	labelExtent := label widget preferredBounds extent.	label label: composedText.	textExtent y &gt; labelExtent y		ifTrue: [height := displayExtent y + (textExtent y - labelExtent y)]		ifFalse: [height := displayExtent y].	width := displayExtent x max: textExtent x + 20.	^width @ height</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>interface construction</category><body package="Interface-Dialogs" selector="addMessage:textLine:type:boundary:">addMessage: messageString textLine: model type: type boundary: ratio 	| composedText layout spec height field grid messageText lookPolicyClass |	height := builder window displayBox height.	messageText := messageString asText.	(lookPolicyClass := builder policy class) useBoldInDialogText ifTrue: [messageText allBold].	composedText := ComposedText 		withText: messageText 		style: (lookPolicyClass systemWidgetTextStyle copy alignment: 0).	grid := composedText bounds height + self defaultGap.	layout := (LayoutFrame new)		leftFraction: 0 offset: 16;		rightFraction: ratio offset: -8;		topOffset: height;		bottomOffset: height + grid.	spec := LabelSpec layout: layout.	spec hasCharacterOrientedLabel: false.	spec setLabel: composedText.	builder add: spec.	layout := (LayoutFrame new)		leftFraction: ratio offset: 8;		rightFraction: 1 offset: -16;		topOffset: height;		bottomOffset: height + grid.	field := InputFieldSpec model: model menu: nil layout: layout.	type notNil ifTrue: [field type: type].	builder add: field.	self addGap: grid.	self minWidth: composedText bounds width * (1 / ratio) ceiling + 48.	^builder wrapper</body></methods><methods><class-id>UI.TableAdaptor</class-id> <category>copying</category><body package="UIBasics-Collections" selector="postCopy">postCopy	"Answer a copy of the receiver."	self breakDependents.	baseCollection :=  baseCollection copy.</body></methods><methods><class-id>UI.WindowExitEvent</class-id> <category>accessing</category><body package="Interface-Events" selector="translatedBy:">translatedBy: aPoint	^self copy translateBy: aPoint</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="helpLabelDefaultString:">helpLabelDefaultString: aString 	| labelThing |	self helpSuppliedByBuilder value ifTrue: [^self].	labelThing := helpLabeledValueHolder value helpText.	helpLabeledValueHolder value 		helpText: ((labelThing isString or: [labelThing == nil]) 				ifTrue: [aString]				ifFalse: [labelThing copy &gt;&gt; aString]).	self changed: #value</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="helpLabelCatalog:">helpLabelCatalog: aSymbol 	| labelThing |	self helpSuppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifTrue: [helpLabeledValueHolder value helpText: self helpLabelDefaultString] 		ifFalse: 			[labelThing := helpLabeledValueHolder value helpText.			helpLabeledValueHolder value 				helpText: ((labelThing isString or: [labelThing == nil]) 						ifTrue: 							[(UserMessage new)								defaultString: labelThing;								catalogID: aSymbol;								yourself]						ifFalse: [labelThing copy &lt;&lt; aSymbol])].	 	self changed: #value</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>accessing</category><body package="UIPainter" selector="helpLabelKeyID:">helpLabelKeyID: aSymbol 	| labelThing |	self helpSuppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifTrue: [helpLabeledValueHolder value helpText: self helpLabelDefaultString]		ifFalse: 			[labelThing := helpLabeledValueHolder value helpText.			helpLabeledValueHolder value 				helpText: ((labelThing isString or: [labelThing == nil]) 						ifTrue: [aSymbol &gt;&gt; labelThing]						ifFalse: [labelThing copy key: aSymbol])].	self changed: #value</body></methods><methods><class-id>UI.CompositeSpecCollection</class-id> <category>copying</category><body package="UIBuilder-Specifications" selector="postCopy">postCopy	super postCopy.	compositeSpec := compositeSpec copy</body></methods><methods><class-id>UI.MacOSXMenuFromMenuBarController</class-id> <category>events</category><body package="UILooks-MacOSX" selector="viewHasCursorWithEvent:">viewHasCursorWithEvent: event	"Answer true if the cursor point of the receiver's sensor lies within 	the display box and border of the menu item dropdown.	This is farily unique to stacked menus, but it makes standard windows like behavior"	| localSensor adulteratedBounds |	view == nil ifTrue: [^false].	event hasPoint ifFalse: [^false].	localSensor := self sensor.	adulteratedBounds := view bounds copy		top: view bounds top - view container border top.	^adulteratedBounds containsPoint: (localSensor cursorPointFor: event)</body></methods><methods><class-id>UI.EmulationScrollBar</class-id> <category>private</category><body package="UILooks-Support" selector="simpleRedisplayIn:colorBackgroundIfNeeded:">simpleRedisplayIn: aRectangle colorBackgroundIfNeeded: aBoolean	"Redisplay the given area of the receiver without doing a full invalidation if possible."	| graphicsContext  |	self isOpen ifFalse: [^self].	graphicsContext := self graphicsContext.	graphicsContext medium supportsInvalidation ifFalse: [^self].	graphicsContext medium hasOutstandingDamage ifTrue: [^self invalidateRectangle: aRectangle repairNow: true].	graphicsContext intersectClip: aRectangle.	aBoolean ifTrue: 		[graphicsContext copy			paint: self backgroundColor;			displayRectangle: aRectangle].	self displayOn: graphicsContext</body></methods><methods><class-id>UI.Panel</class-id> <category>layout algorithms</category><body package="Store-Code Comparison" selector="beFullColumnStretchIf:">beFullColumnStretchIf: aPredicateBlock	self layoutAlgorithm: 			[:rect :parts |			| bottom stretchHeight unstretched |			stretchHeight := 0.			unstretched := parts reject: aPredicateBlock.			unstretched size &lt; parts size				ifTrue: 					[stretchHeight := (rect height								- (unstretched inject: 0 into: [:sum :each | sum + each preferredHeight]))									/ (parts size - unstretched size) max: 0].			bottom := rect top.			parts collect: 					[:each |					| top |					top := bottom.					bottom := top + ((aPredicateBlock value: each)										ifTrue: [stretchHeight]										ifFalse: [each preferredHeight]).					(rect copy)						top: top;						bottom: bottom]]</body></methods><methods><class-id>UI.Panel</class-id> <category>layout algorithms</category><body package="Store-Code Comparison" selector="beFullColumn">beFullColumn	self layoutAlgorithm: 			[:rect :parts |			| bottom |			bottom := rect top.			parts collect: 					[:each |					| top |					top := bottom.					bottom := top + each preferredHeight.					(rect copy)						top: top;						bottom: bottom]]</body></methods><methods><class-id>UI.MultiSelectionSequenceView</class-id> <category>private</category><body package="UIBasics-Components" selector="useSweepSelectionIndex:">useSweepSelectionIndex: anIndex 	"If multiple selections are possible, add the	current selection and all indices from the	current selection to the previous selection,	to the list of selections."	| save delta list newList |	lastSelectionIndex = self zeroIndex ifTrue: 		[self retractAllSelections.		^self].	save := lastSelectionIndex.	save &lt; anIndex 		ifTrue: [delta := -1] 		ifFalse: [delta := 1].	list := self selections copy.	newList := anIndex to: save by: delta.	selectionIndex := self zeroIndex.	(list reject: [:each | newList includes: each]) do: 		[:each | 		selections remove: each ifAbsent: [].		self invalidateElementIndex: each].	(newList reject: [:each | list includes: each]) do: 		[:each | 		selections add: each.		self invalidateElementIndex: each].	lastSelectionIndex := save.	self selectionChannel value: selections</body></methods><methods><class-id>UI.KeyPressedEvent</class-id> <category>converting</category><body package="Interface-Events" selector="forPrefocusPass">forPrefocusPass	"Return my specialized subclass which adds a wasHandled flag to the event."	^(self copy changeClassTo: Array)		changeClassTo: PrefocusKeypressEvent</body></methods><methods><class-id>UI.VisualBlock</class-id> <category>displaying</category><body package="UIBasics-Support" selector="displayOn:">displayOn: aGraphicsContext	| copy |	copy := aGraphicsContext copy.	paint == nil ifFalse: [copy paint: paint].	block value: copy value: self bounds</body></methods><methods><class-id>UI.TwoDList</class-id> <category>copying</category><body package="UIBasics-Collections" selector="postCopy">postCopy	"Answer a copy of the receiver."	self breakDependents.	collection :=  collection copy.</body></methods><methods><class-id>UI.AssociationTree</class-id> <category>copying</category><body package="UIBasics-Collections" selector="copyOld">copyOld	"Answer another instance just like the receiver, but with a copy of 	the receiver's value and a copy 	of each of the receiver's children."	| cpy tmpChildren |	tmpChildren := children.	children := nil.	cpy := self shallowCopy.	cpy value: value copy.	tmpChildren isNil ifFalse: [tmpChildren do: [:child | cpy addChild: child copy]].	children := tmpChildren.	^cpy</body></methods><methods><class-id>UI.AssociationTree</class-id> <category>copying</category><body package="UIBasics-Collections" selector="copy">copy	"Answer another instance just like the receiver, but with a copy of 	the receiver's value and a copy 	of each of the receiver's children."	| cpy tmpChildren |	tmpChildren := children.	children := nil.	cpy := self shallowCopy.	cpy value: value copy.	tmpChildren isNil ifFalse: [tmpChildren do: [:child | cpy addChild: child copy]].	children := tmpChildren.	^cpy</body></methods><methods><class-id>UI.AssociationTree</class-id> <category>copying</category><body package="UIBasics-Collections" selector="copyAndReplaceInSet:">copyAndReplaceInSet: aSet 	"Answer a copy of the receiver with all references to it in aSet 	updated as well."	| cpy tmpChildren |	tmpChildren := children.	children := nil.	cpy := self shallowCopy.	cpy value: value copy.	(aSet includes: self)		ifTrue: 			[aSet remove: self.			aSet add: cpy].	tmpChildren isNil ifFalse: [tmpChildren do: [:child | cpy addChild: (child copyAndReplaceInSet: aSet)]].	children := tmpChildren.	^cpy</body></methods><methods><class-id>UI.ClickableGraphic class</class-id> <category>example</category><body package="Graphics-Visual Objects" selector="example">example	"self example"	| me window text |	window := ScheduledWindow new.	window component: CompositePart new.	0 to: 1		do: 			[:x |			0 to: 1				do: 					[:y |					me := self new.					text := (x @ y) printString asText.					me idleGraphic: (Label with: text).					me						mouseOverGraphic: (Label with: (text copy emphasizeAllWith: #underline)).					me mouseDownGraphic: (Label with: (text copy emphasizeAllWith: #italic)).					me when: Clicked						do: 							[Transcript								show: 'Clicked: ' , (x @ y) printString;								cr].					window component add: me in: (x @ y / 2 extent: 1 asPoint / 2)]].	window openWithExtent: 200 @ 200</body></methods><methods><class-id>UI.ClickableGraphic class</class-id> <category>utility</category><body package="Graphics-Visual Objects" selector="clickableText:">clickableText: aText	"(ApplicationWindow new) component: (self clickableText: 'Click Me'); open"	| clickText baseText |	clickText := self new.	baseText := aText asText.	clickText		idleGraphic: (Label with: (baseText copy						addEmphasis: Array new						removeEmphasis: #()						allowDuplicates: false)).	clickText		mouseOverGraphic: (Label with: (baseText copy						addEmphasis: (Array with: #underline)						removeEmphasis: #()						allowDuplicates: false)).	clickText		mouseDownGraphic: (Label with: (baseText copy						addEmphasis: (Array with: #color -&gt; ColorValue blue with: #underline)						removeEmphasis: #()						allowDuplicates: false)).	clickText		disabledGraphic: (Label with: (baseText copy						addEmphasis: (Array with: #color -&gt; SymbolicPaint inactiveForeground)						removeEmphasis: #()						allowDuplicates: false)).	^clickText</body></methods><methods><class-id>UI.ClickableGraphic class</class-id> <category>utility</category><body package="Graphics-Visual Objects" selector="clickableText:style:">clickableText: aText style: aTextStyle	"(ApplicationWindow new)	component: (self clickableText: 'Click Me'				style: (TextAttributes styleNamed: #fixed));	open"	| clickText baseText |	clickText := self new.	baseText := aText asText.	clickText		idleGraphic: (Label with: (baseText copy						addEmphasis: Array new						removeEmphasis: #()						allowDuplicates: false)				attributes: aTextStyle).	clickText		mouseOverGraphic: (Label with: (baseText copy						addEmphasis: (Array with: #underline)						removeEmphasis: #()						allowDuplicates: false)				attributes: aTextStyle).	clickText		mouseDownGraphic: (Label with: (baseText copy						addEmphasis: (Array with: #color -&gt; ColorValue blue with: #underline)						removeEmphasis: #()						allowDuplicates: false)				attributes: aTextStyle).	clickText		disabledGraphic: (Label with: (baseText copy						addEmphasis: (Array with: #color -&gt; SymbolicPaint inactiveForeground)						removeEmphasis: #()						allowDuplicates: false)				attributes: aTextStyle).	^clickText</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu processing</category><body package="UIBasics-Controllers" selector="noCopyOrCut">noCopyOrCut	"Make content private and remove copy and cut actions from menu and keyboard, if any."	self menuHolder value		ifNotNil: 			[:menu |			(menu menuItemWithValue: #copySelection ifNone: nil)				ifNotNil: [:item | menu hideItem: item].			(menu menuItemWithValue: #cut ifNone: nil)				ifNotNil: [:item | menu hideItem: item]].	self dispatchTable bindValue: #ignoreInputKey: toCommand: #copy.	self dispatchTable bindValue: #ignoreInputKey: toCommand: #cut.</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>private</category><body package="UIBasics-Controllers" selector="privateAccept">privateAccept	"Save the current text of the text being edited."	view triggerEvent: #changing.	accepted := true.	self textHasChanged: false.	model value: self text copy.	self valueChange.	view triggerEvent: #changed</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>event driven</category><body package="UIBasics-Controllers" selector="setUpShiftDownSelectionAt:">setUpShiftDownSelectionAt: aPoint	"Shift is down and there is a selection; extend it"	| gc prevStartBlock prevStopBlock currentBlock pivotBlock |	gc := view graphicsContext.	prevStartBlock := view startBlock.	prevStopBlock := view stopBlock.	currentBlock := view characterBlockAtPoint: aPoint.	self resetTypein.	prevStartBlock = prevStopBlock ifTrue: [view deselect].	pivotBlock := (currentBlock stringIndex - prevStartBlock stringIndex) abs				&gt; (currentBlock stringIndex - prevStopBlock stringIndex) abs					ifTrue: 						["extend the end of the selection closest to the current 					cursor position"						prevStartBlock]					ifFalse: [prevStopBlock].	self		updateSelectionWith: currentBlock		usingPivot: pivotBlock		on: gc copy.	anchorIndex := pivotBlock stringIndex.	view selectionShowing: true.	gc flush.	^pivotBlock</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>private</category><body package="UIBasics-Controllers" selector="getReadOnlyDispatchTable">getReadOnlyDispatchTable	dispatchTable := DispatchTable new.	dispatchTable defaultForCharacters: #normalCharacterKey:.	dispatchTable defaultForNonCharacters: #ignoreInputKey:.	dispatchTable bindValue: #copyKey: toCommand: #copy.	dispatchTable bindValue: #cursorUpKey: to: #Up.	dispatchTable bindValue: #cursorDownKey: to: #Down.	dispatchTable bindValue: #cursorLeftKey: to: #Left.	dispatchTable bindValue: #cursorRightKey: to: #Right.	dispatchTable bindValue: #findDialogKey: toCommand: #find.	dispatchTable bindValue: #findAgainKey: toCommand: #findNext.	dispatchTable bindValue: #findAgainKey: toCommand: #findPrevious.	dispatchTable bindValue: #homeKey: toCommand: #textStartIOfLine.	dispatchTable bindValue: #endKey: toCommand: #textEndOfLine.	dispatchTable bindValue: #pageUpKey: to: #PageUp.	dispatchTable bindValue: #pageDownKey: to: #PageDown.	dispatchTable bindValue: #processTabKey: to: Character tab.	dispatchTable bindValue: #processTabKey: to: #BackTab.	dispatchTable bindValue: #selectAllKey: toCommand: #selectAll.	^dispatchTable</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>event driven</category><body package="UIBasics-Controllers" selector="trackSelectionFrom:to:pivotBlock:showingCaret:">trackSelectionFrom: currentBlock to: newPoint pivotBlock: pivotBlock showingCaret: aBoolean 	| showingCaret gc  pt delta nextBlock singleLineView |	showingCaret := aBoolean.	gc := view graphicsContext.	singleLineView := view isKindOf: InputFieldView.	pt := newPoint.	(delta := self deltaForPoint: pt) ~= Point zero ifTrue: 		[delta y = 0 ifFalse: 			[singleLineView 				ifTrue: [delta y: 0]				ifFalse: 					[delta y abs &lt; view lineGrid						ifTrue: [delta y: delta y sign * view lineGrid]						ifFalse: [delta y: (delta y truncateTo: view lineGrid)]]].		view scrollBy: delta negated.		gc translateBy: delta negated.		delta y &lt; 0			ifTrue: [pt y: view bounds top]			ifFalse: [delta y &gt; 0 ifTrue: [pt y: view bounds bottom]].		delta x &lt; 0			ifTrue: [pt x: view bounds left]			ifFalse: [delta x &gt; 0 ifTrue: [pt x: view bounds right]].		self checkForEvents].	nextBlock := view characterBlockAtPoint: pt.	nextBlock = currentBlock ifFalse: 		[showingCaret ifTrue: 			[view hideInsertionPointFor: pivotBlock on: gc copy.			showingCaret := false].		self			updateSelectionWith: nextBlock			usingPivot: pivotBlock			on: gc copy.		self selectionStartIndex = self selectionStopIndex ifTrue: 			[view displayInsertionPointFor: pivotBlock on: gc copy.			showingCaret := true].		gc flush].	^showingCaret</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu messages</category><body package="UIBasics-Controllers" selector="cut">cut	"Remove the current selection and, if non-empty, place it in the paste buffer"	| cutText |	(cutText := self selection) isEmpty ifTrue: [^self	"nothing to cut"].	self startNextUndo.	self deselect.	self resetTypein.	self silentCut.	(self currentUndo)		beCut;		delete: cutText;		endState: self captureUndoState.	nextUndoBlock := [self startNextUndo].	self selectAndScroll.	self currentSelection: self undoSelection copy</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>event driven</category><body package="UIBasics-Controllers" selector="setUpSelectionAt:">setUpSelectionAt: aPoint	| gc currentBlock pivotBlock |	gc := view graphicsContext.	currentBlock := view characterBlockAtPoint: aPoint.	view deselect.	self setSelectionStartAndResetTypein.	pivotBlock := currentBlock.	anchorIndex := pivotBlock stringIndex.	view startBlock: pivotBlock.	view stopBlock: pivotBlock.	view displayInsertionPointFor: pivotBlock on: gc copy.	view selectionShowing: true.	gc flush.	^pivotBlock</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>event driven</category><body package="UIBasics-Controllers" selector="completeSelectionWithPrevStart:prevStop:pivotBlock:showingCaret:">completeSelectionWithPrevStart: prevStartBlock prevStop: prevStopBlock pivotBlock: pivotBlock showingCaret: showingCaret	| strt gc word |	view isOpen ifFalse: [^self].	gc := view graphicsContext.	(strt := view startBlock) = view stopBlock		ifTrue: 			[showingCaret ifFalse: [view displayInsertionPointFor: strt on: gc copy].			(prevStartBlock = prevStopBlock and: [prevStartBlock = strt])				ifTrue: 					["select a word or bracketed range"					word := self selectWord: pivotBlock stringIndex.					word first = word last						ifFalse: 							[view hideInsertionPointFor: strt on: gc copy.							self selectionStartIndex: word first stopIndex: word last.							view								displaySelectionFrom: view startBlock								to: view stopBlock								on: gc]]].	gc flush.	self setEmphasisHere.	self view updateSpot: #mouse</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu messages</category><body package="UIBasics-Controllers" selector="cancel">cancel	"Restore the text of the paragraph to be the text saved since initialization or	the last accept."	self undoSelection: self text copy.	view updateDisplayContents</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>private</category><body package="UIBasics-Controllers" selector="silentCut">silentCut	"Remove the current selection and place it in the paste buffer.  Do not	affect visual selection."	| currentSelection |	self replaceSelectionWith: Text new.	currentSelection := self undoSelection copy.	self currentSelection: currentSelection</body></methods><methods><class-id>UI.TextEditorController class</class-id> <category>private</category><body package="UIBasics-Controllers" selector="decorateTextItemsIn:">decorateTextItemsIn: aMenu	(aMenu menuItemWithValue: #undo)		labelImage: (GeneralIcons visualFor: #editUndo);		command: #undo.	(aMenu menuItemWithValue: #redo)		labelImage: (GeneralIcons visualFor: #editRedo);		command: #redo.	(aMenu menuItemWithValue: #cut)		labelImage: (GeneralIcons visualFor: #editCut);		command: #cut.	(aMenu menuItemWithValue: #copySelection)		labelImage: (GeneralIcons visualFor: #editCopy);		command: #copy.	(aMenu menuItemWithValue: #paste)		labelImage: (GeneralIcons visualFor: #editPaste);		command: #paste</body></methods><methods><class-id>UI.TextEditorController class</class-id> <category>resources</category><body package="UIBasics-Controllers" selector="readOnlyGroup">readOnlyGroup	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#nameKey: #copySelection 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) 				#command: #copy ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#nameKey: #find 				#value: #find				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#nameKey: #findNext 				#value: #findNext				#command: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAll 					#defaultString: 'Select All' 					#catalogID: #menus ) 				#nameKey: #selectEntireText 				#value: #selectEntireText 				#command: #selectAll ) ) #(1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.TextEditorController class</class-id> <category>resources</category><body package="UIBasics-Controllers" selector="editGroup">editGroup	"Tools.MenuEditor new openOnClass: self andSelector: #editGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Undo 					#defaultString: 'Undo' 					#catalogID: #menus ) 				#value: #undo 				#command: #undo ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Redo 					#defaultString: 'Redo' 					#catalogID: #menus ) 				#value: #redo 				#command: #redo ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) 				#value: #cut 				#command: #cut ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#command: #copy ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) 				#value: #paste 				#command: #paste ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#value: #find				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ReplaceDot 					#defaultString: 'Replace...' 					#catalogID: #menus ) 				#value: #replace				#command: #replace ) ) #(2 3 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="selectAt:">selectAt: characterIndex 	"Place the caret before the character at position characterIndex.  Make	certain the selection is in the view."	self deselect.	startBlock := self characterBlockForIndex: characterIndex.	stopBlock := startBlock copy.	self selectAndScroll</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="setStartSelectionToStopSelection">setStartSelectionToStopSelection	"Set the receiver's start selection to the stop selection."	startBlock = stopBlock		ifFalse: [startBlock :=  self stopBlock copy]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="placeSelectionPointAt:">placeSelectionPointAt: characterIndex 	"Place the character before the character at position characterIndex.  Make	certain the selection is in the view but does not display any thing (ie. assumes 	no selection is showing).	This is used by the TextEditor during typing"	| delta |	startBlock := self characterBlockForIndex: characterIndex.	stopBlock := startBlock copy.	delta := self findSelectionDelta.	delta ~= 0 ifTrue: [self scrollBy: delta negated]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>updating</category><body package="Debugger-Support" selector="updateTheDisplay">updateTheDisplay	"This is used by the browsers only."	| text changedString |	text := self getContents asText.	changedString := displayContents text string ~= text string.	(changedString or: [displayContents text runs ~= text runs])		ifFalse: 			[self controller.	"Make sure we have a controller"			self resetController.			^self].	"If nothing changed, exit"	self isOpen		ifTrue: 			[displayContents setCompositionWidth: self wrappingBox width.			displayContents text: text asText copy]		ifFalse: 			[displayContents setCompositionWidth: ComposedText defaultCompositionWidth.			displayContents setText: text asText copy].	changedString ifTrue: [self setToTop].	self startBlock: nil.	self stopBlock: nil.	selectionShowing := true.	self controller.	"Make sure we have a controller"	self resetController.	"redisplay now so selection updates will display correctly"	self invalidateRectangle: self bounds repairNow: true</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>displaying</category><body package="UIBasics-Components" selector="redisplayAfterReplacementAt:affectedLines:lineDelta:">redisplayAfterReplacementAt: startLine affectedLines: affectedLines lineDelta: lineDelta	"Redisplay the reciever after a change starting at startLine. 	The argument affectedLines is the number of lines that need to be redisplayed. 	The argument lineDelta has the change in total lines. 	This method uses scrolling and only works for tiled views."	| visibleRectangle  stopLine gc |	gc := self graphicsContext.	visibleRectangle := self clippingBox.	self displayObject numberOfLines = 0  ifTrue: [^self invalidate].	stopLine := startLine + affectedLines - 1.	lineDelta = 0		ifTrue:	[gc paint: self backgroundColor.				gc intersectClip: (visibleRectangle := self							visibleRectangleFrom: startLine							to: stopLine).				gc displayRectangle: visibleRectangle.				gc paint: self foregroundColor.				self displayOn: gc]		ifFalse: [ | obsoleteY newY moveRectangle gc2 rectList |				lineDelta &gt; 0					ifTrue: [obsoleteY := self displayObject topAtLineIndex: startLine+(affectedLines - lineDelta max: 0)]					ifFalse: [obsoleteY := self displayObject topAtLineIndex: startLine + lineDelta negated].				newY := obsoleteY + (self lineGrid * lineDelta).				moveRectangle := self computeMoveRectangleFor: visibleRectangle old: obsoleteY new: newY.				gc2 := gc copy.				gc2 intersectClip: visibleRectangle.				rectList := gc2					copyArea: moveRectangle					from: gc2					sourceOffsetX: 0 y: 0					destinationOffsetX: 0 y: ((newY max: visibleRectangle top) - moveRectangle top).					1 to: rectList size  do:						[:j | self redisplayRectangle: ((rectList at: j) intersect: visibleRectangle) on: gc2].	 			self redisplayRectangle: (self visibleRectangleFrom: startLine to: stopLine) on: gc.				lineDelta &lt; 0					ifTrue: [| rr|							rr := visibleRectangle left@((newY+ moveRectangle height) max: visibleRectangle top)									corner: visibleRectangle corner.							self redisplayRectangle: rr on: gc]]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>initialize-release</category><body package="UIBasics-Components" selector="initializeSelection">initializeSelection 	"Establish the initial conditions for editing the paragraph:  place caret	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	self isOpen		ifTrue: [self selectionStartIndex: 1 stopIndex: 1]		ifFalse: [startBlock := 					CharacterBlock						stringIndex: 1						character: nil						boundingRectangle: (6@0 extent: 0 @ self lineGrid).				stopBlock := startBlock copy]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>model access</category><body package="UIBasics-Components" selector="editText:">editText: aText	"The paragraph to be displayed is created from the characters in aString."	self isOpen		ifTrue: 			[self triggerEvent: #changing.			displayContents text: aText asText copy.			self setScrollWidth]		ifFalse: 			[displayContents setCompositionWidth: ComposedText defaultCompositionWidth.			displayContents setText: aText asText copy].	self setToTop.	startBlock := stopBlock := nil.	selectionShowing := true.	self controller.	"Make sure we have a controller"	self resetController.	self resetTextEditorUndo.	self changedPreferredBounds: nil.	self invalidate.	self isOpen ifTrue: [self triggerEvent: #changed]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="hideInsertionPointFor:on:">hideInsertionPointFor: aCharacterBlock on: aGraphicsContext 	"Remove the insertion point on aGraphicsContext for aCharacterBlock."	| r clipRect gc |	clipRect := aGraphicsContext clippingBounds.	r := self insertionPointBoundingBoxFor: aCharacterBlock.	(r intersects: clipRect) ifFalse: [^self].	gc := aGraphicsContext copy.	gc intersectClip: r.	gc paint: self backgroundColor.	gc displayRectangle: r.	gc paint: self foregroundColor.	displayContents displayOn: gc at: self displayOrigin</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>private</category><body package="UIBasics-Components" selector="displayTextIn:on:">displayTextIn: aRectangle on: gc	"Display the receiver's text that intersects aRectangle on GraphicsContext gc.	Show all text whether selected or not in one pass."	| first last ss es x lineRange |	gc paint: self foregroundColor.	(displaySelection not or: [selectionShowing not])		ifTrue: [^self displayObject displayOn: gc copy at: self displayOrigin].	displayContents numberOfLines = 0		ifTrue: [^self displayInsertionPointFor: self startBlock on: gc].	lineRange := displayContents				lineRangeFor: (aRectangle translatedBy: self displayOrigin negated).	first := (displayContents lineAt: lineRange first) first.	last := (displayContents lineAt: lineRange last) last.	x := self displayOrigin x.	ss := self startBlock stringIndex.	es := self stopBlock stringIndex.	((ss &gt; last or: [es &lt; first]) or: [ss = es])		ifTrue: 			[self displayObject displayOn: gc copy at: self displayOrigin.			^self displayInsertionPointFor: self startBlock on: gc].	ss &gt; first		ifTrue: 			[gc paint: self foregroundColor.			self displayFromCharacter: first to: ss - 1 startX: x on: gc.			first := ss.			x := self startBlock left].	self showSelectionBoxOn: gc within: aRectangle.	gc paint: self selectionForegroundColor.	last &lt; es		ifTrue: 			[self displayFromCharacter: first to: last startX: x on: gc]		ifFalse: 			[self displayFromCharacter: first to: es - 1 startX: x on: gc.			gc paint: self foregroundColor.			x := self stopBlock left.			self displayFromCharacter: es to: last startX: x on: gc]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>displaying</category><body package="UIBasics-Components" selector="redisplayRectangle:on:">redisplayRectangle: aRectangle on: aGraphicsContext	"Redisplay the receiver's rectangle aRectangle on aGraphicsContext."	| gc |	gc := aGraphicsContext copy.	gc intersectClip: aRectangle.	gc paint: self backgroundColor.	gc displayRectangle: aRectangle.	gc paint: self foregroundColor.	self displayTextIn: aRectangle on: gc</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>selection</category><body package="UIBasics-Components" selector="selectionStartIndex:stopIndex:">selectionStartIndex: aStartIndex stopIndex: aStopIndex	"Set the receiver's selection start and stop index to the given arguments."	startBlock := self characterBlockForIndex: aStartIndex.	aStartIndex = aStopIndex		ifTrue: [stopBlock := startBlock copy]		ifFalse: [stopBlock := self characterBlockForIndex: aStopIndex]</body></methods><methods><class-id>UI.WindowDisplayPolicy</class-id> <category>displaying</category><body package="Interface-Support" selector="displayDamageList:in:">displayDamageList: aDamageList in: aWindow	"Repair damage in aWindow for the list of rectangles aDamageList.  None of the rectangles are assumed to not contain another of the rectangles, but they may intersect."	| windowGraphicsContext windowVisual |	windowGraphicsContext := aWindow graphicsContext.	windowGraphicsContext paint: aWindow background.	1 to: aDamageList size do: [:i |		windowGraphicsContext displayRectangle: (aDamageList at: i)].	(windowVisual := aWindow component) == nil ifTrue: [^self].	windowGraphicsContext paint: aWindow foregroundColor.	1 to: aDamageList size do: [:i |		windowGraphicsContext clippingRectangle: (aDamageList at: i).		windowVisual displayOn: windowGraphicsContext copy].	aWindow flush</body></methods><methods><class-id>UI.Win95MenuBorder</class-id> <category>displaying</category><body package="UILooks-MSWin" selector="displayOn:forDisplayBox:using:">displayOn: aGraphicsContext forDisplayBox: aRectangle using: colorSource 	"Display the receiver's borders in the specified display box. If colorSource 	is non-nil, it may be consulted for the values of the border colors using LookPreferences 	accessing protocol (#hiliteColor, #shadowColor, etc.)."	"Be sure not to permanently side-effect the supplied GraphicsContext."	| r clipRectangle oldPaint |	clipRectangle := aGraphicsContext clippingBounds.	((self insetDisplayBoxFor: aRectangle)		contains: clipRectangle)		ifTrue: [^self].	oldPaint := aGraphicsContext paint.	r := aRectangle copy.	r top: aRectangle bottom - 2; bottom: aRectangle bottom - 1.	(r intersects: clipRectangle)		ifTrue: [aGraphicsContext paint: colorSource shadowColor; displayRectangle: r].	r top: aRectangle bottom - 1; bottom: aRectangle bottom.	(r intersects: clipRectangle)		ifTrue: [aGraphicsContext paint: colorSource hiliteColor; displayRectangle: r].	aGraphicsContext paint: oldPaint</body></methods><methods><class-id>UI.TransientWindow</class-id> <category>private</category><body package="Interface-Framework" selector="displayDamageEvent:">displayDamageEvent: aDamageList	"Repair damage for the list of rectangles aDamageList."	| gc |	gc := self graphicsContext.	gc paint: self background.	1 to: aDamageList size do: [:i | gc displayRectangle: (aDamageList at: i)].	self component == nil ifTrue: [^self].	1 to: aDamageList size do: [:i |		gc clippingRectangle: (aDamageList at: i).		self component displayOn: gc copy].	self flush</body></methods><methods><class-id>AtomicLoader</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="compileBindingInitializersIn:">compileBindingInitializersIn: aPackageModel		| initialized |	initialized := (bindingsToInitialize collect: [:each | each environment]) asSet.	initialized := initialized copy reject: [:each | each isNameSpace].	initialized do: [:each | aPackageModel recompileSunshineMethodsFor: each].</body></methods><methods><class-id>AtomicLoader</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="initializeBindings">initializeBindings	"Keep trying until there are either none to do, or the number to do doesn't change"	| workingBindings workingSize copyBindings |	bindingsToInitialize isEmpty ifTrue: [^self].	workingBindings := bindingsToInitialize copy.	copyBindings := workingBindings copy.	workingSize := -1.	[workingSize ~= workingBindings size and: [workingBindings notEmpty]] whileTrue:		[workingSize := workingBindings size.		workingBindings do:			[:each |			[each recompile.			each initialize.			each ifNotNil: [copyBindings remove: each]]				on: MessageNotUnderstood				do: [:exception | exception resume]].			workingBindings := copyBindings copy]</body></methods><methods><class-id>AtomicLoader</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="initializeClassesIn:">initializeClassesIn: aPackageModel	"Keep trying until there are either none to do, or the number to do doesn't change.	If there are any still unable to be initialized, go and raise MNU on each after setting doNotMarkClean to true"	| sortedClasses workingSize workingClasses |	classesToInitialize isEmpty ifTrue: [^self].	sortedClasses := SystemUtils sortForLoading: (classesToInitialize collect: [:each | each key]).	workingClasses := sortedClasses copy.	workingSize := -1.	[workingSize ~= sortedClasses size and: [sortedClasses notEmpty]] whileTrue:		[workingSize := sortedClasses size.		sortedClasses do:			[:each | 			[each postLoad: aPackageModel.			workingClasses remove: each]				on: InitializerFailedError				do:					[:exception | 					exception return: nil]].			sortedClasses := workingClasses copy].	sortedClasses notEmpty ifTrue:		[doNotMarkClean := true.		sortedClasses do: 			[:each |			[each postLoad: aPackageModel]				on: InitializerFailedError				do: [:exception | exception resignalAs: MessageNotUnderstood new]]]</body></methods><methods><class-id>OS.IOAccessor class</class-id> <category>utilities</category><body package="OS-Support" selector="convertSimpleStringFromPlatform:">convertSimpleStringFromPlatform: aStringOrBytes	"Convert aStringOrBytes, which has platform character encoding,	to conform to one of Smalltalk's single- or double-byte encodings."	^aStringOrBytes isString		ifTrue: [aStringOrBytes copy]		ifFalse: [aStringOrBytes asStringEncoding: #default]</body></methods><methods><class-id>OS.IOAccessor class</class-id> <category>utilities</category><body package="OS-Support" selector="convertStringForPlatform:">convertStringForPlatform: aString 	"Convert aString, which has a single- or double-byte encoding	and CR line-end convention, to conform to the platform's default	encoding and line-end convention."	| conv str |	conv := self defaultLineEndConvention.	(conv = LineEndCR or: [conv = LineEndTransparent])		ifTrue: [str := aString]		ifFalse: 			[conv = LineEndLF 				ifTrue: [str := aString copy replaceAll: CR with: LF]				ifFalse: 					[conv = LineEndCRLF 						ifTrue: 							[str := aString copyReplaceAll: (String with: CR)										with: (String with: CR with: LF)]						ifFalse: 							[self error: (#errUndefinedLF &lt;&lt; #dialogs &gt;&gt; 'Undefined line-end convention')]]].	str := self convertSimpleStringForPlatform: str.	^str	"IOAccessor convertStringForPlatform: 'abcdefghij'"</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>utilities</category><body package="OS-MacOSX" selector="encodeSelection:">encodeSelection: aString	^(aString copy replaceAll: Character cr with: Character lf) asByteArrayEncoding: #UTF8</body></methods><methods><class-id>OS.PCFilename</class-id> <category>file utilities</category><body package="OS-PC" selector="directoryContents">directoryContents	"Receiver is a directory name.  Return an array of strings	naming files contained in this directory."	(osName last = 16r5C and: [publicName last ~= self separator])		ifTrue: [^self copy withSeparator directoryContents].	^super directoryContents</body></methods><methods><class-id>OS.PCFilename class</class-id> <category>utilities</category><body package="OS-PC" selector="decodeFilename:">decodeFilename: aStringOrBytes	^aStringOrBytes isString		ifTrue: [aStringOrBytes copy]		ifFalse: [aStringOrBytes asStringEncoding: OSSystemSupport concreteClass vmPreferredEncoding]</body></methods><methods><class-id>OS.ExternalStream class</class-id> <category>accessing</category><body package="OS-Streaming" selector="closeOpenStreamsNamed:">closeOpenStreamsNamed: aFilename	"Enumerate over the currently open streams, closing any that are open on aFilename."	OpenStreams copy do:		[:stream|		(stream ioConnection notNil		and: [stream fileName = aFilename asFilename]) ifTrue:			[stream close]]</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>examples</category><body package="Examples" selector="exampleTalkServer">exampleTalkServer	"This example creates a simple UDP server that accepts 	single packets from anybody and broadcasts them to all 	clients that have connected so far. It could be used as the 	basis for a 'talk' server. Start the server (by executing the	following comment), then run exampleTalkClient. To stop	the server, press the &lt;window&gt; button on the mouse."	"[SocketAccessor exampleTalkServer]			forkAt: Processor userInterruptPriority"	| socket address buffer msgSize clients |	clients := Set new.	address := IPSocketAddress new.	buffer := String new: 1024.	"Create a socket on the port server's port."	socket := self newUDPserverAtPort: 6666.	"Announce the server's availability."	Transcript cr; show: (#talkServerStart &lt;&lt; #dialogs &gt;&gt; 'Talk server starting') asString.	"Wait for data until &lt;window&gt; button is pressed or timeout."	[[InputState default mouseButtons = 4] whileFalse: [		(socket readWaitWithTimeoutMs: 200) ifFalse: [			"Get the next message and store its length."				msgSize := socket 				receiveFrom: address 				buffer: buffer 				start: 1 				for: buffer size.			"Add the client to the set of broadcast receivers."			clients add: address copy.			"Broadcast the packet to each client."			clients do: [ :clientAddress | 				socket 					sendTo: clientAddress 					buffer: buffer 					start: 1 					for: msgSize]]]]	ensure:		[Transcript cr; show: (#talkServerShutDown &lt;&lt; #dialogs &gt;&gt; 'Talk server shutting down') asString.		socket close]</body></methods><methods><class-id>OS.Filename</class-id> <category>parsing</category><body package="OS-Support" selector="tail">tail	"Answer the filename suffix as a String."	| index nm |	nm := self asString.	(index := self lastSeparatorIndex) notNil		ifTrue:	[^nm copyFrom: index+1 to: nm size]		ifFalse:	[^nm copy]</body></methods><methods><class-id>OS.Filename class</class-id> <category>utilities</category><body package="OS-Support" selector="expandEnvironmentIn:">expandEnvironmentIn: aFilePattern	"Answer a new file pattern whose elements of the form $VARNAME have been expanded"	"Filename expandEnvironmentIn: '$(HOME)/$(USER)/$(UNDEFINED_VARIABLE)/file'"	"Filename expandEnvironmentIn: '$(COMSPEC)\$(windir)\$(UNDEFINED_VARIABLE)\file'"	| sep in out elem value |	sep := self separator.	in := aFilePattern readStream.	out := aFilePattern copy writeStream.	[in atEnd] whileFalse:		[sep == in peek			ifTrue: [in next. out nextPut: sep]			ifFalse:				[((elem := in upTo: sep) size &gt; 3				and: [elem first == $$				and: [(elem at: 2) == $(				and: [elem last == $)				and: [(value := SystemUtils getEnvironmentVariable: (elem copyFrom: 3 to: elem size - 1)									ifAbsent: []) ~~ nil]]]])					ifTrue: [out nextPutAll: value]					ifFalse: [out nextPutAll: elem].				in atEnd					ifFalse: [out nextPut: sep]]].	^out contents</body></methods><methods><class-id>OS.Filename class</class-id> <category>utilities</category><body package="OS-Support" selector="decodeFilename:">decodeFilename: aStringOrBytes	^aStringOrBytes isString		ifTrue: [aStringOrBytes copy]		ifFalse: [aStringOrBytes asStringEncoding: #default]</body></methods><methods><class-id>OS.Filename class</class-id> <category>parsing</category><body package="OS-Support" selector="splitPath:">splitPath: fullName	"Answer an Array with: head with: tail."	| sepIndex head tail |	sepIndex := fullName lastIndexOf: self separator.	sepIndex &lt; 1		ifTrue: [^Array with: '' with: fullName copy].	head := fullName copyFrom: 1 to: sepIndex.	tail := fullName size &gt; sepIndex		ifTrue: [fullName copyFrom: sepIndex + 1 to: fullName size]		ifFalse: [''].	^Array with: head with: tail</body></methods><methods><class-id>OS.Filename class</class-id> <category>defaults</category><body package="OS-Support" selector="defaultDirectoryName">defaultDirectoryName	"Answer the default directory (e.g. interpretation starting point for	relative names)."	^DefaultDirectoryString copy</body></methods><methods><class-id>OS.MacOSXFilename class</class-id> <category>utilities</category><body package="OS-MacOSX" selector="decodeFilename:">decodeFilename: aStringOrBytes	^aStringOrBytes isString		ifTrue: [aStringOrBytes copy]		ifFalse: [UnicodeCollationAlgorithm new normalizeC: (aStringOrBytes asStringEncoding: #UTF8)]</body></methods><methods><class-id>OS.CEnvironment class</class-id> <category>instance creation</category><body package="OS-Support" selector="fromStrings:">fromStrings: aCollection 	"Create an instance by converting from the external format."	| ce |	ce := self new: aCollection size + (aCollection size // 3).	aCollection do: 		[:elem | 		| lhs rhs eep es |		es := elem size.		eep := elem indexOf: $=.		lhs := eep = 0					ifTrue: [elem copy]					ifFalse: [elem copyFrom: 1 to: eep - 1].		rhs := eep = 0 | (eep = es)					ifTrue: [String new]					ifFalse: [elem copyFrom: eep + 1 to: es].		ce at: lhs put: rhs].	^ce</body></methods><methods><class-id>OS.HandleRegistry</class-id> <category>initialize-release</category><body package="OS-Support" selector="releaseHandles">releaseHandles	"Broadcast a releaseHandle message to all registrants."	| vals execs |	vals := valueArray copy.	execs := executors copy.	1 to: valueArray size do:		[:index | | value |		value := vals at: index.		(value == nil or: [value == valueArray tombstone])			ifFalse: [value releaseHandle].		value := execs at: index.		value == nil			ifFalse: [value releaseHandle]].	1 to: self basicSize do: [:i | self basicAt: i put: nil]</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="construct:">construct:  aFileComponent	^self copy 		addComponent: aFileComponent;		yourself</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="withComponent:">withComponent: component	"Create a new URL with the argument component appended.	The new component is assumed to be already URL-encoded."	| p |	p := (self path isEmpty not and: [self path last = ''])		ifTrue: [self path copyFrom: 1 to: self path size-1]		ifFalse: [self path].	^self copy		query: nil;		fragment: nil;		path: p;		addComponent: component</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>private</category><body package="URISupport" selector="mergePartial:">mergePartial: aPartialURL	self fragment: aPartialURL fragment.	aPartialURL hasNoPath ifTrue: [^aPartialURL query ifNotNil: [self query: aPartialURL query]].	self query: aPartialURL query.	aPartialURL isAbsolute		ifTrue:	[self mergeAbsolutePath: aPartialURL path copy]		ifFalse:	[self mergeRelativePath: aPartialURL path copy]</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="withComponents:">withComponents: comps	"Create a new URL with the argument components appended.	The new components are assumed to be already URL-encoded."	| p uri |	p := (self path isEmpty not and: [self path last = ''])		ifTrue: [self path copyFrom: 1 to: self path size-1]		ifFalse: [self path].	uri := self copy		query: nil;		fragment: nil;		path: p.	comps do: [:s | uri addComponent: s].	^uri</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="resolvePath:">resolvePath: aPath	| aURI |	aURI := aPath asURI.	aURI isPartial ifFalse: [^aURI copy].	^self copy		mergePartial: aURI;		yourself</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>copying</category><body package="URISupport" selector="postCopy">postCopy	super postCopy.	path := path copy.	query := query copy</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="save">save	"This stub method was generated by UIDefiner"	s2 := s1 copy.	self display.	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copyOld">copyOld		^ BST new root: root copy.</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	| temp |	temp := self copy.	anotherBST do: [:value | temp remove: value].	temp do: [:value | self remove: value].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copy">copy		^ BST new root: root copy.</body></methods><methods><class-id>ExtraEmphases.BackHalf</class-id> <category>accessing</category><body package="ExtraEmphases" selector="computeWidthTable">computeWidthTable	widthTable := baseFont widthTable copy.	widthTable 		nonEmptyIndicesDo: [:i | widthTable at: i put: (widthTable at: i) // 2].	^widthTable</body></methods><methods><class-id>ExtraEmphases.LeadingInsert</class-id> <category>accessing</category><body package="ExtraEmphases" selector="computeWidthTable">computeWidthTable	| extra |	widthTable := baseFont widthTable copy.	extra := self extraWidth.	widthTable 		nonEmptyIndicesDo: [:i | widthTable at: i put: (widthTable at: i) + extra].	^widthTable</body></methods><methods><class-id>ExtraEmphases.TrailingInsert</class-id> <category>accessing</category><body package="ExtraEmphases" selector="computeWidthTable">computeWidthTable	| extra |	widthTable := baseFont widthTable copy.	extra := graphic preferredBounds width.	widthTable 		nonEmptyIndicesDo: [:i | widthTable at: i put: (widthTable at: i) + extra].	^widthTable</body></methods><methods><class-id>ExtraEmphases.Substitute</class-id> <category>accessing</category><body package="ExtraEmphases" selector="computeWidthTable">computeWidthTable	| sameWidth |	widthTable := baseFont widthTable copy.	sameWidth := graphic preferredBounds width.	"widthTable nonEmptyIndicesDo: [:i | widthTable at: i put: sameWidth]."widthTable atAllPut: sameWidth.	^widthTable</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="from:">from: aCompiledBlock	"Recursively create a new ProbedCompiledBlock from aCompliedBlock."	| flags |	probeStart := aCompiledBlock numLiterals + 2.	self at: probeStart - 1 put: #actOn:.	1 to: aCompiledBlock numLiterals do: 		[:i | | lit cl bm |		lit := aCompiledBlock literalAt: i.		cl := lit class.		cl == CompiledBlock			ifTrue: 				[self literalAt: i put: (lit := ProbedCompiledBlock from: lit).				lit outerMethod: self]			ifFalse:				[cl == BlockClosure					ifTrue: 						[self literalAt: i put: (lit := lit copy).						bm := ProbedCompiledBlock from: lit method.						lit method: bm.						bm outerMethod: self]					ifFalse: [self literalAt: i put: lit]]].	flags := 16rE0 + (aCompiledBlock usesContextInstVars ifTrue: [16] ifFalse: [0]).	bytes := (ByteArray				with: flags				with: aCompiledBlock numArgs				with: aCompiledBlock numTempsOnly				with: aCompiledBlock frameSize) , aCompiledBlock bytes.	^self</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>probes - recompiling</category><body package="Debugger-Probes" selector="basicReinsertProbesAndIndices:into:">basicReinsertProbesAndIndices: probesAndIndices into: probedMethod	| probesInError |	probesInError := OrderedCollection new.	probesAndIndices do:		[:ac | | probe index newRecord |		probe := ac key baseParent copy.		index := ac value.		newRecord := probedMethod probeRecordFor: (index to: index).		probe record: newRecord.		(probe updateTempVarForMethod: probedMethod)			ifTrue: [probedMethod addProbe: probe]			ifFalse:				[newRecord updateMethod: probedMethod.		"update mclass and selector for reporting"				probesInError add: probe]].	probesInError addAll: probedMethod recompileProbes.	ProbedCompiledMethod reportOnFailedProbes: probesInError."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="parent:">parent: aProbe	parent := aProbe.	probeRecord := parent probeRecord copy.</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="ifNecessaryCopy:andRebindFrom:">ifNecessaryCopy: aMethod andRebindFrom: oldVariables	"This method returns a new method with rebound variables if	rebinding is needed.  Otherwise, the original method is returned."	| nuMethod keepCopy vars |	variables == nil		ifTrue: [^aMethod].	nuMethod := aMethod copy.	keepCopy := false.	vars := OrderedCollection new.	oldVariables associationsDo: [:ac | vars add: ac].	nuMethod withAllBlockMethodsDo:		[:meth |		1 to: meth numLiterals do:			[:i | | lit |			lit := meth at: i.			(vars contains: [:obj | obj == lit])				ifTrue:					[keepCopy := true.					meth at: i put: (variables bindingFor: lit key)]]].	keepCopy		ifFalse: [^aMethod].	^nuMethod</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>commands</category><body package="Debugger-UI" selector="copy">copy	buffer := selection value copy.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>commands</category><body package="Debugger-UI" selector="copyOld">copyOld	buffer := selection value copy.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>commands</category><body package="Debugger-UI" selector="paste">paste	patternList list add: buffer copy beforeIndex: patternList selectionIndex + 1.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor class</class-id> <category>resources</category><body package="Debugger-UI" selector="menuBar">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #pdp) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #pdp) 							#value: #newPattern ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Remove #defaultString: 'Remove' #catalogID: #pdp) 							#value: #removePattern 							#enablementSelector: #patternIsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Undo #defaultString: 'Undo' #catalogID: #pdp) 							#nameKey: #undo 							#value: #undo 							#enablementSelector: #canUndo ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #pdp) 							#value: #copy 							#enablementSelector: #patternIsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #pdp) 							#value: #paste 							#enablementSelector: #canPaste ) ) #(2 1 2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor class</class-id> <category>resources</category><body package="Debugger-UI" selector="menu">menu	"MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #pdp) 				#value: #newPattern ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Remove #defaultString: 'Remove' #catalogID: #pdp) 				#value: #removePattern 				#enablementSelector: #patternIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Undo #defaultString: 'Undo' #catalogID: #pdp) 				#nameKey: #undo 				#value: #undo 				#enablementSelector: #canUndo ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #pdp) 				#value: #copy 				#enablementSelector: #patternIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #pdp) 				#value: #paste 				#enablementSelector: #canPaste ) ) #(2 1 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>private</category><body package="Debugger-Probes" selector="createWindow">createWindow	| aView subViews visual labelBottom |	window := ScheduledWindow				model: self				label: (#WatchWindow &lt;&lt; #pdp &gt;&gt; 'Watch window')				minimumSize: 200@100.	aView := WatchWindowView model: self.	aView controller performer: self.	aView controller menuHolder:		(ValueHolder with: (Menu 			labelList: #((again undo) (#copy cut paste) ('do it' 'print it' 'inspect') 						(cancel) (hardcopy) ('log on' 'log off'))			values: #(again undo copySelection cut paste doIt printIt						inspectIt cancel hardcopy doLog dontLog))).	subViews := CompositePart new.	visual := label asText allBold asParagraph.	labelBottom := visual preferredBounds height + 4.	labelView := BorderedWrapper			on: visual			in: (LayoutFrame					leftFraction: 0 offset: 0					rightFraction: 1 offset: 0					topFraction: 0 offset: 0					bottomFraction: 0 offset: labelBottom)			border: LookPreferences defaultBorder.	subViews add: labelView.	subViews		add: (LookPreferences edgeDecorator on: aView)		in: (LayoutFrame					leftFraction: 0 offset: 0					rightFraction: 1 offset: 0					topFraction: 0 offset: labelBottom					bottomFraction: 1 offset: 0).	window component: subViews.	^window</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="from:full:">from: aCompiledMethod full: fullFlag	| adjustedMethod compiler |	original := aCompiledMethod.	mclass := aCompiledMethod mclass.	sourceCode := aCompiledMethod sourcePointer.	(mclass compilerClass == Compiler		or: [(mclass compilerClass respondsTo: #treatsAsSimpleSmalltalk:)			and: [mclass compilerClass treatsAsSimpleSmalltalk: self getSource]])		ifFalse: [^self error: (#CannotInsertIncompatibleCompiler &lt;&lt; #pdp &gt;&gt; 'Cannot insert probe, selected class uses incompatible compiler.')].	compiler := ProbeExprCompiler new.	fullFlag		ifTrue: [compiler setCompileForProbes].	methodHolder := compiler			parse: aCompiledMethod getSource			in: mclass			environment: aCompiledMethod environment			allowReceiver: true			noPattern: aCompiledMethod usuallyHasSelector not			notifying: nil.	adjustedMethod := methodHolder generate.	probeStart := adjustedMethod numLiterals + 2.	self at: probeStart - 1 put: #actOn:.	1 to: adjustedMethod numLiterals do: 		[:i | | lit cl bm |		lit := adjustedMethod literalAt: i.		cl := lit class.		cl == CompiledBlock			ifTrue: 				[self literalAt: i put: (lit := ProbedCompiledBlock from: lit).				lit outerMethod: self]			ifFalse:				[cl == BlockClosure					ifTrue: 						[self literalAt: i put: (lit := lit copy).						bm := ProbedCompiledBlock from: lit method.						lit method: bm.						bm outerMethod: self]					ifFalse: [self literalAt: i put: lit]]].	self initializeBytes.	^self</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="Debugger-Probes" selector="copy">copy	^self class registerMethod: super copy.</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="Debugger-Probes" selector="copyOld">copyOld	^self class registerMethod: super copy.</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>selection moving-sizing</category><body package="UIPainter" selector="doVerticalSizing:spacing:">doVerticalSizing: aSymbol spacing: anIntegerOrNil	| selectedWidgets newHeight |	(selectedWidgets := self selectionList) size &gt; 1 ifFalse: [^self].  	self hideHandles.	aSymbol == #absolute 	ifTrue: 		[newHeight := anIntegerOrNil].	aSymbol == #first ifTrue:		[newHeight := self computeAlignmentPosition: [:bounds | bounds height] forceNoPrimary: false].	aSymbol == #max ifTrue:		[newHeight := selectedWidgets inject: 0 into: [:sum :each | sum max: each bounds height]].	aSymbol == #min ifTrue:		[newHeight := selectedWidgets inject: SmallInteger maxVal into: [:sum :each | sum min: each bounds height]].	selectedWidgets do:		[:each  | | boundingBox |		boundingBox := each bounds.		view newBounds: (boundingBox copy height: newHeight) oldBounds: boundingBox forWrapper: each].	self showHandles.	self canvasHasChanged: true.	view invalidate</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private</category><body package="UIPainter" selector="fractionalConstraintDialogForRectangular:frame:">fractionalConstraintDialogForRectangular: sel frame: aFrame	|  frame  leftOffset leftFraction rightOffset rightFraction topOffset topFraction bottomOffset bottomFraction dialog bounds oldFrame box newLeftFraction newTopFraction newLeftOffset newTopOffset newRightFraction newBottomFraction newRightOffset newBottomOffset builder |	frame := aFrame.	(leftFraction := self frameValueHolderFor: frame leftFraction)		compute: [:v | self correctFraction: leftFraction].	(leftOffset := self frameValueHolderFor: frame leftOffset)		compute: [:v | self defaultFraction: leftFraction forOffsetString: v].	(rightFraction := self frameValueHolderFor: frame rightFraction)		compute: [:v | self correctFraction: rightFraction].	(rightOffset := self frameValueHolderFor: frame rightOffset)		compute: [:v | self defaultFraction: rightFraction forOffsetString: v].	(topFraction := self frameValueHolderFor: frame topFraction)		compute: [:v | self correctFraction: topFraction].	(topOffset := self frameValueHolderFor: frame topOffset)		compute: [:v | self defaultFraction: topFraction forOffsetString: v].	(bottomFraction := self frameValueHolderFor: frame bottomFraction)		compute: [:v | self correctFraction: bottomFraction].	(bottomOffset := self frameValueHolderFor: frame bottomOffset)		compute: [:v | self defaultFraction: bottomFraction forOffsetString: v].	dialog :=SimpleDialog new.	builder := dialog builder.	builder source: self.	builder aspectAt: #leftOffset put: leftOffset.	builder aspectAt: #leftFraction put: leftFraction.	builder aspectAt: #topOffset put: topOffset.	builder aspectAt: #topFraction put: topFraction.	builder aspectAt: #rightOffset put: rightOffset.	builder aspectAt: #rightFraction put: rightFraction.	builder aspectAt: #bottomOffset put: bottomOffset.	builder aspectAt: #bottomFraction put: bottomFraction.	builder aspectAt: #leftSlide put: (TypeConverter on: leftFraction) stringToNumber.	builder aspectAt: #topSlide put: (TypeConverter on: topFraction) stringToNumber.	builder aspectAt: #rightSlide put: (TypeConverter on: rightFraction) stringToNumber.	builder aspectAt: #bottomSlide put: (TypeConverter on: bottomFraction) stringToNumber.	builder aspectAt: #emptyLeft put: [leftOffset value: ''. leftFraction value: ''].	builder aspectAt: #emptyTop put: [topOffset value: ''. topFraction value: ''].	builder aspectAt: #emptyRight put: [rightOffset value: ''. rightFraction value: ''].	builder aspectAt: #emptyBottom put: [bottomOffset value: ''. bottomFraction value: ''].	(dialog openFrom: (self class interfaceSpecFor: #layoutFrameDialogSpec)) ifFalse: [^self].	bounds := self view bounds.	frame := sel layout asLayout copy.	oldFrame := frame copy.	box := sel bounds.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left - (bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top - (bounds height * newTopFraction) rounded)].	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	(newRightFraction := self frameNumberFor: rightFraction) notNil		ifTrue:			[frame rightFraction: newRightFraction.			frame rightOffset:				(box right - (bounds width * newRightFraction) rounded)].	(newBottomFraction := self frameNumberFor: bottomFraction) notNil		ifTrue:			[frame bottomFraction: newBottomFraction.			frame bottomOffset:				(box bottom - (bounds height * newBottomFraction) rounded)].	newRightOffset := self frameNumberFor: rightOffset.	newBottomOffset := self frameNumberFor: bottomOffset.	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newRightOffset notNil				ifTrue:					[frame leftOffset:						frame leftOffset							+ (bounds width * (newRightFraction - oldFrame rightFraction)) rounded							+ newRightOffset - oldFrame rightOffset]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newBottomOffset notNil				ifTrue:					[frame topOffset:						frame topOffset							+ (bounds height * (newBottomFraction - oldFrame bottomFraction)) rounded							+ newBottomOffset - oldFrame bottomOffset]].	newRightOffset notNil		ifTrue: [frame rightOffset: newRightOffset]		ifFalse:			[newLeftOffset notNil				ifTrue:					[frame rightOffset:						frame rightOffset							+ (bounds width * (newLeftFraction - oldFrame leftFraction)) rounded							+ newLeftOffset - oldFrame leftOffset]].	newBottomOffset notNil		ifTrue: [frame bottomOffset: newBottomOffset]		ifFalse:			[newTopOffset notNil				ifTrue:					[frame bottomOffset:						frame bottomOffset							+ (bounds height * (newTopFraction - oldFrame topFraction)) rounded							+ newTopOffset - oldFrame topOffset]].	(self validateFrame: frame for: sel widget)		ifFalse: [^self].	sel newLayout: frame reducedForm.	view bounds: view bounds.	view topComponent display.	self canvasHasChanged: true.	^self</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>commands</category><body package="UIPainter" selector="doDefine">doDefine	model definer		interactivelyUpgradeDefns: self selectionList copy		for: self</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>selection moving-sizing</category><body package="UIPainter" selector="doHorizontalSizing:spacing:">doHorizontalSizing: aSymbol spacing: anIntegerOrNil	| selectedWidgets newWidth |	(selectedWidgets := self selectionList) size &gt; 1 ifFalse: [^self].  	self hideHandles.	aSymbol == #absolute 	ifTrue: 		[newWidth := anIntegerOrNil].	aSymbol == #first ifTrue:		[newWidth := self computeAlignmentPosition: [:bounds | bounds width] forceNoPrimary: false].	aSymbol == #max ifTrue:		[newWidth := selectedWidgets inject: 0 into: [:sum :each | sum max: each bounds width]].	aSymbol == #min ifTrue:		[newWidth := selectedWidgets inject: SmallInteger maxVal into: [:sum :each | sum min: each bounds width]].	selectedWidgets do:		[:each  | | boundingBox |		boundingBox := each bounds.		view newBounds: (boundingBox copy width: newWidth) oldBounds: boundingBox forWrapper: each].	self showHandles.	self canvasHasChanged: true.	view invalidate</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private</category><body package="UIPainter" selector="replaceSubCanvasesOfClass:andSelector:">replaceSubCanvasesOfClass: aClassName andSelector: aSelector	|  targetWrappers oldSels oldState |	oldSels := self selectionList copy.	targetWrappers := IdentitySet new.	view		downcastEvent: #mapBlock		with:			[:wrpr |			| spec |			((wrpr respondsTo: #spec) and: [((spec := wrpr spec) isKindOf: SubCanvasSpec) and:				[spec majorKey asQualifiedReference = aClassName asQualifiedReference and:					[spec minorKey == aSelector]]])				ifTrue:					[targetWrappers add: wrpr]]		from: view.	targetWrappers isEmpty ifTrue: [^self].	"The subcanvas that needs updating may be buried at any depth within the	structure."	targetWrappers copy do:		[:wrpr |		(view components includes: wrpr)			ifFalse:				[targetWrappers remove: wrpr.				targetWrappers addAll: (self model definer findSelectablesIn: self havingSpecs: (Array with: wrpr spec))]].	oldState := self canvasHasChanged.	targetWrappers do:		[:wrpr |		| new |		new := self replaceElement: wrpr basedOnSpec: wrpr spec.		(oldSels includes: wrpr)			ifTrue: [self quietlySelect: new]].	canvasHasChanged := oldState.	"The canvas that we just updated ourselves for may not be present in some	subcanvas structures that include us, simply because those structures were	built before the canvas was created.  Force the dependents that know about	us to update themselves.  This is going to result in some canvases getting	multiply updated; not nice, but better than missing updates."	(self model targetClass notNil and: [self model targetSelector notNil])		ifTrue:			[UIFinderVW2 changed: #installedCanvas					with: (Array with: model targetClass with: model targetSelector)]</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private-grouping</category><body package="UIPainter" selector="embedLayout:for:containedBy:">embedLayout: layout for: bounds containedBy: containingBounds	| l |	l := layout copy.	(layout isKindOf: LayoutOrigin)		ifTrue: [(layout leftFraction &gt; 0 and: [layout leftOffset ~= 0])					ifTrue: [l leftFraction: bounds left asFloat / containingBounds width offset: 0].				(layout topFraction &gt; 0 and: [layout topOffset ~= 0])					ifTrue: [l topFraction: bounds top asFloat / containingBounds height offset: 0].				(layout isKindOf: LayoutFrame) ifFalse: [^l].				(layout rightFraction &gt; 0 and: [layout rightOffset ~= 0])					ifTrue: [l rightFraction: bounds right asFloat / containingBounds width offset: 0].				(layout bottomFraction &gt; 0 and: [layout bottomOffset ~= 0])					ifTrue: [l bottomFraction: bounds bottom asFloat / containingBounds height offset: 0]].	^l</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private-grouping</category><body package="UIPainter" selector="extractLayout:for:containedBy:">extractLayout: layout for: bounds containedBy: containingBounds	| l |	l := layout copy.	(layout isKindOf: LayoutFrame)		ifTrue: [(layout leftFraction = 0 and: [layout leftOffset = 0 and: [(layout rightFraction + layout topFraction + layout bottomFraction) ~= 0]])					ifTrue: [l leftFraction: bounds left asFloat / containingBounds width].				(layout topFraction = 0 and: [layout topOffset = 0 and: [(layout bottomFraction + layout leftFraction + layout rightFraction ) ~= 0]])					ifTrue: [l topFraction: bounds top asFloat / containingBounds height]]		ifFalse: [(layout isKindOf: LayoutOrigin)					ifTrue: [(layout leftFraction = 0 and: [layout leftOffset = 0 and: [layout topFraction ~= 0]])								ifTrue: [l leftFraction: bounds left asFloat / containingBounds width].							(layout topFraction = 0 and: [layout topOffset = 0 and: [layout leftFraction ~= 0]])								ifTrue: [l topFraction: bounds top asFloat / containingBounds height]]].	^l</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private</category><body package="UIPainter" selector="fractionalConstraintDialogForOriginal:frame:">fractionalConstraintDialogForOriginal: sel frame: aFrame	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method could be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol, but for the moment we	are trying to minimize changes to the base product."	|  frame  leftOffset leftFraction topOffset topFraction  alignmentX alignmentY dialog bounds  box newLeftFraction newTopFraction newLeftOffset newTopOffset newAlignmentX newAlignmentY builder |	frame := aFrame.	leftFraction := self frameValueHolderFor: frame leftFraction.	(leftOffset := self frameValueHolderFor: frame leftOffset)		compute:			[:v |			(leftFraction value = '' and: [(v = '') not])				ifTrue: [leftFraction value: '0']].	topFraction := self frameValueHolderFor: frame topFraction.	(topOffset := self frameValueHolderFor: frame topOffset)		compute:			[:v |			(topFraction value = '' and: [(v = '') not])				ifTrue: [topFraction value: '0']].	(frame isKindOf: AlignmentOrigin)		ifTrue: [alignmentX := self frameValueHolderFor: frame leftAlignmentFraction.				alignmentY := self frameValueHolderFor: frame topAlignmentFraction]		ifFalse: [alignmentX := self frameValueHolderFor: 0.				alignmentY := self frameValueHolderFor: 0].	dialog :=SimpleDialog new.	builder := dialog builder.	builder source: self.	builder aspectAt: #leftOffset put: leftOffset.	builder aspectAt: #leftFraction put: leftFraction.	builder aspectAt: #topOffset put: topOffset.	builder aspectAt: #topFraction put: topFraction.	builder aspectAt: #alignmentX put: alignmentX.	builder aspectAt: #alignmentY put: alignmentY.	builder aspectAt: #leftSlide put: (TypeConverter on: leftFraction) stringToNumber.	builder aspectAt: #topSlide put: (TypeConverter on: topFraction) stringToNumber.	builder aspectAt: #alignmentXSlide put: (TypeConverter on: alignmentX) stringToNumber.	builder aspectAt: #alignmentYSlide put: (TypeConverter on: alignmentY) stringToNumber.	builder aspectAt: #emptyAlignmentX put: [alignmentX value: ''].	builder aspectAt: #emptyAlignmentY put: [alignmentY value: ''].	builder aspectAt: #emptyLeft put: [leftOffset value: ''. leftFraction value: ''].	builder aspectAt: #emptyTop put: [topOffset value: ''. topFraction value: ''].	(dialog openFrom: (self class interfaceSpecFor: #placementFrameDialogSpec)) ifFalse: [^self].	bounds := self view bounds.	frame := sel layout asLayout copy.	box := sel bounds.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box width * frame leftAlignmentFraction]						ifFalse: [0]) -					(bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box height * frame topAlignmentFraction]						ifFalse: [0]) -					(bounds height * newTopFraction) rounded)].	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	newAlignmentX := self frameNumberFor: alignmentX.	newAlignmentY := self frameNumberFor: alignmentY.	(newAlignmentX notNil or: [newAlignmentY notNil])		ifTrue:			[((newAlignmentX ~= 0 or: [newAlignmentY ~= 0]) and:					[(frame isKindOf: AlignmentOrigin) not])				ifTrue: [frame := frame asAlignmentOrigin]].	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newAlignmentX notNil				ifTrue:					[frame leftOffset: frame leftOffset +						(((newAlignmentX -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame leftAlignmentFraction]								ifFalse: [0])) * box width) rounded)]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newAlignmentY notNil				ifTrue:					[frame topOffset: frame topOffset +						(((newAlignmentY -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame topAlignmentFraction]								ifFalse: [0])) * box height) rounded)]].	(frame isKindOf: AlignmentOrigin)		ifTrue:			[newAlignmentX notNil				ifTrue: [frame leftAlignmentFraction: newAlignmentX].			newAlignmentY notNil				ifTrue: [frame topAlignmentFraction: newAlignmentY]].	(self validateFrame: frame for: sel widget)		ifFalse: [^self].	sel newLayout: frame reducedForm.	view bounds: view bounds.	view topComponent display.	self canvasHasChanged: true.	^self</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>resources</category><body package="UIPainter" selector="canvasMenu">canvasMenu	"MenuEditor new openOnClass: self andSelector: #canvasMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #UIPainter) 							#value: #doCopy #command: #copy ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #UIPainter) 							#value: #doCut #command: #cut ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #UIPainter) 							#value: #doPaste #command: #paste ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #UIPainter) 							#value: #accept #command: #accept) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: #(#{Kernel.UserMessage} #key: #Confirm #defaultString: 'Confirm' #catalogID: #UIPainter) 										#value: #cancel ) ) #(1 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Spawn #defaultString: 'Spawn' #catalogID: #UIPainter) 							#value: #doSpawn ) ) #(3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Tools #defaultString: 'Tools' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ImageEditor #defaultString: 'Image Editor' #catalogID: #UIPainter) 							#value: #maskEditor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #MenuEditor #defaultString: 'Menu Editor' #catalogID: #UIPainter) 							#value: #menuEditor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #HotRegionsEditor #defaultString: 'Hot Regions Editor' #catalogID: #UIPainter) 							#value: #regionsEditor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ReusableDataFormComponents #defaultString: 'Reusable Data Form Components' #catalogID: #UIPainter) 							#nameKey: #openReusableComponents							#value: #openReusableComponents ) ) #(3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Layout #defaultString: 'Layout' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Fixed #defaultString: 'Fixed' #catalogID: #UIPainter) 							#nameKey: #doLayoutFixed							#value: #doLayoutFixed #command: #uipainterBeFixed ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Relative #defaultString: 'Relative' #catalogID: #UIPainter) 							#nameKey: #doLayoutRelative							#value: #doLayoutRelative #command: #uipainterBeRelative ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Constrained #defaultString: 'Constrained...' #catalogID: #UIPainter) 							#nameKey: #fractionalConstraintDialog							#value: #fractionalConstraintDialog ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BeBounded #defaultString: 'Be Bounded' #catalogID: #UIPainter) 							#nameKey: #doMakeBounded							#value: #doMakeBounded ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BeUnbounded #defaultString: 'Be Unbounded' #catalogID: #UIPainter) 							#nameKey: #doMakeUnBounded							#value: #doMakeUnBounded ) ) #(3 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Arrange #defaultString: 'Arrange' #catalogID: #UIPainter) 				#nameKey: #arrange				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SnapToGrid #defaultString: 'Snap To Grid' #catalogID: #UIPainter) 							#value: #doSnapSelectionToGrid #command: #uipainterSnapSelectionToGrid ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Group #defaultString: 'Group' #catalogID: #UIPainter) 							#nameKey: #doGroup 							#value: #doGroup #command: #uipainterGroup ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Ungroup #defaultString: 'Ungroup' #catalogID: #UIPainter) 							#nameKey: #doUngroup 							#value: #doUngroup #command: #uipainterUngroup ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BringToFront #defaultString: 'Bring To Front' #catalogID: #UIPainter) 							#value: #toVisualFront   #command: #uipainterCirculateToFront ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BringForward #defaultString: 'Bring Forward' #catalogID: #UIPainter) 							#value: #toVisualFrontOne  #command: #uipainterCirculateFrontwards ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SendToBack #defaultString: 'Send To Back' #catalogID: #UIPainter) 							#value: #toVisualBack   #command: #uipainterCirculateToBack ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SendBackward #defaultString: 'Send Backward' #catalogID: #UIPainter) 							#value: #toVisualBackOne  #command: #uipainterCirculateBackwards ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #AlignDot #defaultString: 'Align...' #catalogID: #UIPainter) 							#nameKey: #alignDialog 							#value: #alignDialog  #command: #uipainterAlign ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #DistributeDot #defaultString: 'Distribute...' #catalogID: #UIPainter) 							#nameKey: #distributeDialog 							#value: #distributeDialog #command: #uipainterDistribute ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #EqualizeDot #defaultString: 'Equalize...' #catalogID: #UIPainter) 							#nameKey: #equalizeDialog 							#value: #equalizeDialog #command: #uipainterEqualize) ) #(1 2 4 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Special #defaultString: 'Special' #catalogID: #UIPainter) 				#nameKey: #special ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PainterTool #defaultString: 'Painter Tool' #catalogID: #UIPainter) 				#value: #doPainterTool ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Palette #defaultString: 'Palette' #catalogID: #UIPainter) 				#value: #doPalette ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InstallDot #defaultString: 'Install...' #catalogID: #UIPainter) 				#value: #doInstall #command: #uipainterInstall ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DefineDot #defaultString: 'Define...' #catalogID: #UIPainter) 				#nameKey: #doDefine				#value: #doDefine ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #BrowseDot #defaultString: 'Browse...' #catalogID: #UIPainter) 				#nameKey: #doBrowse				#value: #doBrowse ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Open #defaultString: 'Open' #catalogID: #UIPainter) 				#nameKey: #doOpen				#value: #doOpen #command: #open ) ) #(5 6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>class initialization</category><body package="UIPainter" selector="initializeDispatchTable">initializeDispatchTable	"Initialize the keyboard dispatch table"	"UIPainterController initializeDispatchTable."	KeyboardDispatchTable := DispatchTable new.	KeyboardDispatchTable defaultForCharacters: #ignoreInputKey:.	KeyboardDispatchTable defaultForNonCharacters: #ignoreInputKey:.	KeyboardDispatchTable bindValue: #cutKey: to: Character del.	KeyboardDispatchTable bindValue: #pasteKey: to: Character lf.	KeyboardDispatchTable bindValue: #cutKey: to: Character backspace.	"Sun convention compatibility"	KeyboardDispatchTable bindValue: #undoKey: to: #L4.	KeyboardDispatchTable bindValue: #copyKey: to: #L6.	KeyboardDispatchTable bindValue: #pasteKey: to: #L8.	KeyboardDispatchTable bindValue: #cutKey: to: #L10.	"Mac convention compatibility"	KeyboardDispatchTable bindValue: #undoKey: toCommand: #undo.	KeyboardDispatchTable bindValue: #cutKey: toCommand: #cut.	KeyboardDispatchTable bindValue: #copyKey: toCommand: #copy.	KeyboardDispatchTable bindValue: #pasteKey: toCommand: #paste.		KeyboardDispatchTable bindValue: #circulateBackKey: toCommand: #uipainterCirculateBackwards.	KeyboardDispatchTable bindValue: #circulateFrontKey: toCommand: #uipainterCirculateFrontwards.	KeyboardDispatchTable bindValue: #tabSelectKey: to: Character tab.	KeyboardDispatchTable bindValue: #bumpUpKey: to: #Up.	KeyboardDispatchTable bindValue: #bumpDownKey: to: #Down.	KeyboardDispatchTable bindValue: #bumpLeftKey: to: #Left.	KeyboardDispatchTable bindValue: #bumpRightKey: to: #Right.	KeyboardDispatchTable bindValue: #alignTopKey: toCommand: #uipainterAlignTop.	KeyboardDispatchTable bindValue: #alignBottomKey: toCommand: #uipainterAlignBottom.	KeyboardDispatchTable bindValue: #alignRightKey: toCommand: #uipainterAlignRight.	KeyboardDispatchTable bindValue: #alignLeftKey: toCommand: #uipainterAlignLeft.	KeyboardDispatchTable bindValue: #alignDialogKey: toCommand: #uipainterAlign.	KeyboardDispatchTable bindValue: #distributeDialogKey: toCommand: #uipainterDistribute.	KeyboardDispatchTable bindValue: #equalizeDialogKey: toCommand: #uipainterEqualize.	KeyboardDispatchTable bindValue: #layoutKey: toCommand: #uipainterLayout.	KeyboardDispatchTable bindValue: #dialogKey: toCommand: #uipainterDialog.	KeyboardDispatchTable bindValue: #groupKey: toCommand: #uipainterGroup.	KeyboardDispatchTable bindValue: #ungroupKey: toCommand: #uipainterUngroup.	KeyboardDispatchTable bindValue: #beRelativeKey: toCommand: #uipainterBeRelative.	KeyboardDispatchTable bindValue: #beFixedKey: toCommand: #uipainterBeFixed.	KeyboardDispatchTable bindValue: #snapSelectionToGridKey: toCommand: #uipainterSnapSelectionToGrid.	KeyboardDispatchTable bindValue: #installKey: toCommand: #uipainterInstall.</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>actions</category><body package="UIPainter" selector="preapply">preapply	| lp painterController |	painterController := propertiesTool controller.	painterController == nil ifTrue: [^self].	(lookPreferences backgroundColor isNil 			and: [lookPreferences foregroundColor isNil 			and: [lookPreferences selectionForegroundColor isNil 			and: [lookPreferences selectionBackgroundColor isNil]]])		ifTrue: [lp := nil]		ifFalse: [lp := lookPreferences copy].	propertiesTool selectionKind == #window		ifTrue: 			[| win temp default |			win := painterController sensor window.			lp == nil				ifTrue: [temp := nil]				ifFalse: 					[temp := win lookPreferences copy.					default := win defaultLookPreferences copy.					temp setForegroundColor: (lookPreferences foregroundColor == nil							ifTrue: [default foregroundColor]							ifFalse: [lookPreferences foregroundColor]).					temp setBackgroundColor: (lookPreferences backgroundColor == nil							ifTrue: [default backgroundColor]							ifFalse: [lookPreferences backgroundColor]).					temp setSelectionForegroundColor: (lookPreferences selectionForegroundColor == nil							ifTrue: [default selectionForegroundColor]							ifFalse: [lookPreferences selectionForegroundColor]).					temp setSelectionBackgroundColor: (lookPreferences selectionBackgroundColor == nil							ifTrue: [default selectionBackgroundColor]							ifFalse: [lookPreferences selectionBackgroundColor]).					temp setHiliteColor: nil.					temp setShadowColor: nil].			propertiesTool spec colors: temp.			win lookPreferences: temp]		ifFalse: 			[propertiesTool spec colors: lp.			propertiesTool selection do: [:wrpr | wrpr lookPreferences: lp]].	painterController canvasHasChanged: true.	self interruptedRead ifTrue: [self readMode value: true]</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>private</category><body package="UIPainter" selector="reloadSelectionInformation">reloadSelectionInformation	propertiesTool selectionKind == #multi		ifTrue: 			[self disableRead.			"self enableApply."]		ifFalse: 			[| selSpec |			selSpec := propertiesTool spec.			selSpec isNil ifTrue: [^self].			self enableRead.			self disableApply.			self showColorSettingsFor: selSpec colorSelections.			readMode value				ifTrue: 					[(lookPreferences := selSpec colors copy) == nil 						ifTrue: [lookPreferences := LookPreferences new].					self showColors]				ifFalse: [self enableApply]].	propertiesTool updateSelectionInTree</body></methods><methods><class-id>Tools.ClassFinder class</class-id> <category>resources</category><body package="Tools-Misc" selector="refreshIcon">refreshIcon	"RefreshIcon := nil"	RefreshIcon == nil		ifTrue: [RefreshIcon := self					iconFigure: self refreshIconColor					shape: self refreshIconMask].	^RefreshIcon copy</body></methods><methods><class-id>Tools.GridWrapper</class-id> <category>displaying</category><body package="UIPainter" selector="displayGridOn:">displayGridOn: aGraphicsContext 	| rect gc top g bottom left right |	g := grid value.	gc := aGraphicsContext copy.	gc paint: self gridPaint.	rect := aGraphicsContext clippingBounds intersect: self bounds.	left := rect left.	right := rect right.	top := rect top + (g // 2) // g * g.	bottom := rect bottom.	(showGrid value == #Show or: [griddedVertically value])		ifTrue: [[top &lt; bottom]				whileTrue: 					[gc displayRectangle: (left @ top corner: right @ (top + 1)).					top := top + g]].	top := rect top.	left := left + (g // 2) // g * g.	(showGrid value == #Show or: [griddedHorizontally value])		ifTrue: [[left &lt; right]				whileTrue: 					[gc displayRectangle: (left @ top corner: left + 1 @ bottom).					left := left + g]]</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>support</category><body package="UIPainter" selector="cancel">cancel	"Reset to the last accepted state."	| view fullSpec win bounds  |	(view := builder composite) controller removeSelections.	view components copy do: [:wrapper | view remove: wrapper. wrapper release].	fullSpec := self defaultSpecClass new fromLiteralArrayEncoding: acceptedState.	builder add: fullSpec component.	windowSpec := fullSpec window.	win := builder window.	(windowSpec labelInBuilder: builder) ifNotNil:[:label| win label: label].	self minWindowExtent: windowSpec min.	self maxWindowExtent: windowSpec max.	(bounds := windowSpec bounds) notNil		ifTrue: 			[self prefWindowExtent: bounds extent].	win lookPreferences: windowSpec colors.</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>support</category><body package="UIPainter" selector="changeComponentPolicyTo:">changeComponentPolicyTo: aPolicyName	| aPolicy currentState controller view formerPrimary formerSelections newSelections allComponents |	aPolicy := ( aPolicyName asQualifiedReference value ) basicNew.	controller := (view := builder composite) controller.	controller broadcastPendingSelectionChange.	currentState := self extractFullSpec.	(formerPrimary := controller primarySelection) notNil		ifTrue: [formerPrimary := formerPrimary spec].	formerSelections := controller selectionList collect: [:sw | sw spec].	controller removeSelections.	view components copy do:		[:wrapper | view remove: wrapper. wrapper release].	builder policy: aPolicy.	(view := view topComponent)		edgeDecorationPolicy: aPolicy borderLayoutPolicy.	view widgetPolicy: aPolicy widgetPolicy.	self fixBuildersWindow.	builder add: currentState component.	builder window flushCaches.	allComponents := NamedSpec new drilledWrappersFrom: builder composite components.	newSelections := allComponents select: 		[:each | 		(each isKindOf: SpecWrapper) and: [formerSelections includes: each spec]].	formerPrimary notNil		ifTrue:			[controller select: (allComponents				detect: [:each | formerPrimary == each spec]				ifNone: [#()]).			controller appendSelections: newSelections]		ifFalse: [controller selectionList: newSelections]</body></methods><methods><class-id>Tools.PoolDictionaryInspector</class-id> <category>field list</category><body package="Tools-Inspector" selector="noSelectionMenu">noSelectionMenu	"Answer a Menu of operations on the variables that is to be displayed 	when the operate menu button is pressed."	^object == Undeclared		ifTrue: [super noSelectionMenu copy					addItem: ((MenuItem labeled: (#RemoveUnusedBindings &lt;&lt; #menus &gt;&gt; 'Remove unused bindings'))									nameKey: #purgeUnusedBindings;									value: #purgeUnusedBindings;									yourself)]		ifFalse: [super noSelectionMenu]</body></methods><methods><class-id>Tools.Workspace class</class-id> <category>resources</category><body package="Tools-Workspace" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_New 								#defaultString: '&amp;New' 								#catalogID: #menus ) 							#nameKey: #fileNew 							#value: #fileNew 							#command: #new							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceNew ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_OpenDot 								#defaultString: '&amp;Open...' 								#catalogID: #menus ) 							#nameKey: #fileOpen 							#value: #fileOpen 							#command: #open							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Save 								#defaultString: '&amp;Save' 								#catalogID: #menus ) 							#nameKey: #fileSave 							#value: #fileSave 							#enablementSelector: #isAtTextPage 							#command: #save							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_AsDot 								#defaultString: 'Save &amp;As...' 								#catalogID: #menus ) 							#nameKey: #fileSaveAs 							#value: #fileSaveAs 							#command: #saveAs							#enablementSelector: #isAtTextPage ) ) #(1 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #menus ) 				#nameKey: #editMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Undo 								#defaultString: '&amp;Undo' 								#catalogID: #menus ) 							#nameKey: #editUndo 							#value: #undo 							#enablementSelector: #canUndo 							#command: #undo ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Cu_t 								#defaultString: 'Cu&amp;t' 								#catalogID: #menus ) 							#nameKey: #editCut 							#value: #cut 							#enablementSelector: #isAtTextPage 							#command: #cut 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Copy 								#defaultString: '&amp;Copy' 								#catalogID: #menus ) 							#nameKey: #editCopy 							#value: #copySelection 							#command: #copy							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Paste 								#defaultString: '&amp;Paste' 								#catalogID: #menus ) 							#nameKey: #editPaste 							#value: #paste 							#command: #paste 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FindDots 								#defaultString: '&amp;Find...' 								#catalogID: #menus ) 							#nameKey: #editFind 							#value: #find 							#command: #find ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReplaceDots 								#defaultString: '&amp;Replace...' 								#catalogID: #menus ) 							#nameKey: #editReplace 							#value: #replace 							#command: #replace ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Select_All 								#defaultString: 'Select &amp;All' 								#catalogID: #menus ) 							#nameKey: #editSelectAll 							#value: #selectAll							#command: #selectAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Encoding 								#defaultString: '&amp;Encoding' 								#catalogID: #menus ) 							#nameKey: #editEncoding ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_InDot 								#defaultString: 'Boss &amp;In...' 								#catalogID: #menus ) 							#value: #bossIn 							#enablementSelector: #canBOSSObjects ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_OutDot 								#defaultString: 'Boss &amp;Out...' 								#catalogID: #menus ) 							#value: #bossOut 							#enablementSelector: #canBOSSObjects ) ) #(1 3 2 1 1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Smalltalk 					#defaultString: '&amp;Smalltalk' 					#catalogID: #menus ) 				#nameKey: #smalltalkSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DoIt 								#defaultString: '&amp;Do it' 								#catalogID: #menus ) 							#value: #smalltalkDoIt 							#command: #doIt 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PrintIt 								#defaultString: '&amp;Print it' 								#catalogID: #menus ) 							#value: #smalltalkPrintIt 							#command: #printIt 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InspectIt 								#defaultString: '&amp;Inspect it' 								#catalogID: #menus ) 							#value: #smalltalkInspectIt 							#command: #inspectIt 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #De_bugIt 								#defaultString: 'De&amp;bug it' 								#catalogID: #menus ) 							#value: #smalltalkDebugIt 							#command: #debugIt 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NamespacesDot 								#defaultString: '&amp;Namespaces...' 								#catalogID: #menus ) 							#value: #editImports 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.BehaviorIcons} #Namespace ) ) ) #(4 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #menus ) 				#nameKey: #viewSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Text 								#defaultString: '&amp;Text' 								#catalogID: #menus ) 							#nameKey: #pageText 							#value: #showTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Variables 								#defaultString: '&amp;Variables' 								#catalogID: #menus ) 							#nameKey: #pageVariables 							#value: #showInspectorPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_BecomeMultiPage 								#defaultString: '&amp;Become Multi-Page' 								#catalogID: #menus ) 							#value: #mutateToWorkbook ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Options 					#defaultString: '&amp;Options' 					#catalogID: #menus ) 				#nameKey: #optionsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Toolbar 								#defaultString: '&amp;Toolbar' 								#catalogID: #menus ) 							#nameKey: #toolbar 							#value: #toggleToolbar 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_StatusBar 								#defaultString: '&amp;Status Bar' 								#catalogID: #menus ) 							#nameKey: #toggleStatusBar 							#value: #toggleStatusBar ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Workspace 								#defaultString: '&amp;Workspace' 								#catalogID: #menus ) 							#value: #helpWorkspace 							#command: #help 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(1 1 ) nil ) ) ) #(6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.SettingsDomain</class-id> <category>notifications</category><body package="Tools-Settings" selector="tryInstallingSomeUnappliedSnapshots">tryInstallingSomeUnappliedSnapshots	"Since this is called by #instanceMethodsChanged which may be called often,	be careful about doing things efficiently. In particular, do not instantiate settings	unless it is necessary, and instead dealing with pragmas directly."	| pragmas |	pragmas := Dictionary new.	(Pragma allNamed: #setting: in: self class class) do:		[:each | pragmas at: (each argumentAt: 1) put: each].	(Pragma allNamed: #setting:position: in: self class class) do:		[:each | pragmas at: (each argumentAt: 1) put: each].	unappliedSnapshots copy do:		[:each | | pragma setting |		(pragmas includesKey: each id) ifTrue:			[pragma := pragmas at: each id.			setting := self class perform: pragma selector.			[setting restoreFrom: each]				on: InvalidStoredSettingDataError				do: [:ex | ex return].			unappliedSnapshots remove: each]]</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>private</category><body package="Tools-Misc" selector="spawnFile">spawnFile	"Open a FileList if the selected file is a directory otherwise open a file 	editor that edits the current selection."	| state controller splitFileName newFileName |	self isFileInfo ifTrue: [^self spawnFileList].	self isDirectory ifTrue: [^self spawnFileList].	self isFileEditing ifFalse: [^self invalidMenuOptionClicked].	controller := self textEditorController.	state := Array				with: controller text copy				with: controller selectionStartIndex				with: controller selectionStopIndex.	splitFileName := Filename splitExtension: fileName.	newFileName := splitFileName first , '-copy.' , splitFileName last.	self class openOnFileNamed: newFileName withTextState: state</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="helpLabelKeyFor:put:">helpLabelKeyFor: item put: aSymbolOrNil 	| changed |	changed := true.	item helpText isString 		ifTrue: 			[aSymbolOrNil isNil 				ifTrue: [changed := false]				ifFalse: [item helpText: (UserMessage 								defaultString: item helpText								key: aSymbolOrNil)]]		ifFalse: 			[item helpText: ((aSymbolOrNil isNil and: [item helpText catalogID isNil]) 				ifTrue: [item helpText defaultString]				ifFalse: [item helpText copy key: aSymbolOrNil])].	changed ifTrue: 			[menuList list 				changed: #at:				with: menuList selectionIndexes asArray first].	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="labelKeyFor:put:">labelKeyFor: item put: aSymbolOrNil	| changed |	changed := true.	item rawLabel isString 		ifTrue: 			[aSymbolOrNil isNil 				ifTrue: [changed := false]				ifFalse: [item rawLabel: (UserMessage defaultString: item rawLabel key: aSymbolOrNil)]]		ifFalse: 			[item rawLabel: ((aSymbolOrNil isNil and: [item rawLabel catalogID isNil])				ifTrue: [item rawLabel defaultString]				ifFalse: [item rawLabel copy key: aSymbolOrNil])].	changed ifTrue: 		[menuList list			changed: #at:			with: menuList selectionIndexes asArray first].	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="catalogIDFor:put:">catalogIDFor: item put: aSymbolOrNil	| changed |	changed := true.	item rawLabel isString		ifTrue: 			[aSymbolOrNil isNil 				ifTrue: [changed := false]				ifFalse: 					[item rawLabel: (UserMessage 						defaultString: item rawLabel 						key: nil 						catalogID: aSymbolOrNil)]]		ifFalse: 			[item rawLabel: ((aSymbolOrNil isNil and: [item rawLabel key isNil])				ifTrue: [item rawLabel defaultString]				ifFalse: [item rawLabel copy catalogID: aSymbolOrNil])].	changed ifTrue: 		[menuList list			changed: #at:			with: menuList selectionIndexes asArray first].	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private</category><body package="UIPainter" selector="pasteBufferDepth:">pasteBufferDepth: newDepth	| delta |	PasteBuffer == nil ifTrue: [PasteBuffer := #()].	delta := PasteBuffer size = 0			ifTrue: [0]			ifFalse: [newDepth-PasteBuffer first value].	^PasteBuffer collect: [:i | i key copy-&gt;(i value+delta)]</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>editing operations</category><body package="UIPainter" selector="shiftLeft">shiftLeft	"Move all selected items to the left. If one of the	selected items is already at the left margin, do nothing.	If a selected item has a submenu, then the submenu	is also shifted left in order to preserve the integrity of	the menu."	| list sel list1 |	list := menuList selectionIndexes copy.	list1 := list copy.		"Add in the submenu, but only if it has not		been added before. This means that the left		shift will add extra items ONLY when needed		to preserve the integrity of the menu, which		means that there's a greater chance that a		right shift will be able to undo the edit."	list copy do:		[:i | (list1 includes: i+1)			ifFalse: [list addAll: (self indicesForAllChildren: i)]].	menuList selectionIndexes: list.	(list contains: [:i | (menuList list at: i) value = 0])		ifTrue: [^self flash].	list do:		[:i |		sel := menuList list at: i.		sel value: (sel value-1 max: 0).		menuList list changed: #at: with: i.		].	self updateProperties.	self rebuildMenu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="defaultStringFor:put:">defaultStringFor: item put: aStringOrNil	| ensuredString |	ensuredString := aStringOrNil ifNil: [String new] ifNotNil: [aStringOrNil trimBlanks].	(item rawLabel isNil			or: [item rawLabel isString 			or: [item rawLabel key isNil &amp; item rawLabel catalogID isNil]])		ifTrue: [item rawLabel: ensuredString]		ifFalse: [item rawLabel: (item rawLabel copy defaultString: ensuredString)].	menuList list		changed: #at:		with: menuList selectionIndexes asArray first.	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private</category><body package="UIPainter" selector="copySelection:">copySelection: list	PasteBuffer := list collect: [:i | i key copy-&gt;i value]</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter" selector="helpCatalogIDFor:put:">helpCatalogIDFor: item put: aSymbolOrNil 	| changed |	changed := true.	item helpText isString 		ifTrue: 			[aSymbolOrNil isNil 				ifTrue: [changed := false]				ifFalse: [item helpText: (UserMessage 								defaultString: item helpText								key: nil								catalogID: aSymbolOrNil)]]		ifFalse: 			[item helpText: ((aSymbolOrNil isNil and: [item helpText key isNil]) 				ifTrue: [item helpText defaultString]				ifFalse: [item helpText copy catalogID: aSymbolOrNil])].	changed ifTrue: 			[menuList list 				changed: #at:				with: menuList selectionIndexes asArray first].	self menuBar value: menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>actions</category><body package="UIPainter" selector="read">read	| isMenuBar spec controller mnu sels |	self changeRequest ifFalse: [^self].	isMenuBar := false.	controller := selectionHolder value.	sels := controller selections.	spec := (sels isNil or: [sels isEmpty])		ifTrue:			[isMenuBar := true.			controller model windowSpec]		ifFalse: [controller selections first spec].	"We are relying on Read not being enabled if the selected component's	controller does not understand #menu."	spec menu isNil		ifTrue:			[(isMenuBar not and: [(mnu := sels first widget controller menu copy) notNil])				ifFalse:					[Dialog warn: (#GenKey6 &lt;&lt; #UIPainter &gt;&gt; 'The selected component''s propertiesdon''t specify a menu') for: builder window.					^self]]		ifFalse:			[mnu := controller builder menuAt: spec menu].	(mnu isNil or: [((mnu := mnu value) isKindOf: Menu) not])		ifTrue:			[Dialog warn: (#GenKey5 &lt;&lt; #UIPainter &gt;&gt; 'The application did not supply a menu.') for: builder window.			^self].	self initializeFromMenu: mnu.	self targetClass: controller builder source selector: spec menu.</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>resources</category><body package="UIPainter" selector="toolBar">toolBar	"MenuEditor new openOnClass: self andSelector: #toolBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install' #catalogID: #UIPainter) 				#nameKey: #install 				#value: #install 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #installMenu ) 				#helpText: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InsertItem #defaultString: 'Insert Item' #catalogID: #UIPainter) 				#nameKey: #addBelow 				#value: #addBelow 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuItem ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #insertItem 					#defaultString: 'Insert Item' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InsertSeparator #defaultString: 'Insert Separator' #catalogID: #UIPainter) 				#nameKey: #addLine 				#value: #addLine 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuSeparator ) 				#helpText: #(#{Kernel.UserMessage} #key: #InsertSeparator #defaultString: 'Insert Separator' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InsertSubmenuItem #defaultString: 'Insert Submenu Item' #catalogID: #UIPainter) 				#nameKey: #addChild 				#value: #addChild 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newSubmenuItem ) 				#helpText: #(#{Kernel.UserMessage} #key: #InsertSubmenuItem #defaultString: 'Insert Submenu Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CutItem #defaultString: 'Cut Item' #catalogID: #UIPainter) 				#nameKey: #cutItem 				#value: #cutItem 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) 				#helpText: #(#{Kernel.UserMessage} #key: #CutItem #defaultString: 'Cut Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CopyItem #defaultString: 'Copy Item' #catalogID: #UIPainter) 				#nameKey: #copyItem 				#value: #copyItem 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) 				#helpText: #(#{Kernel.UserMessage} #key: #CopyItem #defaultString: 'Copy Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PasteItem #defaultString: 'Paste Item' #catalogID: #UIPainter) 				#nameKey: #pasteBelow 				#value: #pasteBelow 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) 				#helpText: #(#{Kernel.UserMessage} #key: #PasteItem #defaultString: 'Paste Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DeleteItem #defaultString: 'Delete Item' #catalogID: #UIPainter) 				#nameKey: #removeSelection 				#value: #removeSelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) 				#helpText: #(#{Kernel.UserMessage} #key: #DeleteItem #defaultString: 'Delete Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveUp #defaultString: 'Move Up' #catalogID: #UIPainter) 				#nameKey: #shiftUp 				#value: #shiftUp 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemUp ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveUp #defaultString: 'Move Up' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveDown #defaultString: 'Move Down' #catalogID: #UIPainter) 				#nameKey: #shiftDown 				#value: #shiftDown 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemDown ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveDown #defaultString: 'Move Down' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveRight #defaultString: 'Move Right' #catalogID: #UIPainter) 				#nameKey: #shiftRight 				#value: #shiftRight 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemRight ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveRight #defaultString: 'Move Right' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveLeft #defaultString: 'Move Left' #catalogID: #UIPainter) 				#nameKey: #shiftLeft 				#value: #shiftLeft 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemLeft ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveLeft #defaultString: 'Move Left' #catalogID: #UIPainter) ) ) #(1 3 4 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>resources</category><body package="UIPainter" selector="editingMenuBar">editingMenuBar	"MenuEditor new openOnClass: self andSelector: #editingMenuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Men_u #defaultString: '&amp;Men&amp;u' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_New #defaultString: '&amp;New' #catalogID: #UIPainter) 							#value: #newMenu 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 8 ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_LoadDot #defaultString: '&amp;Load...' #catalogID: #UIPainter) 							#value: #load 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_InstallDot #defaultString: '&amp;Install...' #catalogID: #UIPainter) 							#value: #install 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #installMenu ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Read #defaultString: '&amp;Read' #catalogID: #UIPainter) 							#value: #read ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_ApplyDot #defaultString: '&amp;Apply...' #catalogID: #UIPainter) 							#value: #apply ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Close #defaultString: '&amp;Close' #catalogID: #UIPainter) 							#value: #closeRequest 							#shortcutKeyCharacter: $Q 							#shortcutModifiers: 8 ) ) #(3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Edit #defaultString: '&amp;Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_NewItem #defaultString: '&amp;New Item' #catalogID: #UIPainter) 							#value: #addBelow 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuItem ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #New_Separator #defaultString: 'New &amp;Separator' #catalogID: #UIPainter) 							#value: #addLine 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuSeparator ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #NewS_ubmenuItem #defaultString: 'New S&amp;ubmenu Item' #catalogID: #UIPainter) 							#value: #addChild 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newSubmenuItem ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cu_tItem #defaultString: 'Cu&amp;t Item' #catalogID: #UIPainter) 							#value: #cutItem 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_CopyItem #defaultString: '&amp;Copy Item' #catalogID: #UIPainter) 							#value: #copyItem 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_PasteItem #defaultString: '&amp;Paste Item' #catalogID: #UIPainter) 							#nameKey: #'$p' 							#value: #pasteBelow 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_DeleteItem #defaultString: '&amp;Delete Item' #catalogID: #UIPainter) 							#nameKey: #'''$d''' 							#value: #removeSelection 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) ) ) #(3 4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Move #defaultString: '&amp;Move' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Up #defaultString: '&amp;Up' #catalogID: #UIPainter) 							#value: #shiftUp 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemUp ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Down #defaultString: '&amp;Down' #catalogID: #UIPainter) 							#value: #shiftDown 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemDown ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Right #defaultString: '&amp;Right' #catalogID: #UIPainter) 							#value: #shiftRight 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemRight ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Left #defaultString: '&amp;Left' #catalogID: #UIPainter) 							#value: #shiftLeft 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemLeft ) ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #V_iew #defaultString: 'V&amp;iew' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_SampleMenuBar #defaultString: '&amp;Sample Menu Bar' #catalogID: #UIPainter) 							#value: #showMenuBar ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Test #defaultString: '&amp;Test' #catalogID: #UIPainter) 				#nameKey: #testItem ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>resources</category><body package="UIPainter" selector="itemsMenu">itemsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #itemsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #UIPainter ) 				#value: #cutItem 				#shortcutKeyCharacter: $X 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #UIPainter ) 				#value: #copyItem 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #UIPainter ) 				#value: #pasteBelow 				#shortcutKeyCharacter: $V 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Delete 					#defaultString: 'Delete' 					#catalogID: #UIPainter ) 				#value: #removeSelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) ) ) #(3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>private</category><body package="UIPainter" selector="frameSizedOriginSelection:in:">frameSizedOriginSelection: aSelection in: aController	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method might be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol."	| bounds frame box newLeftFraction newTopFraction newLeftOffset newTopOffset newWidth newHeight |	bounds := aController view bounds.	frame := aSelection layout asLayout copy.	box := aSelection bounds.	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left - (bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top - (bounds height * newTopFraction) rounded)].	newWidth := self frameNumberFor: sizeWidth.	newHeight := self frameNumberFor: sizeHeight.	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset].	newWidth notNil		ifTrue: [frame width: newWidth].	newHeight notNil		ifTrue: [frame height: newHeight].	^frame</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>private</category><body package="UIPainter" selector="frameOriginalSelection:in:">frameOriginalSelection: aSelection in: aController	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method might be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol."	| bounds frame  box newLeftFraction newTopFraction newLeftOffset newTopOffset newAlignmentX newAlignmentY |	bounds := aController view bounds.	frame := aSelection layout asLayout copy.	frame copy.	box := aSelection bounds.	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	newAlignmentX := self frameNumberFor: alignmentX.	newAlignmentY := self frameNumberFor: alignmentY.	(newAlignmentX notNil or: [newAlignmentY notNil])		ifTrue:			[((newAlignmentX ~= 0 or: [newAlignmentY ~= 0]) and:					[(frame isKindOf: AlignmentOrigin) not])				ifTrue: [frame := frame asAlignmentOrigin]].	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box width * frame leftAlignmentFraction]						ifFalse: [0]) -					(bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box height * frame topAlignmentFraction]						ifFalse: [0]) -					(bounds height * newTopFraction) rounded)].	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newAlignmentX notNil				ifTrue:					[frame leftOffset: frame leftOffset +						(((newAlignmentX -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame leftAlignmentFraction]								ifFalse: [0])) * box width) rounded)]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newAlignmentY notNil				ifTrue:					[frame topOffset: frame topOffset +						(((newAlignmentY -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame topAlignmentFraction]								ifFalse: [0])) * box height) rounded)]].	(frame isKindOf: AlignmentOrigin)		ifTrue:			[newAlignmentX notNil				ifTrue: [frame leftAlignmentFraction: newAlignmentX].			newAlignmentY notNil				ifTrue: [frame topAlignmentFraction: newAlignmentY]].	^frame</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>private</category><body package="UIPainter" selector="frameRectangularSelection:in:">frameRectangularSelection: aSelection in: aController	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method might be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol."	| bounds frame oldFrame box newLeftFraction newTopFraction newLeftOffset newTopOffset newRightFraction newBottomFraction newRightOffset newBottomOffset |	bounds := aSelection container bounds.	frame := aSelection layout asLayout copy.	oldFrame := frame copy.	box := aSelection bounds.	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left - (bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top - (bounds height * newTopFraction) rounded)].	(newRightFraction := self frameNumberFor: rightFraction) notNil		ifTrue:			[frame rightFraction: newRightFraction.			frame rightOffset:				(box right - (bounds width * newRightFraction) rounded)].	(newBottomFraction := self frameNumberFor: bottomFraction) notNil		ifTrue:			[frame bottomFraction: newBottomFraction.			frame bottomOffset:				(box bottom - (bounds height * newBottomFraction) rounded)].	newRightOffset := self frameNumberFor: rightOffset.	newBottomOffset := self frameNumberFor: bottomOffset.	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newRightOffset notNil				ifTrue:					[frame leftOffset:						frame leftOffset +							(bounds width * (newRightFraction - oldFrame rightFraction)) rounded +							newRightOffset - oldFrame rightOffset]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newBottomOffset notNil				ifTrue:					[frame topOffset:						frame topOffset +							(bounds height * (newBottomFraction - oldFrame bottomFraction)) rounded +							newBottomOffset - oldFrame bottomOffset]].	newRightOffset notNil		ifTrue: [frame rightOffset: newRightOffset]		ifFalse:			[newLeftOffset notNil				ifTrue:					[frame rightOffset:						frame rightOffset +							(bounds width * (newLeftFraction - oldFrame leftFraction)) rounded +							newLeftOffset - oldFrame leftOffset]].	newBottomOffset notNil		ifTrue: [frame bottomOffset: newBottomOffset]		ifFalse:			[newTopOffset notNil				ifTrue:					[frame bottomOffset:						frame bottomOffset +							(bounds height * (newTopFraction - oldFrame topFraction)) rounded +							newTopOffset - oldFrame topOffset]].	^frame</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>actions</category><body package="UIPainter" selector="maskify">maskify	| newImage oldImage colorWhite colorBlack takeBuffer putBuffer |	self accept.	oldImage := magnifiedBitView model copy.	newImage := oldImage copy.	Cursor execute showWhile:		[colorWhite := oldImage palette indexOf: ColorValue white.		colorBlack := oldImage palette indexOf: ColorValue black.		takeBuffer := Array new: oldImage width.		putBuffer := Array new: oldImage width.		0 to: newImage height -1 do:			[:rowIndex |			oldImage rowAt: rowIndex into: takeBuffer.			1 to: takeBuffer size do:				[:colIndex |				(takeBuffer at: colIndex) = colorWhite					ifTrue: [putBuffer at: colIndex put: colorWhite]					ifFalse: [putBuffer at: colIndex put: colorBlack]].		newImage rowAt: rowIndex putAll: putBuffer].		magnifiedBitView model: newImage; changedPreferredBounds:nil; invalidate.		directBitView model: newImage; changedPreferredBounds:nil; invalidate].	self modified: true</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>actions</category><body package="UIPainter" selector="cancel">cancel	| newImage |	Cursor execute showWhile:		[newImage := self acceptedState copy.		magnifiedBitView model: newImage; changedPreferredBounds: nil; invalidate.		directBitView model: newImage; changedPreferredBounds: nil; invalidate].</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>private</category><body package="UIPainter" selector="toColor:">toColor: aColorIndex	| controller point oldImage zeroColor newImage takeBuffer putBuffer |	controller := builder window controller.	oldImage := magnifiedBitView model copy.	Cursor crossHair showWhile:		[[controller sensor anyButtonPressed not] whileTrue: [].		[controller sensor anyButtonPressed] whileTrue: []].	point := magnifiedBitView controller sensor cursorPoint.	(magnifiedBitView bounds containsPoint: point) ifFalse: [^self].	point := (point scaledBy: 1 / magnifiedBitView scale) truncated.	(oldImage bounds containsPoint: point)		ifFalse: [^self].	zeroColor := oldImage atPoint: point.	newImage := oldImage copy.	takeBuffer := Array new: oldImage width.	putBuffer := Array new: oldImage width.	0 to: newImage height -1 do:		[:rowIndex |		oldImage rowAt: rowIndex into: takeBuffer.		1 to: takeBuffer size do:			[:colIndex |			(takeBuffer at: colIndex) = zeroColor				ifTrue: [putBuffer at: colIndex put: aColorIndex]				ifFalse: [putBuffer at: colIndex put: (takeBuffer at: colIndex)]].		newImage rowAt: rowIndex putAll: putBuffer].	magnifiedBitView model: newImage; changedPreferredBounds:nil; invalidate.	directBitView model: newImage; changedPreferredBounds: nil; invalidate</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>actions</category><body package="UIPainter" selector="accept">accept	self acceptedState: magnifiedBitView model copy</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>initialize-release</category><body package="UIPainter" selector="initialize">initialize	| image buffer white colorImage |	super initialize.	Screen default colorDepth == 1		ifTrue: [storeMask := ValueHolder with: true]		ifFalse: [storeMask := ValueHolder with: false].	useCachedImage := ValueHolder with: true.	colorImage := self class colorPaletteImage image.	image := Image				extent: 32 @ 32				depth: colorImage depth				palette: colorImage palette.	buffer := Array new: image width.	white := image palette indexOf: ColorValue white.	1 to: buffer size do: [:colIndex | buffer at: colIndex put: white].	0 to: image height - 1 do: [:rowIndex | image rowAt: rowIndex putAll: buffer].	acceptedState := image copy.	magnifiedBitView := ColorBitView model: image.	magnifiedBitView scale: 8 @ 8.	magnifiedBitView controller currentColor: (image palette indexOf: ColorValue black).	directBitView := DirectBitView model: image.	magnifiedBitView changedPreferredBounds: nil.	modified := false.	storeMask onChangeSend: #storeMaskChanged to: self</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>private</category><body package="UIPainter" selector="generateMask">generateMask	| oldImage colorWhite newImage opaque transparent takeBuffer putBuffer |	oldImage := magnifiedBitView model copy.	colorWhite := oldImage palette indexOf: ColorValue white.	newImage := Image				extent: oldImage extent				depth: 1				palette: CoveragePalette monoMaskPalette				bits: (ByteArray new: ((oldImage width + 31 // 32 * 4) * oldImage height)).	opaque := newImage palette indexOf: CoverageValue opaque.	transparent := newImage palette indexOf: CoverageValue transparent.	takeBuffer := Array new: oldImage width.	putBuffer := Array new: oldImage width.	0 to: oldImage height - 1		do: 			[:rowIndex | 			oldImage rowAt: rowIndex into: takeBuffer.			1 to: takeBuffer size do: [:colIndex | (takeBuffer at: colIndex)					== colorWhite					ifTrue: [putBuffer at: colIndex put: transparent]					ifFalse: [putBuffer at: colIndex put: opaque]].			newImage rowAt: rowIndex putAll: putBuffer].	^newImage</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>private</category><body package="UIPainter" selector="setColorFor:">setColorFor: aButtonId	| currentLookPreferences color colorNumber |	color := (builder componentAt: aButtonId) lookPreferences backgroundColor.	currentLookPreferences := (builder componentAt: #currentColorID) lookPreferences copy.	currentLookPreferences setBackgroundColor: color.	colorNumber := magnifiedBitView model  palette indexOf: color ifAbsent: [magnifiedBitView model  palette indexOfPaintNearest: color].	magnifiedBitView controller currentColor: colorNumber.	(builder componentAt: #currentColorID)		lookPreferences: currentLookPreferences</body></methods><methods><class-id>Tools.UIMaskEditor class</class-id> <category>resources</category><body package="UIPainter" selector="maskEditorMenu">maskEditorMenu	"MenuEditor new openOnClass: self andSelector: #maskEditorMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Image #defaultString: 'Image' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Capture #defaultString: 'Capture' #catalogID: #UIPainter) 							#value: #grab ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #LoadDot #defaultString: 'Load...' #catalogID: #UIPainter) 							#value: #load ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #InstallDot #defaultString: 'Install...' #catalogID: #UIPainter) 							#value: #install ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Read #defaultString: 'Read' #catalogID: #UIPainter) 							#nameKey: #read							#value: #read ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Apply #defaultString: 'Apply' #catalogID: #UIPainter) 							#nameKey: #apply							#value: #apply ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #StoreB__WMask #defaultString: 'Store B&amp;&amp;W Mask' #catalogID: #UIPainter) 							#nameKey: #toggleStoreMask							#value: #toggleStoreMask ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #StoreCachedImage #defaultString: 'Store Cached Image' #catalogID: #UIPainter) 							#nameKey: #toggleUseCache							#value: #toggleUseCache ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ResizeImage #defaultString: 'Resize Image' #catalogID: #UIPainter) 							#value: #clip ) ) #(3 2 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 							#value: #cancel ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #UIPainter) 							#value: #accept ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #UIPainter) 							#value: #cut ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #UIPainter) 							#value: #copy ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #UIPainter) 							#value: #paste ) ) #(2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Draw #defaultString: 'Draw' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #FillRectangle #defaultString: 'Fill Rectangle' #catalogID: #UIPainter) 							#nameKey: #fillCurrentColor 							#value: #fillCurrentColor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ReplaceColor #defaultString: 'Replace Color' #catalogID: #UIPainter) 							#nameKey: #toCurrentColor 							#value: #toCurrentColor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ColorToB__W #defaultString: 'Color to B&amp;&amp;W' #catalogID: #UIPainter) 							#value: #maskify ) ) #(3 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>displaying</category><body package="Store-Code Comparison" selector="displayChild:on:">displayChild: aChild on: aGC	| drawDecoration oldPaint detailGC |	oldPaint := aGC paint.	(aChild == self header and: [self hasFocus])		ifTrue: [self displayHeaderFocusOn: aGC].	drawDecoration := self isExpanded and: [aChild == self detailsPanel].	detailGC := aGC copy.	drawDecoration ifTrue: [self drawDetailsBackroundOn: detailGC].	super displayChild: aChild on: detailGC.	drawDecoration ifTrue: [self drawDetailsBorderOn: detailGC].	aGC paint: oldPaint</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>actions</category><body package="Tools-Changes" selector="inspectChangeSet">inspectChangeSet	self currentPackage copy inspect</body></methods><methods><class-id>Tools.SettingsManagerPageTreeRoot</class-id> <category>private</category><body package="Tools-Settings" selector="findPlaceFor:in:">findPlaceFor: aPage in: rootPages	rootPages do:		[:each |		(aPage isChildOf: each) ifTrue:			[^each findPlaceFor: aPage]].	rootPages add: aPage.	rootPages copy do:		[:each |		(each isChildOf: aPage) ifTrue:			[rootPages remove: each.			aPage findPlaceFor: each]]</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>interface opening</category><body package="HighlightingStyles" selector="postBuildWith:">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	self samplesMenu value notNil ifTrue: [self samplesMenu value menuItems first value value].	self emphasisEditor setStyles: (self stylesHolder value collect: [:s | s copy]).	self addHighlighters.	self applyStyles.</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>actions</category><body package="HighlightingStyles" selector="acceptRefresh">acceptRefresh	"Perform an acceptance action."	&lt;action: 0&gt;	self emphasisEditor setStyles: (self stylesHolder value collect: [:s | s copy])</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>changing</category><body package="HighlightingStyles" selector="changedStyle">changedStyle	"Respond to a change in the emphasis editor."	self stylesHolder isBuffering		ifFalse:			[| attrs style |			self stylesHolder value: self emphasisEditor styles.			style := self textController view textStyle copy.			attrs := style characterAttributes copy.			attrs attributes: CharacterAttributes extraDefaults copy.			style setCharacterAttributes: attrs.			self textController view textStyle: style].	self applyStyles</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>change editing</category><body package="System-Changes" selector="doIts:">doIts: aCollection	specialDoIts removeAll: specialDoIts copy; addAll: aCollection</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>store</category><body package="System-Changes" selector="renamedComponent:to:">renamedComponent: aPundle to: newName	"aPundle is being renamed. Move references under old name to new name."	| newKey oldKey changes |	oldKey := ComponentChange fromComponent: aPundle.	newKey := oldKey copy componentName: newName.	(changes := componentChanges removeKey: oldKey ifAbsent: nil) == nil ifFalse: 		[componentChanges at: newKey put: changes]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>menus</category><body package="UIPainter" selector="setMenus">setMenus	| viewMenu selMenu noSelMenu classMenu helpMenu list |	viewMenu := self class viewMenu.	selMenu := self class selMenu.	noSelMenu := self class noSelMenu.	classMenu := self class classMenu.	helpMenu := self class helpMenu.	menuBarMenuWithNoSelection := (Menu new) 		addItem: ((MenuItem labeled: (#_View &lt;&lt; #UIPainter &gt;&gt; '&amp;View')) nameKey: #viewMenu; submenu: viewMenu); 		addItem: ((MenuItem labeled: (#_Class &lt;&lt; #UIPainter &gt;&gt; '&amp;Class')) nameKey: #classMenu; submenu: classMenu); 		addItem: ((MenuItem labeled: (#_Resources &lt;&lt; #UIPainter &gt;&gt; '&amp;Resources')) nameKey: #resourcesMenu; submenu: noSelMenu; disable);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: helpMenu).	classMenu := classMenu copy.	classMenu menuItems do: [:each | each enable].	(classMenu atNameKey: #showDatabaseApplicationStructure) 		enabled: [(self selectedClassOrDo: []) canUnderstand: #dataModel ].	menuBarMenuWithSelection := (Menu new)		addItem: ((MenuItem labeled: (#_View &lt;&lt; #UIPainter &gt;&gt; '&amp;View')) nameKey: #viewMenu; submenu: viewMenu); 		addItem: ((MenuItem labeled: (#_Class &lt;&lt; #UIPainter &gt;&gt; '&amp;Class')) nameKey: #classMenu; submenu: classMenu); 		addItem: ((MenuItem labeled: (#_Resources &lt;&lt; #UIPainter &gt;&gt; '&amp;Resources')) nameKey: #resourcesMenu; submenu: selMenu; disable);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: helpMenu).	menuBarMenuWithNoCanvasSelected := (Menu new)		addItem: ((MenuItem labeled: (#_View &lt;&lt; #UIPainter &gt;&gt; '&amp;View')) nameKey: #viewMenu; submenu: viewMenu); 		addItem: ((MenuItem labeled: (#_Class &lt;&lt; #UIPainter &gt;&gt; '&amp;Class')) nameKey: #classMenu; submenu: classMenu); 		addItem: ((MenuItem labeled: (#_Resources &lt;&lt; #UIPainter &gt;&gt; '&amp;Resources')) nameKey: #resourcesMenu; submenu: noSelMenu);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: helpMenu).	viewMenu := viewMenu copy.	viewMenu menuItems do: [ :item | item label: item label asLowercase.							item label = (#exit &lt;&lt; #UIPainter &gt;&gt; 'exit') asString ifTrue: [ viewMenu hideItem: item ] ].	classMenu := classMenu copy.	classMenu menuItems do: [  :item | item label: item label asLowercase].	classListMenuWithSelection := (Menu new)		addItemGroup: (Array with: ((MenuItem labeled: (#view &lt;&lt; #UIPainter &gt;&gt; 'view')) nameKey: #viewMenu; submenu: viewMenu)).	classMenu visibleMenuItemGroups 		do: [ :group | 1 to: group size 			do: [ :i | i == 1 					ifTrue: [ classListMenuWithSelection addItemGroup: (Array with: (group at: 1)) ] 					ifFalse:[ classListMenuWithSelection addItem: (group at: i)  ] ]].	list := classMenu values asOrderedCollection.	list addFirst: nil.	classListMenuWithSelection values: list. 	classListMenuForNoSelection := (Menu new)		addItemGroup: (Array with: ((MenuItem labeled: (#view &lt;&lt; #UIPainter &gt;&gt; 'view')) nameKey: #viewMenu; submenu: viewMenu));		addItemGroup: (Array with: (MenuItem labeled: (#adddots &lt;&lt; #UIPainter &gt;&gt; 'add...'))) values: #(addClass)</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>commands</category><body package="UIPainter" selector="showClassesByCategory">showClassesByCategory	| selector categoryClasses stringSize |	stringSize := UISettings preferenceFor: #toolsLabelStringLimit.	selector := Dialog				choose: (#SelectClassCategory &lt;&lt; #UIPainter &gt;&gt; 'Select class category...')				fromList: (SpecBearingCategories asSortedStrings collect: [:sel | sel contractTo: stringSize])				values: SpecBearingCategories asSortedStrings				lines: 10				cancel: [nil]				for: builder window.	selector == nil		ifFalse: 			[self filter: #showClassesByLastCategory.				(builder componentAt: #ClassNameListLabel) widget labelString: ((#x1sClasses &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; Classes')			expandMacrosWith: selector asString).			categoryClasses := Set new.			lastCategory := selector.			SpecBearingClasses copy				do: 					[:classID | | cl cln |					(cl := classID valueOrDo: [SpecBearingClasses remove: classID. nil]) notNil						ifTrue:							[cln := cl category.							cln = selector								ifTrue: [categoryClasses add: classID]]].			self showClasses: categoryClasses]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>private</category><body package="UIPainter" selector="removeClassAndAdjustSets:">removeClassAndAdjustSets: aClassID	((SpecBearingClasses remove: aClassID ifAbsent: []) isNil and:			[(RecentlyVisitedClasses remove: aClassID ifAbsent: []) isNil])		ifTrue: [^self].	SpecBearingCategories := Set new.	SpecBearingClasses copy do:		[:classID | | cl |		(cl := classID valueOrDo: []) notNil			ifTrue: [SpecBearingCategories add: cl category]			ifFalse: [SpecBearingClasses remove: classID]]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>commands</category><body package="UIPainter" selector="showClassesByLastCategory">showClassesByLastCategory	| categoryClasses |	lastCategory isNil		ifTrue: 			[self showAllClasses.			^self].	self filter: #showClassesByLastCategory.	(builder componentAt: #ClassNameListLabel) widget labelString: ((#x1sClasses &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; Classes')			expandMacrosWith: lastCategory asString).	categoryClasses := Set new.	SpecBearingClasses copy		do: 			[:classID |			| cl cln |			(cl := classID valueOrDo: [SpecBearingClasses remove: classID. nil]) notNil				ifTrue:					[cln := cl category.					cln = lastCategory						ifTrue: [categoryClasses add: classID]]].	self showClasses: categoryClasses</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>statistics</category><body package="UIPainter" selector="recentlyVisitedClasses">recentlyVisitedClasses	^RecentlyVisitedClasses copy</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>private</category><body package="UIPainter" selector="computeRecentlyVisitedMenu">computeRecentlyVisitedMenu	"UIFinderVW2 computeRecentlyVisitedMenu"	| labels values |	RecentlyVisitedClasses isEmpty		ifTrue:			[Dialog warn: (#GenKey97 &lt;&lt; #UIPainter &gt;&gt; 'There are no recently visited classes')].	labels := OrderedCollection new.	values := OrderedCollection new.	RecentlyVisitedClasses copy do:		[:classID |		| list cl |		((cl := classID valueOrDo: [nil]) notNil and:				[(list := cl class organization listAtCategoryNamed: #'interface specs') isEmpty not])			ifTrue:				[labels add: classID asString.				values add:					(list size == 1						ifTrue:							[[UIPainter new openOnClass: cl andSelector: list first]]						ifFalse:							[Menu								labelArray:									(list collect: [:elt | elt asString]) asArray								values:									(list collect:										[:selName |										[UIPainter new openOnClass: cl andSelector: selName]])])]			ifFalse:				[RecentlyVisitedClasses remove: classID ifAbsent: [self error: (#shouldntHappen &lt;&lt; #UIPainter &gt;&gt; 'shouldn''t happen')]]].	^Menu		labelArray: labels asArray		lines: Array new		values: values asArray</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>interface opening</category><body package="UIPainter" selector="openSourceDialogForResource:">openSourceDialogForResource: resourceType	"Open to collect an existing class and a new or existing selector as 	the 	destination of a UI specification."	| dialog selList newSel results builder ctrl uid finder |	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #clientClass put: (finder := ClassFinder new).	builder aspectAt: #existingSelectors put: (selList := (SelectionInList new) list: List new; selection: nil asValue; yourself).	finder className		compute: 			[:v | | cl |			cl := finder selectedClass.			cl isNil				ifTrue: 					[selList list: Array new.					(dialog builder componentAt: #ClassNameField) flash]				ifFalse: 					[selList list: (self selectorsOfResource: resourceType in: cl class)]].	builder aspectAt: #newSelector put: (newSel := String new asValue).	builder aspectAt: #doAbort put: [dialog close].	dialog		postBuildBlock: 			[:sd :bldr | 			ctrl := (bldr componentAt: #SelectorSIL) widget controller.			uid := ctrl dispatcher copy.			uid doubleClick: [(results := self							resultsForClassName: finder selectedClassID							andSelectorList: selList							orSelectorNamed: newSel value							resource: resourceType) notNil					ifTrue: [dialog close]					ifFalse: [(dialog builder componentAt: (finder foundClass								ifFalse: [#ClassNameField]								ifTrue: [#SelectorSIL])) flash]].			ctrl setDispatcher: uid].	builder aspectAt: #doOK put: [(results := self					resultsForClassName: finder selectedClassID					andSelectorList: selList					orSelectorNamed: newSel value					resource: resourceType) notNil			ifTrue: [dialog close]			ifFalse: [(dialog builder componentAt: (finder foundClass						ifFalse: [#ClassNameField]						ifTrue: [#SelectorSIL])) flash]].	dialog openFrom: (self interfaceSpecFor: #sourceDialog).	^results</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>interface opening</category><body package="UIPainter" selector="openSourceDialogForClass:andResource:">openSourceDialogForClass: aClass andResource: resourceType 	"Open to collect an existing class and a new or existing selector as 	the destination of a UI specification."	| dialog selList newSel results builder ctrl uid listBlock finder |	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #clientClass put: (finder := ClassFinder new).	finder className value: (aClass isNil					ifTrue: [String new]					ifFalse: [aClass fullName]).	listBlock := [:cl | | list |			list := List new.			cl == nil				ifFalse: [cl class selectorsAndMethodsDo:						[:sel :meth |						meth resourceType = resourceType ifTrue: [list add: sel]]].			list sort.			list].	builder aspectAt: #existingSelectors		put: ((selList := SelectionInList new)				list: (listBlock value: aClass);				selection: nil asValue;				yourself).	finder className		compute: 			[:v | | cl |			cl := finder selectedClass.			cl isNil				ifTrue: 					[selList list: Array new.					(dialog builder componentAt: #clientClass) flash]				ifFalse: 					[selList list: (listBlock value: cl)]].	builder aspectAt: #newSelector put: (newSel := String new asValue).	builder aspectAt: #doAbort put: [dialog close].	dialog		postBuildBlock: 			[:sd :bldr | 			ctrl := (bldr componentAt: #SelectorSIL) widget controller.			uid := ctrl dispatcher copy.			uid doubleClick: [(results := self							resultsForClassName: finder selectedClassID							andSelectorList: selList							orSelectorNamed: newSel value							resource: resourceType) notNil					ifTrue: [dialog close]					ifFalse: [(dialog builder componentAt: (finder foundClass								ifFalse: [#clientClass]								ifTrue: [#SelectorSIL])) flash]].			ctrl setDispatcher: uid].	builder aspectAt: #doOK put: [(results := self					resultsForClassName: finder selectedClassID					andSelectorList: selList					orSelectorNamed: newSel value					resource: resourceType) notNil			ifTrue: [dialog close]			ifFalse: [(dialog builder componentAt: (finder foundClass						ifFalse: [#clientClass]						ifTrue: [#SelectorSIL])) flash]].	dialog openFrom: (self interfaceSpecFor: #sourceDialog).	^results</body></methods><methods><class-id>Tools.PaintedDataSetView</class-id> <category>private</category><body package="UIPainter" selector="paintSelectedColumnOn:">paintSelectedColumnOn: graphicsContext 	| ci gc first tf |	gc := graphicsContext copy.	gc paint: self selectionBackgroundColor.	ci := self xRangesFor: selectionIndex inBounds: self bounds.	(selectionIndex &gt; (numFrozen max: 2) and: [ ci first &lt; (tf := (self xRangesFor: numFrozen inBounds: self bounds) last) ])		ifTrue: [ first := tf ]		ifFalse: [ first := ci first ].	gc displayRectangle: (first @ self bounds top corner: ci last @ self bounds bottom).	self displayDragHandleOn: (gc clippingRectangle: ((first @ self bounds top corner: ci last @ self bounds bottom) intersect: self bounds))</body></methods><methods><class-id>Tools.PaintedDataSetView</class-id> <category>private</category><body package="UIPainter" selector="displayDragHandleOn:">displayDragHandleOn: gc	| handleRect tGc tColor |	tGc := gc copy.	handleRect := self dragHandleBounds.	handleRect extent y = 0 ifTrue: [ ^self ].	tColor := tGc paintPreferencesMatchAt: SymbolicPaint selectionForeground.	tGc paintPreferencesMatchAt: SymbolicPaint selectionBackground put: tColor.	tGc displayRectangle: self dragHandleBounds</body></methods><methods><class-id>Tools.FileTools.ParcelFileViewer</class-id> <category>private</category><body package="Tools-File Browser" selector="capitalized:">capitalized: aStringOrSymbol	| copy |	copy := aStringOrSymbol asString copy.	copy at: 1 put: copy first asUppercase.	^copy</body></methods><methods><class-id>Tools.FileTools.FileViewer class</class-id> <category>resources</category><body package="Tools-File Browser" selector="readOnlyCodeMenu">readOnlyCodeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyCodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#command: #doIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#command: #inspectIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#command: #debugIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#command: #copy				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#value: #findNext				#command: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#value: #selectEntireText				#command: #selectAll ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FileTools.FileTextViewer</class-id> <category>private</category><body package="Tools-File Browser" selector="compareTextWithFile:">compareTextWithFile: aFilename	"Open a Differator on the text currently on the page (on the left) and the text from the file on the right."	| text fileText |	self withTextViewControllerDo:		[:textEditor |		text := textEditor text copy.		fileText := [aFilename contentsOfEntireFile]			on: OsError do: [:ex | ex return: String new].		(Differator newOn: text and: fileText) open]</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>resources</category><body package="Tools-File Browser" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Directory 					#defaultString: '&amp;Directory' 					#catalogID: #menus ) 				#nameKey: #directory 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDot 								#defaultString: '&amp;New...' 								#catalogID: #menus ) 							#value: #createSubdirectory 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RenameDot 								#defaultString: '&amp;Rename...' 								#catalogID: #menus ) 							#value: #renameDirectory 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_moveDot 								#defaultString: 'Re&amp;move...' 								#catalogID: #menus ) 							#value: #removeDirectory 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_fresh 								#defaultString: 'Re&amp;fresh' 								#catalogID: #menus ) 							#value: #refreshDirectory 							#enablementSelector: #hasDirectoryInTreeSelected 							#shortcutKeyCharacter: #F5 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #refreshFolder ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_CopyName 								#defaultString: '&amp;Copy Name' 								#catalogID: #menus ) 							#value: #copyDirectoryFilename 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#value: #inspectDirectoryFilename 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GoTo_DefaultDirectory 								#defaultString: 'Go to &amp;Default Directory' 								#catalogID: #menus ) 							#value: #selectDefaultDirectory 							#enablementSelector: #notDefaultDirectorySelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #goToDefaultFolder ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GoToDot 								#defaultString: '&amp;Go to...' 								#catalogID: #menus ) 							#value: #goToDirectory 							#shortcutKeyCharacter: $G 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #goToFolder ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #InitialSelection 								#defaultString: '&amp;Initial Selection' 								#catalogID: #menus ) 							#nameKey: #initialSelection ) ) #(3 3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDot 								#defaultString: '&amp;New...' 								#catalogID: #menus ) 							#nameKey: #create 							#value: #createFile ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RenameDot 								#defaultString: '&amp;Rename...' 								#catalogID: #menus ) 							#value: #renameFileOrDirectory 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_moveDot 								#defaultString: 'Re&amp;move...' 								#catalogID: #menus ) 							#value: #removeFileOrDirectory 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CopyDot 								#defaultString: '&amp;Copy...' 								#catalogID: #menus ) 							#nameKey: #copy 							#value: #copyFile 							#enablementSelector: #hasFileSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Encoding 								#defaultString: '&amp;Encoding' 								#catalogID: #menus ) 							#nameKey: #fileEncoding ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #C_opyName 								#defaultString: 'C&amp;opy Name' 								#catalogID: #menus ) 							#value: #copyFilename 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#value: #inspectFilename 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Edit 								#defaultString: '&amp;Edit' 								#catalogID: #menus ) 							#nameKey: #fileEdit 							#value: #fileEdit 							#enablementSelector: #hasFileSelected 							#shortcutKeyCharacter: $E 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{FileBrowser} #editIcon ) ) ) #(4 1 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #menus ) 				#nameKey: #view 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RefreshAll 								#defaultString: '&amp;Refresh All' 								#catalogID: #menus ) 							#value: #fullUpdate 							#shortcutKeyCharacter: #F5 							#shortcutModifiers: 8 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Zoom 								#defaultString: '&amp;Zoom' 								#catalogID: #menus ) 							#nameKey: #viewZoom 							#value: #toggleZoom 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #zoom ) ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileBrowser 								#defaultString: 'File &amp;Browser' 								#catalogID: #menus ) 							#value: #helpFileBrowser 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AboutFiles 								#defaultString: '&amp;Files' 								#catalogID: #menus ) 							#value: #helpFiles ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #aboutVisualWorks ) ) #(2 1 ) nil ) ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>resources</category><body package="Tools-File Browser" selector="baseFileListMenu">baseFileListMenu	"MenuEditor new openOnClass: self andSelector: #baseFileListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_NewDot #defaultString: '&amp;New...' #catalogID: #menus) 				#nameKey: #create 				#value: #createFile ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameDot #defaultString: 'Re&amp;name...' #catalogID: #menus) 				#value: #renameFileOrDirectory 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #defaultString: '&amp;Remove...' #catalogID: #menus) 				#value: #removeFileOrDirectory 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CopyDot #defaultString: '&amp;Copy...' #catalogID: #menus) 				#nameKey: #copy 				#value: #copyFile 				#enablementSelector: #hasFileSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Encoding #defaultString: '&amp;Encoding' #catalogID: #menus) 				#nameKey: #fileEncoding ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #C_opyName #defaultString: 'C&amp;opy Name' #catalogID: #menus) 				#value: #copyFilename 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InspectFilename #defaultString: '&amp;Inspect Filename' #catalogID: #menus) 				#value: #inspectFilename 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Edit #defaultString: '&amp;Edit' #catalogID: #menus) 				#value: #fileEdit 				#enablementSelector: #hasFileSelected 				#shortcutKeyCharacter: $E 				#shortcutModifiers: 8 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #editIcon ) ) ) #(4 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ArtificialTreeItemHolder class</class-id> <category>instance creation</category><body package="Tools-Modules" selector="hierarchicallyArranged:usingDirectRelation:">hierarchicallyArranged: aCollection usingDirectRelation: aBlock	| roots |	roots := OrderedCollection new.	aCollection do: 		[:each | | item |		item := self on: each.		roots copy do: 			[:eachRoot |			(aBlock value: each value: eachRoot value) ifTrue:				[roots remove: eachRoot.				item addChild: eachRoot]].		(roots anySatisfy: [:some | some maybeAddDirectChild: item using: aBlock])			ifFalse: [roots add: item]].	^(self on: nil) children: roots</body></methods><methods><class-id>Tools.TopLevelParcelGroup</class-id> <category>accessing</category><body package="Tools-Parcel Manager" selector="sortedSubgroups">sortedSubgroups	| extraGroups home sorted |	extraGroups := subgroups copy.	extraGroups		remove: visualWorksGroup;		remove: goodiesGroup;		remove: previewGroup.	home := extraGroups detect: [:some | some name = '.'] ifNone: [nil].	sorted := OrderedCollection new.	home notNil ifTrue:		[extraGroups remove: home.		sorted add: home].	sorted 		add: visualWorksGroup;		add: goodiesGroup;		add: previewGroup.	sorted addAll: (extraGroups asSortedCollection: [:a :b | a name &lt;= b name]).	^sorted asArray</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>resources</category><body package="UIPainter" selector="fieldMenu">fieldMenu	^MenuBuilder new		add: (#find &lt;&lt; #UIPainter &gt;&gt; 'find...')-&gt;[:ctrlr | ctrlr find];		add: (#replace &lt;&lt; #UIPainter &gt;&gt; 'replace...')-&gt;			[:ctrlr |			ctrlr replace.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		line;		add: (#undo &lt;&lt; #UIPainter &gt;&gt; 'undo') -&gt;			[:ctrlr |			ctrlr undo.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		line;		add: (#copy &lt;&lt; #UIPainter &gt;&gt; 'copy')-&gt;[:ctrlr | ctrlr copySelection];		add: (#cut &lt;&lt; #UIPainter &gt;&gt; 'cut')-&gt;			[:ctrlr |			ctrlr cut.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		add: (#paste &lt;&lt; #UIPainter &gt;&gt; 'paste')-&gt;			[:ctrlr |			ctrlr paste.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		line;		add: (#accept &lt;&lt; #UIPainter &gt;&gt; 'accept')-&gt;[:ctrlr | ctrlr accept];		add: (#cancel &lt;&lt; #UIPainter &gt;&gt; 'cancel')-&gt;[:ctrlr | ctrlr cancel];		menu</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>private</category><body package="UIPainter" selector="currentSpecFor:andController:">currentSpecFor: oneOrMoreUISpecifications andController: aController	"Answer the relevant spec and set the selectionKind for the oneOrMoreUISpecifications selected."	^oneOrMoreUISpecifications size = 0 		ifTrue: 			[selectionKind := #window.			aController model windowSpec copy]		ifFalse: 			[oneOrMoreUISpecifications size = 1 				ifTrue: 					[selectionKind := #single.					oneOrMoreUISpecifications first spec copy]				ifFalse: 					[selectionKind := #multi.					MultiSpec new]]</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>actions</category><body package="UIPainter" selector="apply">apply	"Copy the information in 'currentSpecCopy' to the selected components."	| labelM labelConstructor |	currentSpecCopy isDataValid ifFalse: [^self].	(controller == nil or: [controller view == nil]) ifTrue: [^self].	lock := true.	client preapply.	selectionKind == #single 		ifTrue: 			["replaceElement:etc. will cause change to be noted, and  select: will cause UIPainterWatchers to be alerted."			| selElem sel spec doReselect doInvalidate |			selElem := selection first.			sel := controller selectionList.			doReselect := sel size = 1 and: [sel first = selElem].			spec := currentSpecCopy copy.			doInvalidate := (spec getLabel isNil or: [selElem spec getLabel isNil]) not.			(spec shouldCompareLayouts: selElem spec) ifTrue: 				[spec layout: selElem spec layout.				currentSpecCopy layout = spec layout ifFalse: [currentSpecCopy layout: spec layout]].			selElem := controller 				replaceElement: selElem 				basedOnSpec: spec.			selection := Array with: selElem.			doReselect ifTrue: [controller select: selElem].			doInvalidate ifTrue: [currentView invalidate]]		ifFalse: 			[selectionKind == #multi				ifTrue: 					[| newSelection spec controllerSelections | 					newSelection := OrderedCollection new: selection size.					controllerSelections := controller selectionList.					controllerSelections copy do: 						[:selElem | 						spec := selElem spec copy.						currentSpecCopy copyPropertiesTo: spec.						newSelection add: (controller 							replaceElement: selElem 							basedOnSpec: spec)].					selection := newSelection.					controller selectionList: newSelection.					self fillCanvasTree.					self updateSelectionInTree]				ifFalse: 					[selectionKind == #window						ifTrue: 							[labelConstructor := (currentSpecBindings at: #labelConstructor ifAbsent: [nil]).							labelM := labelConstructor isNil 								ifTrue: [currentSpecCopy labelInBuilder: controller model builder]								ifFalse: [labelConstructor unsavedLabel].							(currentSpecCopy labelInBuilder: controller model builder) = labelM ifFalse: 								[(currentSpecBindings at: #labelConstructor) acceptUnsavedChanges.								labelM := currentSpecCopy labelInBuilder: controller model builder].							(labelM notNil and: [labelM asString isEmpty and: [(UIPainter preferenceFor: #hostWindowManager) == #OSFMotif]])								ifTrue: 									[self builder window component flash.									^self]. 							controller model windowSpec label: labelM.							controller model windowSpec: currentSpecCopy copy.							controller model fixBuildersWindow.							controller model builder window flushCaches.							labelM isNil ifFalse: [controller model builder window label: labelM].							controller canvasHasChanged: true.							canvasTree selection isNil ifTrue: [self updateSelectionInTree].							labelM isNil ifFalse: [canvasTree selection label: labelM]. 							(builder componentAt: #canvasTree) widget updateAt: 1.]]].	self statusBarText value: controller activePainterWindow label asString.	self displayButtonsForUnmodifiedState.	client postapply.	lock := false</body></methods><methods><class-id>Tools.CommandBindingsEditor.BindingPanel</class-id> <category>accessing</category><body package="Tools-Settings-Commands" selector="keystrokes:">keystrokes: aKeystrokeArray	self removeAll: self children copy.	(aKeystrokeArray isNil or: [ aKeystrokeArray isEmpty ]) ifTrue: [		self add: (BindingLabel bindingPanel: self keystroke: nil)	] ifFalse: [		aKeystrokeArray do: [ :keystroke |			self add: (BindingLabel bindingPanel: self keystroke: keystroke)		]	]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>private</category><body package="Tools-Changes" selector="updateList">updateList	"Update the current list by recomputing the displayed list from the underlying list.	 Note that we do so lazily to display the visible part of the new list quicker.	 Each actual list entry is calculated in the selectionInList's visualBlocks created	 in the receiver's postBuildWith: method."	Cursor execute showWhile: [		| oldChange newIndex |		selectionIndex &gt; 0 ifTrue: [oldChange := list at: selectionIndex].		filter := nil.		filterList do: [:aSymbol | aSymbol notNil ifTrue: [self addFilter: aSymbol]].		filter isNil			ifTrue: [filter := [:change | true].					list := changes copy]			ifFalse: [list := changes select: filter].		newIndex :=			oldChange == nil				ifTrue: [0]				ifFalse: [list identityIndexOf: oldChange].		"Simply set the selectionInList's list to be the empty list.  This speeds		 up redisplay at the cost of slightly slower scrolling."		selectionInList list: (List withSize: list size).		self updateSelection: newIndex]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>accessing</category><body package="Tools-Changes" selector="value:">value: aValue 	"The receiver's text for the currently selected change (if any) has 	changed. Update the text view, and update the change's text."	| thisChange newChange |	value := aValue.	self changed: #value.	(value size &gt; 0 and: [selectionIndex &gt; 0]) ifTrue:		[thisChange := list at: selectionIndex.		thisChange text ~= value asString ifTrue: [			"Since this ChangeList may share changes with others			 (via spawning or Drag+Drop), copy the change to			 ensure the change in text doesn't affect anything else."			newChange := thisChange copy.			newChange text: value asString.			list at: selectionIndex				put: (changes						at: (changes indexOf: thisChange)						put: newChange).			self updateSelection: selectionIndex]]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>accessing</category><body package="Tools-Changes" selector="existingText">existingText	"Answer a Text corresponding to the current version of the change	 (method or class) in the system."	| change src conflictText originalText sysCat different srcFragments originalFragments differences |	selectionIndex &lt;= 0 ifTrue: [^self blankText].	"Take a copy of both texts to ensure the emphasis in the text itself is 	not modified by the comparison."	(originalText := self selectionText) isNil ifTrue: [originalText := ''].	originalText := originalText copy asText.	(conflictText := self noConflictTextFor: (change := self selection))		== nil			ifFalse: 				[self setValue: originalText.				self changed: #value.				^conflictText].	src := (change cleanSourceFrom: (self conflictTextFor: change)) copy				asText.	srcFragments := src smalltalkOrWordAndWhitespaceFragments.	originalFragments := originalText smalltalkOrWordAndWhitespaceFragments.	differences := originalFragments differences: srcFragments.	different := differences anySatisfy: [:each | each isMatch not].	differences do: #applyAnyDifferenceTextEmphases.	self setValue: originalText.	self changed: #value.	^different		ifTrue: [src]		ifFalse: 			[((change isMethodRelated				and: [change category ~= (sysCat := change systemCategory)])					ifTrue: 						[#protocol1s &lt;&lt; #dialogs &gt;&gt; 'protocol &lt;1s&gt;' expandMacrosWith: (sysCat isNil									ifTrue: [ClassOrganizer defaultProtocol]									ifFalse: [sysCat])]					ifFalse: [(#NoConflict &lt;&lt; #dialogs &gt;&gt; 'no conflict') asString]) asText				emphasizeAllWith: #italic]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>private-menus</category><body package="Tools-Changes" selector="buildTextMenu">buildTextMenu	| menu |	menu := Menu				labelList: (Array with: (Array with: #Accept &lt;&lt; #dialogs &gt;&gt; 'Accept')						with: (Array								with: #DoIt &lt;&lt; #dialogs &gt;&gt; 'Do it'								with: #PrintIt &lt;&lt; #dialogs &gt;&gt; 'Print it'								with: #InspectIt &lt;&lt; #dialogs &gt;&gt; 'Inspect it'								with: #DebugIt &lt;&lt; #dialogs &gt;&gt; 'Debug it'))							, TextEditorController editGroupLabels , (Array									with: (Array with: #ChangeTextStyle &lt;&lt; #dialogs &gt;&gt; 'Change Text Style')									with: (Array with: #Format &lt;&lt; #dialogs &gt;&gt; 'Format'											with: #Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))				values: #(#accept #doIt #printIt #inspectIt #debugIt)						, TextEditorController editGroupSelectors							, #(#changeTextStyle #format:from: #cancel).	(menu menuItemWithValue: #accept)		shortcutKeyCharacter: $S;		shortcutModifiers: 2.	#(#doIt #printIt #inspectIt #debugIt #cut #paste)		with: #($D $P $Q $B $X $V)		do: 			[:each :eachKey |			(menu menuItemWithValue: each)				labelImage: (ToolbarIconLibrary visualFor: each);				shortcutKeyCharacter: eachKey;				shortcutModifiers: 2].	(menu menuItemWithValue: #copySelection)		labelImage: (ToolbarIconLibrary visualFor: #copy);		shortcutKeyCharacter: $C;		shortcutModifiers: 2.	^menu</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>private-icons</category><body package="UIPainter" selector="populateSpec:">populateSpec: prototypeSpec 	"Replicate a prototype spec by creating clones and changing the layout.	Also send adaptButton:toRepresent: message to chage button's properties.	The layout algorithm is 'numberOfColumns' icons in a row in the window."	| width height maximumColumns iconPosition currentColumn firstX rows rect finalExtent |	rect := (prototypeSpec layout rectangleRelativeTo: builder window bounds preferred: nil).	width := rect width.	height := rect height.	maximumColumns := self numberOfColumns.	iconPosition := 0 @ 0.	firstX := iconPosition x.	currentColumn := 0. 	activeSpecs		do: 			[:spec | 			| newButtonSpec |			newButtonSpec := prototypeSpec copy.			newButtonSpec helpText: spec componentName.			newButtonSpec layout: prototypeSpec layout copy.			(newButtonSpec layout) 				leftOffset: newButtonSpec layout leftOffset + iconPosition x;				rightOffset: newButtonSpec layout rightOffset + iconPosition x;				topOffset: newButtonSpec layout topOffset + iconPosition y;				bottomOffset: newButtonSpec layout bottomOffset + iconPosition y.			self adaptButton: newButtonSpec toRepresent: spec.			builder add: newButtonSpec.			currentColumn := currentColumn + 1.			(currentColumn \\ maximumColumns) isZero				ifTrue: 					[iconPosition := iconPosition + (0 @ height).					iconPosition x: firstX]				ifFalse: [iconPosition := iconPosition + (width @ 0)]].	rows := currentColumn - 1 // maximumColumns.	finalExtent := 0 @ (rows * height).	finalExtent := builder window minimumSize + finalExtent.	(builder window) changeExtent: finalExtent; minimumSize: finalExtent; maximumSize: finalExtent.</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>private</category><body package="Tools-Workspace" selector="compareTextWithFile">compareTextWithFile	"Open a Differator on the text currently on the page (on the left) and the text from the file on the right."	| text fileText |	text := self textEditor text copy.	fileText := [self filenameWithEncoding contentsOfEntireFile]		on: OsError do: [:ex | ex return: String new].	(Differator newOn: text and: fileText) open</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>actions</category><body package="Store-UI" selector="resetProfiles">resetProfiles	profiles := RepositoryManager repositories copy asList</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	profiles := RepositoryManager repositories copy asList</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>defining</category><body package="UIPainter" selector="addNamedFontsMethod:using:">addNamedFontsMethod: aSymbol using: aFullSpec	| usedStyles |	usedStyles := aSymbol == #all		ifTrue: [VariableSizeTextAttributes styles copy]		ifFalse: [self extractNamedStyles: aFullSpec].	self writeDefineNamedFontsMethod: usedStyles.</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>private</category><body package="Tools-Workspace" selector="capitalized:">capitalized: aString	^aString copy		at: 1 put: aString first asUppercase;		yourself</body></methods><methods><class-id>Tools.FileDialogNSSavePanel</class-id> <category>private</category><body package="Tools-Dialogs" selector="asHostPattern:">asHostPattern: aStringOrUserMessage	"Used by compatibility interface."	^aStringOrUserMessage asString copy replaceAll: $# with: $?</body></methods><methods><class-id>Tools.Trippy.SequenceInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="privateMoveAllAtIndices:beforeIndex:">privateMoveAllAtIndices: aCollection beforeIndex: anIndex	"Reposition elements at indices listed in aCollection so that they are all located at indices {anIndex, anIndex+1, ...}. The size of the resulting collection is the same as that of the original."	| scratch mobile insertionPoint |	scratch := object copy.	aCollection asSortedCollection reverseDo: [:each | scratch removeAtIndex: each].	mobile := aCollection collect: [:each | object at: each].	insertionPoint := aCollection		inject: anIndex		into: [:result :index | index &lt; anIndex ifTrue: [result - 1] ifFalse: [result]].	mobile reverseDo:		[:each | scratch add: each beforeIndex: insertionPoint].	object replaceFrom: 1 to: object size with: scratch startingAt: 1.	^insertionPoint to: insertionPoint + aCollection size - 1</body></methods><methods><class-id>Tools.Trippy.ArrayInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="privateMoveAllAtIndices:beforeIndex:">privateMoveAllAtIndices: aCollection beforeIndex: anIndex	"Reposition elements at indices listed in aCollection so that they are all 	located at indices {anIndex, anIndex+1, ...}. The size of the resulting collection 	is the same as that of the original."	| static mobile insertionPoint newObject |	static := object copy asOrderedCollection.	aCollection asSortedCollection reverseDo: [:each | static removeAtIndex: each].	mobile := aCollection collect: [:each | object at: each].	insertionPoint := aCollection		inject: anIndex		into: [:result :index | index &lt; anIndex ifTrue: [result - 1] ifFalse: [result]].	newObject := object class new: object size.	newObject		replaceFrom: 1 to: insertionPoint - 1 with: static startingAt: 1;		replaceFrom: insertionPoint to: insertionPoint + mobile size - 1 with: mobile startingAt: 1;		replaceFrom: insertionPoint + mobile size to: newObject size with: static startingAt: insertionPoint.	newObject become: object.	^insertionPoint to: insertionPoint + aCollection size - 1</body></methods><methods><class-id>Tools.Trippy.TextEditorInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="coerceText:">coerceText: aTextOrString	"Answer the argument as a new instance of a class compatible with that	of the current object. We currently assume that can only be one of String	subclasses or Text."	^(self object isKindOf: Text)		ifTrue: [aTextOrString asText copy]		ifFalse: [self object class fromString: aTextOrString asString]</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="pickSingleObjectIn:ifCancelled:">pickSingleObjectIn: partCollection ifCancelled: aBlock	| labels objects objectsCopy |	partCollection size = 1 ifTrue: [^partCollection first value].	labels := OrderedCollection new.	objects := OrderedCollection new.	partCollection do:		[:part |		labels add: ('&lt;1s&gt;: &lt;2s&gt;'			expandMacrosWith: part displayString			with: part value displayString).		objects add: part value].	objectsCopy := objects copy.	labels add: ((#All1pAsAnArray &lt;&lt; #dialogs &gt;&gt; 'All &lt;1p&gt; as an Array') expandMacrosWith: partCollection size).	objects add: objectsCopy asArray.	labels add: ((#All1pAsAnOC &lt;&lt; #dialogs &gt;&gt; 'All &lt;1p&gt; as an OrderedCollection') expandMacrosWith: partCollection size).	objects add: objectsCopy asOrderedCollection.	labels add: ((#All1pAsASet &lt;&lt; #dialogs &gt;&gt; 'All &lt;1p&gt; as a Set') expandMacrosWith: partCollection size).	objects add: objectsCopy asSet.	^Dialog		choose: (#UseWhichOfTheseObjectsQ &lt;&lt; #dialogs &gt;&gt; 'Use which of these objects?')		fromList: labels		values: objects		lines: 8		cancel: aBlock</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="computeMultiSelectionText">computeMultiSelectionText	| stream |	stream := TextStream on: (String new: 200).	self selections do:		[:each |		stream			nextPutAllText: each displayString copy asText allBold;			nextPutAll: ':  ';			nextPutAll: each text.		stream cr].	^stream contents</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="augmentTextFieldController:">augmentTextFieldController: aController	"Provide additional tuning of the text controller used in the '#text' widget (the widget where we display the selected object's printStrings)."		| menu item |	aController		initializeMenuForCode;		autoAccept: false.	menu := aController menu copy.	item := MenuItem labeled: #AddField &lt;&lt; #inspector &gt;&gt; 'Add Field'.	item value: [self addDerivedField].	menu addItem: item atPosition: 10.2.	aController menuHolder value: menu</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector class</class-id> <category>resources</category><body package="Tools-Trippy" selector="fieldListMenu">fieldListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #fieldListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Inspect 					#defaultString: '&amp;Inspect' 					#catalogID: #menus ) 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Dive 					#defaultString: '&amp;Dive' 					#catalogID: #menus ) 				#nameKey: #dive 				#value: #dive ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Back 					#defaultString: '&amp;Back' 					#catalogID: #menus ) 				#nameKey: #back 				#value: #back 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #navigatePrevious ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#nameKey: #editSelectAll 				#value: #selectAllFields 				#command: #selectAll				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #selectFields ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#nameKey: #copy 				#value: #copySelection 				#enablementSelector: #canCopy 				#command: #copy				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #menus ) 				#nameKey: #paste 				#value: #paste 				#command: #paste				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Refresh 					#defaultString: '&amp;Refresh' 					#catalogID: #menus ) 				#nameKey: #refresh 				#value: #refresh ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.Trippy.Clipboard</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize">initialize	zeroStandIn := '0' copy. "unique object to stand in for 0 value"	self empty</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="configureCodeViewController:">configureCodeViewController: aController	| menu |	aController		initializeMenuForCode;		autoAccept: false;		doNotHandleLocally: #formatSelection.	"The menu must be copied before chaging items, or else the shared menu in the class would be changed."	menu := aController menu copy.	aController menuHolder value: menu. 	(menu menuItemWithValue: #formatSelection)		label: (#Format &lt;&lt; #menus &gt;&gt; 'Format') asString</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>copying</category><body package="HighlightingStyles" selector="postCopy">postCopy	"Finish copying the receiver.  A shallow copy works fine for everything	 except the emphasis, which effectively must be a deep copy.  This is	 because we must make sure embedded associations are copied.  In	 the normal course of things, the emphasis array itself doesn't matter,	 but rather the contents."	self breakDependents.	emphasis class == Array		ifTrue: [emphasis := emphasis collect: [:e | e copy]]		ifFalse: [emphasis := emphasis copy]</body></methods><methods><class-id>Tools.FileDialogWin32Surrogate</class-id> <category>accessing</category><body package="Tools-Dialogs" selector="asHostPattern:">asHostPattern: aStringOrUserMessage	"Used by compatibility interface."	^aStringOrUserMessage asString copy replaceAll: $# with: $?</body></methods><methods><class-id>Tools.TreeItemHolder</class-id> <category>accessing</category><body package="Tools-Modules" selector="children">children	^(childrenBlock value: value) collect:		[:each | self copy value: each]</body></methods><methods><class-id>Tools.SettingsManagerPage</class-id> <category>page tree building</category><body package="Tools-Settings" selector="findPlaceFor:">findPlaceFor: aPage	children do:		[:each |		(aPage isChildOf: each) ifTrue:			[^each findPlaceFor: aPage]].	children add: aPage.	children copy do:		[:each |		(each isChildOf: aPage) ifTrue:			[children remove: each.			aPage findPlaceFor: each]].	SequenceableCollectionSorter		sort: children		using: [:a :b | 			a position = b position				ifTrue: [a label asString &lt; b label asString]				ifFalse: [a position &lt; b position]]</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>converting</category><body package="Store-Code Comparison" selector="withoutComponents:">withoutComponents: aCollectionOfCodeComponents	"Return a reduced copy, of me with all members of aCollectionOfCodeComponents and any blueprints that reference them, removed."	| reduced |	reduced := self copy.	reduced leftCodeComponents: (leftCodeComponents				reject: [:each | aCollectionOfCodeComponents includes: each]).	reduced rightCodeComponents: (rightCodeComponents				reject: [:each | aCollectionOfCodeComponents includes: each]).	^reduced cleanseUnmatchedChanges</body></methods><methods><class-id>Tools.Workbook</class-id> <category>actions</category><body package="Tools-Workspace" selector="pageTearOff">pageTearOff	"Remove the current text page from the workbook and open it	as a separate workspace (not a workbook). If this was the last text	page, close the current workbook. The new window should have	reasonable size and position--that is same size as the original workbook	and either same or cascaded position, depending on whether the	workbook stays or goes. With the MPUI introduction, if the original window	is closed, it should be done *after* opening the new one."	| thisPage workspace bounds wasLastPage |	bounds := self builder window displayBox.	thisPage := self currentTextPage.	thisPage deactivate.	workspace := Workspace new textPage: thisPage.	locals keysAndValuesDo:		[:key :value | workspace addLocal: key value: value].	wasLastPage := self textPageCount &lt;= 1.	wasLastPage ifFalse:		[self removePage: thisPage.		bounds := Screen default makeRectangleVisible:			(bounds copy moveBy: 20@20)].	workspace 		allButOpenInterface: #windowSpec;		finallyOpenIn: bounds withType: #normal.	wasLastPage ifTrue:		[self builder window controller closeAndUnschedule]</body></methods><methods><class-id>Tools.Workbook class</class-id> <category>resources</category><body package="Tools-Workspace" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Page 					#defaultString: '&amp;Page' 					#catalogID: #menus ) 				#nameKey: #pageMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_New 								#defaultString: '&amp;New' 								#catalogID: #menus ) 							#nameKey: #fileNew 							#value: #fileNew 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceNew ) 							#command: #new ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_OpenDot 								#defaultString: '&amp;Open...' 								#catalogID: #menus ) 							#nameKey: #fileOpen 							#value: #fileOpen 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceOpen ) 							#command: #open ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Save 								#defaultString: '&amp;Save' 								#catalogID: #menus ) 							#nameKey: #fileSave 							#value: #fileSave 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $S 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceSave ) 							#command: #save ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_AsDot 								#defaultString: 'Save &amp;As...' 								#catalogID: #menus ) 							#nameKey: #fileSaveAs 							#value: #fileSaveAs 							#enablementSelector: #isAtTextPage 							#command: #saveAs ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RenameDot 								#defaultString: '&amp;Rename...' 								#catalogID: #menus ) 							#nameKey: #pageRename 							#value: #pageRename 							#enablementSelector: #canRenamePage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_TearOff 								#defaultString: '&amp;Tear Off' 								#catalogID: #menus ) 							#nameKey: #pageTearOff 							#value: #pageTearOff 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_move 								#defaultString: 'Re&amp;move' 								#catalogID: #menus ) 							#nameKey: #pageClose 							#value: #pageClose 							#enablementSelector: #canClosePage ) ) #(1 3 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #menus ) 				#nameKey: #editMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Cu_t 								#defaultString: 'Cu&amp;t' 								#catalogID: #menus ) 							#nameKey: #editCut 							#value: #cut 							#enablementSelector: #isAtTextPage 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) 							#command: #cut ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Copy 								#defaultString: '&amp;Copy' 								#catalogID: #menus ) 							#nameKey: #editCopy 							#value: #copySelection 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) 							#command: #copy ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Paste 								#defaultString: '&amp;Paste' 								#catalogID: #menus ) 							#nameKey: #editPaste 							#value: #paste 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) 							#command: #paste ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FindDots 								#defaultString: '&amp;Find...' 								#catalogID: #menus ) 							#nameKey: #editFind 							#value: #find 							#command: #find ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReplaceDots 								#defaultString: '&amp;Replace...' 								#catalogID: #menus ) 							#nameKey: #editReplace 							#value: #replace 							#command: #replace ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Select_All 								#defaultString: 'Select &amp;All' 								#catalogID: #menus ) 							#nameKey: #editSelectAll 							#value: #selectAll 							#command: #selectAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Encoding 								#defaultString: '&amp;Encoding' 								#catalogID: #menus ) 							#nameKey: #editEncoding ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_InDot 								#defaultString: 'Boss &amp;In...' 								#catalogID: #menus ) 							#value: #bossIn 							#enablementSelector: #canBOSSObjects ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_OutDot 								#defaultString: 'Boss &amp;Out...' 								#catalogID: #menus ) 							#value: #bossOut 							#enablementSelector: #canBOSSObjects ) ) #(3 2 1 1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Smalltalk 					#defaultString: '&amp;Smalltalk' 					#catalogID: #menus ) 				#nameKey: #smalltalkSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DoIt 								#defaultString: '&amp;Do it' 								#catalogID: #menus ) 							#value: #smalltalkDoIt 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) 							#command: #doIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PrintIt 								#defaultString: '&amp;Print it' 								#catalogID: #menus ) 							#value: #smalltalkPrintIt 							#shortcutKeyCharacter: $P 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) 							#command: #printIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InspectIt 								#defaultString: '&amp;Inspect it' 								#catalogID: #menus ) 							#value: #smalltalkInspectIt 							#shortcutKeyCharacter: $Q 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) 							#command: #inspectIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #De_bugIt 								#defaultString: 'De&amp;bug it' 								#catalogID: #menus ) 							#value: #smalltalkDebugIt 							#shortcutKeyCharacter: $B 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) 							#command: #debugIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileItIn 								#defaultString: '&amp;File it In' 								#catalogID: #menus ) 							#value: #smalltalkFileItIn ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NamespacesDot 								#defaultString: '&amp;Namespaces...' 								#catalogID: #menus ) 							#value: #editImports 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.BehaviorIcons} #Namespace ) ) ) #(4 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Options 					#defaultString: '&amp;Options' 					#catalogID: #menus ) 				#nameKey: #optionsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Toolbar 								#defaultString: '&amp;Toolbar' 								#catalogID: #menus ) 							#nameKey: #toolbar 							#value: #toggleToolbar 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_StatusBar 								#defaultString: '&amp;Status Bar' 								#catalogID: #menus ) 							#nameKey: #toggleStatusBar 							#value: #toggleStatusBar ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Workspace 								#defaultString: '&amp;Workspace' 								#catalogID: #menus ) 							#value: #helpWorkspace 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) 							#command: #help ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(1 1 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.Workbook class</class-id> <category>resources</category><body package="Tools-Workspace" selector="toolBar">toolBar	"Tools.MenuEditor new openOnClass: self andSelector: #toolBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #New 					#defaultString: 'New' 					#catalogID: #menus ) 				#value: #fileNew 				#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceNew ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #New 					#defaultString: 'New' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Open 					#defaultString: 'Open' 					#catalogID: #menus ) 				#value: #fileOpen 				#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceOpen ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Open 					#defaultString: 'Open' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Save 					#defaultString: 'Save' 					#catalogID: #menus ) 				#nameKey: #fileSave 				#value: #fileSave 				#labelImage: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspaceSave ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Save 					#defaultString: 'Save' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) 				#nameKey: #cut 				#value: #cut 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#nameKey: #copy 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) 				#nameKey: #paste 				#value: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #DoIt 					#defaultString: 'Do it' 					#catalogID: #menus ) 				#value: #smalltalkDoIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #DoIt 					#defaultString: 'Do it' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #PrintIt 					#defaultString: 'Print it' 					#catalogID: #menus ) 				#value: #smalltalkPrintIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #PrintIt 					#defaultString: 'Print it' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InspectIt 					#defaultString: 'Inspect it' 					#catalogID: #menus ) 				#value: #smalltalkInspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #InspectIt 					#defaultString: 'Inspect it' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #DebugIt 					#defaultString: 'Debug it' 					#catalogID: #menus ) 				#value: #smalltalkDebugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #DebugIt 					#defaultString: 'Debug it' 					#catalogID: #menus ) ) ) #(3 3 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.DBProfileListSetting</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	super initialize.	profiles := DBProfileManager profiles copy asList</body></methods><methods><class-id>Tools.DBProfileListSetting</class-id> <category>actions</category><body package="Database" selector="resetProfiles">resetProfiles	profiles := DBProfileManager profiles copy asList</body></methods><methods><class-id>Tools.SideBySideTextComparisonView</class-id> <category>initialize-release</category><body package="Tools-Differences" selector="initializeLayoutAlgorithm">initializeLayoutAlgorithm	| frame midX |	self childFramingBlock: 			[:rect :child :index |			frame := rect copy bottom: rect top + child preferredBounds height.			midX := rect left midpoint: rect right.			index = 1				ifTrue: [frame right: midX - self halfGapWidth]				ifFalse: [frame left: midX + self halfGapWidth].			frame]</body></methods><methods><class-id>Tools.SideBySideTextComparisonView</class-id> <category>initialize-release</category><body package="Tools-Differences" selector="leftText:rightText:">leftText: aLeftCharacterArray rightText: aRightCharacterArray	| leftText rightText |	self releaseAllComponents.	leftText := (aLeftCharacterArray ifNil: ['']) asText copy.	rightText := (aRightCharacterArray ifNil: ['']) asText copy.	self computeDifferencesLeft: leftText right: rightText.	self add: (self createTextEditorFor: leftText asValue).	self add: (self createTextEditorFor: rightText asValue)</body></methods><methods><class-id>Tools.DiffList</class-id> <category>differating</category><body package="Tools-Differences" selector="pushOntoStack:">pushOntoStack: stack	| stopIndex target n2 start1 start2 |	start1 := match1 key + 1.	start2 := match2 key + 1.	stopIndex := list2 size.	start1 to: list1 size do:		[:n1 |		target := list1 at: n1.		n2 := start2-1.		[(n2 := n2+1) &lt;= stopIndex] whileTrue:			[target = (list2 at: n2)				ifTrue:					[(self copy push: n1 with: n2 baseIndex: 1)							mergeWith: stack.					"Revise stopIndex to reflect the new limit."					stopIndex := n2-1.					stopIndex &lt; start2 ifTrue: [^self]]]]</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private</category><body package="BOSS" selector="ownExternalAssociations">ownExternalAssociations	"Answer an Array of the associations contained in the receiver's externals dictionary.  Only answer those actually contained in the receiver's external dictionary and not any in its superclass."	"We add a copy of the association so BOSS readers don't map the original association to the values answered by this method."	| associations |	associations := OrderedCollection new.	self externals ownAssociationsDo: [:anAssoc |		associations add: anAssoc copy].	^associations asArray</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>public runtime</category><body package="External-Interface" selector="libraryFiles:">libraryFiles: aStringOrArray	"SomeExternalInterface libraryFiles: #('library.so' 'library file with spaces.dll')"	"SomeExternalInterface libraryFiles: 'library.so library.sl'"	"Reset my libraryFiles. To have this take effect immediately, I unload my libraries, so that	a new search for the affected libraries will occur the next time they are invoked.	Alternatively, you can edit my class-definition template accordingly and accept it."	| newList |	newList := self scanFieldNames: aStringOrArray.	libraryFiles isNil		ifTrue:			[libraryFiles := LinkedOrderedCollection new.			superclass libraryFiles notNil				ifTrue: [libraryFiles addBackup: superclass libraryFiles]]		ifFalse:			[(self libraryFilesArray isSameSequenceAs: newList) ifTrue: [^self].			self unloadLibraries.			libraryFiles copy				ownDo:					[:each | each isDefinedByAnnotation ifFalse: [libraryFiles remove: each]]].	newList		do:			[:lib | 			libraryFiles				add:					(ExternalLibraryHolder named: lib directories: libraryDirectories owner:							self)]</body></methods><methods><class-id>External.CStructureLayout</class-id> <category>enumerating</category><body package="External-Types" selector="doStruct:">doStruct: aType	"Align the argument within the receiver's current layout."	| layout align |	layout := self copy initialize.	aType keysAndValuesDo: [:key :alt |		aType align: key on: (alt value typeDo: layout)].	align := layout alignment.	aType alignment: align.	layout allocate: 0 aligned: align.	aType dataSize: layout numBytes.	aType beStructure.	^structAlignBlock value: self value: aType</body></methods><methods><class-id>External.CStructureLayout</class-id> <category>enumerating</category><body package="External-Types" selector="doUnion:">doUnion: aType	"Align the argument within the receiver's current layout."	| size align |	size := 0.	align := 1.	aType do: [:alt | | layout layoutAlign |		layout := self copy initialize.		alt value typeDo: layout.		layoutAlign := layout alignment.		layout allocate: 0 aligned: layoutAlign.		size := size max: layout numBytes.		align := align max: layoutAlign].	aType alignment: align.	aType dataSize: size.	aType beUnion.	^unionAlignBlock value: self value: aType</body></methods><methods><class-id>External.CStructureLayout class</class-id> <category>layouts</category><body package="External-Types" selector="defaultLayout">defaultLayout	"Answer the current platform's default layout."	^DefaultLayout copy</body></methods><methods><class-id>External.CProcedureType</class-id> <category>accessing-compilation</category><body package="External-Types" selector="typesKindsAndSizesDo:">typesKindsAndSizesDo: aBlock	| types kinds sizes |	types := Array new: self basicSize.	kinds := types copy.	sizes := types copy.	1 to: self basicSize do:		[:i| | type |		type := types at: i put: (self basicAt: i).		kinds at: i put: type kind.		sizes at: i put: (type isVoid ifTrue: [0] ifFalse: [type dataSize])].	^aBlock value: types value: kinds value: sizes</body></methods><methods><class-id>External.CPointer</class-id> <category>pointer arithmetic</category><body package="External-Data" selector="+">+ offset	"Answer a pointer whose address is incremented by offset elements.  The answered pointer is a copy of the receiver with the referent address properly adjusted.  The pointer value will be adjusted by (offset * size of the receiver's referent type).  Please see the class comments for more details."	^self copy += offset</body></methods><methods><class-id>External.CPointer</class-id> <category>primitives</category><body package="External-Data" selector="primCopyCStringFromHeap:pointerKind:">primCopyCStringFromHeap: address pointerKind: pointerKind	"Answer an instance of a String by copying the null terminated string pointed to by the receiver from the external heap.  The terminating null is not part of the answered String.  This method does not directly check to see if the receiver's type is appropriate for a String copy operation.  If the receiver's referent type is incorrect, a signal will eventually be raised as the receiver's contents will fail to store into a Smalltalk String object.  The second argument is used to distinguish between segmented and linear pointers."	&lt;primitive: 335 errorCode: error&gt;	| cPointer aChar theString |	self referentAddress == 0 ifTrue: [^self error: (#errDereferenceNullPointer &lt;&lt; #external &gt;&gt; 'Attempt to dereference a NULL pointer.')].	(error isError	and: [error name == #'allocation failed'	and: [thisContext sender sender method ~~ thisContext method]])		ifTrue:			[error handleErrorFor: #largeSpace.			^self primCopyCStringFromHeap: address pointerKind: pointerKind].	theString := (String primitiveArgumentClass new: 16) writeStream.	cPointer := self copy.	[(aChar := cPointer contents) == 0]		whileFalse:			[theString nextPut: aChar.			cPointer += 1].	^theString contents</body></methods><methods><class-id>External.CPointer</class-id> <category>copying</category><body package="External-Data" selector="copyCStringSequenceFromHeap:">copyCStringSequenceFromHeap: encoding	"Answer a sequence of Strings by copying strings pointed to by the receiver from the heap.  Each string is null-terminated, with the last string followed by two null bytes.  The terminating null is not part of the answered Strings.  This method does not directly check to see if the receiver's type is appropriate for a String copy operation.  If the receiver's referent type is incorrect, a signal will eventually be raised as the receiver's contents will fail to store into a Smalltalk String object."	| cPointer result wide nullCount next |	self referentAddress == 0 ifTrue: [^self error: (#errDereferenceNullPointer &lt;&lt; #external &gt;&gt; 'Attempt to dereference a NULL pointer.')].	result := OrderedCollection new.	wide := StreamEncoder encodingUsesWideChars: encoding.	nullCount := wide ifTrue: [2] ifFalse: [1].	cPointer := self copy type: CIntegerType char pointerType.	[next := wide		ifTrue: [cPointer primCopyDoubleByteStringFromHeap: 0 pointerKind: type kind]		ifFalse: [cPointer primCopyCStringFromHeap: 0 pointerKind: type kind].	next isEmpty] whileFalse:		[result add: (next asStringEncoding: encoding).		cPointer += (next size + nullCount)].	^result</body></methods><methods><class-id>External.ExternalMethod</class-id> <category>copying</category><body package="External-Interface" selector="postCopy">postCopy	"Answer the receiver with all internal state properly reset after a copy operation."	super postCopy.	virtuals := virtuals copy.	^self</body></methods><methods><class-id>External.LinkedOrderedCollection</class-id> <category>accessing</category><body package="External-Collections" selector="removeAll">removeAll	self copy ownDo: [:el | self remove: el]</body></methods><methods><class-id>Refactory.CodeHighlighter.CodeHighlightingParser</class-id> <category>initialize-release</category><body package="RBCodeHighlighting" selector="text:">text: aText 	text := aText.	string := text string copy.	text addEmphasis: #() removeEmphasis: StyleDescription stylesToRemove allowDuplicates: false</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper class</class-id> <category>instance creation</category><body package="Method Wrapper Base" selector="on:inClass:">on: aSelector inClass: aClass 	| wrapper |	(self canWrap: aSelector inClass: aClass) ifFalse: [^nil].	wrapper := (self methods at: aSelector numArgs				ifAbsentPut: [self createMethodFor: aSelector numArgs]) copy.	wrapper class: aClass selector: aSelector.	^wrapper</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>matching</category><body package="SmaCC Runtime" selector="matchCollection:index:to:index:inContext:">matchCollection: matchNodes index: matchIndex to: programNodes index: programIndex inContext: aDictionary	| node currentIndex currentDictionary nodes |	matchNodes size &lt; matchIndex ifTrue: [^programNodes size &lt; programIndex].	node := matchNodes at: matchIndex.	node isListMatch		ifTrue:			[currentIndex := programIndex - 1.			[currentDictionary := aDictionary copy.			programNodes size &lt; currentIndex				or:					[(self						matchCollection: matchNodes						index: matchIndex + 1						to: programNodes						index: currentIndex + 1						inContext: currentDictionary)						and:							[nodes := programNodes copyFrom: programIndex to: currentIndex.							(currentDictionary at: node ifAbsentPut: [nodes]) = nodes								ifTrue:									[currentDictionary keysAndValuesDo: [:key :value | aDictionary at: key put: value].									^true].							false]]] whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size &lt; programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) ifFalse: [^false].	^self		matchCollection: matchNodes		index: matchIndex + 1		to: programNodes		index: programIndex + 1		inContext: aDictionary</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>copying</category><body package="SmaCC Runtime" selector="postCopy">postCopy	super postCopy.	self		allGettersDo:			[:each | 			self				perform: (self convertToSetter: each)				with:					((self compositeVariableSelectors includes: each)						ifTrue: [(self perform: each) collect: [:item | item copy]]						ifFalse: [(self perform: each) copy])]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParseNode</class-id> <category>matching</category><body package="SmaCC Runtime" selector="copyInContext:">copyInContext: aDictionary	| copy |	copy := self copy.	self tokenVariables		do:			[:selector | copy perform: (self convertToSetter: selector) with: ((self perform: selector) copyInContext: aDictionary)].	self nodeVariables		do:			[:selector | copy perform: (self convertToSetter: selector) with: ((self perform: selector) copyInContext: aDictionary)].	self compositeTokenVariables		do:			[:selector | 			copy				perform: (self convertToSetter: selector)				with: ((self perform: selector) collect: [:each | each copyInContext: aDictionary])].	self compositeNodeVariables		do:			[:selector | 			copy				perform: (self convertToSetter: selector)				with: ((self perform: selector) collect: [:each | each copyInContext: aDictionary])].	^copy</body></methods><methods><class-id>Refactory.SmaCC.SmaCCPatternNode</class-id> <category>matching</category><body package="SmaCC Runtime" selector="copyInContext:">copyInContext: aDictionary	^(aDictionary at: self ifAbsent: [nil]) copy</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	^(self copy)		protocol: self newProtocol;		newProtocol: self protocol;		toggleUndoState;		yourself</body></methods><methods><class-id>Refactory.Browser.AbstractCodeModel</class-id> <category>navigator accessing</category><body package="Browser-BrowserUI" selector="setSelector:">setSelector: aSelector 	navigator updateWithState: ((state copy)				selector: aSelector;				yourself)</body></methods><methods><class-id>Refactory.Browser.PackageChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	| oldPackage |	oldPackage := self currentPackage.	oldPackage isNil ifTrue: [^nil].	^(self copy)		package: oldPackage;		toggleUndoState;		yourself</body></methods><methods><class-id>Refactory.Browser.MoveObjectChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	^(self copy)		move: targetNamespace , '.' , self simpleObjectName			to: self originalNamespaceName;		yourself</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary	^self copy</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>matching</category><body package="Browser-Parser" selector="matchList:index:against:index:inContext:">matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 	| node currentIndex currentDictionary nodes |	matchNodes size &lt; matchIndex ifTrue: [^programNodes size &lt; programIndex].	node := matchNodes at: matchIndex.	node isList 		ifTrue: 			[currentIndex := programIndex - 1.						[currentDictionary := aDictionary copy.			programNodes size &lt; currentIndex or: 					[nodes := programNodes copyFrom: programIndex to: currentIndex.					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 							[(self 								matchList: matchNodes								index: matchIndex + 1								against: programNodes								index: currentIndex + 1								inContext: currentDictionary) 									ifTrue: 										[currentDictionary 											keysAndValuesDo: [:key :value | aDictionary at: key put: value].										^true].							false]]] 					whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size &lt; programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) 		ifFalse: [^false].	^self 		matchList: matchNodes		index: matchIndex + 1		against: programNodes		index: programIndex + 1		inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings" selector="buildParseTree">buildParseTree	parseTree := (class parseTreeFor: selector) copy.	parseTree isNil ifTrue: [self refactoringError: (#CouldNotParseMethod &lt;&lt; #browser &gt;&gt; 'Could not parse method')]</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>initialize-release</category><body package="Browser-BaseUI" selector="initialize">initialize	super initialize.	self actionList list: (List 				withAll: ((RBCommand actions values collect: [:each | each copy]) 						asSortedCollection: [:a :b | a name asString &lt; b name asString])).	self typeList list: (List withAll: RBCommand withAllSubclasses).	self nameHolder onChangeSend: #changedName to: self.	self descriptionHolder onChangeSend: #changedDescription to: self.	self actionHolder onChangeSend: #changedAction to: self.	self enabledHolder onChangeSend: #changedEnabled to: self.	self receiverHolder onChangeSend: #changedReceiver to: self.	self typeList selectionIndexHolder onChangeSend: #changedType to: self</body></methods><methods><class-id>Refactory.Browser.BrowserDefinitionTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseRe_ferencesDots 					#defaultString: 'Browse Re&amp;ferences...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable References' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseRea_dersDots 					#defaultString: 'Browse Rea&amp;ders...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable Readers' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_WritersDots 					#defaultString: '&amp;Browse Writers...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable Writers' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_AddVariableDots 					#defaultString: '&amp;Add Variable...' 					#catalogID: #browser ) 				#nameKey: #'Add Instance Variable' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RemoveVariableDots 					#defaultString: '&amp;Remove Variable...' 					#catalogID: #browser ) 				#nameKey: #'Remove Selected Instance Variable' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Refactor 					#defaultString: 'Refactor' 					#catalogID: #browser ) 				#nameKey: #refactorMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Push_Up 								#defaultString: 'Push &amp;Up' 								#catalogID: #browser ) 							#nameKey: #'Push Up Selected Instance Variable' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Push_Down 								#defaultString: 'Push &amp;Down' 								#catalogID: #browser ) 							#nameKey: #'Push Down Selected Instance Variable' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CreateAccessors 								#defaultString: 'Create Accessors' 								#catalogID: #browser ) 							#nameKey: #'Create Selected Instance Variable Accessors' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #A_bstract 								#defaultString: 'A&amp;bstract' 								#catalogID: #browser ) 							#nameKey: #'Abstract Selected Instance Variable' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Protect 								#defaultString: '&amp;Protect' 								#catalogID: #browser ) 							#nameKey: #'Protect Selected Instance Variable' 							#value: 							#action: ) ) #(2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#command: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#command: #printIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#command: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#command: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Explain 					#defaultString: 'Explain' 					#catalogID: #browser ) 				#nameKey: #'Explain Code' 				#value: 				#action: 				#command: #explain ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(1 3 3 4 1 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self temporaries: (self temporaries collect: [:each | each copy]).	self statements: (self statements collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self contents: (self contents collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	| newDict |	newDict := classSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	classSelectors := newDict.	newDict := metaClassSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	metaClassSelectors := newDict.	initializers := initializers copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="implementorsOf:in:">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector.	anEnvironment classesDo: 			[:class | 			((class includesSelector: aSelector) 				and: [anEnvironment includesSelector: aSelector in: class]) 					ifTrue: 						[class isMeta 							ifTrue: [metaDict at: class soleInstance fullRootName put: selectors copy]							ifFalse: [classDict at: class fullRootName put: selectors copy]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body></methods><methods><class-id>Refactory.Browser.MethodNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI" selector="defaultMenu">defaultMenu	"Ugly method to add the spawn hierarchy after the spawn in the method list 	(assuming that our navigator has the spawn hierarchy action)."	| newMenu menuItem spawnMenuItem |	newMenu := super defaultMenu copy.	menuItem := (navigator menuNamed: #classMenu) 				atNameKey: #'Spawn Class Hierarchy'.	spawnMenuItem := newMenu atNameKey: #'Spawn Method'.	menuItem isNil | spawnMenuItem isNil ifTrue: [^newMenu].	newMenu addItem: menuItem copy atPosition: spawnMenuItem position + 0.00001.	^newMenu</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private-store</category><body package="Browser-BrowserUI" selector="pundlesWithoutCurrentObjectOverrides">pundlesWithoutCurrentObjectOverrides		| withoutPundles |	withoutPundles := self pundles copy asSet.	self classesAndNameSpaces do:		[:each | 		(Override overridesForClassOrNameSpace: each) ifNotNil: 			[:overridesForMethod | 			overridesForMethod do: 				[:eachOverride | 				withoutPundles addAll: (eachOverride sources select: [:eachSource | eachSource isPackage])]]].	^withoutPundles</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private-code components</category><body package="Browser-BrowserUI" selector="codeIn:codeComponents:sharedVariablesDo:nameSpacesDo:definedClassesDo:methodsDo:">codeIn: aNameCollection codeComponents: parcelPackageCollection sharedVariablesDo: svBlock nameSpacesDo: nsBlock definedClassesDo: cBlock methodsDo: mBlock 	aNameCollection do: 			[:each | 			| binding ref |			ref := each asQualifiedReference.			binding := ref bindingOrNil.			parcelPackageCollection do: 					[:codeComponent | 					binding isForNameSpace 						ifTrue: 							[(codeComponent definesObject: binding value) 								ifTrue: [nsBlock value: binding value]]						ifFalse: 							[(codeComponent definesClass: binding value) 								ifTrue: [cBlock value: binding value].							(codeComponent definedSelectorsFor: binding value) copy 								do: [:sel | mBlock value: binding value value: sel].							(codeComponent definedSelectorsFor: binding value class) copy 								do: [:sel | mBlock value: binding value class value: sel]].					(codeComponent definedBindingsFor: binding value) copy do: 							[:sv | 							sv isForGeneral 								ifTrue: 									[svBlock 										value: (binding value fullName , '.' , sv key) asQualifiedReference]]]]</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>store-packages</category><body package="Browser-BrowserUI" selector="storeInspectChangeSet:">storeInspectChangeSet: dbid 	| hasChanges |	hasChanges := false.	self packages do: 			[:each | 			| changeSet |			changeSet := each changeSetFor: dbid.			(changeSet notNil and: [changeSet notEmpty]) 				ifTrue: 					[hasChanges := true.					changeSet copy inspect]].	hasChanges ifFalse: [self warn: (#NoChanges &lt;&lt; #browser &gt;&gt; 'No changes')]</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>removal-scopes</category><body package="Browser-BrowserUI" selector="validateObjectRemovalChange:">validateObjectRemovalChange: aCompositeChange	"Determine if any of the object removals have references from else where in the system. We need to consider not only the objects themselves, but any contained objects (or subclasses) as well. If they do, have a dialog with the user about what to do about it (cancel, proceed, or browse them), return true/false based on whether the change should be allowed to proceed.First step is to extract the removals (there may be override adjustments in there too)."	| ws selectedRemovals classesWithChild notEmptyNamespaces references warningChunks allRemovals |	selectedRemovals := ((aCompositeChange changes select: [:each | each isKindOf: RemoveObjectChange]) collect: #changeObject)				asSet.	classesWithChild := Set new.	notEmptyNamespaces := Set new.	allRemovals := selectedRemovals copy.	selectedRemovals do: 			[:eachSelection |			eachSelection isNameSpace				ifTrue: 					[| victims |					victims := eachSelection withAllNameSpacesAndAllClasses.					selectedRemovals do: [:eachRemoval | victims remove: eachRemoval ifAbsent: []].					victims isEmpty						ifFalse: 							[notEmptyNamespaces add: eachSelection.							allRemovals addAll: victims]]				ifFalse: 					[eachSelection allSubclasses do: 							[:eachSubclass |							(selectedRemovals includes: eachSubclass)								ifFalse: 									[allRemovals add: eachSubclass.									classesWithChild add: eachSelection]]]].	references := Dictionary new.	self showWaitCursorWhile: 			[allRemovals do: [:each | references at: each put: (BrowserEnvironment new referencesTo: each fullyQualifiedReference binding)]].	references do: [:eachEnvironment | eachEnvironment removeScopes: allRemovals].	references := references reject: #isEmpty.	(references isEmpty and: [classesWithChild isEmpty and: [notEmptyNamespaces isEmpty]]) ifTrue: [^true].	warningChunks := OrderedCollection new.	references isEmpty		ifFalse: 			[ws := String new writeStream.			ws				nextPutAll: (#ObjectRemovalsReferencedElsewhereC &lt;&lt; #browser						&gt;&gt; 'Some of the objects to be removed are referenced elsewhere in the system:') asString.			(references keys asSortedCollection: [:a :b | a name &lt; b name]) do: 					[:each |					ws nextPutAll: ('&lt;n&gt;&lt;t&gt;&lt;1s&gt; -- &lt;2s&gt;' expandMacrosWith: each toolListDisplayString								with: ((references at: each) dispositionToObjectRemoval: each))].			warningChunks add: ws contents].	classesWithChild isEmpty		ifFalse: 			[ws := String new writeStream.			ws nextPutAll: (#ClassesToRemoveHaveChildrenC &lt;&lt; #browser &gt;&gt; 'Some of the classes to be removed have unselected subclasses:')						asString.			(classesWithChild asSortedCollection: [:a :b | a name &lt; b name]) do: 					[:each |					ws nextPutAll: ('&lt;n&gt;&lt;t&gt;&lt;1s&gt; -- &lt;2s&gt;' expandMacrosWith: each toolListDisplayString								with: (self explainClassRemoval: each subclassVictims: each allSubclasses asSet - selectedRemovals))].			warningChunks add: ws contents].	notEmptyNamespaces isEmpty		ifFalse: 			[ws := String new writeStream.			ws				nextPutAll: (#NamespacesToRemoveAreNotEmpty &lt;&lt; #browser &gt;&gt; 'Some of the namespaces to be removed contain unselected items:')						asString.			(notEmptyNamespaces asSortedCollection: [:a :b | a name &lt; b name]) do: 					[:each |					ws nextPutAll: ('&lt;n&gt;&lt;t&gt;&lt;1s&gt; -- &lt;2s&gt;' expandMacrosWith: each toolListDisplayString								with: (self explainScopeRemoval: each containedVictims: each withAllNameSpacesAndAllClasses asSet - selectedRemovals))].			warningChunks add: ws contents].	^self confirmRemoval: (warningChunks fold: [:a :b | '&lt;1s&gt;&lt;n&gt;&lt;n&gt;&lt;2s&gt;' expandMacrosWith: a with: b]) references: references</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects" selector="renameChangesForObject:to:">renameChangesForObject: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForObject: aClassName to: newClassName]);		yourself</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>copying</category><body package="Browser-ChangeObjects" selector="postCopy">postCopy	super postCopy.	changes := changes collect: [:each | each copy]</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="executeNotifying:">executeNotifying: aBlock 	| undos undo |	undos := changes collect: 					[:each | 					[each executeNotifying: aBlock] on: RefactoryChangeFailureNotification						do: [:ex | each == changes first ifTrue: [ex pass] ifFalse: [ex resume]]].	(undos anySatisfy: [:each | each isNil]) ifTrue: [^nil].	undo := self copy.	undo changes: undos reverse.	^undo</body></methods><methods><class-id>Refactory.Browser.BundleStructureView</class-id> <category>displaying</category><body package="Browser-BrowserUI" selector="displayOn:">displayOn: aGC	"In addition to drawing the subparts, we show which is being drug, and in the event we're scanning, we actually forgo drawing the subparts, drawing a progress label instead."	state = #idle ifFalse: [self displayDragOn: aGC copy].	super displayOn: aGC</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self value: self value copy</body></methods><methods><class-id>Refactory.Browser.PrerequisitesExplorerView</class-id> <category>displaying</category><body package="Browser-Prerequisites" selector="displayOn:">displayOn: aGC	"In addition to drawing the subparts, we show which is being drug, and in the event we're scanning, we actually forgo drawing the subparts, drawing a progress label instead."	self isScanning ifTrue: [^self displayScanningOn: aGC].	state = #idle ifFalse: [self displaySelectedOn: aGC copy].	super displayOn: aGC</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self body: self body copy.	self arguments: (self arguments collect: [:each | each copy]).	self tags: (self tags collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.MoveMethodToOverrideInPackageChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	| originalPackage |	originalPackage := self currentPackage.	originalPackage isNil ifTrue: [^nil].	^(self copy)		oldPackageName: packageName;		package: originalPackage;		toggleUndoState;		yourself</body></methods><methods><class-id>Refactory.Browser.CommentChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	^(self copy)		comment: self commentObject comment;		toggleUndoState;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoryObjectChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects" selector="renameChangesForObject:to:">renameChangesForObject: aClassName to: newClassName 	| newString |	newString := self 				changeVariable: self objectName				thatBeginsWith: aClassName				toBeginWith: newClassName.	self objectName = newString 		ifFalse: 			[^(self copy)				objectName: newString;				yourself].	^self</body></methods><methods><class-id>Refactory.Browser.BundleStructureTool</class-id> <category>actions</category><body package="Browser-BrowserUI" selector="addToSubcomponents">addToSubcomponents	| currentItems |	currentItems := self bundle containedItems.	(self promptForAddWithout: (currentItems copyWith: self bundle))		ifNotNil: 			[:toAdd |			toAdd isEmpty				ifFalse: 					[self bundle containedItems: ((currentItems copy)								addAll: toAdd;								yourself).					(self widgetAt: #bundleStructureView) addSubcomponentRows: toAdd]]</body></methods><methods><class-id>Refactory.Browser.CodeComponentSummaryTool</class-id> <category>updating</category><body package="Browser-BrowserUI" selector="updateContents">updateContents	"What a pain, TextEditorView makes this (where this equals messing with the tabs via the style) kind of hard, so we have to get down and dirty with its guts."		| newText view paragraph newStyle widths left tabs |	newText := self summaryText addHyperlinkEmphases.	self textController ifNil: [^self].	view := self textController view.	paragraph := view displayContents.	newStyle := paragraph textStyle copy.	widths := newText computeMinimumTabWidthsUsing: view graphicsContext.	left := 0.	tabs := widths collect: [:each | left := left + each + 45].	newStyle useTabs: #(1) , tabs.	paragraph		compositionWidth: view wrappingBox width		text: newText		style: newStyle		fitWidth: true.	view		displayContents: paragraph;		invalidate</body></methods><methods><class-id>Refactory.Browser.CodeComponentSummaryTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) ) #(1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation		| undo |	undo := self copy.	undo propertyValue: self installedPropertyValue.	^undo</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>menu accessing</category><body package="Browser-BaseUI" selector="buildMenuFrom:">buildMenuFrom: aMenu	| newMenu |	newMenu := Menu new.	aMenu allMenuItemGroups do: 			[:group |			| items index newIndex |			items := OrderedCollection new.			group do: 					[:each |					((#(#action: #rbItem) includes: each value)						or: [each value isSymbol and: [each value keywords size &gt; 1]])							ifTrue: [items add: (self createActionMenuItemFrom: each)]							ifFalse: 								[each value = #dynamicMenu									ifTrue: [items addAll: (self dynamicMenuItemsFrom: each)]									ifFalse: 										[| newItem symbol |										newItem := each copy.										newItem truePerformerBlock: [:ignore | self].										"Force all messages that we understand to be dispatched to us, 										no matter if they are used in the menu bar or elsewhere."										((symbol := newItem value) isSymbol and: [self respondsTo: newItem value])											ifTrue: [newItem value: [self perform: symbol]].										items add: newItem]]].			items do: [:each | each notNil ifTrue: [self createSubMenuItemFor: each]].			index := 0.			[index &lt; items size] whileTrue: 					[newIndex := items								nextIndexOf: nil								from: index + 1								to: items size.					newIndex isNil ifTrue: [newIndex := items size + 1].					newMenu addItemGroup: (items copyFrom: index + 1 to: newIndex - 1).					index := newIndex]].	^newMenu</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>menu accessing</category><body package="Browser-BaseUI" selector="buildTopLevelMenuFrom:">buildTopLevelMenuFrom: aMenuName	| menu |		[menu := (self class menuNamed: aMenuName) copy				augmentFrom: self class				to: self menuAugmentationRoot				menuName: aMenuName				for: self]			on: MenuAugmentationError			do: [:ex | ex isResumable ifTrue: [ex resume]].	^(self doesMenuNeedToBeRebuilt: menu)		ifTrue: [[self buildMenuFrom: menu]]		ifFalse: [self buildMenuFrom: menu]</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>menu accessing</category><body package="Browser-BaseUI" selector="createActionMenuItemFrom:">createActionMenuItemFrom: aMenuItem	| newItem commandName |	newItem := aMenuItem copy.	newItem rawLabel: (self menuLabelFor: aMenuItem).	newItem nameKey: aMenuItem nameKey.	commandName := aMenuItem nameKey.	(commandName notNil and: [aMenuItem value ~= #rbItem])		ifTrue:			[newItem value: [self action: newItem].			newItem				helpText: (self actionNamed: aMenuItem nameKey asString) description]		ifFalse: [newItem value: nil].	newItem enablementSelector: #isMenuItemEnabled:.	aMenuItem enablementSelector notNil		ifTrue: [newItem hidden: [self isMenuItemHidden: aMenuItem]].	^newItem</body></methods><methods><class-id>Refactory.Browser.CopyrightNoticeTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(1 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.AddClassChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects" selector="renameChangesForObject:to:">renameChangesForObject: aClassName to: newClassName 	| newChange tree newSuperclass superclass |	newChange := super renameChangesForObject: aClassName to: newClassName.	tree := RBParser parseExpression: newChange definition				onError: [:s :e | ^newChange].	tree isMessage ifFalse: [^newChange].	tree arguments size &lt; 2 ifTrue: [^newChange].	superclass := tree arguments at: 2.	(superclass isLiteralNode and: [superclass value isBindingReference]) 		ifFalse: [^newChange].	newSuperclass := self 				changeVariable: superclass value asString				thatBeginsWith: aClassName				toBeginWith: newClassName.	newSuperclass = superclass value asString ifTrue: [^newChange].	tree arguments at: 2		put: (RBLiteralNode 				value: (LiteralBindingReference pathString: newSuperclass)).	^(newChange copy)		definition: tree formattedCode;		fillOutDefinition;		yourself</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule</class-id> <category>copying</category><body package="Browser-Smalllint" selector="postCopy">postCopy	super postCopy.	rules := rules collect: #copy</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule class</class-id> <category>instance creation</category><body package="Browser-Smalllint" selector="ruleFor:protocol:">ruleFor: aClass protocol: aProtocol 	| allRules prot label |	aProtocol isString		ifTrue:			[prot := aProtocol.			label := aProtocol asString copy.			label at: 1 put: label first asUppercase]		ifFalse:			[prot := aProtocol value.			label := aProtocol key].	allRules := aClass withAllSubclasses inject: OrderedCollection new				into: 					[:sum :each | 					sum						addAll: ((BrowserEnvironment new selectorsFor: prot asSymbol									in: each class) collect: [:selector | each perform: selector]);						yourself].	^self rules: (allRules asSortedCollection: [:a :b | a name &lt; b name])		name: label</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self arguments: (self arguments collect: [:each | each copy]).	self body: self body copy</body></methods><methods><class-id>Refactory.Browser.ExtractMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="checkAssignments:">checkAssignments: variableNames 	| node outsideVars removeAssigned |	removeAssigned := variableNames copy.	node := self placeholderNode.	outsideVars := variableNames 				select: [:each | (node whoDefines: each) references: each].	outsideVars size == 1 		ifTrue: [self checkSingleAssignment: outsideVars asArray first].	outsideVars size &gt; 1 		ifTrue: 			[self refactoringError: (#CannotExtractAssignmentWithoutAllRefs &lt;&lt; #browser &gt;&gt; 'Cannot extract assignment without all references.')].	removeAssigned removeAll: outsideVars.	(RBReadBeforeWrittenTester readBeforeWritten: removeAssigned		in: extractedParseTree) notEmpty 		ifTrue: 			[self refactoringError: (#CannotExtractAssignmentIfReadBeforeWritten &lt;&lt; #browser &gt;&gt; 'Cannot extract assignment if read before written.')].	removeAssigned 		do: [:each | (node whoDefines: each) removeTemporaryNamed: each].	self createTemporariesInExtractedMethodFor: variableNames</body></methods><methods><class-id>Refactory.Browser.RBActionDispatcher</class-id> <category>copying</category><body package="Browser-BaseUI" selector="postCopy">postCopy	super postCopy.	objects := objects copy</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing-pundles</category><body package="Browser-BaseUI" selector="selectPundle:">selectPundle: aPundleModel 	| newState |	newState := state copy.	newState		definitions: #();		protocols: #();		objectNames: #();		pundle: aPundleModel.	self updateWithState: newState</body></methods><methods><class-id>Refactory.Browser.RenameObjectChange</class-id> <category>private</category><body package="Browser-ChangeObjects" selector="executeNotifying:">executeNotifying: aBlock 		[| undos |	self changeObjectReference renameTo: newName.	undos := changes collect: 					[:each | 					(each renameChangesForObject: oldName asString to: self newUnambiguousName) 						executeNotifying: aBlock].	(undos anySatisfy: [:each | each isNil]) ifTrue: [^nil].	^(self copy)		changes: undos reverse;		rename: self newUnambiguousName to: oldName asQualifiedReference simpleName;		yourself] 			on: RefactoryChangeFailureNotification			do: [:ex | ex resume]</body></methods><methods><class-id>Refactory.Browser.BundleStructureMergeChange</class-id> <category>converting</category><body package="Store-Merge Management" selector="asUndoOperation">asUndoOperation	^(self copy)		structure: self bundle structure;		yourself</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="copyOptionsFrom:">copyOptionsFrom: aDictionary 	| dict |	dict := self options.	dict == self class refactoringOptions 		ifTrue: [^self options: aDictionary copy].	dict keysAndValuesDo: 			[:key :value | 			value == (self class refactoringOptions at: key) 				ifTrue: [dict at: key put: (aDictionary at: key)]].	self options: dict</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>utilities</category><body package="Browser-Refactorings" selector="safeMethodNameFor:basedOn:">safeMethodNameFor: aClass basedOn: aString 	"Creates an unused method name containing aString"	| baseString newString hasParam i |	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	hasParam := newString last = $:.	hasParam 		ifTrue: [baseString := newString copyFrom: 1 to: newString size - 1].	i := 0.	[aClass hierarchyDefinesMethod: newString asSymbol] whileTrue: 			[i := i + 1.			newString := baseString , i printString 						, (hasParam ifTrue: [':'] ifFalse: [''])].	^newString asSymbol</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>transforming-class/namespace names</category><body package="Browser-Refactorings" selector="replaceReferenceTo:inPath:toBe:">replaceReferenceTo: aRBProgramItem inPath: path toBe: aString 	| newPath index nameStream |	newPath := path copy.	index := path size + 1.		[index := path 				prevIndexOf: aRBProgramItem name				from: index - 1				to: 1.	index notNil] 			whileTrue: 				[nameStream := WriteStream on: String new.				(1 to: index) do: [:i | nameStream nextPutAll: (path at: i)]					separatedBy: [nameStream nextPut: $.].				(self methodClass referencedItem: nameStream contents) == aRBProgramItem 					ifTrue: [newPath at: index put: aString]].	^newPath</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="setOption:toUse:">setOption: aSymbol toUse: aBlock	| dict |	dict := self options.	dict == self class refactoringOptions ifTrue: [self options: dict copy].	^self options at: aSymbol put: aBlock</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(aDictionary at: self) copy</body></methods><methods><class-id>Refactory.Browser.MenuViewer</class-id> <category>private</category><body package="Browser-BrowserUI" selector="initializeMenu:">initializeMenu: aMenu	| simplifiedCopy |	simplifiedCopy := aMenu copy.	simplifiedCopy menuItems do: 			[:each |			each value: [self selection value: each value].			each enablementSelector: nil.			each indicationSelector: nil.			each submenu				ifNotNil: [:submenu | each submenu: (self initializeMenu: submenu)]].	^simplifiedCopy</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule class</class-id> <category>private</category><body package="Browser-Smalllint" selector="modifiesTree:in:">modifiesTree: aCollectionTree in: aParseTree 	| notifier args |	notifier := ParseTreeSearcher new.	args := Array with: (RBPatternVariableNode named: '`@object').	notifier 		matchesAnyTreeOf: (#(#add: #addAll: #remove: #removeAll:) collect: 					[:each | 					RBMessageNode 						receiver: aCollectionTree copy						selector: each						arguments: args])		do: [:aNode :answer | true].	^notifier executeTree: aParseTree initialAnswer: false</body></methods><methods><class-id>Refactory.Browser.BrowserCommentTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_GenerateDefaultComment 					#defaultString: '&amp;Generate Default Comment' 					#catalogID: #browser ) 				#nameKey: #'Generate Default Class Comment' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#command: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#command: #printIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#command: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#command: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(1 1 4 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>probes</category><body package="Debugger-Browser Extensions" selector="basicReinsertProbesAndIndices:into:">basicReinsertProbesAndIndices: probesAndIndices into: probedMethod	| probesInError |	probesInError := OrderedCollection new.	probesAndIndices do:		[:ac | | probe index newRecord |		probe := ac key baseParent copy.		index := ac value.		newRecord := probedMethod probeRecordFor: (index to: index).		probe record: newRecord.		(probe updateTempVarIndexForMethod: probedMethod)			ifTrue: [probedMethod addProbe: probe]			ifFalse:				[newRecord updateMethod: probedMethod.		"update mclass and selector for reporting"				probesInError add: probe]].	probesInError addAll: probedMethod recompileProbes.	ProbedCompiledMethod reportOnFailedProbes: probesInError.</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>private</category><body package="Browser-BrowserUI" selector="updateTextWidget">updateTextWidget	| widget prefs |	builder isNil ifTrue: [^self].	widget := builder componentAt: #textEditor.	widget isNil ifTrue: [^self].	modified 		= (widget lookPreferences foregroundColor = self modifiedTextColor) 			ifTrue: [^self].	prefs := modified 				ifTrue: [initialLookPrefs copy foregroundColor: self modifiedTextColor]				ifFalse: [initialLookPrefs].	widget lookPreferences: prefs</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #F_ormat 					#defaultString: 'F&amp;ormat' 					#catalogID: #browser ) 				#nameKey: #'Format Code' 				#value: 				#action: 				#command: #format ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #GoToClass 					#defaultString: 'Go to Class' 					#catalogID: #browser ) 				#nameKey: #'Navigate to Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseClassInNewWindow 					#defaultString: 'Browse Class in New Window' 					#catalogID: #browser ) 				#nameKey: #'Open Browser on Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseReferencesToClass 					#defaultString: 'Browse References to Class' 					#catalogID: #browser ) 				#nameKey: #'Browse References to Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVariableRe_ferencesDots 					#defaultString: 'Browse Variable Re&amp;ferences...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable References' 				#value: 				#action: 				#enablementSelector: #hasInstanceVariableSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVariableRea_dersDots 					#defaultString: 'Browse Variable Rea&amp;ders...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable Readers' 				#value: 				#action: 				#enablementSelector: #hasInstanceVariableSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVariable_WritersDots 					#defaultString: 'Browse Variable &amp;Writers...' 					#catalogID: #browser ) 				#nameKey: #'Selected Global Instance Variable Writers' 				#value: 				#action: 				#enablementSelector: #hasInstanceVariableSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_SendersOfSelector 					#defaultString: 'Browse &amp;Senders of Selector' 					#catalogID: #browser ) 				#nameKey: #'Selected Message References' 				#value: 				#action: 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_ImplementorsOfSelector 					#defaultString: 'Browse &amp;Implementors of Selector' 					#catalogID: #browser ) 				#nameKey: #'Selected Message Implementors' 				#value: 				#action: 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Refactor 					#defaultString: 'Refactor' 					#catalogID: #browser ) 				#nameKey: #refactorMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ExtractValueToTemporary 								#defaultString: '&amp;Extract Value to Temporary' 								#catalogID: #browser ) 							#nameKey: #'Extract to Temporary' 							#value: 							#action: 							#enablementSelector: #hasValueNodeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_nameVariableAsDots 								#defaultString: 'Re&amp;name Variable As...' 								#catalogID: #browser ) 							#nameKey: #'Rename Selected Temporary Variable' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MoveToInner_Scope 								#defaultString: 'Move to Inner &amp;Scope' 								#catalogID: #browser ) 							#nameKey: #'Move Selected Temporary to Innermost Scope' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Con_vertToInstanceVariable 								#defaultString: 'Con&amp;vert to Instance Variable' 								#catalogID: #browser ) 							#nameKey: #'Convert Temporary Variable to Instance Variable' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RemoveParameter 								#defaultString: '&amp;Remove Parameter' 								#catalogID: #browser ) 							#nameKey: #'Remove Selected Parameter' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #In_lineParameter 								#defaultString: 'In&amp;line Parameter' 								#catalogID: #browser ) 							#nameKey: #'Inline Selected Parameter' 							#value: 							#action: 							#enablementSelector: #hasTemporaryVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #In_lineMethod 								#defaultString: 'In&amp;line Method' 								#catalogID: #browser ) 							#nameKey: #'Inline Method' 							#value: 							#action: 							#enablementSelector: #hasMessageNodeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ExtractToTemporary 								#defaultString: '&amp;Extract to Temporary' 								#catalogID: #browser ) 							#nameKey: #'Extract to Temporary' 							#value: 							#action: 							#enablementSelector: #hasMessageNodeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InlineAssignedTemporary 								#defaultString: '&amp;Inline Assigned Temporary' 								#catalogID: #browser ) 							#nameKey: #'Inline Temporary' 							#value: 							#action: 							#enablementSelector: #hasAssignmentSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PushVariable_Up 								#defaultString: 'Push Variable &amp;Up' 								#catalogID: #browser ) 							#nameKey: #'Push Up Selected Instance Variable' 							#value: 							#action: 							#enablementSelector: #hasInstanceVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CreateAccessors 								#defaultString: 'Create Accessors' 								#catalogID: #browser ) 							#nameKey: #'Create Selected Instance Variable Accessors' 							#value: 							#action: 							#enablementSelector: #hasInstanceVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MakeVariableA_bstract 								#defaultString: 'Make Variable A&amp;bstract' 								#catalogID: #browser ) 							#nameKey: #'Abstract Selected Instance Variable' 							#value: 							#action: 							#enablementSelector: #hasInstanceVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ProtectVariable 								#defaultString: '&amp;Protect Variable' 								#catalogID: #browser ) 							#nameKey: #'Protect Selected Instance Variable' 							#value: 							#action: 							#enablementSelector: #hasInstanceVariableSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ExtractMethod 								#defaultString: '&amp;Extract Method' 								#catalogID: #browser ) 							#nameKey: #'Extract Method' 							#value: 							#action: 							#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #extractMethod ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExtractMethodToComponent 								#defaultString: 'Extract Method to Component' 								#catalogID: #browser ) 							#nameKey: #'Extract Method to Component' 							#value: 							#action: ) ) #(13 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#command: #doIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#command: #printIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#command: #inspectIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#command: #debugIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Explain 					#defaultString: 'Explain' 					#catalogID: #browser ) 				#nameKey: #'Explain Code' 				#value: 				#action: 				#command: #explain ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copy				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(2 9 4 1 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.AddProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	^(self protocolObject organization categories includes: self protocol) 		ifTrue: [self copy]		ifFalse: 			[self isData 				ifTrue: 					[RemoveProtocolChange nameSpace: self changeObject protocol: self protocol]				ifFalse: 					[RemoveProtocolChange class: self changeObject protocol: self protocol]]</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>copying</category><body package="Browser-BaseUI" selector="postCopy">postCopy	super postCopy.	properties := properties copy</body></methods><methods><class-id>Refactory.Browser.SmalllintCodeTool</class-id> <category>actions</category><body package="Browser-SmalllintUI" selector="run">run	| rule |	rule := self selectedRule.	rule rules isEmpty ifTrue: [^self].	self runRule: rule copy</body></methods><methods><class-id>Refactory.Browser.SmalllintCodeTool</class-id> <category>private</category><body package="Browser-SmalllintUI" selector="distinctRules">distinctRules	| components |	components := OrderedCollection withAll: self lintRuleList selections.	components isEmpty 		ifTrue: [components := OrderedCollection with: self allLintChecks].	components copy 		do: [:each | each allRules do: [:rule | components remove: rule ifAbsent: []]].	^components</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	definitions := definitions copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>private</category><body package="Browser-Refactorings" selector="itemsDo:">itemsDo: aBlock 	| seen |	seen := IdentitySet new.	self items copy do: 			[:each | 			aBlock value: each.			seen add: each name].	self isDefined ifFalse: [^self].	self realNameSpace bindingsDo: 			[:each | 			| variable item |			variable := each key.			((seen includes: variable) or: [(item := self itemFor: variable) isNil]) 				ifFalse: [aBlock value: item]]</body></methods><methods><class-id>Refactory.Browser.SelectionPackageStatus</class-id> <category>tooltips</category><body package="Browser-BrowserUI" selector="allConnectionsText">allConnectionsText	"Build a paragraph from the toolTexts of the selections repository connections. Build a style for the paragraph that makes the tabs look good."	| pundle ws paragraph style text columnWidths left |	codeModel state narrowestSelectionType == #codeComponent ifFalse: [^nil].	pundle := codeModel state codeComponent.	pundle databaseInformations isEmpty ifTrue: [^nil].	ws := TextStream on: String new.	((pundle databaseInformations reject: [:each | each dbIdentifier isEmpty])		sorted: [:a :b | a dbIdentifier &lt; b dbIdentifier])			do: [:each | ws nextPutAllText: each toolText]			separatedBy: [ws cr].	text := ws contents.	text isEmpty ifTrue: [^nil].	paragraph := ComposedText withText: text.	style := inputField widgetPolicy lookPolicyClass systemTextStyle copy.	columnWidths := text				computeMinimumTabWidthsUsing: inputField graphicsContext.	left := 0.	style		useTabs: #(1) , (columnWidths collect: [:each | left := left + each + 30]).	paragraph textStyle: style.	^paragraph</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager</class-id> <category>copying</category><body package="Store-Merge Management" selector="postCopy">postCopy	redo := redo copy.	undo := undo copy.</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self arguments: (self arguments collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>private-formatting</category><body package="Browser-Parser" selector="formatMessage:cascade:">formatMessage: aMessageNode cascade: cascadeBoolean	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length argLimit |	selectorParts := aMessageNode selectorParts.	arguments := aMessageNode arguments.	formattedArgs := OrderedCollection new.	argLimit := self maximumArgumentsPerLine.	(arguments allSatisfy: [:each | each children isEmpty])		ifTrue: [argLimit := argLimit + 1].	multiLine := aMessageNode selector numArgs &gt; argLimit.	length := aMessageNode selector size + arguments size + 1.	firstArgLength := 0.	self indentWhile: 			[1 to: arguments size				do: 					[:i |					| formatter string |					formatter := (self copy)								lineStart: (selectorParts at: i) length negated;								yourself.					string := formatter format: (arguments at: i).					formattedArgs add: string.					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].					length := length + string size.					multiLine := multiLine or: [formatter isMultiLine]]].	multiLine := multiLine				or: [length + self lineLength &gt; self lineLengthLimit].	indentFirst := cascadeBoolean not and: 					[multiLine and: 							[(self startMessageSendOnNewLine: aMessageNode) or: 									[self lineLength + selectorParts first length + 2 + firstArgLength										&gt; self lineLengthLimit]]].	indentFirst ifTrue: [self indent].	self		formatMessageSelector: selectorParts		withArguments: formattedArgs		multiline: multiLine</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>private-formatting</category><body package="Browser-Parser" selector="formatBlockNode:startBlockString:endBlockString:">formatBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString	| seqNode multiline formattedBody formatter |	seqNode := aBlockNode body.	formatter := (self copy)				lineStart: 0;				yourself.	formattedBody := formatter format: seqNode.	multiline := self lineLength + formattedBody size &gt; self lineLengthLimit				or: [formatter isMultiLine].	multiline ifTrue: [self indent].	codeStream nextPutAll: startBlockString.	self addModerateExtraSpace.	aBlockNode arguments do: 			[:each |			codeStream nextPut: $:.			self visitNode: each.			codeStream space].	aBlockNode arguments notEmpty		ifTrue: 			[codeStream nextPutAll: '| '.			multiline ifTrue: [self indent]].	codeStream nextPutAll: formattedBody.	self addModerateExtraSpace.	codeStream nextPutAll: endBlockString</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser" selector="acceptMessageNode:">acceptMessageNode: aMessageNode	| newFormatter code |	newFormatter := self copy.	code := newFormatter format: aMessageNode receiver.	codeStream nextPutAll: code.	codeStream space.	newFormatter isMultiLine		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])		while: [self formatMessage: aMessageNode cascade: false]</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>accessing</category><body package="Browser-Refactorings" selector="instanceVariableNames">instanceVariableNames	^self privateInstanceVariableNames copy</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>testing</category><body package="Browser-Refactorings" selector="referencedItem:in:">referencedItem: aString in: aNamespace	"Search for the named item, giving access to both our local names (e.g. shared variables) but searching aNamespace rather than our namespace and imports. The simplest thing that could possibly work seems to be to copy ourselves, tweak the namespace, and hope."	| copy |	aNamespace isNil ifTrue: [^self referencedItem: aString].	copy := self copy.	copy parent: aNamespace.	^copy referencedItem: aString</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>private</category><body package="Browser-Refactorings" selector="prepareForRemoval">prepareForRemoval	super prepareForRemoval.	self superclass isNil ifTrue: [self rootNameSpace removeRootClass: self].	self subclasses copy do: 			[:each | 			each isMeta 				ifTrue: [each superclass: nil]				ifFalse: [each environment removeLocalObject: each]].	self superclass notNil ifTrue: [self superclass removeSubclass: self].	self metaclass superclass notNil 		ifTrue: [self metaclass superclass removeSubclass: self metaclass]</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self messages: (self messages collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	instanceBehaviorNames := instanceBehaviorNames copy.	classBehaviorNames := classBehaviorNames copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="safeVariableNameBasedOn:">safeVariableNameBasedOn: aString 	"Creates an unused variable name containing aString"	| baseString newString i allTempVars |	allTempVars := inlineParseTree allTemporaryVariables.	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	i := 0.		[(allTempVars includes: newString) 		or: [class definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="addSelfReferenceToSourceMessage">addSelfReferenceToSourceMessage	| newArguments |	newArguments := OrderedCollection withAll: sourceMessage arguments.	newArguments addFirst: sourceMessage receiver copy.	sourceMessage 		renameSelector: (self addArgumentToSelector: sourceMessage selector)		andArguments: newArguments</body></methods><methods><class-id>Refactory.Browser.SelectorProtocolNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI" selector="iconFor:">iconFor: aMethodCategory	"Return a graphic that shows the count of methods in this category. It's back coloring is based on whether all, none, or some of the methods are currently visible in the browser. As is the number count text color."	"The back 'shape' is actually a series of rectangles, we get a cleaner looking ovoid this way since it stays balanced, whereas arc/wedge drawings aliases really bad."	"The bit with style gridding, pure dart throwing until I found an algorithm that positioned it correctly on all 3 display systems."		| totalCount hereCount countStyle listView label countTextColor |	navigator selectedClass ifNil: [^nil].	totalCount := self totalMethodCountIn: aMethodCategory.	hereCount := self visibleMethodCountIn: aMethodCategory.	listView := self widgetAt: #objectList.	countStyle := listView textStyle copy.	countStyle gridForFont: #small withTopLead: 0 bottomLead: 0.	countTextColor := (hereCount		between: 1		and: totalCount - 1)		ifTrue: [ColorValue black]		ifFalse: [ColorValue white].	label := Label		with:			(totalCount printString asText				emphasizeAllWith:					(Array						with: #small						with: #color -&gt; countTextColor))		attributes: countStyle.	^VisualStack		with:			((totalCount isZero not and: [hereCount = totalCount])				ifTrue: [GeneralIcons darkMethodCountBackground]				ifFalse: [GeneralIcons lightMethodCountBackground])		with: label</body></methods><methods><class-id>Refactory.Browser.SmalllintResultEditor</class-id> <category>private</category><body package="Browser-SmalllintUI" selector="removeCurrentResultFrom:">removeCurrentResultFrom: displayedResults 	| currentResult last newList |	currentResult := self selectedResult.	displayedResults remove: currentResult ifAbsent: [].	newList := displayedResults copy.	last := nil.	displayedResults reverseDo: 			[:each | 			(each isComposite and: [(each rules includes: last) not])				ifTrue: [newList remove: each ifAbsent: []]				ifFalse: [last := each]].	^newList</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects" selector="asUndoOperation">asUndoOperation	| compositeChange category |	compositeChange := CompositeRefactoryChange named: self name.	category := self protocolObject organization 				categoryOfElement: self symbol.	compositeChange addChange: ((self copy)				protocol: category;				yourself).	self includesProtocol 		ifFalse: 			[compositeChange addChange: (self isData 						ifTrue: 							[RemoveProtocolChange nameSpace: self changeObject protocol: self protocol]						ifFalse: 							[RemoveProtocolChange class: self changeObject protocol: self protocol])].	compositeChange toggleUndoState.	^compositeChange</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self receiver: self receiver copy.	self arguments: (self arguments collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI" selector="windowSpec">windowSpec	"Some very hackish code that adds the horizontal scrollbar to the list. 	If you know of a better way to do this, please feel free to clean it up :)."	| spec allSpecs index listSpec flagsIndex |	ShowHorizontalScrollbar ifFalse: [^self basicWindowSpec].	spec := self basicWindowSpec copy.	spec at: spec size put: spec last copy.	allSpecs := spec last last copy.	index := (1 to: allSpecs size) 				detect: [:each | (allSpecs at: each) includes: #objectList]				ifNone: [nil].	index isNil ifTrue: [^spec].	listSpec := allSpecs at: index.	flagsIndex := listSpec indexOf: #flags:.	flagsIndex odd 		ifTrue: 			[listSpec at: flagsIndex + 1 put: ((listSpec at: flagsIndex + 1) bitOr: 2)]		ifFalse: [allSpecs at: index put: (allSpecs at: index) , #(#flags: 15)].	spec last at: spec last size put: allSpecs.	^spec</body></methods><methods><class-id>Refactory.Browser.CodeComponentBlockTool class</class-id> <category>resources</category><body package="Browser-BrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #browser ) 				#nameKey: #Accept 				#value: 				#action: 				#command: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#command: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#command:  #printIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#command: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#command: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #browser ) 				#nameKey: #'Cut Selection' 				#value: 				#action: 				#command: #cut 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#command: #copy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #browser ) 				#nameKey: #'Paste Selection' 				#value: 				#action: 				#command: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editPaste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #browser ) 				#nameKey: #'Replace Text' 				#value: 				#action: 				#command: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #browser ) 				#nameKey: #Cancel 				#value: 				#action: ) ) #(1 4 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.InlineParameterRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="modifyImplementorParseTree:in:">modifyImplementorParseTree: parseTree in: aClass 	| node assignment |	node := (parseTree arguments at: parameterIndex) copy.	parseTree body addTemporaryNamed: node name.	assignment := RBAssignmentNode variable: node copy value: expressions first.	parseTree body addNodeFirst: assignment.	super modifyImplementorParseTree: parseTree in: aClass</body></methods><methods><class-id>Refactory.Browser.BasicLintRule</class-id> <category>accessing</category><body package="Browser-Smalllint" selector="filteredResult">filteredResult	^(SmalllintFilterEnvironment onEnvironment: result		and: (self class filterDictionary at: self name ifAbsent: [result copyEmpty]) 				copy not)		label: result label;		lintRuleName: self name;		yourself</body></methods><methods><class-id>Refactory.Browser.BasicLintRule class</class-id> <category>accessing</category><body package="Browser-Smalllint" selector="addFilter:for:">addFilter: anEnvironment for: aString 	self filterDictionary at: aString put: anEnvironment copy</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	super postCopy.	bundleNames := bundleNames copy.	packageNames := packageNames copy</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects" selector="renameChangesForObject:to:">renameChangesForObject: aClassName to: newClassName 	| newChange tree newReceiver |	newChange := super renameChangesForObject: aClassName to: newClassName.	tree := RBParser parseExpression: newChange definition				onError: [:s :e | ^newChange].	tree isMessage ifFalse: [^newChange].	tree receiver isVariable ifFalse: [^newChange].	newReceiver := self 				changeVariable: tree receiver name				thatBeginsWith: aClassName				toBeginWith: newClassName.	newReceiver = tree receiver name ifTrue: [^newChange].	tree receiver: (RBVariableNode named: newReceiver).	^(newChange copy)		definition: tree formattedCode;		fillOutDefinition;		yourself</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	self variable: self variable copy.	self value: self value copy</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	protocols := protocols copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="replaceBindingReference:">replaceBindingReference: aReference 	| path newPath |	path := aReference path.	newPath := self 				replaceReferenceTo: object				inPath: path				toBe: newName.	^(aReference copy)		path: newPath;		yourself</body></methods><methods><class-id>Refactory.Browser.RemoveObjectRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings" selector="reparentSubclasses">reparentSubclasses	objectNames do: 			[:each | 			| class |			class := self model classNamed: each.			class notNil 				ifTrue: 					[self model reparentClasses: class subclasses copy to: class superclass]]</body></methods><methods><class-id>Graphics.VariableCharacterAttributes</class-id> <category>private</category><body package="Internationalization" selector="updatedQueryFor:">updatedQueryFor: aFontPolicy	| locale pixels family encoding |	(aFontPolicy isNil or: [(policyCache first) == aFontPolicy])		ifFalse:			[self invalidateQueryCache.			policyCache at: 1 put: aFontPolicy].	updatedQuery notNil 		ifTrue: [^updatedQuery].	locale := Locale current.	updatedQuery := (self defaultQueryFor: aFontPolicy) copy.	pixels := locale preferredPixelSizeFor: aFontPolicy.	"Algorithm for following 4 lines from FontPolicy&gt;&gt;stringMatchFrom:to:test:value:weight:"	family := updatedQuery family.	family isNil		ifTrue: [ family := #()]		ifFalse: [ family isString ifTrue: [ family := Array with: family]].	family := Locale current preferredFontFamily, family.	doScaling		ifTrue: [updatedQuery  pixelSize: (pixels * self scalingFactor) rounded].	encoding := locale defaultStreamEncoder encodingType.	encoding isNil ifFalse: [encoding := encoding asString].	updatedQuery 		family: family;		encoding: encoding;		encodings: locale preferredEncodings.	^updatedQuery</body></methods><methods><class-id>Graphics.ScreenFont class</class-id> <category>private</category><body package="Graphics-Fonts" selector="filterEncoding:on:">filterEncoding: encName on: platform	| encoder i |	encoder := CharacterEncoder encoderNamed: encName platform: platform.	encoder := encoder copy.	(0 to: 31), (127 to: 160) do: [:c |		(i := encoder encode: (Character value: c)) == 65535			ifFalse: [encoder encode: Character illegalCode asCharacter as: i]].	^encoder</body></methods><methods><class-id>Graphics.ScreenFont class</class-id> <category>class initialization</category><body package="Graphics-Fonts" selector="iso8859Encoder">iso8859Encoder	| encoder |	encoder := ISO8859L1String encoder copy.	"Ignore unprintable characters"	0 to: 31 do: [:i | encoder encode: Character illegalCode asCharacter as: i].	127 to: 160 do: [:i | encoder encode: Character illegalCode asCharacter as: i].	^encoder</body></methods><methods><class-id>Graphics.VariableSizeTextAttributes</class-id> <category>system startup</category><body package="Graphics-Fonts" selector="updateLineGridding:">updateLineGridding: aFontPolicy	| font |	lastFontPolicy == aFontPolicy ifTrue: [^self].	lastFontPolicy := aFontPolicy.	characterAttributes scalingFactor == nil		ifTrue:			[| fontD |			fontD := (self defaultFontFor: lastFontPolicy) copy.			fontD pixelSize: (lastFontPolicy preferredFontSize * self scalingFactor) rounded.			characterAttributes setDefaultQuery: fontD for: lastFontPolicy]		ifFalse:			["The CharacterAttributes must have enough smarts to do this by itself."			characterAttributes invalidateQueryCache].	font := lastFontPolicy findFont: (self fontAt: fontAttributeForLeading for: lastFontPolicy).	baseline := font ascent + topLeading.	lineGrid := font height + bottomLeading + topLeading</body></methods><methods><class-id>Graphics.XFont class</class-id> <category>utilities</category><body package="Graphics-Fonts" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen 	| encoding fontName encodingName fd |	fd := concreteFontDescription copy.	encodingName := concreteFontDescription specifiesEncoding		ifTrue: [concreteFontDescription encoding]		ifFalse: [concreteFontDescription name].	encoding := self encoderNamed: encodingName.	(concreteFontDescription specifiesPixelSize and: [concreteFontDescription pixelSize = 0]) 		ifTrue: 			[fontName := self generateFontNameFor: concreteFontDescription name using: requestedFontDescription pixelSize.			fd pixelSize: requestedFontDescription pixelSize]		ifFalse: [fontName := concreteFontDescription name].	fd name: fontName.	^(aScreen		fontNamed: fontName		fromClass: self		encoding: encoding)		setDescription: fd</body></methods><methods><class-id>Graphics.Printer class</class-id> <category>examples</category><body package="Examples" selector="exampleFonts">exampleFonts	"Printer exampleFonts."	| text document font |	document := Document new.	document		doFooter: true		footerString: 'Printer exampleFonts'		doPageNumbers: true.	text := (#reallyLongText &lt;&lt; #examples &gt;&gt; 'The lazy brown dog jumped over the quick fox''s back, but since the fox was quick, he managed to catch up to the dog later and eat it.  The moral of this story is always to eat your Wheaties.') asText.	font := FontDescription new pixelSize: 10; boldness: 0.5.	#('times' 'helvetica' 'courier')		do: 			[:family |			| style |			font family: family; italic: false.			style := TextAttributes defaultFontQuery: font copy.			style baseline: 10.			style lineGrid: 10 * 12 // 10.			document startParagraph.			document addText: family under: (TextAttributes styleNamed: #default).			document startParagraph.			document addText: text under: style copy.			font italic: true.			style := TextAttributes defaultFontQuery: font copy.			style baseline: 10.			style lineGrid: 10 * 12 // 10.			document startParagraph.			document addText: family, '-italic' under: (TextAttributes styleNamed: #default).			document startParagraph.			document addText: text under: style copy].	document toPrinter</body></methods><methods><class-id>Graphics.Printer class</class-id> <category>examples</category><body package="Examples" selector="exampleFontSizes">exampleFontSizes	"Printer exampleFontSizes."	| text document font |	document := Document new.	document		doFooter: true		footerString: 'Printer exampleFontSizes'		doPageNumbers: true.	text := (#reallyLongText &lt;&lt; #examples &gt;&gt; 'The lazy brown dog jumped over the quick fox''s back, but since the fox was quick, he managed to catch up to the dog later and eat it.  The moral of this story is always to eat your Wheaties.') asText.	font := FontDescription new family: 'times'; boldness: 0.5; italic: false.	#(6 10 14 18 )		do: 			[:size |			| style |			font pixelSize: size.			style := TextAttributes defaultFontQuery: font copy.			style baseline: size.			style lineGrid: size * 12 // 10.			document startParagraph.			document addText: font pixelSize printString under: (TextAttributes styleNamed: #default).			document startParagraph.			document addText: text under: style copy].	document toPrinter</body></methods><methods><class-id>Graphics.CachedImage</class-id> <category>converting</category><body package="Graphics-Images" selector="renderDithered:">renderDithered: im	| medium gc |	medium := im paintBasis retainedMediumWithExtent: im extent.	gc := medium graphicsContext.	gc paintPolicy: gc paintPolicy copy.	gc paintPolicy imageRenderer: OrderedDither new.	gc copyImage: im to: Point zero.	^medium</body></methods><methods><class-id>Graphics.MacOSXFont class</class-id> <category>utilities</category><body package="Graphics-Fonts" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen 	"Answer an instance of the receiver that best represents the argument, 	 concreteFontDescription, given the font it is most closely to resemble, 	 requestedFontDescription.  The argument, aScreen, is the current Screen 	 object the font should be associated with.  PostScriptFonts are independent 	 of the Screen argument."	| size fontName encoding fontDescription boldValue isItalic screenFont |	encoding := self encoderNamed: self defaultEncodingName.	fontDescription := concreteFontDescription copy.	size := concreteFontDescription specifiesPixelSize 				ifTrue: [concreteFontDescription pixelSize]				ifFalse: [requestedFontDescription pixelSize].	fontName := concreteFontDescription family.	"'HelveticaNeue' matches 'helv*', which doesn't work here."	(fontName = 'Helvetica Neue' or: [fontName = 'HelveticaNeue']) 		ifTrue: [fontName := 'Helvetica'].	boldValue := requestedFontDescription specifiesBoldness 				ifTrue: [requestedFontDescription boldness]				ifFalse: 					[requestedFontDescription name isString 						ifTrue: 							[(self boldnessDescription: requestedFontDescription name) 								ifNil: [concreteFontDescription boldness]]						ifFalse: [concreteFontDescription boldness]].	isItalic := requestedFontDescription specifiesItalic 				ifTrue: [requestedFontDescription italic]				ifFalse: 					[requestedFontDescription name isString 						ifTrue: 							[(self italicDescription: requestedFontDescription name) 								ifNil: [concreteFontDescription italic]]						ifFalse: [concreteFontDescription italic]].	fontName := fontName , ' ' , size printString , ' ' 				, boldValue printString , ' ' 				, (isItalic ifTrue: ['1'] ifFalse: ['0']) , ' ' 				, requestedFontDescription setWidth printString.	screenFont := aScreen 		fontNamed: fontName		fromClass: self		encoding: encoding.	screenFont setDescription: fontDescription.	concreteFontDescription family = 'Lucida_Grande' ifTrue: [screenFont tuneWidthsOn: aScreen].	^screenFont.</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>accessing</category><body package="Graphics-Text Support" selector="bindValue:to:">bindValue: aValue to: aCharacter	"Arrange for aValue to be answered whenever aCharacter is passed in"	| array |	self forkCopy.	(composeTable includesKey: aCharacter)		ifTrue:	[self notify: (#errBindMetaCharacter &lt;&lt; #dialogs &gt;&gt; 'This character is a meta-character.  Proceed to rebind it').				composeTable removeKey: aCharacter].	array := baseTable at: aCharacter ifAbsent: nil.	array class == Array		ifTrue:	[array := array copy.				array replaceAll: (array at: 1) with: aValue]		ifFalse:	[array := aValue].	baseTable at: aCharacter put: array</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="copyOld">copyOld	"Prevent the baseTable and composeTable from being corrupted if	more than one DispatchTable are sharing them"	shared := true.	^super copy</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="copy">copy	"Prevent the baseTable and composeTable from being corrupted if	more than one DispatchTable are sharing them"	shared := true.	^super copy</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>private</category><body package="Graphics-Text Support" selector="forkCopy">forkCopy	"The receiver needs to be modified.  Copy the shared state"	shared		ifTrue:			[composeTable := composeTable copy.			baseTable := baseTable copy.			commandMapping := commandMapping copy.			shared := false].</body></methods><methods><class-id>Graphics.DispatchTable</class-id> <category>accessing</category><body package="Graphics-Text Support" selector="bindValue:to:modifiers:">bindValue: aValue to: aCharacter modifiers: metaCollection	"Arrange for aValue to be answered whenever aCharacter is passed in	with the same set of meta state bits defined in metaCollection."	| array index |	self forkCopy.	(composeTable includesKey: aCharacter)		ifTrue:	[self notify: (#errBindMetaCharacter &lt;&lt; #dialogs &gt;&gt; 'This character is a meta-character.  Proceed to rebind it').				composeTable removeKey: aCharacter].	array := baseTable at: aCharacter ifAbsent: [nil].	array class == Array		ifTrue: [ array := array copy ]		ifFalse: [array := Array new: 32 withAll: array].	index := 0.	(metaCollection includes: #shift) ifTrue: [index := index bitOr: InputState shiftMask].	(metaCollection includes: #control) ifTrue: [index := index bitOr: InputState ctrlMask].	(metaCollection includes: #meta) ifTrue: [index := index bitOr: InputState metaMask].	(metaCollection includes: #alt) ifTrue: [index := index bitOr: InputState altMask].	(metaCollection includes: #command) ifTrue: [index := index bitOr: InputState commandMask].	array at: index+1 put: aValue.	baseTable at: aCharacter put: array</body></methods><methods><class-id>Graphics.MappedPalette</class-id> <category>accessing</category><body package="Graphics-Palettes" selector="mapResolution">mapResolution	"Answer the resolutions of my inverse map, in bits.  A resolution	is the number of bits used to represent a stimulus component	of a color, e.g. a red resolution of 4 means that 4 bits will be used	to store the red component.  The resolutions are returned as	a four-element array of the red, green, blue, and gray resolutions	in order."	^mapResolution copy</body></methods><methods><class-id>Graphics.MappedPalette class</class-id> <category>defaults</category><body package="Graphics-Palettes" selector="defaultMapResolution">defaultMapResolution	"Answer the default inverse map resolutions, in bits.  A resolution	is the number of bits used to represent a stimulus component	of a color, e.g. a red resolution of 4 means that 4 bits will be used	to store the red component.  The resolutions are returned as	a four-element array of the red, green, blue, and gray resolutions	in order."	^DefaultMapResolution copy</body></methods><methods><class-id>Graphics.FontPolicy</class-id> <category>utilities</category><body package="ExtraEmphases" selector="findFont:">findFont: aFontDescription 	"Answer the nearest font from those available on this device	to the requested FontDescription"	| font bestMatch |	fdCache = aFontDescription ifTrue: [^dfCache].	font := fontCache at: aFontDescription ifAbsent: [nil].	font == nil 		ifFalse: 			[fdCache := aFontDescription copy.			dfCache := font.			^font].	bestMatch := self findBestFont: aFontDescription.	aFontDescription isComposite 		ifTrue: 			[font := CompositeFont 						createFont: bestMatch						toResemble: aFontDescription						for: self]		ifFalse: 			[font := fontClass 						createFont: bestMatch						toResemble: aFontDescription						on: device].	font := self decorateFont: font with: aFontDescription.	fontCache at: aFontDescription copy put: font.	fdCache := aFontDescription.	dfCache := font.	^font</body></methods><methods><class-id>Graphics.FontPolicy</class-id> <category>private</category><body package="Graphics-Fonts" selector="matchFont:allowance:">matchFont: requestedFont allowance: allowance	"Find all fonts that approximately or exactly match the requested font"	| list req |	list := OrderedCollection new: 40.	req := requestedFont copy.	req optimizeMatching.	1 to: availableFonts size do:		[:i |		| concreteFont distance |		concreteFont := availableFonts at: i.		distance := self measureDistancesFrom: req to: concreteFont stopAt: allowance.		distance &lt;= allowance			ifTrue:	[list add: distance -&gt; concreteFont]].	list isEmpty		ifFalse:	[^list asSortedCollection: [:x :y | x key &lt; y key]].	^noFontBlock 		ifNil: [self class noMatchingFontSignal raiseRequestWith: requestedFont]		ifNotNil: [OrderedCollection with: allowance-&gt;(noFontBlock value: requestedFont)]</body></methods><methods><class-id>Graphics.FontPolicy</class-id> <category>private</category><body package="Graphics-Fonts" selector="bestFont:allowance:">bestFont: requestedFont allowance: allowance 	"Find a font that approximately or exactly matches the requested font"	| req limit best |	limit := allowance.	req := requestedFont copy.	req optimizeMatching.	best := nil.	1 to: availableFonts size		do: 			[:i | 			| concreteFont distance |			concreteFont := availableFonts at: i.			distance := self 						measureDistancesFrom: req						to: concreteFont						stopAt: limit.			distance &lt; limit 				ifTrue: 					[limit := distance.					best := concreteFont]].	best == nil ifFalse: [^best].	^noFontBlock 		ifNil: [self class noMatchingFontSignal raiseRequestWith: requestedFont]		ifNotNil: [noFontBlock value: requestedFont]</body></methods><methods><class-id>Graphics.Document</class-id> <category>initialize-release</category><body package="System-Printing" selector="initialize">initialize	"Set up defaults,  and create an ordered collection to hold the 	intermediate representation of the document."	entities 			:= OrderedCollection new: 255.	currentMargins := DefaultMargins copy.	self setTabs: DefaultTabStops copy.	self setMargins: currentMargins copy</body></methods><methods><class-id>Graphics.Document</class-id> <category>adding entities</category><body package="System-Printing" selector="startParagraph">startParagraph	"Set up to start a new paragraph of text.  In particular, reset margins."	self setMargins: self margins copy.	entities add: (Message selector: #startParagraph)</body></methods><methods><class-id>Graphics.ExtendedFontDescription</class-id> <category>copying</category><body package="ExtraEmphases" selector="postCopy">postCopy	super postCopy.	extensions := extensions copy.</body></methods><methods><class-id>Graphics.OrderedDither</class-id> <category>private</category><body package="Graphics-Color Rendering" selector="postCopy">postCopy	super postCopy.	array := array collect: [:row | row copy]</body></methods><methods><class-id>Graphics.OrderedDither</class-id> <category>private-tessellation</category><body package="Graphics-Color Rendering" selector="finishTessellation">finishTessellation	"Take final steps in calculating the threshold array, following tessellation stages."	"Rotate odd order arrays by 45 degrees."	| tempArray center offset |	tempArray := self copy.	center := self centerPoint.	offset := -1@1.	1 to: height do:		[:row |		| threshold baseOrigin |		threshold := array at: row.		baseOrigin := center + ((1@1) * (row - 1)).		1 to: width do:			[:col |			threshold at: col put: (tempArray atPoint: baseOrigin + (offset * (col - 1)))]]</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>bounds accessing</category><body package="Graphics-Visual Objects" selector="computePreferredBounds">computePreferredBounds	"Compute the receiver's preferredBounds"	| size |	size := components size.	size = 0 ifTrue:		[^preferredBounds := 0 @ 0 corner: 0 @ 0].	preferredBounds := (components at: 1) bounds copy.	2 to: size do: [:i |		preferredBounds := preferredBounds merge: (components at: i) bounds].	^preferredBounds</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>rebuilding</category><body package="Graphics-Visual Objects" selector="client:components:">client: aSubCanvas components: compList	| theComponents |	theComponents := self components copy.	theComponents do: [:each | self removeComponent: each].	compList do: [:each | self addComponent: each].	self invalidate.	^theComponents</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>displaying</category><body package="Graphics-Visual Objects" selector="displayOn:">displayOn: aGraphicsContext	"Display each of the receiver's components."	| clipBox |	clipBox := aGraphicsContext clippingBounds.	1 to: components size do:		[:i |		| component |		component := components at: i.		(component intersects: clipBox)			ifTrue: [component displayOn: aGraphicsContext copy]]</body></methods><methods><class-id>Graphics.LayoutOrigin</class-id> <category>converting</category><body package="Interface-Support" selector="reducedForm">reducedForm	"Answer the most reduced form for representing the receiver.  This	includes reducing floats to integers where possible."	| result |	(leftFraction = 0 and: [topFraction = 0]) ifTrue: [^Point x: left y: top].	result := self copy.	leftFraction = 0	ifTrue: [result leftFraction: 0].	topFraction = 0	ifTrue: [result topFraction: 0].	leftFraction = 1	ifTrue: [result leftFraction: 1].	topFraction = 1	ifTrue: [result topFraction: 1].	^result</body></methods><methods><class-id>Graphics.CharacterBlockScanner</class-id> <category>stop conditions</category><body package="Graphics-Text Scanning" selector="space">space	"When the line is justified, the spaces will not be the same as the 	font's space character.  A padding of extra space must be 	considered in trying to find which character the cursor is pointing at. 	Answer whether the scanning has crossed the cursor."	spaceCount := spaceCount + 1.	lastSpaceOrTabExtent := lastCharacterExtent copy.	lastSpaceOrTabExtent x: spaceWidth.	destX + lastSpaceOrTabExtent x &gt; characterPoint x ifTrue: [		 lastCharacterExtent := lastSpaceOrTabExtent copy.		^self crossedX].	lastIndex := lastIndex + 1.	destX := destX + spaceWidth.	^false</body></methods><methods><class-id>Graphics.CharacterBlockScanner</class-id> <category>stop conditions</category><body package="Graphics-Text Scanning" selector="paddedSpace">paddedSpace	"When the line is justified, the spaces will not be the same as the 	font's space character.  A padding of extra space must be 	considered in trying to find which character the cursor is pointing at. 	Answer whether the scanning has crossed the cursor."	| pad |	spaceCount := spaceCount + 1.	pad := self justifiedPadFor: spaceCount.	lastSpaceOrTabExtent := lastCharacterExtent copy.	lastSpaceOrTabExtent x: spaceWidth + pad.	destX + lastSpaceOrTabExtent x &gt; characterPoint x ifTrue: [		lastCharacterExtent := lastSpaceOrTabExtent copy.		^self crossedX].	lastIndex := lastIndex + 1.	destX := destX + lastSpaceOrTabExtent x.	^false</body></methods><methods><class-id>Graphics.CharacterBlockScanner</class-id> <category>stop conditions</category><body package="Graphics-Text Scanning" selector="tab">tab	"Handle leading and internal tabs in a justified line.  Leading tabs are 	considered legal and should be reflected on the display gracefully.  	Internal tabs (when the line is justified) are considered at the very 		best a misguided use of the character, and are reflected on the display 	the best we can."		| currentX |	currentX := destX.	(textStyle alignment = Justified and: [spaceCount &gt; 0])		ifTrue:			[currentX := currentX				+ (textStyle tabWidth - (self justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[currentX := textStyle nextTabXFrom: currentX leftMargin: leftMargin				rightMargin: rightMargin spaceWidth: spaceWidth].	lastSpaceOrTabExtent := (currentX - destX max: 0) @ lastCharacterExtent y.	currentX &gt; characterPoint x		ifTrue:			[lastCharacterExtent := lastSpaceOrTabExtent copy.			^self crossedX].	destX := currentX.	lastIndex := lastIndex + 1.	^false</body></methods><methods><class-id>Graphics.PostScriptPrinterFont class</class-id> <category>utilities</category><body package="Graphics-Printing-PostScript" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen	| fontName fd |	fd := concreteFontDescription copy.	fontName := concreteFontDescription name, '~', requestedFontDescription pixelSize printString.	fd pixelSize: requestedFontDescription pixelSize.	fd name: fontName.	^(aScreen			fontNamed: fontName			fromClass: self)		setDescription: fd</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>private</category><body package="Graphics-Text Support" selector="setAlignment:">setAlignment: anAlignment	"Set the receiver's alignment to be anAlignment."	| old |	self setTextStyle: self textStyle copy.	old := self textStyle alignment.	old = anAlignment ifTrue: [^self].	self textStyle alignment: anAlignment.	old = LeftFlush		ifTrue: [self composeAll]</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="firstIndent:">firstIndent: anInteger 	"Set the horizontal indentation of the first line to be	anInteger in the style of the receiver."	self setTextStyle: self textStyle copy.	self textStyle firstIndent: ((anInteger max: 0)				min: compositionWidth - DefaultSpace - self rightIndent).	self composeAll</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="clearIndents">clearIndents	"Reset all the indentation settings to be 0."	self setTextStyle: self textStyle copy.	self textStyle firstIndent: 0.	self textStyle restIndent: 0.	self textStyle rightIndent: 0.	self composeAll</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="gridWithLead:">gridWithLead: leadInteger 	"Set the line grid of the receiver's style for displaying text to the height	of the first font in the receiver's style + the argument, leadInteger."	self setTextStyle: self textStyle copy.	self textStyle 		gridForFont: (text emphasisAt: 1)		withLead: leadInteger.		"assumes only one font referred to by runs"	self updateCompositionHeight.</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="rightIndent:">rightIndent: anInteger 	"Set the right margin indentation for the lines of the receiver to be	anInteger in the style of the receiver."	| maxRightIndent |	self setTextStyle: self textStyle copy.	self firstIndent &gt; self restIndent		ifTrue: [maxRightIndent := compositionWidth - DefaultSpace - self firstIndent max: 1]		ifFalse: [maxRightIndent := compositionWidth - DefaultSpace - self restIndent max: 1].	self textStyle rightIndent: (anInteger min: maxRightIndent).	self composeAll</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>displaying</category><body package="Graphics-Text Support" selector="displayFromCharacter:to:startX:forTranslation:on:">displayFromCharacter: startIndex to: stopIndex startX: startX forTranslation: aPoint on: aGraphicsContext	"Display the characters between startIndex and stopIndex on 	aGraphicsContext. The x position of the first character is at startX. 	This is useful for displaying text selections.	It is important to start displaying at the character before startIndex 	if startIndex is not the start of a line and after stopIndex if the stop 	is not the end of a line because some hosts do kerning for us. This 	would result in some missing parts of characters that intruded into 	the bounding box of the characters. This is most noticable with italic 	text."	| stop lineIndex startForLine stopForLine  leftX rightX top scanner textSize lineRecord lineGrid left gc|	self fontPolicy: aGraphicsContext fontPolicy.	textSize := self text size.	startIndex &gt; textSize ifTrue: 		[^self].	stop := stopIndex.	stop &gt; textSize ifTrue: [stop := textSize].	scanner := self getDisplayScanner.	scanner textStyle: self textStyle.	lineIndex := self lineIndexOfCharacterIndex: startIndex.	lineRecord := self lineAt: lineIndex.	stopForLine := lineRecord last.	stopIndex &lt; stopForLine ifTrue: [stopForLine := stopIndex].	startForLine := startIndex.	rightX:= self rightMarginForDisplay + aPoint x.	top  := (self topAtLineIndex: lineIndex) + aPoint y.	lineGrid := self lineGridFor: aGraphicsContext fontPolicy.	left := (self leftMarginForDisplayForLine: lineIndex) + aPoint x.	gc := aGraphicsContext.	lineRecord first = startForLine		ifTrue: [leftX := left]		ifFalse: ["move the start index back by one if the previous character is				not white space.  Change the clipping box of the first line so it appears that				we started displaying at startX"				| line index char |				line := self textAt: lineIndex.				index := startForLine - 1.				(char := line at: index) isSeparator					ifTrue: [leftX := startX]					ifFalse: [| font r |							font := aGraphicsContext findFont:									(self textStyle fontAt: (line emphasisAt: index)												for: self fontPolicy).							gc := aGraphicsContext copy.							r := gc clippingBounds.							gc clippingRectangle: (r left: (startX max: r left)). 							leftX := startX -(font widthOf: char).							startForLine := index]].	[scanner 		displayLine: lineRecord		inText: (self textAt: lineIndex)		left: left		right: rightX		startX: leftX		top: top		startIndex: startForLine		stopIndex: stopForLine		on: gc.	stop &lt;= stopForLine 			ifTrue: [ | cRect cb|					stopForLine = lineRecord last ifTrue: [^self].					cb := gc clippingBounds.					leftX := scanner destX.					cRect := cb origin corner: (leftX min: cb right)@cb bottom.					gc clippingRectangle: cRect.					scanner 						displayLine: lineRecord						inText: (self textAt: lineIndex)						left: left						right: rightX						startX: leftX						top: top						startIndex: stopForLine+1						stopIndex: stopForLine+1						on: gc.						gc clippingRectangle: cb.						^self].	"Set the GraphicsContext back to the original since the clipping may have been changed	for the first line."	gc := aGraphicsContext.	lineIndex := lineIndex + 1.	lineRecord := self lineAt: lineIndex.	startForLine := lineRecord first.	stopForLine := lineRecord last.	stop &lt; stopForLine ifTrue: [stopForLine := stop].	leftX := (self leftMarginForDisplayForLine: lineIndex) + aPoint x.		left := leftX.	top := top + lineGrid] repeat</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>justification and spacing</category><body package="Graphics-Text Support" selector="restIndent:">restIndent: anInteger 	"Set the indentation for all but the first line of the receiver to be	anInteger in the style of the receiver."	self setTextStyle: self textStyle copy.	self textStyle restIndent: ((anInteger max: 0)				min: compositionWidth - DefaultSpace - self rightIndent).	self composeAll</body></methods><methods><class-id>Graphics.ByteCharacterEncoder</class-id> <category>copying</category><body package="Graphics-Fonts" selector="postCopy">postCopy	super postCopy.	decoder := decoder copy.	encoder := encoder copy.</body></methods><methods><class-id>Graphics.LayoutFrame</class-id> <category>converting</category><body package="Interface-Support" selector="reducedForm">reducedForm	"Generate the most reduced form for representing the receiver.  This	includes reducing floats to integers where possible."	| result |	(leftFraction = 0 and:		[topFraction = 0 and:			[rightFraction = 0 and:				[bottomFraction = 0]]])		ifTrue:			[^Rectangle				left: left				right: right				top: top				bottom: bottom].	result := self copy.	leftFraction = 0		ifTrue: [result leftFraction: 0].	topFraction = 0		ifTrue: [result topFraction: 0].	rightFraction = 0		ifTrue: [result rightFraction: 0].	bottomFraction = 0		ifTrue: [result bottomFraction: 0].	leftFraction = 1		ifTrue: [result leftFraction: 1].	topFraction = 1		ifTrue: [result topFraction: 1].	rightFraction = 1		ifTrue: [result rightFraction: 1].	bottomFraction = 1		ifTrue: [result bottomFraction: 1].	^result</body></methods><methods><class-id>Graphics.LineInformationTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="postCopy">postCopy	"The receiver is a copy.  Copy the lines."	super postCopy.	lines := lines copy</body></methods><methods><class-id>Graphics.DocumentRenderer</class-id> <category>private</category><body package="System-Printing" selector="flushBuffer:">flushBuffer: aText		| ct ctt |	ctt := textStyle copy.	(ctt respondsTo: #fontPolicyBlock:)		ifTrue:			[ctt setCharacterAttributes: textStyle characterAttributes copy.			ctt				fontPolicyBlock: [output fontPolicy];				flushGridding].	tabsArePositions		ifTrue: [ctt useTabPositions: currentTabs]		ifFalse: [ctt useTabs: currentTabs].	ct := ComposedText		withText: aText		style: ctt		compositionWidth:			(output clippingBounds insetBy: self deviceMargins) width		fontPolicy: output fontPolicy.	self outputComposedText: ct</body></methods><methods><class-id>Graphics.CharacterAttributes</class-id> <category>accessing</category><body package="Graphics-Fonts" selector="fontAt:for:">fontAt: aStyle for: aFontPolicy	"Answer a FontDescription corresponding to the style"	| query |	aStyle == nil		ifTrue: [^self defaultFontFor: aFontPolicy].	(query := self queryCacheAt: aStyle for: aFontPolicy ifAbsent: [nil]) == nil		ifFalse: [^query].	query := (self defaultFontFor: aFontPolicy) copy.	self apply: aStyle to: query with: nil for: aFontPolicy.	self queryCacheAt: aStyle for: aFontPolicy put: query.	^query</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>class initialization</category><body package="Graphics-Fonts" selector="initializeDefaults">initializeDefaults	"CharacterAttributes initializeDefaults"	| pragmas |	DefaultAttributes == nil		ifTrue: [DefaultAttributes := IdentityDictionary new].	DefaultAttributes keys copy do: [:key | DefaultAttributes removeKey: key].	pragmas := Pragma allNamed: #stylesWithOrder: in: self class.	pragmas := pragmas asSortedCollection: [:p1 :p2 |			(p1 argumentAt: 1) &lt;= (p2 argumentAt: 1)].	pragmas do: [:p |		self perform: p selector with: DefaultAttributes].	CharacterAttributes allGeneralInstancesDo: [:ca |		ca invalidateQueryCache].</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>images</category><body package="Graphics-Printing-PostScript" selector="copyArea:fromGraphicsMedium:sourceOffset:destinationOffset:">copyArea: aShape fromGraphicsMedium: aGraphicsMediumOrImage sourceOffset: srcOffsetPoint destinationOffset: destOffsetPoint 	"Copy an area of anImage to my display medium. The source 	area is described by aShape translated by srcOffsetPoint; the 	destination area is described by aShape translated by 	destOffsetPoint in my coordinate system."	| maskExtent mask maskGC |	(aShape isKindOf: Rectangle)		ifTrue: [^self copy				intersectClip: (aShape translatedBy: destOffsetPoint);				displayImage: aGraphicsMediumOrImage at: destOffsetPoint-srcOffsetPoint].	((aShape isKindOf: Image) and: [aShape paintBasis = CoverageValue])		ifTrue: [^self				copyMaskedArea: aShape				fromImage: aGraphicsMediumOrImage asImage				sourceOffset: srcOffsetPoint				destinationOffset: destOffsetPoint].	"Render aShape onto a Mask, then perform the copy."	maskExtent := aGraphicsMediumOrImage extent.	mask := Mask extent: maskExtent.	maskGC := mask graphicsContext.	self installDIGraphicsStateOn: maskGC.	maskGC		clippingRectangle: nil;		paint: CoverageValue opaque.	maskGC display: aShape at: srcOffsetPoint.	self		copyMaskedArea: mask asImage		fromImage: aGraphicsMediumOrImage asImage		sourceOffset: 0@0		destinationOffset: destOffsetPoint-srcOffsetPoint.	mask close.</body></methods><methods><class-id>Graphics.PostScriptGraphicsContext</class-id> <category>images</category><body package="Graphics-Printing-PostScript" selector="copyMaskedArea:fromImage:sourceOffset:destinationOffset:">copyMaskedArea: aShape fromImage: anImage sourceOffset: srcOffsetPoint destinationOffset: destOffsetPoint 	"Copy an area of aShape to my display medium. The source 	area is described by anImage translated by srcOffsetPoint; the 	destination area is described by anImage translated by 	destOffsetPoint in my coordinate system."	| shape |	shape := aShape asImage.	medium languageLevel = 3 		ifTrue: 			[self 				writeImage: anImage				maskedBy: shape				at: destOffsetPoint]		ifFalse: 			[| uniqueColorIndexes im2 |			uniqueColorIndexes := Set new.			anImage pixelsDo: 					[:x :y | 					(shape atX: x y: y) = 1 						ifTrue: [uniqueColorIndexes add: (anImage atX: x y: y)]].			uniqueColorIndexes do: 					[:p | 					im2 := anImage convertToCoverageWithOpaquePixel: p.					im2 						copy: im2 bounds						from: 0 @ 0						in: shape						rule: RasterOp and.					im2 bitsAreAllZero 						ifFalse: 							[(self copy)								paint: (anImage palette at: p);								displayMask: im2 at: destOffsetPoint]]]</body></methods><methods><class-id>Graphics.TextAttributes</class-id> <category>tabs and margins</category><body package="Graphics-Fonts" selector="useTabs:">useTabs: newTabsArray	"Change the tab stops used by this text style."	tabsArray := newTabsArray copy.	equalTabs := (tabsArray size &lt;= 2 or: [tabsArray = (tabsArray first to: tabsArray last by: tabsArray first)])	  ifTrue: [tabsArray first]	  ifFalse: [0].	tabsArePositions := false.</body></methods><methods><class-id>Graphics.TextAttributes class</class-id> <category>class initialization</category><body package="Graphics-Fonts" selector="default">default	"TextAttributes default"	^DefaultTextStyle copy</body></methods><methods><class-id>Graphics.TextAttributes class</class-id> <category>constants</category><body package="Graphics-Fonts" selector="styleNamed:">styleNamed: aSymbol	"Answer the style named aSymbol from the text style dictionary."	^(TextStyles at: aSymbol) copy</body></methods><methods><class-id>Graphics.TextAttributes class</class-id> <category>constants</category><body package="Graphics-Fonts" selector="styleNamed:ifAbsent:">styleNamed: aSymbol ifAbsent: aBlock	"Answer the style named aSymbol from the text style dictionary.	If the style is not in the dictionary, answer the result of	evaluating aBlock."	^(TextStyles at: aSymbol ifAbsent: aBlock) copy</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>displaying</category><body package="Graphics-Visual Objects" selector="displayOn:at:enabled:">displayOn: aGraphicsContext at: aPoint enabled: aBoolean 	aBoolean		ifFalse:  			[| copyGC |			copyGC := aGraphicsContext copy.			copyGC paint: SymbolicPaint hilite.			self displayOn: copyGC at: aPoint + (1 @ 1)].	self displayOn: aGraphicsContext at: aPoint</body></methods><methods><class-id>Graphics.EllipticalArc</class-id> <category>private</category><body package="Graphics-Geometry" selector="computeBounds">computeBounds	"Answer the Rectangle that minimally bounds the coordinate region used	by the receiver, independent of considerations such as line width."	(startAngle = 0 and: [sweepAngle = 360]) ifTrue: [^boundingBox copy].	^self class boundingRectangleForPoints: (self computePoints copyWith: boundingBox center).</body></methods><methods><class-id>Graphics.RasterOp</class-id> <category>copying</category><body package="Graphics-Support" selector="copyBits">copyBits	"Perform the movement of bits from one bitmap to another	described by the instance variables of the receiver."	| sx sy dx dy w h tempBitmap |	combinationRule = RasterOp paint		ifTrue: [^self paintBits].	dx := destX max: clipX.	dy := destY max: clipY.	sx := sourceX + dx - destX.	sy := sourceY + dy - destY.	w := width min: (clipX + clipWidth - dx).	h := height min: (clipY + clipHeight - dy).	halftone == nil ifTrue:		[^destination copyBitsStride: destStride width: destWidth atX: dx y: dy				from: source stride: sourceStride width: sourceWidth atX: sx y: sy				width: w height: h rule: combinationRule].	source == nil ifTrue:		[^destination tileBitsStride: destStride width: destWidth atX: dx y: dy				from: halftone stride: halftoneStride width: halftoneWidth				atX: dx - halftonePhaseX y: dy - halftonePhaseY				width: w height: h rule: combinationRule].	"Three-operand case."	(combinationRule = 0 or: [combinationRule = 10 or: [combinationRule = 15]]) ifTrue:		["no source necessary"		^destination copyBitsStride: destStride width: destWidth atX: dx y: dy				from: source stride: sourceStride width: sourceWidth atX: sx y: sy				width: w height: h rule: combinationRule].	combinationRule = 5 ifTrue: ["nop" ^self].	"If we can perform the raster operation in two stages without an intermediate	bitmap, do so."	(combinationRule = 1 or: [combinationRule = 2 or: [combinationRule = 3]]) ifTrue:		[^self copyBitsTwoStageRule1: combinationRule rule2: 1			destX: dx destY: dy sourceX: sx sourceY: sy			halftoneX: halftonePhaseX halftoneY: halftonePhaseY width: w height: h].	(combinationRule = 12 or: [combinationRule = 13 or: [combinationRule = 14]]) ifTrue:		[^self copyBitsTwoStageRule1: combinationRule rule2: 13			destX: dx destY: dy sourceX: sx sourceY: sy			halftoneX: halftonePhaseX halftoneY: halftonePhaseY width: w height: h].	"Use an intermediate bitmap for the AND of the source and halftone."	tempBitmap := source copy.	tempBitmap tileBitsStride: sourceStride width: sourceWidth atX: sx y: sy				from: halftone stride: halftoneStride width: halftoneWidth				atX: dx - halftonePhaseX y: dy - halftonePhaseY				width: w height: h rule: RasterOp and.	destination copyBitsStride: destStride width: destWidth atX: dx y: dy				from: tempBitmap stride: sourceStride width: sourceWidth atX: sx y: sy				width: w height: h rule: combinationRule</body></methods><methods><class-id>Graphics.SyntheticFont</class-id> <category>accessing</category><body package="Graphics-Fonts" selector="widthTable">widthTable	| widthTable w |	widths == nil		ifTrue:	[^baseFont widthTable].	widthTable := baseFont widthTable copy.	1 to: widthTable size do:		[ :i |		(w := widths at: i) == nil ifFalse: [widthTable at: i put: w]].	^widthTable</body></methods><methods><class-id>Graphics.SyntheticFont</class-id> <category>converting</category><body package="Graphics-Fonts" selector="withColor:">withColor: aColor	^self copy color: aColor</body></methods><methods><class-id>Graphics.SyntheticFont</class-id> <category>converting</category><body package="Graphics-Fonts" selector="withUnderline">withUnderline	^self copy underline: true</body></methods><methods><class-id>Graphics.SyntheticFont</class-id> <category>converting</category><body package="Graphics-Fonts" selector="withStrikeout">withStrikeout	^self copy strikeout: true</body></methods><methods><class-id>Graphics.DeviceFont</class-id> <category>displaying</category><body package="Graphics-Fonts" selector="displayCharacters:from:to:at:on:">displayCharacters: string from: start to: stop at: aPoint on: aGraphicsContext	"Render the string onto the graphicsContext"	| p char |	p := aPoint copy.	start to: stop do:		[:i |		char := string at: i.		char isInteger			ifTrue: [char := self decode: char].		self displayCharacter: char at: p on: aGraphicsContext.		p x: p x + (self widthOf: char)].</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>displaying</category><body package="Graphics-Support" selector="copyArea:fromImage:sourceOffset:destinationOffset:">copyArea: aShape fromImage: anImage sourceOffset: srcOffsetPoint destinationOffset: destOffsetPoint 	"Copy an area of anImage to my display medium. The source	area is described by aShape translated by srcOffsetPoint; the 	destination area is described by aShape translated by 	destOffsetPoint in my coordinate system."	| image gc |	image := paintPolicy representImage: anImage forMedium: medium.	(aShape isKindOf: Rectangle)		ifFalse: [^self copyCompleteArea: aShape					from: image asRetainedMedium graphicsContext					sourceOffset: srcOffsetPoint					destinationOffset: destOffsetPoint].	gc := self copy.	gc intersectClip: (aShape translatedBy: destOffsetPoint).	image bitsPerPixel = 1		ifTrue:			[gc				displayUninterpretedMonoImageBits: image				foreground: (medium palette indexOfPaintNearest: (image palette at: 1 ifAbsent: [self paint]))				background: (medium palette indexOfPaintNearest: (image palette at: 0 ifAbsent: [self paint]))				at: destOffsetPoint - srcOffsetPoint]		ifFalse: [gc displayUninterpretedImageBits: image at: destOffsetPoint - srcOffsetPoint]</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>accessing</category><body package="Graphics-Support" selector="clientData">clientData	"Answer a copy of the receiver's client-data dictionary. A copy, rather than 	the dictionary itself is returned because we take the position that clientData 	is immutable."	^clientData isNil		ifTrue: [IdentityDictionary new]		ifFalse: [clientData copy]</body></methods><methods><class-id>Graphics.CompositeFont</class-id> <category>displaying</category><body package="Internationalization" selector="displayCharacters:from:to:at:on:">displayCharacters: string from: start to: stop at: aPoint on: gc	"Render the string onto the graphicsContext."	| p |	p := aPoint copy.	start to: stop do:		[:index | | char |		char := string at: index.		self selectFontFor: char.		"Get aGraphicsContext to reinstall the currentFont."		gc font: self.		currentFont displayCharacter: char at: p on: gc.		p := (p x + (currentFont widthOf: char)) @ p y ]</body></methods><methods><class-id>Graphics.CompositeFont class</class-id> <category>utility</category><body package="Internationalization" selector="createFont:toResemble:for:">createFont: bestMatch toResemble: aFontDescription for: fontPolicy	"Return an instance of self with the font set described by aFontDescription."	| fonts encodings actualEncodings actualEncoders |	fonts := OrderedCollection new.	encodings := aFontDescription encodings.	actualEncodings := OrderedCollection new.	actualEncoders := OrderedCollection new.	encodings do:		[ :encoding | | font best fontDesc |			fontDesc := aFontDescription copy.			fontDesc encodings: nil.			fontDesc encoding: encoding.			(Locale current ignoreSerifEncodings includes: encoding) ifTrue: [fontDesc serif: nil].			best := fontPolicy findBestFont: fontDesc.			font := (fontPolicy fontClass				createFont: best				toResemble: fontDesc				on: fontPolicy graphicsDevice).			actualEncodings add: font encodingType.			actualEncoders add: font encoder.			fonts add: font].	^CompositeFont new 		with: fonts asArray		priorityTable: (self				getPriorityTableFor: actualEncodings asArray				from: actualEncoders asArray)</body></methods><methods><class-id>Graphics.OptimizedLineWidthInfoTable</class-id> <category>copying</category><body package="Graphics-Text Support" selector="postCopy">postCopy	"The receiver is a copy.  Copy the lines and widths."	super postCopy.	widths := widths copy</body></methods><methods><class-id>Graphics.OptimizedLineWidthInfoTable</class-id> <category>private</category><body package="Graphics-Text Support" selector="setLines:lastLine:">setLines: anArray lastLine: aNumber	"Set the lines and last line given by the arguments."	super setLines: anArray lastLine: aNumber.	widestLine := 0.	widths := anArray copy.</body></methods><methods><class-id>Graphics.TextMeasurer class</class-id> <category>class initialization</category><body package="Graphics-Text Scanning" selector="initialize">initialize	"Initialize the stop conditions."	"TextMeasurer initialize"	| array |	EndOfRun := -1.	CrossedX := -2.	NoStopConditions := StopsDictionary new.	StopConditions := StopsDictionary new.	StopConditions at: Character tab put: #tab.	StopConditions at: Character lf put: #cr.	"line feed"	StopConditions at: Character cr put: #cr.	"carriage return"	StopConditions at: Character newPage put: #cr.	"new page"	SpaceStopConditions := StopConditions copy.	SpaceStopConditions at: $  put: #space.	PaddedStopConditions := StopConditions copy.	PaddedStopConditions at: $  put: #paddedSpace.	CodeMaps := IdentityDictionary new.	array := WordArray new: 256.	array at: 1 put: 65535.	1 to: 255 do: [:i | array at: i+1 put: i].	CodeMaps at: #unmapped put: array.	FontEncodingTypeCache := nil.	StringEncodingTypeCache := nil.	StopsDictionaryCache := nil.	MapCache := nil.</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="reflectInYTo:">reflectInYTo: newImage	"Fill newImage with the result of reflecting the receiver	about the horizontal axis.  Answer newImage."	| row |	(newImage isLike: self) ifFalse: [self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	newImage == self ifTrue: [^self copy reflectInYTo: newImage].  "can't do in place"	row := self pixelArraySpecies new: self packedRowSize.	0 to: height - 1 do:		[:y |		self packedRowAt: y into: row.		newImage packedRowAt: height - 1 - y putAll: row].	^newImage</body></methods><methods><class-id>Graphics.Image</class-id> <category>accessing</category><body package="Graphics-Images" selector="bits">bits	"Answer a copy of my bitmap contents."	^bits copy</body></methods><methods><class-id>Graphics.Image</class-id> <category>editing utilitys</category><body package="Graphics-Images" selector="minimalStorageString">minimalStorageString	self depth = 1 ifTrue: [^self storeString].	^(self copy convertToPalette: (MappedPalette withColors: self uniqueColorValues asArray)) storeString</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="fillShapeAround:to:outlinedBy:">fillShapeAround: interiorPoint to: newImage outlinedBy: pixelValue	"Fill the interior of some outlined region with the given	pixel value, storing the result into newImage.  The	outlined region is delimited by an outline of pixels with the	given pixel value.  InteriorPoint marks a location in the	interior or the region.  A mark is placed at this point as a	seed, then the seed is smeared into a blob until there is no	change in the blob when it fills the region.  The receiver	must have a depth of one, so pixelValue must be 0 or 1."	| dirs previousSmear all cycle noChange mergeRule eraseRule clearRule |	(newImage isLike: self) ifFalse: [self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	depth = 1 ifFalse: [self error: (#errRequiresDepth &lt;&lt; #dialogs &gt;&gt; 'Shape filling requires image depth=1')].	newImage == self ifTrue: [^self copy fillShapeAround: interiorPoint to: newImage outlinedBy: pixelValue].  "can't do in place"	pixelValue = 0		ifTrue:			[mergeRule := RasterOp and.			eraseRule := RasterOp reverseUnder.			clearRule := RasterOp writeOnes]		ifFalse:			[pixelValue = 1				ifTrue:					[mergeRule := RasterOp under.					eraseRule := RasterOp erase.					clearRule := RasterOp writeZeros]				ifFalse: [self error: (#errShapeFilling &lt;&lt; #dialogs &gt;&gt; 'Shape filling requires pixelValue=0 or 1')]].	newImage == self ifTrue: [^self copy fillShapeAround: interiorPoint to: newImage outlinedBy: pixelValue].  "can't do in place"	all := self bounds.	newImage copy: all from: 0@0 in: newImage rule: clearRule.	newImage atPoint: interiorPoint put: pixelValue.		"Place a seed in the interior"	previousSmear := newImage copy.	dirs := Array with: 1@0 with: -1@0 with: 0@1 with: 0 @ -1.	cycle := 0.	[(cycle := cycle+1) \\ 4 = 0 and:   "check for no change every 4 smears"		[previousSmear copy: all from: 0@0 in: newImage rule: RasterOp reverse.		noChange := previousSmear bitsAreAllZero.		previousSmear copy: all from: 0@0 in: newImage rule: RasterOp over.		noChange]]		whileFalse: 			[dirs do:				[:dir |    "smear in each of the four directions"				newImage copy: all from: dir in: newImage rule: mergeRule.				"After each smear, trim around the region border"				newImage copy: all from: 0@0 in: self rule: eraseRule]].	newImage copy: all from: 0@0 in: self rule: mergeRule.	^newImage</body></methods><methods><class-id>Graphics.Image</class-id> <category>copying</category><body package="Graphics-Images" selector="postCopy">postCopy	" Copy any necessary instance variable	values after doing a shallowCopy.	Subclasses may extend this. "	super postCopy.	bits := bits copy</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="fillConvexShapeTo:outlinedBy:">fillConvexShapeTo: newImage outlinedBy: pixelValue	"Fill the interior of the outermost outlined region in the	receiver with the given pixel value, storing the	result into newImage.  The outlined region is delimited by an	outline of pixels with the given pixel value.  The outlined	region must not be concave by more than 90 degrees.  The	receiver must have a depth of one, so pixelValue must be	0 or 1."	| temp skew all mergeRule intersectRule |	(newImage isLike: self) ifFalse: [self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	depth = 1 ifFalse: [self error: (#errRequiresDepth &lt;&lt; #dialogs &gt;&gt; 'Shape filling requires image depth=1')].	pixelValue = 0		ifTrue:			[mergeRule := RasterOp and.			intersectRule := RasterOp under]		ifFalse:			[pixelValue = 1				ifTrue:					[mergeRule := RasterOp under.					intersectRule := RasterOp and]				ifFalse: [self error: (#errShapeFilling &lt;&lt; #dialogs &gt;&gt; 'Shape filling requires pixelValue=0 or 1')]].	newImage == self ifTrue: [^self copy fillConvexShapeTo: newImage outlinedBy: pixelValue].  "can't do in place"	all := self bounds.	newImage copy: all from: 0@0 in: self rule: RasterOp over.	temp := self copy.	skew := 1.	[skew &lt; width] whileTrue:		[newImage copy: all from: skew@0 in: newImage rule: mergeRule.		skew := skew+skew].	skew := 1.	[skew &lt; width] whileTrue:		[temp copy: all from: skew negated@0 in: temp rule: mergeRule.		skew := skew+skew].	newImage copy: all from: 0@0 in: temp rule: intersectRule.	temp copy: all from: 0@0 in: self rule: RasterOp over.	skew := 1.	[skew &lt; height] whileTrue:		[temp copy: all from: 0@skew in: temp rule: mergeRule.		skew := skew+skew].	newImage copy: all from: 0@0 in: temp rule: intersectRule.	temp copy: all from: 0@0 in: self rule: RasterOp over.	skew := 1.	[skew &lt; height] whileTrue:		[temp copy: all from: 0@skew negated in: temp rule: mergeRule.		skew := skew+skew].	newImage copy: all from: 0@0 in: temp rule: intersectRule.	^newImage</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="rotateByQuadrants:to:">rotateByQuadrants: quads to: newImage	"Fill newImage with a copy of the receiver	rotated clockwise by quads * 90 degrees.	quads = 0 means unchanged, 1 means clockwise 90 degrees, and so on.	Answer newImage."	| angle rotSize rotImage all destPt sourcePt sourceDelta destDelta rotOrigin mask temp |	newImage == self ifTrue: [^self copy rotateByQuadrants: quads to: newImage].  "can't do in place"	angle := quads bitAnd: 3.  "take angle mod 360 degrees"	angle = 0		ifTrue: [^newImage copy: self bounds from: 0@0 in: self rule: RasterOp over].   "null rotation"	angle = 2		ifTrue:			[newImage copy: self bounds from: 0@0 in: self rule: RasterOp over.			newImage reflectInXTo: newImage.			newImage reflectInYTo: newImage.			^newImage].  "two reflections does 180 degrees"	"Break the problem up into squares of size 2^N, and rotate them"	rotSize := (width min: height)   "minimum rotation size"				max: (64 min: (width max: height)).  "but faster if we do larger chunks"	rotSize := 2 raisedTo: ((rotSize-1) asFloat floorLog: 2)+1.  "force up to a power of 2"	(newImage isLike: self withExtent: self extent transpose) ifFalse:		[self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	rotImage := self copyEmpty: rotSize asPoint.	all := rotImage bounds.	sourcePt := 0@0.	width &gt;= height		ifTrue:			[sourceDelta := rotSize@0.			angle=1				ifTrue:					[destPt := 0@0.					destDelta := sourceDelta transpose.					rotOrigin := (rotSize-height)@0]				ifFalse:					[destPt := 0@(width-rotSize).					destDelta := (0@0) - sourceDelta transpose.					rotOrigin := 0@0]]		ifFalse:			[sourceDelta := 0@rotSize.			angle=1				ifTrue:					[destPt := (height-rotSize)@0.					destDelta := (0@0) - sourceDelta transpose.					rotOrigin := 0@0]				ifFalse:					[destPt := 0@0.					destDelta := sourceDelta transpose.					rotOrigin := 0@(rotSize-width)]].	mask := rotImage copyEmpty.	temp := rotImage copyEmpty.	(width max: height) - 1 // rotSize + 1 timesRepeat:		[rotImage copy: all from: sourcePt in: self rule: RasterOp over.		rotImage rotate2: angle mask: mask temp: temp.		newImage copy: (all translatedBy: destPt) from: rotOrigin in: rotImage rule: RasterOp over.		sourcePt := sourcePt + sourceDelta.		destPt := destPt + destDelta].	^newImage</body></methods><methods><class-id>Graphics.Image</class-id> <category>image processing</category><body package="Graphics-Images" selector="reflectInXTo:">reflectInXTo: newImage	"Fill newImage with the result of reflecting the receiver	about the vertical axis.  Answer newImage. "	| rop |	(newImage isLike: self) ifFalse: [self error: (#errIncompatibleDestiniation &lt;&lt; #dialogs &gt;&gt; 'Destination is incompatible with source')].	newImage == self ifTrue: [^self copy reflectInXTo: newImage].  "can't do in place"	rop := RasterOp		destinationImage: newImage		sourceImage: self		halftoneImage: nil		combinationRule: RasterOp over		destOrigin: 0 @ 0		sourceOrigin: 0 @ 0		halftonePhase: 0 @ 0		extent: 1 @ height		clipRect: (0@0 extent: self extent).	0 to: width - 1 do: [:x |		rop destX: width - 1 - x; sourceX: x; copyBits].	^newImage</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>copying</category><body package="Graphics-Geometry" selector="postCopy">postCopy	super postCopy.	origin := origin copy.	corner := corner copy</body></methods><methods><class-id>Graphics.AlphaCompositedImage</class-id> <category>utilities</category><body package="Graphics-Images" selector="masked:">masked: anotherAlphaCompositedImage	| copy newBits maskingBits |	copy := self copy.	newBits := copy image bitsInstVar.	maskingBits := anotherAlphaCompositedImage image bitsInstVar.	1 to: newBits size		by: 4		do: [:n | newBits at: n put: (newBits at: n) * (maskingBits at: n) // 255].	^copy</body></methods><methods><class-id>Graphics.AlphaCompositedImage</class-id> <category>accessing</category><body package="Graphics-Images" selector="disabled">disabled	"Return a copy of the receiver that will fade into the background by taking 33% of all of the alpha values."		| washedOutImage bits |	washedOutImage := image copy.	bits := washedOutImage bitsInstVar.	1		to: bits size		by: 4		do:			[:n | 			bits				at: n				put: (bits at: n) // 3].	^self class image: washedOutImage</body></methods><methods><class-id>Graphics.AlphaCompositedImage</class-id> <category>copying</category><body package="Graphics-Images" selector="postCopy">postCopy	image := image copy</body></methods><methods><class-id>Graphics.MSWindowsFont class</class-id> <category>utilities</category><body package="Graphics-Fonts" selector="createFont:toResemble:on:">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen	| encoder synthetic fName fd divider oneString zeroString |	encoder := OSSystemSupport concreteClass vmPreferredEncoding = #default				ifTrue: [self encoderNamed: concreteFontDescription encoding]				ifFalse: [UnicodeCharacterEncoder new].	divider := (#[16r7E] asStringEncoding: #default) first.	oneString := String with: $1 with: divider.	zeroString := String with: $0 with: divider.	fd := concreteFontDescription copy.	synthetic := concreteFontDescription pixelSize = 0.	synthetic := synthetic				or: [requestedFontDescription boldness &gt; 0.6						and: [concreteFontDescription boldness &lt; 0.6]].	synthetic := synthetic or: [requestedFontDescription italic].	synthetic := synthetic or: [requestedFontDescription underline].	synthetic := synthetic or: [requestedFontDescription strikeout].	synthetic		ifTrue: [| stream size boldValue isItalic |			size := concreteFontDescription pixelSize = 0						ifTrue: [requestedFontDescription pixelSize]						ifFalse: [concreteFontDescription pixelSize].			boldValue := requestedFontDescription specifiesBoldness						ifTrue: [requestedFontDescription boldness]						ifFalse: [requestedFontDescription name isString								ifTrue: [((requestedFontDescription name tokensBasedOn: $~) at: 3) asNumber										/ 1000.0]								ifFalse: [concreteFontDescription boldness]].			isItalic := requestedFontDescription specifiesItalic						ifTrue: [requestedFontDescription italic]						ifFalse: [requestedFontDescription name isString								ifTrue: [((requestedFontDescription name tokensBasedOn: $~) at: 4) asNumber &gt; 0]								ifFalse: [concreteFontDescription italic]].			stream := String new writeStream.			stream				nextPutAll: concreteFontDescription family;				nextPut: divider.			stream				print: size;				nextPut: divider.			stream				print: (boldValue &gt; 0.6 ifTrue: [700] ifFalse: [400]);				nextPut: divider.			stream nextPutAll: (isItalic ifTrue: [oneString] ifFalse: [zeroString]).			stream nextPutAll: (requestedFontDescription underline						ifTrue: [oneString]						ifFalse: [zeroString]).			stream nextPutAll: (requestedFontDescription strikeout						ifTrue: [oneString]						ifFalse: [zeroString]).			stream				nextPutAll: (self extractEncoding: concreteFontDescription name);				nextPut: divider.			stream nextPutAll: '0'.			fName := stream contents.			fd				boldness: (requestedFontDescription boldness &gt; 0.6							ifTrue: [0.7]							ifFalse: [0.5]);				italic: requestedFontDescription italic;				underline: requestedFontDescription underline;				strikeout: requestedFontDescription strikeout;				pixelSize: size;				name: fName]		ifFalse: [fName := concreteFontDescription name].	^(aScreen fontNamed: fName fromClass: self encoding: encoder)		setDescription: fd</body></methods><methods><class-id>Lens.LDMRelationsBody</class-id> <category>graph manipulation</category><body package="LDM-Framework" selector="closeAllFrom:side:">closeAllFrom: element side: side	"Close all the relationships from element for the given side. First get all the open relationships, then let the generator close those relationship. Then remove the relationships that are not connected to the focus (foa) and rebuild the graph view"	| clossable |	clossable := graph relationshipsFromElement: element side: side.	clossable keysAndValuesDo: [:rel :related | 		generator			userCloseRelationship: rel			from: element			to: related copy			side: side].	generator checkConnectivity: self foa. 	self rebuild</body></methods><methods><class-id>Lens.LDMBrowserModel</class-id> <category>private</category><body package="LDM-Framework" selector="updateAttributesFor:">updateAttributesFor: perspective 	"Arrange the attributes of the relationships in a dictionary so the access is faster. The attributes in the 	dictionary may be programatically changed, thus overriding the default defined in the perspective"	attributes := IdentityDictionary new.	perspective relDesc		do: 			[:rDesc | 			| rel |			rel := LDMRelationship at: (rDesc at: 1) asSymbol.			attributes at: rel put: rDesc copy]</body></methods><methods><class-id>Lens.LDMSelectionService</class-id> <category>accessing</category><body package="LDM-Framework" selector="selectedViews">selectedViews	"Answer the value for selectedViews"	^self getSelectedViews copy</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>displaying</category><body package="LDM-Framework" selector="displayOn:">displayOn: aGraphicsContext 	"Display each of the receiver's components. 	If the view is selected then use selection colors."	| clipBox aGC |	"aGraphicsContext class == CYPSGenerator ifTrue: [^self displayOnPs: aGraphicsContext]."	aGC := aGraphicsContext copy.	clipBox := aGC clippingBounds.	aGC paint: self foregroundColor.	1 to: components size		do: 			[:i | 			| component |			component := components at: i.			(component intersects: clipBox)				ifTrue: [component displayOn: aGC copy]]</body></methods><methods><class-id>Lens.LDMTransitiveClosureRel</class-id> <category>computing</category><body package="LDM-Framework" selector="relatedTo:">relatedTo: el 	"Starts with the set that results from applying one time the 	basicRelationship. Then applies it to all of the members in the set, 	as many times as required (it stops when the set doesn't grow any 	more elements ). Remember that here we are interested only in the 	relationship between the root and all the tree.	This computation can be quite expensive. The algorithm presented here is	completely general. A more specific solution for specific cases can be	implemented in the elements themselves"	| resultSet incrementSet |	resultSet := r1 relatedTo: el.	incrementSet := resultSet copy.	[incrementSet isEmpty]		whileFalse: 			[| newIncrementSet |			newIncrementSet := IdentitySet new.			incrementSet do: [:newEl | newIncrementSet addAll: (r1 relatedTo: newEl)].			incrementSet := IdentitySet new.			newIncrementSet do: [:newEl2 | (resultSet includes: newEl2)					ifFalse: 						[incrementSet add: newEl2.						resultSet add: newEl2]]].	^resultSet</body></methods><methods><class-id>Lens.LDMArrowView</class-id> <category>display box accessing</category><body package="LDM-Framework" selector="preferredBounds">preferredBounds	"Compute the preferredBounds for the receiver"	CachedBounds == nil		ifTrue: 			[| imageOff imageOn labelOff labelOn |			imageOff := offImage isNil						ifTrue: [0 @ 0]						ifFalse: [offImage preferredBounds extent].			imageOn := onImage isNil						ifTrue: [0 @ 0]						ifFalse: [onImage preferredBounds extent].			labelOff := (ComposedText withText: label style: LabelStyle) preferredBounds extent.			labelOn := (ComposedText withText: label asText copy allBold style: LabelStyle) preferredBounds extent.			CachedBounds := Rectangle origin: 0 @ 0 corner: (imageOff x + labelOff x max: imageOn x + labelOn x)							+ 0 @ ((imageOff y max: labelOff y)								max: (imageOn y max: labelOn y))].	^CachedBounds</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="translationsFromPostgres">translationsFromPostgres	"^an IdentityDictionary 	I return my session specific disctionary of translation blocks. Because different session may wish 	to translate thinfs differently, the blocks must be local to the session."	translationsFromPostgres isNil ifTrue: [translationsFromPostgres := self class translationsFromPostgres copy].	^translationsFromPostgres</body></methods><methods><class-id>Protocols.Struct</class-id> <category>copying</category><body package="Protocols-Common" selector="postCopy">postCopy	1 to: lastIndex do: [ :i | self basicAt: i put: (self basicAt: i) copy ]</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>overrides</category><body package="Store-Repository Access" selector="validateClassAndNameSpaceOverlaps:">validateClassAndNameSpaceOverlaps: queryBoolean	"Answer true if user validates class redefinitions."	| coll pname |	( coll := nameSpaces copy ) addAll: classes.     	coll do: 		[ :obj | |  action |		action := queryBoolean			ifTrue: 				[ | pkg message |				pkg := Registry containingPackageForSymbol: obj absoluteSymbol.				pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].				message := (#_1sIsAlreadyDefinedIn2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is already defined in &lt;2s&gt;')					expandMacrosWith: obj fullName with: pname.				Override overrideReplaceOrCancel: message 				]			ifFalse: 				[ pname = Registry nullPackageName 							ifTrue: [ #replace ] ifFalse: [ #override ].				].		action == #cancel  			ifTrue: [ ^false ].		action == #override			ifTrue: [ overrides add: ( obj -&gt; ( Override forClassOrNameSpace: obj ) ) ]		].	^true.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support" selector="removeDbs:">removeDbs: aCollectionOfDatabaseIdentifiers	"Removes anything associated with databases in aCollectionOfDatabaseIdentifiers	This is only reached through the switchDatabase operation, 	which is only available while logged in."		dbInfo copy keys do:		[:eachDatabaseInfoSymbol | 		(aCollectionOfDatabaseIdentifiers includes: eachDatabaseInfoSymbol) ifTrue:			[dbInfo size == 1 ifTrue: [self databaseInformationForOrCreate: DbRegistry dbIdentifier].			dbInfo removeKey: eachDatabaseInfoSymbol]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Tools-Blueprints" selector="propertyBlueprints">propertyBlueprints	| output propertiesWithoutVolitileKeys |	"AR #61875 this code was modified because it was pulling in a StoreBase prerequisite, which Tools-Blueprints is not allowed to do."	propertiesWithoutVolitileKeys := properties copy.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesWithoutVolitileKeys removeKey: each ifAbsent: [nil]].	output := Array new writeStream.	propertiesWithoutVolitileKeys keysAndValuesDo: 			[:propertyName :propertyValue |			| coercedValue |			propertyName = #version				ifFalse: 					[coercedValue := (propertyValue isKindOf: BlockClosure)								ifTrue: [propertyValue method getSource]								ifFalse: [propertyValue].					output nextPut: ((CodeComponentPropertyBlueprint new)								codeComponent: self;								key: propertyName;								value: coercedValue)]].	^output contents</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>resources</category><body package="Store-UI-Unloadables Support" selector="readOnlyCodeMenu">readOnlyCodeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyCodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#value: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#value: #selectEntireText ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>selector accessing</category><body package="PackageCategories" selector="classAndSelectorDo:">classAndSelectorDo: aBlock 	"For each pair of the class and its selectors and the meta class and its selectors	evaluate aBlock."	| actual |	actual := self actualClassMeta: false.	(self selectorsMeta: false) copy		do: [:selector | aBlock value: actual value: selector].	actual := self actualClassMeta: true.	(self selectorsMeta: true) copy		do: [:selector | aBlock value: actual value: selector]</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>data accessing</category><body package="PackageCategories" selector="classAndDataKeyDo:">classAndDataKeyDo: aBlock 	"For each pair of the class and its datakeys, evaluate aBlock."	| actual |	actual := self actualClass.	self dataKeys copy do: 		[ :dataKey | aBlock value: actual value: dataKey].</body></methods><methods><class-id>Store.PublishPundlesDialog</class-id> <category>private</category><body package="Store-UI" selector="culledPundles">culledPundles	| packages bundles |	packages := pundles select: #isPackage.	bundles := pundles select: #isBundle.	packages copy do:		[:eachPackage |		(bundles detect: [:eachBundle | eachPackage enclosingComponents includes: eachBundle] ifNone: [nil])			ifNotNil: [packages remove: eachPackage]].	bundles copy do:		[:each |		(bundles detect: [:eachBundle | each enclosingComponents includes: eachBundle] ifNone: [nil])			ifNotNil: [bundles remove: each]].	packages copy do:		[:each |		| count |		(count := packages occurrencesOf: each) &gt; 1 ifTrue: [count - 1 timesRepeat: [packages remove: each ifAbsent: [nil]]]].	bundles copy do:		[:each |		| count |		(count := bundles occurrencesOf: each) &gt; 1 ifTrue: [count - 1 timesRepeat: [bundles remove: each ifAbsent: [nil]]]].	^bundles, packages</body></methods><methods><class-id>Store.PackageModel</class-id> <category>overrides</category><body package="PackageCategories" selector="cleanUpOverrides">cleanUpOverrides	self overrides copy do:		[ :over | | obj |		( obj := over object ) == nil			ifFalse: 				[ ( ( over getSources: obj ) includes: self )					ifTrue: [ over silentlyRemove ]				].		].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-Component Support" selector="computeFullDiffsBetweenDBPackage:into:">computeFullDiffsBetweenDBPackage: aDBPackage into: diff 	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number2 since this method	is called with arguments reversed."	| coll1 coll2 |	"methods"	coll1 := aDBPackage methodsWithSource asSet.	coll2 := OrderedCollection new: coll1 size.	self methods 		do: [:method | coll1 remove: method ifAbsent: [coll2 add: method]].	"At this point coll1 contains methods that are only in aDBPackage	and coll2 methods that are only the receiver."	diff methodsSide: 2 put: coll2.	diff methodsSide: 1 put: coll1.	"data"	coll1 := aDBPackage data asSet.	coll2 := OrderedCollection new: coll1 size.	self data do: [:datum | coll1 remove: datum ifAbsent: [coll2 add: datum]].	"At this point coll1 contains data that are only in aDBPackage	and coll2 data that are only the receiver."	diff dataSide: 2 put: coll2.	diff dataSide: 1 put: coll1.	"namespaces"	coll1 := aDBPackage nameSpacesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self nameSpacesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff nameSpacesSide: 2 put: coll2.	diff nameSpacesSide: 1 put: coll1.	"classes"	coll1 := aDBPackage classesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self classesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff classesSide: 2 put: coll2.	diff classesSide: 1 put: coll1.	coll1 := aDBPackage metaclassesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self metaclassesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff metaSide: 2 put: coll2.	diff metaSide: 1 put: coll1.	self computeOverrideDiffsBetweenDBPackage: aDBPackage into: diff.	^diff</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="PackageCategories" selector="classesNamed:">classesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassDescriptor or ClassExtensionDescriptors."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self classesDefinedInPackage do: 		[ :cl | (names includes: cl absoluteName)				ifTrue: 				[ names remove: cl absoluteName.				selected add: cl				]		].	self metaclassesDefinedInPackage do: 		[ :cl | (names includes: cl absoluteName, ' class')			ifTrue: 				[names remove: cl absoluteName, ' class'.				selected add: cl]		].	names do: 		[ :nm|  selected add: ( ClassExtensionDescriptor fullName: nm meta: false ) ].	^selected</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="PackageCategories" selector="removeEmptyModels">removeEmptyModels	models copy do: 		[ :model | 		model isEmpty			ifTrue: [ self removeModel: model ]		]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="PackageCategories" selector="nameSpacesNamed:">nameSpacesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of NameSpaceDescriptor or NameSpacesExtensionDescriptors."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self nameSpacesDefinedInPackage do: 		[ :ns | (names includes: ns absoluteName)				ifTrue: 				[ names remove: ns absoluteName.				selected add: ns				]		].	names do: [:nm|  selected add: ((NameSpaceExtensionDescriptor new) fullName: nm; yourself)].	^selected</body></methods><methods><class-id>Store.PackageModel</class-id> <category>change set conversion</category><body package="PackageCategories" selector="copyModels:">copyModels: modelDictionary	"Deep copy the modelDictionary into the receiver."	"Meant for internal use only."	models := IdentityDictionary new.	modelDictionary keysAndValuesDo:		[ :key :value | models at: key put: value copy ].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing-browser</category><body package="PackageCategories" selector="allMethodsBut:">allMethodsBut: oldCollection 	"Answer an array. The first element has collection of methods that are 	defined in the backage but not in oldCollection. 	The second has method defined in oldColection but not in the package."	| coll newColl oldMethod |	coll := oldCollection copy.	newColl := List new.	self methods		do: 			[:method | 			oldMethod := coll detect: [:each | each sameAs: method]						ifNone: [nil].			oldMethod isNil				ifTrue: [newColl add: method]				ifFalse: [coll remove: oldMethod]].	^Array with: newColl with: coll</body></methods><methods><class-id>Store.PackageModel</class-id> <category>initialize-release</category><body package="PackageCategories" selector="release">release	models notNil 		ifTrue: [ models copy do: [ :model | self removeModel: model ] ].	models := IdentityDictionary new.	Registry removePackage: self</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="PackageCategories" selector="cleanse:">cleanse: warn	"Cleanse the component. Remove any class or method definitions	 that are no longer in the system, including the postLoadMethod."	| warnBlock |	warnBlock := [ :str | warn ifTrue: [ Transcript show: ((#nRemovingNonexistant1s &lt;&lt; #packages &gt;&gt; '&lt;n&gt;Removing non-existant &lt;1s&gt;') expandMacrosWith: str)  ] ].	models keys do:		[ :key |		 key asStrictReference isDefined			ifFalse: 				[ warnBlock value: key.				models removeKey: key. 				].		].	self extendedClassModels do:		[ :model | 		model classAndSelectorDo:			[ :cls :selector | 			cls compiledMethodAt: selector ifAbsent: 				[ warnBlock value: ((#x1s2s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt;')						expandMacrosWith: cls fullName						with: selector).				model removeSelector: selector meta: cls isMeta 				]			].		model classAndDataKeyDo:			[ :cls :key |			( cls includesDataKey: key )				ifFalse: [ warnBlock value: (cls fullName, '.', key).						model removeDataKey: key ]			]		].	self extendedNameSpaceModels do:		[ :model | 		model nameSpaceAndDataKeyDo:			[ :ns :key |			( ns includesDataKey: key )				ifFalse: [ warnBlock value: (ns fullName, '.', key).						model removeDataKey: key ]			]		].	models copy do:		[ :m | m isEmpty ifTrue: [ self removeModel: m ] ]</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>private</category><body package="Store-Merge Management" selector="asGeneralResolution">asGeneralResolution	| instance |	instance := self copy.	instance alternative: nil.	^instance</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>actions</category><body package="Store-UI" selector="updateFiles">updateFiles	| targetPundleModel fileDescriptions |	targetPundleModel := self specList first dbPundle.	fileDescriptions := targetPundleModel fileDescriptions.	self fileList do:		[:each |		each publish ifTrue:			[(fileDescriptions contains: [:eachFile | eachFile portableFilename asString = each name])				ifTrue:					[targetPundleModel removeFile: each name.					targetPundleModel addFile: each name]				ifFalse: [targetPundleModel addFile: each name]]].	fileDescriptions := targetPundleModel fileDescriptions copy.	fileDescriptions do:		[:each |		(self fileList anySatisfy: [:eachFile | eachFile name = each portableFilename asString]) ifFalse:			[targetPundleModel removeFile: each portableFilename asString]]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>utility</category><body package="Store-Component Support" selector="inspectChangeSet">inspectChangeSet		changeSet ifNil: [^Dialog warn: (#NoChangesFor1s &lt;&lt; #store &gt;&gt; 'No changes for &lt;1s&gt;' expandMacrosWith: dbIdentifier)].	changeSet inspectorClass		inspect: changeSet copy		label: (#ChangesFor1s &lt;&lt; #store &gt;&gt; 'Changes for &lt;1s&gt;' expandMacrosWith: dbIdentifier)</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>installation</category><body package="Atomic Compiling and Loading" selector="initializeBindings">initializeBindings	"Keep trying until there are either none to do, or the number to do doesn't change"	| workingBindings workingSize copyBindings |	bindingsToInitialize isEmpty ifTrue: [^self].	workingBindings := bindingsToInitialize copy.	copyBindings := workingBindings copy.	workingSize := -1.	[workingSize ~= workingBindings size and: [workingBindings notEmpty]] whileTrue:		[workingSize := workingBindings size.		workingBindings do:			[:each |			[each recompile.			each initialize.			each ifNotNil: [copyBindings remove: each]]				on: MessageNotUnderstood				do: [:exception | exception resume]].			workingBindings := copyBindings copy]</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-definition sorting</category><body package="Atomic Compiling and Loading" selector="sortedClasses">sortedClasses	| classes orderedClasses workingClasses names |	(classes := self loadingDictionaryClasses) isEmpty ifTrue: [^#()].	(Gathering for: (classes first package name), ' - Classes') started.	orderedClasses := OrderedCollection new: classes size.	workingClasses := classes copy.	[workingClasses isEmpty] whileFalse:		[names := (workingClasses collect: [:each | each longName]) asSet.		workingClasses copy do:			[:each |			(names contains: [:eachName | eachName = each superclassName]) ifFalse:				[orderedClasses add: each.				workingClasses remove: each]]].	loadingDictionary at: #classes put: orderedClasses.	(Gathering for: (classes first package name), ' - Classes') finished.	^orderedClasses</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>installation</category><body package="Atomic Compiling and Loading" selector="initializeClasses">initializeClasses	"Keep trying until there are either none to do, or the number to do doesn't change.	If there are any still unable to be initialized, go and raise MNU on each after setting doNotMarkClean to true"		| sortedClasses workingClasses packageDictionary workingSize |	classesToInitialize isEmpty ifTrue: [^self].	sortedClasses := SystemUtils sortForLoading: (classesToInitialize collect: [:each | each key]).	workingClasses := sortedClasses copy.	workingSize := -1.	[workingSize ~= sortedClasses size and: [sortedClasses notEmpty]] whileTrue:		[workingSize := sortedClasses size.		packageDictionary := Dictionary new.		self putClasses: sortedClasses intoDictionary: packageDictionary.		self installFromPackagesIn: packageDictionary removingFrom: workingClasses.		sortedClasses := workingClasses copy].	(self loadingDictionaryExtensionMethods select: [:each | each isMeta and: [each selector = #initialize]])		do:			[:each | 			[(self realFromShadow: each mclass) instanceBehavior postLoad: each packageModel]				on: InitializerFailedError , MessageNotUnderstood				do: [:exception | exception return: nil]].	workingClasses notEmpty		ifTrue:			[pundlesNeedPostInstallReconcile := true.			workingClasses				do:					[:each | 					[each postLoad: (Registry containingPackageForClass: each)]						on: InitializerFailedError						do: [:exception | exception resignalAs: MessageNotUnderstood new]]]</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-definition sorting</category><body package="Atomic Compiling and Loading" selector="sortedNamespaces">sortedNamespaces	| namespaces orderedNamespaces workingNamespaces names |	(namespaces := self loadingDictionaryNamespaces) isEmpty ifTrue: [^#()].	orderedNamespaces := OrderedCollection new: namespaces size.	workingNamespaces := namespaces copy.	[workingNamespaces isEmpty] whileFalse:		[names := workingNamespaces collect: [:each | each longName].		workingNamespaces copy do:			[:each |			(names contains: [:eachName | eachName = each ownerName]) ifFalse:				[orderedNamespaces add: each.				workingNamespaces remove: each]]].	loadingDictionary at: #namespaces put: orderedNamespaces.	^orderedNamespaces</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-compiling</category><body package="Atomic Compiling and Loading" selector="compilerMethodInShadow:orRealClassDefinesCompiler:">compilerMethodInShadow: aShadowClassOrMetaClass orRealClassDefinesCompiler: aClassOrMetaClass	| compilerMethod |	aShadowClassOrMetaClass ifNotNil: 		[aShadowClassOrMetaClass instanceBehavior == Object ifFalse:			[compilerMethod := aShadowClassOrMetaClass isMeta				ifTrue: 					[(aShadowClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: 						[(aShadowClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]				ifFalse: 					[(aShadowClassOrMetaClass class selectors includes: #compilerClass) ifTrue: 						[(aShadowClassOrMetaClass class compiledMethodAt: #compilerClass) copy]]]].	compilerMethod ifNotNil: [^compilerMethod].	aClassOrMetaClass ifNil: [^nil].	^aClassOrMetaClass isMeta		ifTrue: [(aClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]		ifFalse: [(aClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aClassOrMetaClass class compiledMethodAt: #compilerClass) copy]].</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-definition sorting</category><body package="Atomic Compiling and Loading" selector="sortedFullClasses">sortedFullClasses	| classes workingClasses names |	sortedFullClasses ifNotNil: [^sortedFullClasses].	(classes := self fullLoadClasses) isEmpty ifTrue: [^#()].	sortedFullClasses := OrderedCollection new: classes size.	workingClasses := classes copy.	[workingClasses isEmpty] whileFalse:		[names := workingClasses collect: [:each | each longName].		workingClasses copy do:			[:each |			(names contains: [:eachName | eachName = each superclassName]) ifFalse:				[sortedFullClasses add: each.				workingClasses remove: each]]].	^sortedFullClasses</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>actions</category><body package="Store-UI" selector="cancelChanges">cancelChanges	self targetedPundles list copy do:		[:each |		each blessingLevelNumber = -54 ifFalse: [self targetedPundles list remove: each]].	self enableApply</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="PackageCategories" selector="removeNonexistentComponents">removeNonexistentComponents	contentDescriptions copy do:		[ :descr |		descr == nil			ifFalse: 				[ descr component == nil					ifTrue: [ self removeComponentDescription: descr ]				]		].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>initialization</category><body package="Store-Component Support" selector="resetContentsFrom:">resetContentsFrom: aBundleConnectionInformation	"Make this database information adopt the parameter information's view of what pundles the bundle contains and in what order.  Since addComponentDescription: is lazy (does nothing if it is already there), the first statement only adds pundles we do not already have.  The second removes pundles which we have but which the newly loaded version does not have.  If the two content description collections are still not equal (content description equality only checks names) then we resort our pundle orders to match that of the (about-to-be) loaded pundle."	(self copy initializeContentsFrom: aBundleConnectionInformation)		contentDescriptions do: [:each | self addComponentDescription: each].	(contentDescriptions reject:		[:each | aBundleConnectionInformation contentDescriptions includes: each])			do: [:each | self removeComponentDescription: each].	contentDescriptions = aBundleConnectionInformation contentDescriptions ifFalse:		[self shouldTrackChanges ifTrue: [self addOtherChange: pundle structureMark].		Registry changedBundleStructure: self pundle.		SequenceableCollectionSorter			sort: contentDescriptions			using: [:a :b | (aBundleConnectionInformation contentDescriptions indexOf: a)						&lt; (aBundleConnectionInformation contentDescriptions indexOf: b)]].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>initialization</category><body package="PackageCategories" selector="initializeContentsFrom:">initializeContentsFrom: aBundleConnectionInformation	"Set up the initial contents from  an existing dbconnection."		contentDescriptions := 		( aBundleConnectionInformation contentDescriptions collect:			[ :desc | 			desc copy 				id: nil; 				dbIdentifier: dbIdentifier;				yourself 			] ) asList.	#{Store.DbRegistry} ifDefinedDo:			[ :reg |			fileDescriptions := aBundleConnectionInformation fileDescriptions collect:				[ :desc | 				desc copy 					dbTrace: nil; 					yourself 				].			].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="PackageCategories" selector="removeNonexistentComponentsRecursive">removeNonexistentComponentsRecursive	contentDescriptions copy do:		[ :descr | | comp |		descr == nil			ifFalse: 				[ ( comp := descr component ) == nil					ifTrue: [ self removeComponentDescription: descr ]					ifFalse: 						[ comp isBundle 							ifTrue: [ comp removeNonexistentComponentsRecursive ]						]				]		].</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>utility</category><body package="Store-Broker-Obsolete" selector="smalltalkWildcardToSql:">smalltalkWildcardToSql: aString	"Translates a smalltalk wild card string to a sql wildcard string."	"* becomes % and ? becomes _"	| string index |	string := aString copy.	[ ( index := string indexOfSubCollection: '*' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $% ].	[ ( index := string indexOfSubCollection: '?' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $_ ].	^string</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="PackageCategories" selector="cleanseModels:">cleanseModels: warn	"Check that all models exist - remove non-existant models and display a warning if warn is true."	| real undeclaredModel |	modelDictionary values copy do: 		[:models |		models first isNil			ifTrue: 				[[real := (models at: 2) actual] 					on: UnloadedObjectError					do: [:exception | modelDictionary removeKey: models second absoluteSymbol].				real isNil ifFalse: 					[modelDictionary removeKey: (models at: 2) absoluteSymbol.					2 to: models size do: 						[:index |						| model |						model := models at: index.						model fullClassSymbol: real absoluteSymbol.						self addModel: model]]]				ifFalse: 					[[models first actual] 						on: UnloadedObjectError						do: 							[:exception |							warn ifTrue: 								[Dialog warn: (#RemovingNonexistentC1s &lt;&lt; #packages &gt;&gt; 'Removing non-existent: &lt;1s&gt;'										expandMacrosWith: models first absoluteName)].						modelDictionary removeKey: models first absoluteSymbol]]].	undeclaredModel := modelDictionary at: #'Root.Smalltalk.Kernel.Undeclared' ifAbsent: [^self].	((undeclaredModel allButFirst: 1) select: [:each | each package = self nullPackage]) do:		[:each |		each dataKeys copy do: [:eachData | (Undeclared includesKey: eachData) ifFalse: [each removeDataKey: eachData]].		each dataKeys isEmpty ifTrue: [self removeModel: each named: #'Root.Smalltalk.Kernel.Undeclared']]</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>package partitioning</category><body package="PackageCategories" selector="unloadEmptyPackages">unloadEmptyPackages	"DANGER unprotected unloads"	"self unloadEmptyPackages"  	Registry allPackages copy do: 		[:pkg | pkg isCompletelyEmpty  ifTrue: [pkg doUnloadFromImage]].	Registry allBundles copy do: 		[ :bundle | 		bundle removeNonexistentComponents.		bundle isCompletelyEmpty   ifTrue: [ bundle doUnloadFromImage ]		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>unloading</category><body package="PackageCategories" selector="preUnloadChecksFromBundle:">preUnloadChecksFromBundle: aBundle 	| bundles bnames bundle components |	bundles := Registry enclosingComponentsFor: self.	aBundle notNil 		ifTrue: 			[ bundles remove: aBundle ifAbsent: nil.			components := aBundle allContainedItems				select: [ :c | c isBundle ].			bundles copy do: 				[ :b | ( components includes: b ) ifTrue: [ bundles remove: b ] ]			].	bnames := bundles collect: [ :b | b name ].	(self unloadProblemsQuery: bnames header: ((#UnloadingPackageWillModifySomeBundles &lt;&lt; #packages &gt;&gt; 'The package to be unloaded, "&lt;1s&gt;", is contained in the bundles&lt;2s&gt;listed below.  Proceeding will modify these bundles.')			expandMacrosWith: self name			with: (String with: Character cr)))		ifFalse: [^false].	bundle := aBundle == nil		ifTrue: [ self ]		ifFalse: [ aBundle ].	self contents reverseDo: 		[ :comp | 		comp notNil 			ifTrue: 				[ ( comp runPreUnloadFrom: bundle )					ifFalse: [ ^false ]				]		].	^true</body></methods><methods><class-id>Store.BundleModel</class-id> <category>content management</category><body package="PackageCategories" selector="addComponent:">addComponent: aComponentDescription	"Add a component to the receiver."	| changed |	changed := false.	self databaseInfomationOrCreate.	self databaseInformationsDo: 		[:eachDatabaseInformation |		changed := (eachDatabaseInformation addComponentDescription: aComponentDescription copy) or: [changed]].	(changed and: [self shouldTrackChanges]) ifTrue: 		[self addOtherChange: self structureMark.		Registry changedBundleStructure: self]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>content management</category><body package="PackageCategories" selector="anyContentDescriptions">anyContentDescriptions	"Answer a collection of pundle descriptors for any database connection"	dbInfo isEmpty		ifTrue: [ ^#( ) ].	dbInfo size &gt; 1 		ifTrue: [ 	dbInfo removeKey: self noDbSymbol ifAbsent: nil ].	^dbInfo values first contentDescriptions collect:		[ :desc |		desc copy			id: nil; 			dbIdentifier: nil;			yourself		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-Component Support" selector="anyFileDescriptions">anyFileDescriptions	"Answer a collection of file descriptors for any database connection"	dbInfo isEmpty ifTrue: [^OrderedCollection new].	dbInfo size &gt; 1 ifTrue: [dbInfo removeKey: self noDbSymbol ifAbsent: nil].	^dbInfo values first fileDescriptions collect: [:each | each copy dbTrace: nil]</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>notifications</category><body package="Store-Repository Access" selector="profileSelected">profileSelected	| profile name |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name] ifNone: [^self].	currentProfileHolder value: profile copy.	DbRegistry tablePrefix: profile tableOwner.	(StoreSettings preferenceModelFor: #tablePrefix) value: profile tableOwner</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>instantiating</category><body package="Store-Database Model" selector="instantiateAllOfPackage:requiredFor:">instantiateAllOfPackage: aPackage requiredFor: aPackageModel	"Trace everything that we will need in order to publish a new version, assuming the change set associated with aPackageModel is correct. aPackage should be the trace of aPackageModel and in the same database. Don't worry about getting rid of proxies, because we know this is being read from the current database"	| dbInfo methodList methodNames query parameters nonOptimizedQuery tempMethods batchOfMethodNames|	aPackageModel ifNil: [^self].	dbInfo := aPackageModel databaseInformationFor: aPackage session databaseIdentifier.	dbInfo isNil 		ifTrue: [methodList := #()]		ifFalse: [			dbInfo changeSet isEmpty ifTrue: [^self].			methodList := dbInfo changeSet modifiedMethodDescriptors].	(aPackage methods isGlorpProxy not or: [aPackage methods isInstantiated]) ifTrue: [		"We've already been read. Just go over the changed list of methods to make sure we haven't got any new ones"		self instantiateIndividualMethodsIn: aPackage requiredFor: aPackageModel.		^self].	parameters := aPackage methods parameters.	methodList isEmpty ifFalse: [		methodNames := methodList collect: [:eachMethodDescriptor | eachMethodDescriptor selector].		tempMethods := OrderedCollection new.		"Now we run a query to bring back methods with those names (this may bring back a few too many that haven't changed but have the same name, but that's OK). We really just want to bring these and their source into cache, but hold onto the collection against the off-chance it gets GCd"		1 to: methodNames size by: 100 do: [:i |			batchOfMethodNames := methodNames copyFrom: (i min: methodNames size) to: (i + 99 min: methodNames size).			query := ((aPackage session system descriptorFor: StorePackage) mappingForAttributeNamed: #methods) query copy.			query AND: [:each | each definition name in: batchOfMethodNames].			tempMethods add: (query executeWithParameters: parameters in: aPackage session)]].	"Now we force read the methods collection without any optimization as to what to bring back"	nonOptimizedQuery := ((aPackage session system descriptorFor: StorePackage) mappingForAttributeNamed: #methods) query copy.	nonOptimizedQuery tracing: nonOptimizedQuery defaultTracing.	nonOptimizedQuery alsoFetch: [:each | each definition].	aPackage privateSetMethods: (nonOptimizedQuery executeWithParameters: parameters in: aPackage session).	tempMethods yourself.	self instantiateEverythingButMethodsOf: aPackage.</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>private</category><body package="Store-Merge Management" selector="environmentOrderFor:">environmentOrderFor: aCollectionOfChangeResolvers	| orderedResolvers workingResolvers names workingSize |	orderedResolvers := OrderedCollection new: aCollectionOfChangeResolvers size.	workingResolvers := aCollectionOfChangeResolvers asOrderedCollection.	workingSize := -1.	[workingSize ~= workingResolvers size and: [workingResolvers notEmpty]] whileTrue:		[names := workingResolvers collect: [:each | each definitionName].		workingSize := workingResolvers size.		workingResolvers copy do:			[:each |			(names contains: [:eachName | '*.', eachName match: each ownerNameForLoadOrdering ignoreCase: false]) ifFalse:				[orderedResolvers add: each.				workingResolvers remove: each]]].	orderedResolvers addAll: workingResolvers.	^orderedResolvers</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>merge support</category><body package="Store-Merge Management" selector="makeResolutionProposals">makeResolutionProposals	"if the alternatives without the one (if any) associated with the base leaves precisely 	one alternative, that single alternative is the one that becomes the proposed alternative."		resolutions do: [:packageResolutions | packageResolutions makeResolutionProposals].	resolutions do: [:packageResolutions | packageResolutions removeEmptyResolvers].	self resolutions copy do:		[:each |		each resolutions isEmpty ifTrue: [resolutions removeKey: each name]].	self detectMoves.</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>accessing</category><body package="Store-Merge Management" selector="affectedBundles">affectedBundles	"Answer a collection of image bundles that were affected by applying modifications.	Meaning, that they have modifications that will be lost.	Make sure these are in semi-Hierarchy order... parents before their children, but siblings in any order	as long as each of their children is 'after' each one somewhere... 	We build this using add: and not addFirst, so the order at the end is reversed.	Given	A		B			C			D		E	First the empty children/build dictionary pass give us E D C, with the dictionary having A and B.	This is a simple optimization to not ever bother to add it to the lookup dictionary used later 	since we know that those with no children are 'before' all others.	Now, we go over the Dictionary keys, and make sure that nothing IN each is also in the remaining targets.	On the first pass, that makes sure B does go in, but A does not (since A contains B)	Finally, A gets added."		| targetBundles sortedBundles previousSize bundleDictionary |	targetBundles := (self bundleModels select: #hasBeenModified) asOrderedCollection.	sortedBundles := OrderedCollection new.	bundleDictionary := Dictionary new.	targetBundles copy do: 		[:each | 		| children |		children := (each contentDescriptions select: #isBundle) collect: #component.		children isEmpty			ifTrue: 				[targetBundles remove: each. 				sortedBundles add: each]			ifFalse: [bundleDictionary at: each put: children]].	previousSize := -1.	[targetBundles size &gt; 0 and: [previousSize ~= targetBundles size]] whileTrue:		[previousSize := targetBundles size.		bundleDictionary copy keysAndValuesDo:			[:eachBundle :containedBundles |			((bundleDictionary at: eachBundle) contains: [:eachChild | targetBundles includes: eachChild]) ifFalse:				[sortedBundles add: eachBundle. 				targetBundles remove: eachBundle. 				bundleDictionary removeKey: eachBundle]]].	sortedBundles addAll: targetBundles.	^sortedBundles reverse</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>private</category><body package="Store-Merge Management" selector="applyUnapplied:">applyUnapplied: aCollection	| errors clone currentChanges |	errors := false.	Refactory.Browser.RefactoryChangeManager undoSize: Refactory.Browser.RefactoryChangeManager undoSize + 1.	clone := Refactory.Browser.RefactoryChangeManager instance copy.	aCollection do: 		[:each | 		each apply			ifTrue: 				[each markApplied.				each undoValue ifNotNil: [:value | currentUndos add: value]]			ifFalse: [errors := true]].	Refactory.Browser.RefactoryChangeManager instance resetFrom: clone.	currentChanges := Refactory.Browser.CompositeRefactoryChange named: 		(#MergeChangesApplied1p &lt;&lt; #store &gt;&gt; 'Merge Actions Applied : &lt;1p&gt;' expandMacrosWith: Timestamp now).	currentUndos reverseDo: [:each | currentChanges addChange: each].	Refactory.Browser.RefactoryChangeManager instance addUndo: currentChanges.	^errors</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>database utility</category><body package="Store-Database Model" selector="allNamesMatching:inClassNamed:">allNamesMatching: aString inClassNamed: aClassName	"Wildcard search and select for methods that are in a class in the image"	| query session likeString |	likeString := aString copy replaceAll: $* with: $%.	session := StoreLoginFactory currentStoreSession.	query := Query		read: self		where: [:eachMethod | (eachMethod name like: likeString) AND: [eachMethod className = aClassName]].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query.</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>database utility</category><body package="Store-Database Model" selector="allNamesMatching:in:">allNamesMatching: aString in: aSessionOrNil		| session query likeString |	likeString := aString copy replaceAll: $* with: $%.	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name like: likeString].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	self resolutions do: [:each | each removeEmptyResolvers].	self resolutions copy do:		[:each |		each resolutions isEmpty ifTrue: [resolutions removeKey: each name ifAbsent: [nil]].		each isBundleStructureResolver and: [each alternatives isEmpty ifTrue: 			[resolutions size = 1 ifTrue: [resolutions := Dictionary new]]]]</body></methods><methods><class-id>Store.Glorp.PropertyResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	| newResolutions |	newResolutions := resolutions copy.	resolutions keysAndValuesDo:		[:key :value |		value alternatives isEmpty ifTrue: [newResolutions removeKey: key].		value applied ifTrue: [newResolutions removeKey: key]].	resolutions := newResolutions.</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopy">postCopy	super postCopy.	definition := definition copy.	comment := comment copy.</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="allNamesMatching:in:">allNamesMatching: aString in: aSessionOrNil		| session query likeString |	likeString := aString copy replaceAll: $* with: $%.	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name like: likeString].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>loading</category><body package="Store-Database Model" selector="loadFailedClasses:">loadFailedClasses: aCollection	aCollection copy do:		[:each |		each loadSourceDirect ifNotNil: [aCollection remove: each]]</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>converting</category><body package="Store-Database Model" selector="classesNamed:">classesNamed: aSetOfNames	"Convert aSetOfnames into a collection of StoreClassesInPackage"		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:each :other | each name &lt; other name].	self classes do:		[:each | 		(names includes: each absoluteName) ifTrue:			[names remove: each absoluteName.			selected add: each]].	names do: [:each | selected add: (ClassDescriptor fullName: each meta: false)].	^selected</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>private-utilities</category><body package="Store-Database Model" selector="superclassOrder:">superclassOrder: aCollectionOfStoreClasses	"Sort all of the classes in the list into a collection where no class is preceded by a subclass or 	by its metaclass. I cannot use method in SystemUtils since the classes are not in the image"		| workingCopy orderedClasses classNames |	workingCopy := aCollectionOfStoreClasses copy.	orderedClasses := OrderedCollection new.	[workingCopy isEmpty]		whileFalse:			[classNames := workingCopy collect: [:each | each absoluteName].			workingCopy copy do:				[:each | 				(each isPseudo not and: [classNames includes: each superclassName])					ifFalse:						[orderedClasses add: each.						workingCopy remove: each]]].	^orderedClasses</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	| newResolutions |	newResolutions := resolutions copy.	resolutions keysAndValuesDo:		[:key :value |		value alternatives isEmpty ifTrue: [newResolutions removeKey: key].		value applied ifTrue: [newResolutions removeKey: key]].	resolutions := newResolutions.</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="getState">getState	"Shadow browsers need to have their state initialized with the right environment 	(as do loaded ones until we provide a global access to loaded glorp store models).	Some environments are pundle environments, others are not. Only get pundles for those that are:"	| newState newEnvironment |	newState := super getState.	newEnvironment := environment.	environment isPundleEnvironemt ifTrue:		[newEnvironment := self environment copy.		newEnvironment setPundles: self pundles].	newState environment: newEnvironment.	^newState.</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>menus</category><body package="Store-UI" selector="openFilterDialog">openFilterDialog	&lt;menuItem: #(#FilterDots #store 'Filter...')		nameKey: #filterDialog		enablement: true		indication: nil		shortcutKeyCharacter: $F		shortcutModifiers: 8		menu: #(#Packages #Packages)		position: 30.1&gt;	(RepositoryFilterDialog openUsing: self pundleFilter) ifTrue: 		[pundleFilter := PundleFilter lastAppliedFilter copy.		self refreshListAndSelections]</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI" selector="implementorsOf:in:">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector asSymbol.	anEnvironment classesDo: 		[:class | 		| storeMetaClass |		((class includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: class]) 			ifTrue: [classDict at: class fullRootName put: selectors copy].		storeMetaClass := class isImageObject ifTrue: [class] ifFalse: [class storeMetaClass].		((storeMetaClass includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: storeMetaClass]) 			ifTrue: [metaDict at: storeMetaClass fullRootName put: selectors copy]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="recordForStructureTag:">recordForStructureTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there.	Unlike other 'records' for tag objects, we answer a tag with the package(pundle) being me"	^aTag copy		package: self; 		yourself</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>full classes</category><body package="Store-Database Model" selector="generateFullClasses">generateFullClasses	"We can't just gather up my sub component items, because there may be (multiple) extension methods	So what we do, is we we create our own dictionary and fill or combine as needed, careful to copy	things since each sub package keeps its own dictionary of items we don't want to munge"	| gatheredClasses |	gatheredClasses := Dictionary new.	self containedItems do: 		[:each |		each fullClasses keysAndValuesDo: 			[:key :value |			| currentClass |			currentClass := gatheredClasses at: key ifAbsent: [nil].			currentClass isNil				ifTrue: [gatheredClasses at: key put: value copy]				ifFalse: [currentClass addAllFrom: value]]].	^gatheredClasses</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>loading</category><body package="Store-Database Model" selector="downloadFiles">downloadFiles		| allFiles |	allFiles := self files copy.	(self leafItems collect: 		[:each | 		each isBundle			ifTrue: [each files]			ifFalse: [#()]]) do: 				[:each | allFiles addAll: each].	allFiles size &gt; 0 ifFalse: [^self].	(DownloadingFiles for: self) started.	Store.Policies filePolicy downloadFiles: allFiles.	(DownloadingFiles for: self) finished</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>loading</category><body package="Store-Database Model" selector="downloadFilesUsing:">downloadFilesUsing: aBundleCompilationResult		| allFiles |	allFiles := self files copy.	(self leafItems collect: 		[:each | 		each isBundle			ifTrue: [each files]			ifFalse: [#()]]) do: 				[:each | allFiles addAll: each].	allFiles size &gt; 0 ifFalse: [^self].	Store.Policies filePolicy downloadFiles: allFiles using: aBundleCompilationResult</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>store faking</category><body package="StoreForGlorpVWUI" selector="asPundleWithComponentDescriptions">asPundleWithComponentDescriptions	"Return a copy of ourselves that has actual store component descriptions instead of our entities. Used in e.g. initializeFromDB: to let Store put things back the way it thinks things ought to be, and not old onto any of our entities. This copy really won't work at all for most purposes. The bundles and packages aren't even going to be dictionaries"	| copy |	copy := self copy.	copy privateSetBundles: #().	copy privateSetPackages: (self pundles collect: [:each | each asComponentDescriptionForReal]).	copy privateSetFiles: (self files collect: [:each | each asComponentDescriptionForReal]).	^copy.</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="augmentTextFieldController:">augmentTextFieldController: aController	"Provide additional tuning of the text controller used in the '#text' widget (the widget where we display the selected object's printStrings)."		| menu copyItem |	aController		initializeMenuForCode;		autoAccept: false.	menu := aController menu copy.	copyItem := menu menuItemWithValue: #copySelection.	menu := Menu new.	menu addItem: copyItem.	aController menuHolder value: menu</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI" selector="fieldListMenu">fieldListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #fieldListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Inspect 					#defaultString: '&amp;Inspect' 					#catalogID: #menus ) 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Dive 					#defaultString: '&amp;Dive' 					#catalogID: #menus ) 				#nameKey: #dive 				#value: #dive ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Back 					#defaultString: '&amp;Back' 					#catalogID: #menus ) 				#nameKey: #back 				#value: #back 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #navigatePrevious ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#nameKey: #editSelectAll 				#value: #selectAllFields 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #selectFields ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#nameKey: #copy 				#value: #copySelection 				#enablementSelector: #canCopy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Refresh 					#defaultString: '&amp;Refresh' 					#catalogID: #menus ) 				#nameKey: #refresh 				#value: #refresh ) ) #(3 1 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>printing</category><body package="Store-Database Model" selector="fileOutMethodsOn:">fileOutMethodsOn: aSourceFileManager	| allMethods |	allMethods := self instanceMethods copy.	allMethods addAll: self classMethods.	allMethods do:		[:each | each fileOutSourceOn: aSourceFileManager]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="recordForPropertyTag:">recordForPropertyTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there.	Unlike other 'records' for tag objects, we answer a tag with the package(pundle) being me"		^(self properties includesKey: aTag property)		ifFalse: [nil]		ifTrue:			[(aTag copy)				package: self;				yourself]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="asPundleWithComponentDescriptions">asPundleWithComponentDescriptions	"I should never be sent!"	| copy |	copy := self copy.	^copy.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="Store-Database Model" selector="propertiesForFileOut">propertiesForFileOut	^self properties copy.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>reconciling</category><body package="Store-Database Model" selector="propertiesMatch">propertiesMatch	| previousProperties myProperties previousSize mySize |	self previous isNil ifTrue: [^false].	previousProperties := self previous properties copy.	Dialect volatilePropertyKeys do: [:each | previousProperties removeKey: each ifAbsent: []].	myProperties := self properties.	myProperties isNil ifTrue: [^previousProperties == myProperties].	myProperties keysAndValuesDo: [:eachKey :eachValue |		(self ignorableProperties includes: eachKey)			ifFalse: [				(previousProperties at: eachKey ifAbsent: [Object new]) = eachValue					ifFalse: [^false]]].	previousSize := 0.	previousProperties keysDo: [:eachKey | (self ignorableProperties includes: eachKey) ifFalse: [previousSize := previousSize + 1]].	mySize := 0.	myProperties keysDo: [:eachKey | (self ignorableProperties includes: eachKey) ifFalse: [mySize := mySize + 1]].	^mySize = previousSize.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="propertiesWithoutVolatileKeys">propertiesWithoutVolatileKeys	| propertiesCopy |	propertiesCopy := self properties copy.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesCopy removeKey: each ifAbsent: [nil]].	^propertiesCopy</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>private</category><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:notIn:olderThan:usingPundleFilter:">allVersionsInitiallyNamed: aString in: aSession notIn: aCollection olderThan: aTimeStamp usingPundleFilter: aPundleFilter	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order	with optional range of blessing(s) and date(s)"		| session query sameNamed otherNames oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString AND: each timestamp &lt;= aTimeStamp].	aPundleFilter applyFilterToQuery: query.	query orderBy: [:each | each timestamp descending].	sameNamed := session execute: query.	sameNamed isEmpty ifTrue: [^sameNamed].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed		inject: OrderedCollection new		into:			[:sum :each | 			(each parent notNil and: 				[each parent name ~= aString and: 				[(sum includes: each parent name) not and: 				[(aCollection includes: each parent name) not]]])					ifTrue: [sum add: each parent name].			sum].	^otherNames copy		inject: sameNamed copy		into:			[:sum :each | 			sum , (self 				allVersionsInitiallyNamed: each 				in: aSession 				notIn: aCollection , otherNames 				olderThan: oldestTimestamp 				usingPundleFilter: aPundleFilter)]</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>query utility</category><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:usingPundleFilter:">allVersionsInitiallyNamed: aString in: aSession usingPundleFilter: aPundleFilter	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order	with optional range of blessing(s) and date(s)"	| session query sameNamed otherNames result oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	aPundleFilter applyFilterToQuery: query.	query orderBy: [:each | each timestamp descending].	(sameNamed := session execute: query) isEmpty ifTrue: [^#()].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed 		inject: OrderedCollection new		into: 			[:sum :each |			(each parent notNil and: 				[each parent name ~= aString and: 					[(sum includes: each parent name) not]])					ifTrue: [sum add: each parent name].			sum].	result := otherNames 		copy inject: sameNamed copy		into: 			[:sum :each |			sum , (self 				allVersionsInitiallyNamed: each				in: aSession				notIn: ((otherNames copy) add: aString; yourself)				olderThan: oldestTimestamp				usingPundleFilter: aPundleFilter)].	^result sorted: [:each :other | each timestamp &gt; other timestamp]</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>private</category><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:notIn:olderThan:">allVersionsInitiallyNamed: aString in: aSession notIn: aCollection olderThan: aTimeStamp	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"		| session query sameNamed otherNames oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString AND: each timestamp &lt;= aTimeStamp].	query orderBy: [:each | each timestamp descending].	sameNamed := session execute: query.	sameNamed isEmpty ifTrue: [^sameNamed].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed		inject: OrderedCollection new		into:			[:sum :each | 			(each parent notNil and: [each parent name ~= aString and: [(sum includes: each parent name) not and: [(aCollection includes: each parent name) not]]])				ifTrue: [sum add: each parent name].			sum].	^otherNames copy		inject: sameNamed copy		into:			[:sum :each | 			sum , (self allVersionsInitiallyNamed: each in: aSession notIn: aCollection , otherNames olderThan: oldestTimestamp)]</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>query utility</category><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:">allVersionsInitiallyNamed: aString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query sameNamed otherNames result oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	(sameNamed := session execute: query) isEmpty ifTrue: [^#()].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed inject: OrderedCollection new into:		[:sum :each |		(each parent notNil and: [each parent name ~= aString and: [(sum includes: each parent name) not]])			ifTrue: [sum add: each parent name].		sum].	result := otherNames copy inject: sameNamed copy into:		[:sum :each |		sum, (self allVersionsInitiallyNamed: each in: aSession notIn: (otherNames copy add: aString; yourself) olderThan: oldestTimestamp)].	^result sorted: [:each :other | each timestamp &gt; other timestamp]</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI" selector="implementorsOf:in:">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector asSymbol.	anEnvironment classesDo: 		[:class | 		| storeMetaClass |		((class includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: class]) 			ifTrue: [classDict at: class fullRootName put: selectors copy].		storeMetaClass := class isImageObject ifTrue: [class] ifFalse: [class storeMetaClass].		((storeMetaClass includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: storeMetaClass]) 			ifTrue: [metaDict at: storeMetaClass fullRootName put: selectors copy]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopy">postCopy	super postCopy.	mainClass := mainClass copy.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>adding</category><body package="Store-Database Model" selector="addAllFrom:">addAllFrom: aStoreClassExtension	"We don't just add them all, since the values might be held onto, so we make a copy of our values	Just to make sure new values don't bleed into other owners.	Because of the possible existance of overrides, we do this the hard way. Overriden (last) gets priority"	| newMethods |	newMethods := OrderedSet withAll: aStoreClassExtension classMethods.	newMethods addAll: classMethods.	classMethods := newMethods.	newMethods := OrderedSet withAll: aStoreClassExtension instanceMethods.	newMethods addAll: instanceMethods.	instanceMethods := newMethods.	sharedVariables := sharedVariables copy. 	sharedVariables addAll: aStoreClassExtension sharedVariables.	(classDefinition isNil and: [aStoreClassExtension classDefinition notNil])		ifTrue: [classDefinition := aStoreClassExtension classDefinition].	metaclass := StoreMetaclassExtension on: self</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource		| allMethods |	self classDefinition ifNotNil: [self classDefinition loadSource].	allMethods := self instanceMethods copy.	allMethods addAll: self classMethods.	allMethods do: [:each | each loadSource].	self sharedVariables do: [:each | each loadSource].</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopy">postCopy	super postCopy.	instanceMethods := instanceMethods copy.	classMethods := classMethods copy.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private</category><body package="Store-Merge Management" selector="environmentOrderFor:">environmentOrderFor: aCollectionOfChangeResolvers	| orderedResolvers workingResolvers names workingSize |	orderedResolvers := OrderedCollection new: aCollectionOfChangeResolvers size.	workingResolvers := aCollectionOfChangeResolvers asOrderedCollection.	workingSize := -1.	[workingSize ~= workingResolvers size and: [workingResolvers notEmpty]] whileTrue:		[names := workingResolvers collect: [:each | each definitionName].		workingSize := workingResolvers size.		workingResolvers copy do:			[:each |			(names contains: [:eachName | '*.', eachName match: each ownerNameForLoadOrdering ignoreCase: false]) ifFalse:				[orderedResolvers add: each.				workingResolvers remove: each]]].	orderedResolvers addAll: workingResolvers.	^orderedResolvers</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private</category><body package="Store-Merge Management" selector="resolveToText">resolveToText	selectedResolution isNil 		ifTrue: [self packageSelectionChanged]		ifFalse: 			[| packageModel resolution textController parseSucceeded | 			selectedResolution isApplyable ifFalse: [^self packageSelectionChanged].			selectedResolution isResolver ifFalse: [^self packageSelectionChanged].			packageModel := self packageForAccept.			packageModel isNil ifTrue: [^self packageSelectionChanged].			textController := (self builder componentAt: #displayTextID) widget controller.			Policies packagePolicy 				forcePackage: packageModel 				while: [parseSucceeded := selectedResolution parseText: textController text].			parseSucceeded ifFalse: [^self packageSelectionChanged].			self text: textController text copy.			resolution := UserInputResolution				forPackage: packageModel				text: textController text copy.			selectedResolution isMethodResolver ifTrue:				[resolution protocol: (self protocolStringOfSelectedResolutionFrom: self currentResolutionPackageItem)].			selectedResolution addAlternative: resolution.			selectedResolution proposed: resolution.			selectedResolution applied: false.			selectedResolution isMove ifTrue: 				[selectedResolution movePair movePair: nil.				selectedResolution movePair: nil].			self updateResolutionsWithoutRebuild]</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>accessing</category><body package="Store-Database Model" selector="newVersion">newVersion	| copy |	copy := self copy.	copy previous: self.	^copy</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	| newResolutions |	newResolutions := resolutions copy.	resolutions keysAndValuesDo:		[:key :value |		value isProposedRemovalNotInPackage ifTrue: [newResolutions removeKey: key ifAbsent: [nil]].		value alternatives isEmpty ifTrue: [newResolutions removeKey: key ifAbsent: [nil]].		value applied ifTrue: [newResolutions removeKey: key ifAbsent: [nil]]].	resolutions := newResolutions.</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>resources</category><body package="Store-UI" selector="textMenu">textMenu	"Tools.MenuEditor new openOnClass: self andSelector: #textMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#nameKey: #copySelection 				#value: #copySelection 				#enablementSelector: #atLeastOnePundleVersionSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #find 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #findNext 				#value: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAll 					#defaultString: 'Select All' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #selectEntireText 				#value: #selectEntireText ) ) #(1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>action</category><body package="Atomic Compiling and Loading" selector="retryUnloadablesFor:">retryUnloadablesFor: aCompilationResult	"A bit of recursion... If the result is for bundle, we recurse in until they are for individual packages"	aCompilationResult isForBundle ifTrue: [^aCompilationResult results do: [:each | self retryUnloadablesFor: each]].	aCompilationResult unloadableDefinitions copy do:		[:each | 		| packageModel |		packageModel := each parameter package			ifNil: [aCompilationResult package storeModel]			ifNotNil: [:value | value storeModel].		([each parameter loadSourceInto: packageModel]			on: Error			do: [:exception | exception return]) ifNotNil:				[:value | 				(each parameter isForMethod and: [each parameter isMeta and: [each parameter selector = #initialize]])					ifTrue: [each parameter correspondingImageClass instanceBehavior postLoad: packageModel].				aCompilationResult unloadableDefinitions remove: each]].	aCompilationResult unloadableDefinitions isEmpty ifTrue: [aCompilationResult pundle storeModel markNotModified]</body></methods><methods><class-id>XML.SAXBuilderDriver</class-id> <category>content handler</category><body package="XML" selector="startElement:localName:qName:attributes:">startElement: namespaceURI localName: localName qName: name attributes: attributes	| nm |	document == nil ifTrue: [self startDocument].	nm := NodeTag new		qualifier: ((name includes: $:)				ifTrue: [name copyUpTo: $:]				ifFalse: [''])		ns: namespaceURI		type: localName.	elementStack addLast: (SAXElementContext new tag: nm).	elementStack last		attributes: (attributes collect: [:att | att copy]);		nodes: OrderedCollection new;		namespaces: newNamespaces.	newNamespaces := nil.	builder pushTag: nm.</body></methods><methods><class-id>XML.ChoicePattern</class-id> <category>copying</category><body package="XML" selector="postCopy">postCopy	super postCopy.	items := items collect: [:i | i copy].</body></methods><methods><class-id>XML.ModifiedPattern</class-id> <category>copying</category><body package="XML" selector="postCopy">postCopy	super postCopy.	node := node copy</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>private</category><body package="XML-source" selector="selectorFor:">selectorFor: aTag	^selectors at: aTag ifAbsentPut:			[| t |			t := aTag type copy replaceAll: $: with: $_.			t replaceAll: $. with: $_.			t replaceAll: $- with: $_.			('compile_', t, ':') asSymbol]</body></methods><methods><class-id>XML.SequencePattern</class-id> <category>copying</category><body package="XML" selector="postCopy">postCopy	super postCopy.	items := items collect: [:i | i copy].</body></methods><methods><class-id>XML.MixedPattern</class-id> <category>copying</category><body package="XML" selector="postCopy">postCopy	super postCopy.	items := items collect: [:i | i copy].</body></methods><methods><class-id>XML.AttributeType</class-id> <category>validating</category><body package="XML" selector="simpleValidateValueOf:for:">simpleValidateValueOf: anAttribute for: aParser	| v |	v := anAttribute value copy.	v replaceAll: Character cr with: Character space.	v replaceAll: Character lf with: Character space.	v replaceAll: Character tab with: Character space.	anAttribute value: v</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>private</category><body package="XML-source" selector="selectorFor:">selectorFor: aTag	^selectors at: aTag ifAbsentPut:			[| t |			t := aTag type copy replaceAll: $: with: $_.			t replaceAll: $. with: $_.			t replaceAll: $- with: $_.			('scan_', t, ':') asSymbol]</body></methods><methods><class-id>XML.SAXCanonicalWriter</class-id> <category>private</category><body package="XML" selector="emitNotation:">emitNotation: array	| sysID frag |	sysID := array at: 3.	sysID == nil ifTrue: [^super emitNotation: array].	sysID size to: 2 by: -1 do: [:i |		frag := sysID copyFrom: i to: sysID size.		frag replaceAll: $: with: $/.		frag replaceAll: $\ with: $/.		([(baseURI resolvePath: frag) asString = sysID] on: Error do: [:x | x return: false])			ifTrue: [^super emitNotation: (array copy at: 3 put: frag; yourself)]].	super emitNotation: array</body></methods><methods><class-id>XML.DocumentType</class-id> <category>printing</category><body package="XML" selector="printCanonicalOn:">printCanonicalOn: aStream	"Jumping through hoops to get Notations printed	just as Sun desires--Are public IDs really supposed	to have their white space normalized? If so, we	should move normalization to the parser."	| s s1 |	notations isEmpty ifTrue: [^self].	aStream nextPutAll: '&lt;!DOCTYPE ';		nextPutAll: declaredRoot asString;		nextPutAll: ' ['; cr.	(notations asSortedCollection: [:n1 :n2 | n1 name &lt; n2 name])		do: [:n |			aStream nextPutAll: '&lt;!NOTATION ';				nextPutAll: n name; space.			n publicID == nil				ifTrue: [aStream nextPutAll: 'SYSTEM']				ifFalse:					[s := n publicID copy.					s replaceAll: Character cr with: Character space.					s replaceAll: Character lf with: Character space.					s replaceAll: Character tab with: Character space.					[s1 := s copyReplaceAll: '  ' with: ' '.					s1 = s] whileFalse: [s := s1].					aStream						nextPutAll: 'PUBLIC ''';						nextPutAll: s;						nextPut: $'].			n systemID == nil				ifFalse: [aStream						nextPutAll: ' ''';						nextPutAll: n systemID;						nextPut: $'].			aStream nextPutAll: '&gt;'; cr].	aStream nextPutAll: ']&gt;'; cr.</body></methods><methods><class-id>Core.StringParameterSubstitution</class-id> <category>accessing</category><body package="Collections-Text" selector="map:using:">map: descriptionCharacter using: aTwoArgBlock	"Store the mapping between a character and the block	that describes how to transform an argument into a substring.	The block takes two arguments--the transformer (i.e., the	reciever), and the index of the argument to be rendered.	We copy the mapping table before modifying it, so that	other instances that share the same table won't be side-	effected by the change."	argumentTypeMapping := argumentTypeMapping copy.	argumentTypeMapping at: descriptionCharacter put: aTwoArgBlock</body></methods><methods><class-id>Core.StringParameterSubstitution class</class-id> <category>defaults</category><body package="Collections-Text" selector="default">default	^Default copy</body></methods><methods><class-id>Core.IntegerArray</class-id> <category>external copying</category><body package="Collections-Arrayed" selector="copyToHeap:">copyToHeap: mallocSelector 	"Copy the receiver to the external heap. The argument is a method 	selector that accepts one argument and determines how to allocate 	data for the receiver -- it is typically one of #malloc: or #malloc16:. 	The selector's argument is the number of objects of the receiver's 	baseCType to allocate. Answer a pointer to the data. If the allocation 	fails a primitive failed signal is raised."	| aPointer currentPointer size |	aPointer := self baseCType referentType perform: mallocSelector with: self basicSize.	currentPointer := aPointer copy.	size := self size.	1 to: size		do: 			[:index | 			currentPointer contents: (self at: index).			currentPointer += 1].	^aPointer</body></methods><methods><class-id>Core.RunArray</class-id> <category>copying</category><body package="Collections-Arrayed" selector=",">, aRunArray	"Answer a new RunArray that is a concatenation of the receiver and	aRunArray. "	| new copySize newRuns newValues index |	(aRunArray isKindOf: RunArray)		ifFalse:			[new := self copy.			"attempt to be sociable"			aRunArray do: [:each | new addLast: each].			^new].	runs size = 0 ifTrue: [^aRunArray copy].	aRunArray runs size = 0 ifTrue: [^self copy].	"Compute size of runs/values in result."	copySize := runs size + aRunArray runs size.	(values last = aRunArray values first) ifTrue:		["runs at boundary will be merged"		copySize := copySize - 1].	newRuns := Array new: copySize.	newValues := Array new: copySize.	"copy self into result"	index := self				copyFromRun: 1				offset: 0				toRun: runs size				offset: runs last - 1				intoRuns: newRuns				values: newValues				startingAt: 1.	"copy argument into result"	aRunArray		copyFromRun: 1		offset: 0		toRun: aRunArray runs size		offset: aRunArray runs last - 1		intoRuns: newRuns		values: newValues		startingAt: index.	^self class runs: newRuns values: newValues</body></methods><methods><class-id>Core.RunArray</class-id> <category>enumerating</category><body package="ExternalWebBrowser-Text" selector="collect:">collect: aBlock	"Assume that the result is to have the same run layout as the reciever and visit the value for each span only once."	^self class		runs: runs copy		values: (values collect: aBlock)</body></methods><methods><class-id>Core.RunArray</class-id> <category>copying</category><body package="Collections-Arrayed" selector="postCopy">postCopy	super postCopy.	runs := runs copy.	values := values copy</body></methods><methods><class-id>Core.LaggedFibonacciRandom</class-id> <category>copying</category><body package="Magnitude-Numbers" selector="postCopy">postCopy	"The values need to be copied because if not copies	can affect the behavior of the original object after	sufficient values are answered"	super postCopy.	self values: self values copy</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>private</category><body package="Internationalization" selector="accessInputForToken:usingLiteralPossibilities:fromStream:">accessInputForToken: token usingLiteralPossibilities: outputPossibilities fromStream: workStream	"Answers the inputString derived, or nil if not possible to answer a value."	"If we have multiple match possibilities, we want to take the one closest to our location in the stream."	| matchDictionary lowestValue inputString match keepKey keyValue |	match := false.	matchDictionary := Dictionary new.	outputPossibilities do: 			[:eachValue |			| matchLocation aString |			aString := workStream copy contents.			matchLocation := aString indexOfSubCollection: eachValue						startingAt: workStream position + 1.			matchLocation &gt; 0				ifTrue: 					[(aString copyFrom: matchLocation to: matchLocation + eachValue size - 1)						= eachValue							ifTrue: 								[match := true.								matchDictionary at: eachValue copy put: matchLocation + 0]]].	match		ifFalse: [self propertyAt: #withoutAnomalies put: false]		ifTrue: 			[lowestValue := nil.			matchDictionary keysAndValuesDo: 					[:key :value |					lowestValue isNil						ifTrue: [lowestValue := value]						ifFalse: [value &lt; lowestValue ifTrue: [lowestValue := value]]].			"Exclude shorter matches at duplicated locations as substrings found in error."			matchDictionary copy keysAndValuesDo: 					[:key :value |					value = lowestValue						ifTrue: 							[keepKey isNil								ifTrue: [keepKey := key]								ifFalse: [key size &gt; keepKey size ifTrue: [keepKey := key]]]].			lowestValue = (workStream position + 1)				ifTrue: 					[keyValue := keepKey.					inputString := workStream next: keyValue size.					inputString = keyValue						ifFalse: 							[match := false.							self propertyAt: #withoutAnomalies put: false]]].	^inputString</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>reading Locale</category><body package="Internationalization" selector="readLocaleDataOfType:for:">readLocaleDataOfType: aSymbol for: aStream	"Values expected for aSymbol are: 	#time 	#date 	#stamp"	"Depending upon the type of object request, 	this method answers either a Time, a Date, or a Timestamp."	| policy fieldNumber policyStream delimiterToken weekday month day year hour minute second millisecond ampm createdDate createdTime createdTimestamp aStreamPosition offsetFromUTC |	aStreamPosition := aStream position.	self propertyAt: #withoutAnomalies put: true.	#(#custom #full #long #medium #short #editing #timeEditing #iso8601 #iso8601Enhanced)		do: 			[:policyFormatNameSymbol |			| workStream |			weekday := month := day := year := hour := minute := second := millisecond := createdDate := createdTime := createdTimestamp := nil.			workStream := aStream copy.			workStream position: aStreamPosition.			policy := printPolicy policyNamed: policyFormatNameSymbol ifAbsent: [nil].			policy isNil				ifTrue: [self propertyAt: #withoutAnomalies put: false]				ifFalse: 					[self propertyAt: #withoutAnomalies put: true.					aSymbol == #stamp ifTrue: [fieldNumber := 1].					aSymbol == #date ifTrue: [fieldNumber := 2].					aSymbol == #time ifTrue: [fieldNumber := 3].					policy := printPolicy fieldFormat: fieldNumber for: policy.					policy notNil						ifTrue: 							[policy := self groomPolicy: policy.							"policy := policy copyWithoutWhitespace."							policyStream := policy readStream.							self propertyAt: #withoutAnomalies put: true.							second := 0.							millisecond := 0.							policyStream do: 									[:token |									| isAlphameric isNumeric outputPossibilities inputString |									inputString := nil.									(self propertyAt: #withoutAnomalies)										ifTrue: 											[delimiterToken := nil.											outputPossibilities := OrderedCollection new.											(token isKindOf: PrintFormatToken)												ifTrue: 													["First find out what kind of output this token generates."													isAlphameric := false.													isNumeric := false.													isNumeric := #($y $Y $b $w $f $d $j $G $a $i $h $k $l $m $s $n $c $u)																includes: token selectorCharacter.													isNumeric														ifFalse: [isAlphameric := #($B $A $p) includes: token selectorCharacter].													"If output is generated from a set of possibilities, look at that set for matching."													(printPolicy tokenInterpretationDispatchTable at: token selectorCharacter)														value: token														value: outputPossibilities.													outputPossibilities isEmpty														ifFalse: 															[(#($r) includes: token selectorCharacter)																ifFalse: 																	[inputString := self																				accessInputForToken: token																				usingLiteralPossibilities: outputPossibilities																				fromStream: workStream]																ifTrue: 																	[inputString := self																				accessInputForToken: token																				usingSymbolicPossibilities: outputPossibilities																				fromStream: workStream].	"Time zone offsets have multiple wildcarded formats."															(self propertyAt: #withoutAnomalies)																ifTrue: 																	["The days of the week and the months of the year may come from lists."																	(#($r) includes: token selectorCharacter)																		ifTrue: [offsetFromUTC := inputString copy].																	(#($A $a) includes: token selectorCharacter)																		ifTrue: [weekday := inputString copy].																	(#($b $B) includes: token selectorCharacter)																		ifTrue: [month := inputString copy].																	token selectorCharacter = $p ifTrue: [ampm := inputString copy]]]														ifTrue: 															["output possibilities is empty..."															"Then find out what delimits this token's output."															policyStream atEnd																ifFalse: 																	[delimiterToken := policyStream peek	"Read workStream up to this marker."]																ifTrue: [delimiterToken := nil	"End of stream"].															delimiterToken notNil																ifTrue: 																	[(delimiterToken isKindOf: PrintFormatToken)																		ifFalse: 																			["Then read workStream to see if current content matches our expectations."																			inputString := workStream upTo: delimiterToken.																			workStream position - 1 &gt; 0																				ifTrue: [workStream skip: -1]																				ifFalse: [self propertyAt: #withoutAnomalies put: false].																			"If the content type does not match that of the format, this is an 									anomaly."																			(isNumeric and: [(self isStringNumeric: inputString) not])																				ifTrue: [self propertyAt: #withoutAnomalies put: false].																			(self propertyAt: #withoutAnomalies)																				ifTrue: 																					[(#($d $j $f $G) includes: token selectorCharacter)																						ifTrue: [day := inputString copy].																					(#($y $Y $u) includes: token selectorCharacter)																						ifTrue: [year := inputString copy].																					(#($i $h $k $l) includes: token selectorCharacter)																						ifTrue: [hour := inputString copy].																					(#($m) includes: token selectorCharacter)																						ifTrue: [minute := inputString copy].																					(#($s) includes: token selectorCharacter)																						ifTrue: [second := inputString copy].																					(#($n $c) includes: token selectorCharacter)																						ifTrue: 																							[aSymbol = #stamp																								ifTrue: [millisecond := inputString copy]																								ifFalse: [workStream skip: (inputString size + 1) * -1]].																					month isNil																						ifTrue: 																							[(#($b $B) includes: token selectorCharacter)																								ifTrue: [month := inputString copy]]]]																		ifTrue: 																			[isNumeric ifTrue: [inputString := workStream next: token numericModifier].																			(isNumeric and: [(self isStringNumeric: inputString) not])																				ifTrue: [self propertyAt: #withoutAnomalies put: false].																			(self propertyAt: #withoutAnomalies)																				ifTrue: 																					[(#($d $j $f $G) includes: token selectorCharacter)																						ifTrue: [day := inputString copy].																					(#($y $Y $u) includes: token selectorCharacter)																						ifTrue: [year := inputString copy].																					(#($i $h $k $l) includes: token selectorCharacter)																						ifTrue: [hour := inputString copy].																					(#($m) includes: token selectorCharacter)																						ifTrue: [minute := inputString copy].																					(#($s) includes: token selectorCharacter)																						ifTrue: [second := inputString copy].																					(#($n $c) includes: token selectorCharacter)																						ifTrue: 																							[aSymbol = #stamp																								ifTrue: [millisecond := inputString copy]																								ifFalse: [workStream skip: (inputString size + 1) * -1]].																					month isNil																						ifTrue: 																							[(#($b $B) includes: token selectorCharacter)																								ifTrue: [month := inputString copy]]]]]																ifFalse: 																	["Delimiter token is nil, which means we have reached the end of the stream."																	"Then read aStream to see if current content matches our expectations."																	inputString := workStream upToEnd.																	"If the content type does not match that of the format, this is an 								anomaly."																	(isNumeric and: [(self isStringNumeric: inputString) not])																		ifTrue: [self propertyAt: #withoutAnomalies put: false].																	(self propertyAt: #withoutAnomalies)																		ifTrue: 																			[(#($d $j $f $G) includes: token selectorCharacter)																				ifTrue: [day := inputString copy].																			(#($y $Y $u) includes: token selectorCharacter)																				ifTrue: [year := inputString copy].																			(#($i $h $k $l) includes: token selectorCharacter)																				ifTrue: [hour := inputString copy].																			(#($m) includes: token selectorCharacter)																				ifTrue: [minute := inputString copy].																			(#($s) includes: token selectorCharacter)																				ifTrue: [second := inputString copy].																			(#($n $c) includes: token selectorCharacter)																				ifTrue: 																					[aSymbol = #stamp																						ifTrue: [millisecond := inputString copy]																						ifFalse: [workStream skip: (inputString size + 1) * -1]].																			month isNil																				ifTrue: 																					[(#($b $B) includes: token selectorCharacter)																						ifTrue: [month := inputString copy]]]]]]												ifFalse: 													["If not a PrintFormatToken, token must be a character."													token = workStream next														ifFalse: [self propertyAt: #withoutAnomalies put: false]]]	"Without anomalies"]	"Policystream processing."]	"Policy notNil - narrow"].	"Policy notNil - wide"			(self propertyAt: #withoutAnomalies)				ifTrue: 					["Create and answer the requested object here."					(aSymbol = #date or: [aSymbol = #stamp])						ifTrue: 							[(month respondsTo: #string)								ifTrue: 									[(self isStringNumeric: month string)										ifFalse: [month := self indexOfMonth: month string]										ifTrue: [month := month string asNumber]].							(day respondsTo: #string) ifTrue: [day := day string asNumber].							(year respondsTo: #string) ifTrue: [year := year string asNumber].							((day isInteger and: [month isInteger]) and: [year isInteger])								ifTrue: 									["Y2K check, in case they entered a two-digit year. This code used to live in Date&gt;&gt;newDay:monthNumber:year:"									year &lt; 100 ifTrue: [year := Date today year // 100 * 100 + year].									createdDate := Date newDay: day monthNumber: month year: year]								ifFalse: [createdDate := nil]].					(aSymbol = #time or: [aSymbol = #stamp])						ifTrue: 							[(hour respondsTo: #string) ifTrue: [hour := hour string asNumber].							(minute respondsTo: #string) ifTrue: [minute := minute string asNumber].							(second respondsTo: #string) ifTrue: [second := second string asNumber].							(millisecond respondsTo: #string)								ifTrue: [millisecond := millisecond string asNumber].							"Check for AM or PM. 		If hour = 12 and AM, change hour to 0.		if hour &lt; 12 and PM, add 12 to hour."							ampm notNil								ifTrue: 									[| matched |									matched := false.									((printPolicy shortAmPm at: 1) match: ampm)										ifTrue: 											[hour = 12 ifTrue: [hour := 0].											ampm := printPolicy shortAmPm at: 1.											matched := true].									matched										ifFalse: 											[((printPolicy shortAmPm at: 2) match: ampm)												ifTrue: 													[hour &lt; 12 ifTrue: [hour := hour + 12].													ampm := printPolicy shortAmPm at: 2.													matched := true]].									matched										ifFalse: 											[((printPolicy longAmPm at: 1) match: ampm)												ifTrue: 													[hour = 12 ifTrue: [hour := 0].													ampm := printPolicy longAmPm at: 1.													matched := true]].									matched										ifFalse: 											[((printPolicy longAmPm at: 2) match: ampm)												ifTrue: 													[hour &lt; 12 ifTrue: [hour := hour + 12].													ampm := printPolicy longAmPm at: 2]]].							(hour &gt;= 0 and: [hour &lt;= 23])								ifFalse: 									[self error: (#errNotValidHour &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is not a valid hour'												expandMacrosWith: hour)].							(minute &gt;= 0 and: [minute &lt;= 59])								ifFalse: 									[self										error: (#errNotValidMinute &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is not a valid minute'												expandMacrosWith: minute)].							(second &gt;= 0 and: [second &lt;= 59])								ifFalse: 									[self										error: (#errNotValidSecond &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is not a valid second'												expandMacrosWith: second)].							(millisecond &gt;= 0 and: [millisecond &lt;= 999])								ifFalse: 									[self										error: (#errNotValidMillisecond &lt;&lt; #dialogs												&gt;&gt; '&lt;1p&gt; is not a valid millisecond' expandMacrosWith: millisecond)].							createdTime := Time fromSeconds: 60 * (60 * hour + minute) + second].					aSymbol = #date						ifTrue: 							[createdDate notNil								ifTrue: 									[aStream position: workStream position.									^createdDate]].					aSymbol = #time						ifTrue: 							[createdTime notNil								ifTrue: 									[aStream position: workStream position.									^createdTime]].					aSymbol = #stamp						ifTrue: 							[createdTimestamp := Timestamp new fromDate: createdDate										andTime: createdTime.							createdTimestamp notNil								ifTrue: 									[createdTimestamp millisecond: millisecond.									aStream position: workStream position.									^createdTimestamp]]]	"withoutAnomalies true"].	"policyFormatNameSymbols do"	"Fallback: if using the policy format to parse the textual representation has failed, 	try the readLatin methods. If these cannot understand the textual representation,	they will fail with an error dialog as always."	aStream position: aStreamPosition.	aSymbol = #date ifTrue: [^self readLatinDateFrom: aStream].	aSymbol = #time ifTrue: [^self readLatinTimeFrom: aStream].	aSymbol = #stamp ifTrue: [^self readLatinTimestampFrom: aStream].	^nil	"Error - and we should not ever get here, because the fallback above should handle failures in the classic manner."</body></methods><methods><class-id>Core.WeakDictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopy">postCopy	super postCopy.	valueArray addDependent: self.	executors := executors copy.	accessLock := RecursionLock new</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Collections-Arrayed" selector="asStringEncoding:">asStringEncoding: encoding	"Convert self encoded in encoding to Unicode string."	| map cache |	cache := LastDecodeMap.	cache key == encoding		ifTrue: [map := cache value]		ifFalse:			[map := Lock critical:					[Decodings at: encoding ifAbsent: [#createMap]].			map == #createMap				ifTrue: [map := self class createDecodeMapFor: encoding].			map == nil				ifFalse: [LastDecodeMap := encoding -&gt; map]].	map == #identityMap		ifTrue: [^self copy changeClassToThatOf: ''].	^map == nil		ifTrue: [String fromIntegerArray: self encoding: encoding]		ifFalse: [self asStringFromMap: map encoding: encoding]</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Collections-Arrayed" selector="asByteString">asByteString	"Answer an instance of ByteString which is = to self."	^self copy changeClassTo: ByteString</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Collections-Arrayed" selector="literalArrayEncoding">literalArrayEncoding	"Return a literal suitable for reconstituting the receiver."	^self copy</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>bit manipulation</category><body package="Magnitude-Numbers" selector="bitAt:put:">bitAt: i put: k	"Set the bit at the ith position.  Only k's first bit is considered"	| answer digitIndex bitIndex newDigit |	answer := self copy.	digitIndex := i - 1 // 8 + 1.	bitIndex := i - 1 \\ 8 + 1.	newDigit := (self digitAt: digitIndex) bitAt: bitIndex put: k.	answer digitAt: digitIndex put: newDigit.	^answer compressed</body></methods><methods><class-id>Core.UnicodeCollationAlgorithm</class-id> <category>initialize-release</category><body package="Collections-Collation" selector="atString:putKey:">atString: stringAsArray putKey: key	| dict cp keepMask setMask old string unit |	string := String fromIntegerArray: stringAsArray.	cp := string first codePoint.	string size ~= 1		ifTrue: [			dict := tailoredCollationContractions				at: string first				ifAbsent: [collationContractions					at: string first					ifAbsent: [CompactDictionary new]].			dict := dict copy.			dict at: string put: (self packArray: key as: collationAllLevels species).			tailoredCollationContractions at: string first put: dict.			keepMask := CollateContract bitInvert.			setMask := CollateContract]		ifFalse: [			keepMask := CollateContract.			key size &gt; 1				ifTrue:					[setMask := CollateExpanded.					tailoredCollationExpansions at: (Character value: cp) put: (self packArray: key as: collationAllLevels species)]				ifFalse:					[setMask := CollateSimple.					unit := CollateUnit new decodeFromLiteralArray: key first.					tailoredCollationAllLevels testMissing: cp copyFrom: collationAllLevels.					tailoredCollationAllLevels packIndex: cp k1: unit k1 k2: unit k2 k3: unit k3 ignorable: unit ignorable]].	tailoredCollationFlags testMissing: cp+1 copyFrom: collationFlags.	old := tailoredCollationFlags at: cp+1.	tailoredCollationFlags at: cp+1 put: ((old bitAnd: keepMask) bitOr: setMask).</body></methods><methods><class-id>Core.Object</class-id> <category>glorp</category><body package="Store-Database Model" selector="glorpCopyIn:">glorpCopyIn: aDictionary	"For non-storeForGlorp objects, just copy normally"	^self copy.</body></methods><methods><class-id>Core.BehaviorShell</class-id> <category>copying</category><body package="Kernel-Classes" selector="postCopy">postCopy	"Reset the list of subclasses,	and copy the method dictionary."	super postCopy.	self methodDictionary: self methodDict copy</body></methods><methods><class-id>Core.ByteEncodedString class</class-id> <category>system startup</category><body package="Collections-String Support" selector="install">install	| encoding className decodingMap stringClass nm |	encoding := self platformStringPreference.	nm := encoding at: 1.	nm changeClassTo: ByteString.	className := StringClasses at: nm.	stringClass := className asQualifiedReference value.	decodingMap := encoding at: 2."	stringClass encoder decodingMap = decodingMap		ifFalse:			[[Processor activeProcess priority: Processor userSchedulingPriority.			self error: 'The VI and VM have different ideas of the preferred encoding']					forkAt: Processor systemRockBottomPriority]."	self defaultPlatformClass: stringClass.	PrimitiveArgumentClass := ByteArray."	128 to: 256 do: [:i | decodingMap at: i put: Character illegalCode asCharacter]."	PrimitiveArgumentClass		bePreferredClassWithEncoding: stringClass encoder decodingMap copy</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>copying</category><body package="Collections-Sequenceable" selector="copyWith:">copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and 	includes the argument, newElement, at the end."	| newCollection |	newCollection := self copy.	newCollection add: newElement.	^newCollection</body></methods><methods><class-id>Core.CompositeLocale class</class-id> <category>accessing</category><body package="Internationalization" selector="named:">named: aLocaleName	"Strip off the encoding portion of the name if supplied"	| localeName index |	(index := aLocaleName string indexOfSubCollection: '.' startingAt: 1) &gt; 0		ifTrue: [localeName := aLocaleName string copyFrom: 1 to: index - 1]		ifFalse: [localeName := aLocaleName string copy].	^self locale: localeName asSymbol		encoding: (self platformLocaleAndEncoding at: 2)</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>copying</category><body package="Collections-Sequenceable" selector=",">, aSequenceableCollection 	"Answer a copy of the receiver concatenated with the argument,	a SequenceableCollection."		^self copy		addAll: aSequenceableCollection;		yourself</body></methods><methods><class-id>Core.InternalCodeWriterStream</class-id> <category>storage</category><body package="System-Code Storage" selector="storeString:">storeString: aString	(aString isString and: [aString isSymbol not]) ifFalse:		[self storeString: aString asString.		^aString].	aString class == ByteString		ifTrue:			[self storeByte: 1.			self storeLength: aString size.			self nextPutAll: aString asByteArray]		ifFalse: [aString class == TwoByteString			ifTrue:				[self storeByte: 2.				self storeLength: aString basicSize.				self nextPutAll: (aString copy changeClassTo: ByteArray)]			ifFalse: [aString class == FourByteString				ifTrue:					[self storeByte: 4.					self storeLength: aString basicSize.					self nextPutAll: (aString copy changeClassTo: ByteArray)]				ifFalse: [self storeString: aString asByteString]]].	^aString</body></methods><methods><class-id>Core.LocaleEncodingComponent class</class-id> <category>class initialization</category><body package="Internationalization" selector="initialize">initialize	"LocaleEncodingComponent initialize"		EncodingDictionary == nil ifTrue: [EncodingDictionary := Dictionary new].	(EncodingDictionary includesKey: #unix) ifFalse: [			EncodingDictionary at: #unix put: IdentityDictionary new].	(EncodingDictionary includesKey: #win32) ifFalse: [			EncodingDictionary at: #win32 put: IdentityDictionary new].	EncodingDictionary do: [:dict |		dict keys copy do: [:eName | dict removeKey: eName]].	(self class selectors select: [:i | 'install*Encoding' match: i]) do: [:sel | self perform: sel].</body></methods><methods><class-id>Core.LocaleEncodingComponent class</class-id> <category>installation</category><body package="Internationalization" selector="install_ASCII_Encoding">install_ASCII_Encoding	| enc copy starter |	starter := (StreamEncoder new: #ASCII) encoding.	enc := self new.	enc		name: starter;		compoundTextEncodeOrder: #(#ascii #iso1);		cutPasteEncoding: #CompoundText;		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: starter);		ignoreSerifEncodings: #();		needsInputMethod: true;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	self addEncoding: enc platform: #unix.	copy := enc copy.	copy		needsInputMethod: false;		preferredPixelSize: nil;		cutPasteEncoding: #UTF16.	self addEncoding: copy platform: #win32</body></methods><methods><class-id>Core.LocaleEncodingComponent class</class-id> <category>installation</category><body package="Internationalization" selector="install_UTF8_Encoding">install_UTF8_Encoding	| enc copy starter |	starter := (StreamEncoder new: #UTF8) encoding.	enc := self new.	enc		name: starter;		compoundTextEncodeOrder: #(#ascii #iso1);		cutPasteEncoding: #CompoundText;		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: starter);		ignoreSerifEncodings: #();		needsInputMethod: true;		preferredEncodings: #('iso8859-1' 'iso10646-1');		preferredFontFamily: #();		preferredPixelSize: 12.	self addEncoding: enc platform: #unix.	copy := enc copy.	copy		needsInputMethod: false;		preferredPixelSize: nil;		cutPasteEncoding: #UTF16;		preferredEncodings: nil.	self addEncoding: copy platform: #win32</body></methods><methods><class-id>Core.Collection</class-id> <category>removing</category><body package="Collections-Abstract" selector="removeAll">removeAll	"Remove every element in the receiver. Return a collection of the items removed."	^self removeAll: self copy</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="Collections-Abstract" selector="copyReplaceAll:with:">copyReplaceAll: oldSubCollection with: newSubCollection 	"Answer a copy of the receiver in which all occurrences of 	oldSubCollection have been replaced by newSubCollection.  If there 	are no such occurrences, answer a copy of the receiver."	| matchIndex matchIndices newCollection oldIndex newIndex newPlace |	"If there are no matches, answer the receiver."	(matchIndex := self indexOfSubCollection: oldSubCollection startingAt: 1) &gt; 0		ifFalse: [^self copy].	matchIndices := OrderedCollection with: matchIndex.	[(matchIndex := self indexOfSubCollection: oldSubCollection startingAt: matchIndex + oldSubCollection size) &gt; 0]		whileTrue: [matchIndices addLast: matchIndex].	"Copy the collection, replacing all the occurrences."	newCollection := self species withSize: self size + ((newSubCollection size - oldSubCollection size) * matchIndices size).	oldIndex := 1.	newIndex := 1.	[matchIndices isEmpty]		whileFalse: 			[matchIndex := matchIndices removeFirst.			"Copy the subcollection up to the match."			newPlace := newIndex + matchIndex - oldIndex.			newCollection				replaceFrom: newIndex				to: newPlace - 1				with: self				startingAt: oldIndex.			oldIndex := matchIndex + oldSubCollection size.			"Insert the new subcollection."			newIndex := newPlace + newSubCollection size.			newCollection				replaceFrom: newPlace				to: newIndex - 1				with: newSubCollection				startingAt: 1].	"Copy the collection beyond the last match."	newCollection		replaceFrom: newIndex		to: newCollection size		with: self		startingAt: oldIndex.	^newCollection	"'How noww brown cowow?' copyReplaceAll: 'ow' with: 'ello'"</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="Collections-Abstract" selector="copyUpTo:">copyUpTo: anObject	"Answer a copy of the receiver from index 1 to the first occurrence of 	anObject, non-inclusive."	| index |	index := self indexOf: anObject ifAbsent: [^self copy].	^self copyFrom: 1 to: index-1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="Collections-Abstract" selector="sorted">sorted	"Return a sorted copy of the receiver."	| sortedVersion |	sortedVersion := self copy.	sortedVersion sort.	^sortedVersion.</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="Collections-Abstract" selector="sorted:">sorted: aBlock	"Return a sorted copy of the receiver using aBlock as the sort criteria.	e.g. #(1 4 -5 -2 3) sorted: [:a :b | a abs &lt;= b abs]	returns a sorted copy of the receiver as	#(1 -2 3 4 -5)"	| sortedVersion |	sortedVersion := self copy.	sortedVersion sort: aBlock.	^sortedVersion.</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopy">postCopy	valueArray := valueArray copy</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopyWithCopiedValues">postCopyWithCopiedValues	self postCopy.	1 to: valueArray size do:		[:i| | value |		nil == (value := valueArray at: i) ifFalse: [valueArray at: i put: value copy]]</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories" selector="asClassNameOnly">asClassNameOnly	"Check if the string names meta class and strip 	the postfix class."	^self namesMetaClass		ifTrue: [self classNameOnly]		ifFalse: [self copy]</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="Collections-Streams" selector="policy">policy	^StreamPolicy default copy</body></methods><methods><class-id>Core.OrderedSet</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopy">postCopy	super postCopy.	values := values copy</body></methods><methods><class-id>Core.Behavior</class-id> <category>recompiling</category><body package="Kernel-Classes" selector="rebindAllMethods:">rebindAllMethods: varNames	"Regenerate all the methods in the receiver's method dictionary"	| newMethods |	newMethods := methodDict copy.	self selectorsAndMethodsDo:		[:sel :meth | | newMethod |		newMethod := self						rebindMethod: meth						oldVariableNames: varNames.		newMethods at: sel put: (self validateMethod: newMethod forSelector: sel)].	methodDict := newMethods.	self flushVMmethodCache</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing instances and variables</category><body package="Kernel-Classes" selector="allSharedPools">allSharedPools	"Answer a Set of the pools, dictionaries, that the receiver and the	receiver's ancestors share."	^(superclass == nil or: [SystemUtils isVW20LanguageCompatible not])		ifTrue:			[self sharedPools copy]		ifFalse: 			[| aSet |			aSet := superclass allSharedPools.			aSet addAll: self sharedPools.			aSet]</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="Kernel-Classes" selector="copyMethodDictionary">copyMethodDictionary	methodDict := methodDict copy</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating class hierarchy</category><body package="Kernel-Classes" selector="clearInstanceVariables">clearInstanceVariables	"After creating the copy, clear in the copy those instance variables that would be confusing"	superclass := nil.	methodDict := methodDict copy.	subclasses := nil</body></methods><methods><class-id>Core.Behavior</class-id> <category>copying</category><body package="Kernel-Classes" selector="postCopy">postCopy	"Reset the list of subclasses,	and copy the method dictionary."	super postCopy.	subclasses := nil. 			methodDict := methodDict copy</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing class hierarchy</category><body package="Kernel-Classes" selector="subclasses">subclasses	"Answer the receiver's subclasses.  Return a copy so that callers who 	add or delete subclasses won't get confused."	^subclasses == nil		ifTrue: [Array new]		ifFalse: [subclasses copy]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>organization</category><body package="BOSS" selector="orderedCategories:">orderedCategories: aList	"Set the list of categories known by the class's organization.	If the organization knows categories not on this list, add them	at the end.  If the system does not support the development	environment (organization is nil), do nothing."	| list2 |	organization == nil ifTrue: [^self].	list2 := aList copy asOrderedCollection.	self organization categories do:		[:cat |		(list2 includes: cat)			ifFalse: [list2 add: cat]].	self organization categories: list2</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance variables</category><body package="Kernel-Classes" selector="changeInstVarName:to:">changeInstVarName: aString to: aReplacement 	"Replace the variable known as aString with aReplacement"	| newArray |	(self instVarNames includes: aString) 		ifFalse: 			[self 				error: (#InstVarNotFound &lt;&lt; #dialogs 						&gt;&gt; '&lt;1s&gt; is not one of my instance variables' expandMacrosWith: aString)].	newArray := self instVarNames copy replaceAll: aString with: aReplacement.	self instanceVariableNames: (newArray fold: [:a :b | a , ' ' , b])</body></methods><methods><class-id>Core.Class</class-id> <category>instance variables</category><body package="Kernel-Classes" selector="changeInstVarName:to:">changeInstVarName: aString to: aReplacement 	"Replace the variable known as aString with aReplacement"	(self instVarNames includes: aString) 		ifFalse: 			[self 				error: (#InstVarNotFound &lt;&lt; #dialogs 						&gt;&gt; '&lt;1s&gt; is not one of my instance variables' expandMacrosWith: aString)].	(self classBuilder)		currentClass: self;		superclass: superclass;		instanceVariables: (self instVarNames copy replaceAll: aString					with: aReplacement);		format: self format;		reviseSystem</body></methods><methods><class-id>Core.GapString</class-id> <category>copying</category><body package="Collections-String Support" selector="postCopy">postCopy	super postCopy.	string := string copy</body></methods><methods><class-id>Core.List</class-id> <category>copying</category><body package="UIBasics-Collections" selector="postCopy">postCopy	"Answer a copy of the receiver."	self breakDependents.	collection :=  collection copy.</body></methods><methods><class-id>Core.CompositeTimeZone</class-id> <category>copying</category><body package="Magnitude-General" selector="postCopy">postCopy	policies := policies copy</body></methods><methods><class-id>Core.ExceptionSet</class-id> <category>adding</category><body package="Kernel-Exception Handling" selector=",">, anExceptionSelector 	"Answer a copy of the receiver concatenated with the argument,	anExceptionSelector."	^(self copy)		add: anExceptionSelector;		yourself</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installESLocale">installESLocale	"Spanish"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #esCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_es);		timePolicy: (TimestampPrintPolicy newFor: #_es);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copy.	copy name: #'es_ES.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #esn) put: #'es_ES.CP1252';		at: #('win32 *' #ESN) put: #'es_ES.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installFILocale">installFILocale	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #fiCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_fi);		timePolicy: (TimestampPrintPolicy newFor: #_fi);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copy.	copy		name: #'fi_FI.CP1252';		preferredPixelSize: nil;		defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #fin) put: #'fi_FI.CP1252';		at: #('win32 *' #FIN) put: #'fi_FI.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>class initialization</category><body package="Internationalization" selector="ensureAllLocalesHaveUTF8Alternative">ensureAllLocalesHaveUTF8Alternative	"For each locale that we have with some other encoding, create a version that's the same but uses UTF-8 encoding. Ideally we'd have a complete set of locales, or a decoupling of language from encoding, but in the meantime this handles the most common case, where Linux distributions often have UTF-8 encodings for arbitrary system locales."	| unixLocales |	unixLocales := LocaleDictionary at: #unix.	unixLocales copy keysAndValuesDo: [:eachLocaleName :eachLocale | | utf8Name |		eachLocaleName = #C ifFalse: [			utf8Name := ((eachLocaleName readStream through: $.) , 'UTF-8') asSymbol.			unixLocales at: utf8Name ifAbsentPut: [				| newLocale |				LocaleMap at: (Array with: '* linux' with: utf8Name) put: utf8Name.				eachLocale copy					name: utf8Name;					defaultStreamEncoder: UTF8StreamEncoder;					yourself]]]</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installCLocale">installCLocale	| locale copy |	locale := self new.	locale		name: #C;		collationPolicy: nil;		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: nil;		numberPolicy: nil;		timePolicy: nil;		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.5 @ 11.0; "Letter paper size in inch"		defaultStreamEncoder: ISO8859L1String encoder;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copy.	self addLocale: copy platform: #unix.	copy := locale copy.	copy preferredPixelSize: nil;		  defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installUSLocale">installUSLocale 	| locale copy |	 locale := self new.	 locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #usCurrency);		numberPolicy: (NumberPrintPolicy newFor: #us);		timePolicy: (TimestampPrintPolicy newFor: #us);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.5 @ 11.0; "Letter paper size in inch"		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12. 	copy := locale copy.	copy name: #'en_US.HPRoman8'.	copy defaultStreamEncoder: 			(StreamEncoder lookupEncoderDirectory: #HP_Roman8).	self addLocale: copy platform: #unix.	copy := locale copy.	copy name: #'en_US.ISO8859-1'.	copy defaultStreamEncoder: ISO8859L1String encoder.	self addLocale: copy platform: #unix.	copy := locale copy.	copy name: #'en_GB.ISO8859-15'.	copy defaultStreamEncoder: CharacterEncoder iso8859_15Encoder.	self addLocale: copy platform: #unix.	copy := locale copy.	copy name: #'en_US.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: CharacterEncoder mscp1252.	self addLocale: copy platform: #win32.	LocaleMap		at: #('* hp *' #american) put: #'en_US.HPRoman8';		at: #('* hp *' #'american.iso88591') put: #'en_US.ISO8859-1';		at: #('* hp *' #'en_US.roman8') put: #'en_US.HPRoman8';		at: #('* hp *' #'en_US.iso88591') put: #'en_US.ISO8859-1';		at: #('* sun *' #en_GB) put: #'en_GB.ISO8859-15';		at: #('* sun *' #en_US) put: #'en_US.ISO8859-1';		at: #('* sun *' #En_US) put: #'en_US.ISO8859-1';		at: #('* ibm *' #en_US) put: #'en_US.ISO8859-1';		at: #('* ibm *' #en_GB) put: #'en_GB.IBM-1252@euro';		at: #('* sequent *' #en_US) put: #'en_US.ISO8859-1';		at: #('win32 *' #enu) put: #'en_US.CP1252';		at: #('win32 *' #ENU) put: #'en_US.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installRUSLocale">installRUSLocale	"Locale installRUSLocale"      | locale copy |      locale := self new.      locale		collationPolicy: (StringCollationPolicy newFor: #russianCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1); "?"		currencyPolicy: (NumberPrintPolicy newFor: #rusCurrency);		numberPolicy: (NumberPrintPolicy newFor: #rus);		timePolicy: (TimestampPrintPolicy newFor: #rus);		cutPasteEncoding: #CompoundText;		needsInputMethod: true;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12. "Letter paper size in inch"	copy := locale copy.	copy name: #'ru_RU.CP1251';		preferredPixelSize: nil; 		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #ms_cp_1251). 	self addLocale: copy platform: #win32.	copy := locale copy.	copy name: #'ru_RU.KOI8-R'.	copy defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #KOI8R).	self addLocale: copy platform: #unix.	LocaleMap		at: #('win32 *' #rus) put: #'ru_RU.CP1251';		at: #('win32 *' #RUS) put: #'ru_RU.CP1251'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installDKLocale">installDKLocale	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #dkCurrency);		numberPolicy: (NumberPrintPolicy newFor: #dk);		timePolicy: (TimestampPrintPolicy newFor: #dk);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copy.	copy		name: #'da_DK.CP1252';		preferredPixelSize: nil;		defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #dan) put: #'da_DK.CP1252';		at: #('win32 *' #DAN) put: #'da_DK.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installPTLocale">installPTLocale	"Portuguese (Portugal)"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #ptCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_pt);		timePolicy: (TimestampPrintPolicy newFor: #_pt);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copy.	copy		name: #'pt_PT.CP1252';		preferredPixelSize: nil;		defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #ptg) put: #'pt_PT.CP1252';		at: #('win32 *' #PTG) put: #'pt_PT.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installNOLocale">installNOLocale	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #noCurrency);		numberPolicy: (NumberPrintPolicy newFor: #no);		timePolicy: (TimestampPrintPolicy newFor: #no);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copy.	copy name: #'no_NO.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #nor) put: #'no_NO.CP1252';		at: #('win32 *' #NOR) put: #'no_NO.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installSELocale">installSELocale	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #seCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_se);		timePolicy: (TimestampPrintPolicy newFor: #_se);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"Letter paper size in inch"	copy := locale copy.	copy		name: #'sv_SE.CP1252';		preferredPixelSize: nil;		defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #sve) put: #'sv_SE.CP1252';		at: #('win32 *' #SVE) put: #'sv_SE.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installPTBLocale">installPTBLocale	"Portuguese (Brazil)"	| locale copy |	locale := self new.	locale		name: #'pt_BR.CP1252';		collationPolicy: nil;		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #brazilCurrency);		numberPolicy: (NumberPrintPolicy newFor: #brazil);		timePolicy: (TimestampPrintPolicy newFor: #brazil);		cutPasteEncoding: #CompoundText;		defaultStreamEncoder: ISO8859L1String encoder;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copy.	self addLocale: copy platform: #unix.	copy := locale copy.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #ptb) put: #'pt_BR.CP1252';		at: #('win32 *' #PTB) put: #'pt_BR.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installUALocale">installUALocale	"Ukrainian locale."	| locale copy |	locale := self new.	locale 		collationPolicy: (StringCollationPolicy newFor: #ukrainianCollate:to:); 		currencyPolicy: (NumberPrintPolicy newFor: #uaCurrency); 		numberPolicy: (NumberPrintPolicy newFor: #ua);		timePolicy: (TimestampPrintPolicy newFor: #ua);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929; "A4paper in inches"		ignoreSerifEncodings: #(); 		needsInputMethod: true; 		preferredEncodings: nil; 		preferredPixelSize: nil;		preferredFontFamily: #().		copy := locale copy.	copy name: #'ua_UA.CP1251';		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #ms_cp_1251).	self addLocale: copy platform: #win32.	copy := locale copy.	copy preferredEncodings: #('koi8-u' 'koi8-r').	copy name: #'ua_UA.KOI8-U';		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #'koi8-u').	self addLocale: copy platform: #unix.	LocaleMap		at: #('win32 *' #ukr) put: #'ua_UA.CP1251';		at: #('win32 *' #UKR) put: #'ua_UA.CP1251'.</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installDELocale">installDELocale	"German"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #germanCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #deCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_de);		timePolicy: (TimestampPrintPolicy newFor: #_de);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copy.	copy name: #'de_DE.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #deu) put: #'de_DE.CP1252';		at: #('win32 *' #DEU) put: #'de_DE.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installNLLocale">installNLLocale	"self installNLLocale."	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #dutchCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #nlCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_nl);		timePolicy: (TimestampPrintPolicy newFor: #_nl);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.27 @ 11.69;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	"A4 paper size in inch"	copy := locale copy.	copy name: #'nl_D.HPRoman8'.	copy		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #HP_Roman8).	self addLocale: copy platform: #unix.	copy := locale copy.	copy name: #'nl_D.ISO8859-1'.	copy defaultStreamEncoder: ISO8859L1String encoder.	self addLocale: copy platform: #unix.	copy := locale copy.	copy name: #'nl_D.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #nld) put: #'nl_D.CP1252';		at: #('win32 *' #NLD) put: #'nl_D.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installFRLocale">installFRLocale	"French"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #englishCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #frCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_fr);		timePolicy: (TimestampPrintPolicy newFor: #_fr);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copy.	copy name: #'fr_FR.CP1252'.	copy preferredPixelSize: nil.	copy defaultStreamEncoder: MSCP1252String encoder.	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #fra) put: #'fr_FR.CP1252';		at: #('win32 *' #FRA) put: #'fr_FR.CP1252'</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="Internationalization" selector="installELLocale">installELLocale	"Greek"	"The locale names with underscore prepended in the numberPolicy:	and timePolicy: method sends allow the eight Legacy locales with	names which overlap locales in the CLDR set to continue to	coexist. These eight locales are #de, #el, #es, #fi, #fr, #nl, #pt and #se."	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #greekCollate:to:);		compoundTextEncodeOrder: #(#ascii #iso1);		currencyPolicy: (NumberPrintPolicy newFor: #elCurrency);		numberPolicy: (NumberPrintPolicy newFor: #_el);		timePolicy: (TimestampPrintPolicy newFor: #_el);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929;		ignoreSerifEncodings: #();		needsInputMethod: false;		preferredEncodings: nil;		preferredFontFamily: #();		preferredPixelSize: 12.	copy := locale copy.	copy name: #'el_EL.CP1253'.	copy preferredPixelSize: nil.	copy		defaultStreamEncoder: (StreamEncoder lookupEncoderDirectory: #ms_cp_1253).	self addLocale: copy platform: #win32.	LocaleMap		at: #('win32 *' #el) put: #'el_EL.CP1253';		at: #('win32 *' #EL) put: #'el_EL.CP1253'</body></methods><methods><class-id>Core.SharedQueue</class-id> <category>copying</category><body package="Kernel-Processes" selector="postCopy">postCopy     " Finish doing whatever is required,     beyond a shallowCopy, to implement 'copy'.     Answer the receiver."     | dup |     [accessProtect critical: [dup := contents  copy]] valueUninterruptably.     self init: dup capacity.     contents := dup.     contents size timesRepeat: [readSynch  signal].     ^self</body></methods><methods><class-id>Core.SubscriptionRegistry</class-id> <category>adding</category><body package="System-Announcements" selector="addSubscription:">addSubscription: anAnnouncementSubscription	"Add a subscription with copy-on-write to avoid conflicts if there is iteration in progress."	| class originalSubscriptions |	class := anAnnouncementSubscription announcementClass.	originalSubscriptions := classesAndSubscriptions at: class ifAbsent: [nil].	originalSubscriptions isNil		ifTrue:			[classesAndSubscriptions := classesAndSubscriptions copy.			classesAndSubscriptions at: class put: (Array with: anAnnouncementSubscription)]		ifFalse:			[classesAndSubscriptions 				at: class				put: (originalSubscriptions copyWith: anAnnouncementSubscription)]</body></methods><methods><class-id>Core.SubscriptionRegistry</class-id> <category>removing</category><body package="System-Announcements" selector="removeSubscription:">removeSubscription: anAnnouncementSubscription	"Remove using copy-on-write to avoid any conflicts with iteration already in progress."	| newSubscriptions class |	class := anAnnouncementSubscription announcementClass.	newSubscriptions := (classesAndSubscriptions at: class ifAbsent: [^self])		copyWithout: anAnnouncementSubscription.	anAnnouncementSubscription deactivate.	newSubscriptions isEmpty 		ifTrue: 			[classesAndSubscriptions := classesAndSubscriptions copy.			classesAndSubscriptions removeKey: class]		ifFalse: 			[classesAndSubscriptions at: class put: newSubscriptions]</body></methods><methods><class-id>Core.ExtrapolatedSystemTimeZone</class-id> <category>converting</category><body package="OS-Support" selector="localToUniversal:">localToUniversal: localTimestamp	" Convert a timestamp in the current timezone to a universal timestamp. "	| yearAdjustment localTimestampAdjusted universalTimestamp |	(self system timestampWithinRange: localTimestamp)		ifTrue: [^super localToUniversal: localTimestamp].	yearAdjustment := self system timestampRangeYearAdjustment: localTimestamp.	localTimestampAdjusted := (localTimestamp copy)				year: localTimestamp year - yearAdjustment;				yourself.	universalTimestamp := self system localToUniversal: localTimestampAdjusted.	universalTimestamp year: universalTimestamp year + yearAdjustment.	^universalTimestamp		milliseconds: localTimestamp milliseconds;		partialNanosecond: localTimestamp partialNanosecond;		yourself</body></methods><methods><class-id>Core.ExtrapolatedSystemTimeZone</class-id> <category>converting</category><body package="OS-Support" selector="universalToLocal:">universalToLocal: universalTimestamp	" Convert a universal timestamp to equivalent timestamp in the current timezone. "	| yearAdjustment universalTimestampAdjusted localTimestamp |	(self system timestampWithinRange: universalTimestamp)		ifTrue: [^super universalToLocal: universalTimestamp].	yearAdjustment := self system				timestampRangeYearAdjustment: universalTimestamp.	universalTimestampAdjusted := (universalTimestamp copy)				year: universalTimestamp year - yearAdjustment;				yourself.	localTimestamp := self system universalToLocal: universalTimestampAdjusted.	localTimestamp year: localTimestamp year + yearAdjustment.	^localTimestamp		milliseconds: universalTimestamp milliseconds;		partialNanosecond: universalTimestamp partialNanosecond;		yourself</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>growing</category><body package="Collections-Arrayed" selector="copyWithSize:">copyWithSize: newSize	"Answer a copy of me that can store at least newSize elements."	| new |	new := self class new: newSize.	1 to: (self basicSize min: new size) do:		[:i |		new basicAt: i put: (self basicAt: i) copy].	^new</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>compressing</category><body package="Collections-Arrayed" selector="uncompress">uncompress	"Make #at:put: go faster, by forcing similiar segments to be different objects."	compressed := false.	2 to: self basicSize do: [:i |		1 to: i-1 do: [:j |			(self basicAt: i) == (self basicAt: j)				ifTrue: [self basicAt: i put: (self basicAt: i) copy]]].</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>copying</category><body package="Collections-Collation" selector="testMissing:copyFrom:">testMissing: index copyFrom: otherCollection	| page |	(otherCollection class == self class			or: [otherCollection species == self species			or: [otherCollection pageSize == self pageSize]])		ifFalse: [self error: 'Incompatible collection implementations'].	page := index - 1 // 256 + 1.	page &gt; self basicSize		ifTrue: [self become: (self copyWithSize: page*256)].	(self basicAt: page) == nil		ifTrue: [self basicAt: page put: (otherCollection basicAt: page) copy].</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>accessing</category><body package="Collections-Arrayed" selector="at:put:">at: anIndex put: anObject 	"We copy the segment each time in case someone has asked for 	sharing. This makes for low space, but works only if stores are quite 	infrequent."	| c i1 |	i1 := (anIndex - 1 bitShift: -8) + 1.	c := self basicAt: i1.	c == nil		ifTrue: [c := self newPage]		ifFalse: [compressed ifTrue: [c := c copy]].	c at: (anIndex - 1 bitAnd: 255) + 1 put: anObject.	self basicAt: i1 put: c.	^anObject</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>accessing</category><body package="Collections-Streams" selector="peek">peek	"Answer what would be returned with a self next, without	changing position.  If the receiver is at the end, answer nil."	| nextObject savedSkipSize |	self atEnd ifTrue: [^nil].	savedSkipSize := skipSize copy.	nextObject := self next.	self skip: -1.	skipSize restore: savedSkipSize.	^nextObject</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>accessing</category><body package="Collections-Streams" selector="next">next	"Answer the next object in the Stream represented by the receiver."	| ch |	binary		ifTrue: [^stream next].	skipSize reset.	ch := encoder readFrom: stream.	ch == nil		ifTrue:			[skipSize clear.			^nil].	lineEndCharacter == ch				"no need to convert"		ifFalse: [^ch].	lineEndConvention == LineEndLF		"convert LF to CR"		ifTrue: [^CR].	lineEndConvention == LineEndCRLF	"convert CRLF to CR"		ifTrue: [ | char skip1 |			skip1 := skipSize copy.				"We need to nil this out in case we find a CR				not followed by an LF, and need to back up."			skipSize reset.			char := [encoder readFrom: stream]					on: Stream endOfStreamSignal					do: [:ex | ex return: nil].			char == nil ifTrue: [^CR].			char == LF				ifTrue: [skipSize mergeCount: skip1]				ifFalse:					[self skip: -1.					skipSize restore: skip1].			^CR]</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>accessing</category><body package="Collections-Streams" selector="peekFor:">peekFor: anObject 	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	| nextObject savedSkipSize |	self atEnd ifTrue: [^false].	savedSkipSize := skipSize copy.	nextObject := self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	self skip: -1.	skipSize restore: savedSkipSize.	^false</body></methods><methods><class-id>Core.Dictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopy">postCopy	super postCopy.	1 to: self capacity do:		[:i| | value |		nil == (value := self basicAt: i)			ifFalse:				[self basicAt: i put: value copy]]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>copying</category><body package="Collections-Unordered" selector="postCopyWithCopiedValues">postCopyWithCopiedValues	self postCopy.	1 to: self capacity do:		[:i| | value |		nil == (value := self basicAt: i)			ifFalse:				[value := value copy.				value value: value value copy.				self basicAt: i put: value]]</body></methods><methods><class-id>Core.Text</class-id> <category>converting</category><body package="Collections-Text" selector="withCRs">withCRs	"Answer a Text with all instances of $\ replaced by CRs. Retain all emphases."	^self shallowCopy 		setString: (self string collect: [:char | char = $\ ifTrue: [Character cr] ifFalse: [char]])		setRuns: self runs copy</body></methods><methods><class-id>Core.Text</class-id> <category>copying</category><body package="Collections-Text" selector="postCopy">postCopy	super postCopy.	string := string copy.	runs := runs copy</body></methods><methods><class-id>Core.Text</class-id> <category>copying</category><body package="Collections-Text" selector="copyReplaceFrom:to:with:">copyReplaceFrom: start to: stop with: aText 	^self copy replaceFrom: start to: stop with: aText</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private</category><body package="Collections-Text" selector="rangeOfPattern:reverseFrom:ignoreCase:">rangeOfPattern: pattern reverseFrom: start ignoreCase: caseInsensitive	"Find the first occurrence of pattern within the receiver, in reverse direction beginning at start,	allowing one character in place of each #, and zero or more characters in place of each *.	Answer the range of the match, or (0 to: 0) if no match.  If caseInsensitive is true, ignore case differences."	| patternList nextIndex firstIndex p searchSelector startReversed result matchList |	searchSelector := caseInsensitive				ifTrue: [#findSameAs:startingAt:wildcard:]				ifFalse: [#findString:startingAt:wildcard:].	patternList := pattern tokensBasedOn: $*.	patternList removeAllSuchThat: [:i | i isEmpty].	patternList isEmpty		ifTrue: [^pattern isEmpty ifTrue: [0 to: 0] ifFalse: [start to: start - 1]].	startReversed := 1 max: 1 + self size - start.	[startReversed &lt; self size] whileTrue: 			[matchList := patternList copy.			firstIndex := self reverse						perform: searchSelector						with: (p := matchList removeFirst) reverse						with: startReversed						with: $#.			firstIndex = 0 ifTrue: [^0 to: 0].			result := 2 + self size - firstIndex - p size.			matchList isEmpty ifTrue: [^result to: result + p size - 1].			nextIndex := result + p size.			[matchList isEmpty or: [nextIndex = 0]] whileFalse: 					[nextIndex := self								perform: searchSelector								with: (p := matchList removeFirst)								with: nextIndex								with: $#.					nextIndex = 0						ifTrue: [startReversed := 1 max: 1 + self size - result]						ifFalse: [nextIndex := nextIndex + p size]].			matchList isEmpty ifTrue: [^result to: nextIndex - 1]].		^0 to: 0</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Collections-Text" selector="chopTo:">chopTo: num	"Answer a string chopped to num characters by combining the	initial and final substrings of sufficient size."	| first last result |	num &gt;= self size ifTrue: [^self copy].	num = 1 ifTrue: [^self species with: (self at: 1)].	first := (num + 1) // 2.	last := num // 2.	result := self species new: num.	result replaceFrom: 1 to: first with: self startingAt: 1.	result replaceFrom: first + 1 to: num with: self startingAt: self size - last + 1.	^result	"	'antidisestablishmentarianism' chopTo: 10 'antidanism'	"</body></methods><methods><class-id>OSkLogSwitch</class-id> <category>services</category><body package="OSkLogger" selector="close">close	"^selfI close and remove all my targets.  This means any further entries will simly be dropped."	self logTargets copy do: 			[:aTarget | 			aTarget close.			self logTargets remove: aTarget].	^self</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	self queryModel onChangeSend: #changedQuery to: self.	self blockFactor: 1.	self connectedStatusHolder onChangeSend: #connectedStatusChanged to: self.	self executeStatusHolder onChangeSend: #executeStatusChanged to: self.	self moreAnswersStatusHolder onChangeSend: #moreAnswersStatusChanged to: self.	self truncateColumnsStatusHolder onChangeSend: #truncateColumnsStatusChanged to: self.	self dsvList list: List new.	dsvList list add: (Array with: '   ' with: '   ') copy.</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private-dataset</category><body package="Database" selector="addColumnLabel:width:">addColumnLabel: aString width: aNumber	"Add a column to the dataset view. To go into effect, send &gt;&gt;invalidate to the dataset."	| columnCollection newColumn dataset columnSpec newColumnNumber aspectSymbol |	dataset := self datasetWidget.	columnCollection := dataset columnDescriptors asOrderedCollection.	columnSpec := columnCollection first description copy.	newColumnNumber := columnCollection size + 1.	aspectSymbol := ('selectedRow ', newColumnNumber printString) asSymbol.	columnSpec				label: aString;				model: aspectSymbol;				width: aNumber.	newColumn := columnSpec columnWithBuilder: self builder.	columnCollection add: newColumn.	dataset columnDescriptors: columnCollection.</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private</category><body package="Database" selector="updateDataset:columns:">updateDataset: list columns: descrs	"Update the dataset with the list of data records, and descrs database column descriptions."	| col width columnWidths |	self clearDataset.	dsvList list addAll: list copy.	columnWidths := self truncateColumnsStatusHolder value				ifTrue: [self truncatedWidthsOfColumns: descrs]				ifFalse: [self adequateWidthsOfColumns: descrs forRows: list].	1 to: descrs size		do: 			[:index |			col := descrs at: index.			width := columnWidths at: index.			index = 1				ifTrue: [self firstColumnLabel: col name width: width]				ifFalse: [self addColumnLabel: col name width: width]].	self datasetWidget invalidate.	self datasetWidget isVisible: true			"Ensure that the dataset gets displayed."</body></methods><methods><class-id>Database.AdHocQueryTool class</class-id> <category>resources</category><body package="Database" selector="errorTextMenu">errorTextMenu	"MenuEditor new openOnClass: self andSelector: #errorTextMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #copy #catalogID: #database #defaultString: 'copy' )				#value: #copySelection ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>accessing</category><body package="Database" selector="upToEnd">upToEnd	"Answer the current contents of the receiver's input stream. All rows of the answer	set are fetched. Since there must be a unique object for every entry of the set, the	allocateForEachRow control in the session is ignored and  a copy of the bindOutput	object is always made."	| cont getRow |	( session == nil ) "No more answers."		ifTrue: [ self class endOfStreamSignal raiseSignal. ^#().].	cont := WriteStream on: (self contentsSpecies new: 512).	session allocateForEachRow		ifTrue:	[ getRow :=  [ self next ]		"next made the copy" ]		ifFalse:	[ getRow := [ self next copy ] 	"next didn't make the copy" ].	[ self atEnd ]		whileFalse: [ cont nextPut: getRow value ].	^cont contents</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>accessing</category><body package="Database" selector="next:into:startingAt:">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection.	Since there must be a unique object for every entry of the set, the allocateForEachRow	control in the session is ignored and  a copy of the bindOutput object is always made."	| index stopIndex getRow |	index := startIndex.	stopIndex := index + anInteger.	session allocateForEachRow		ifTrue:	[ getRow :=  [ self next ]		"next made the copy" ]		ifFalse:	[ getRow := [ self next copy ] 	"next didn't make the copy" ].	[ self atEnd not and: [ index &lt; stopIndex ] ]		whileTrue:		[ "Collect the next row by executing the getRow block from			above and then insert into the collection."			aSequenceableCollection at: index put: getRow value.			index := index + 1 ].	^aSequenceableCollection</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-answer set</category><body package="Database" selector="nextRowExternal">nextRowExternal	"Answer with the next row of data.  Answer nil at end"	| currentRowCopy |	( self advanceExternal == nil ) ifTrue:		[ "We've exhausted the answer set.  No DBMS cancel is necessary."		self state: #validResults.		^nil ].	"If we have a resultTemplate, use it to provide the answer."	( resultTemplate == nil ) ifFalse:		[ bufferIndex := 1.		^self nextViaTemplate: resultTemplate ].	currentRowCopy := allocateForEachRow		ifTrue:			[ currentRow copy ]		ifFalse:			[ currentRow ].	1 to: numColumns		do: [ :index |			(rowAdaptors at: index)				value: currentRowCopy				value: (self getFieldExternal: index) ].	^currentRowCopy</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-answer set</category><body package="Database" selector="getRowExternal:offset:">getRowExternal: fetchOrientation offset: fetchOffset	"Answer with the next row of data.  Answer nil at end"	| currentRowCopy |	( (self advanceExternal: fetchOrientation offset: fetchOffset) == nil ) ifTrue:		[ "We've exhausted the answer set.  No DBMS cancel is necessary."		self state: #validResults.		^nil ].	"If we have a resultTemplate, use it to provide the answer."	( resultTemplate == nil ) ifFalse:		[ bufferIndex := 1.		^self nextViaTemplate: resultTemplate ].	currentRowCopy := allocateForEachRow		ifTrue:			[ currentRow copy ]		ifFalse:			[ currentRow ].	1 to: numColumns		do: [ :index |			(rowAdaptors at: index)				value: currentRowCopy				value: (self getFieldExternal: index) ].	^currentRowCopy</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>actions</category><body package="Database" selector="saveProfile">saveProfile	| name savedProfile |	name := Dialog request: (#ProfileName &lt;&lt; #database &gt;&gt; 'Profile name:') initialAnswer: self currentProfile originalName.	name isEmpty ifTrue: [^self].	self currentProfile name: name.	savedProfile := self currentProfile copy.	self 		addOrReplaceProfile: savedProfile;		currentProfile: self currentProfile;		updateProfileList</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	super initialize.	self initializeAspects.	self 		updateProfileList;		currentProfile: self lastUsedProfile copy.	self databaseListHolder value: self knownDatabases.	self environmentListHolder value: 		self knownEnvironmentStrings asSortedCollection.	self userNameListHolder value:		self knownUserNames asSortedCollection.	self connectionProfileHolder onChangeSend: #profileSelected to: self.	currentProfileHolder onChangeSend: #profileChanged to: self</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>notifications</category><body package="Database" selector="profileSelected">profileSelected	| name profile |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name].	currentProfileHolder value: profile copy</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>store</category><body package="Store-Repository Access" selector="openProfile:">openProfile: aProfileOrNil	^self chooseProfileInitially: aProfileOrNil copy</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-participation</category><body package="Database" selector="participantsDo:">participantsDo: aBlock	"Invoke aBlock for each participant."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	participantsSemaphore critical:		[ (self participants copy) do:			[ :each |			(each == 0 or: [ each isExecutor ]) ifFalse:				[ aBlock value: each ] ] ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-participation</category><body package="Database" selector="participantsDetect:ifNone:">participantsDetect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	^participantsSemaphore critical:		[ (self participants copy)			detect:				[ :each |				(each == 0 or: [ each isExecutor ])					ifTrue: [ false ]					ifFalse: [ aBlock value: each ] ]			ifNone: exceptionBlock ]</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>sql generation</category><body package="GlorpQueries" selector="rewriteSetOperationUsing:">rewriteSetOperationUsing: aSelector	"Rewrite any INTERSECT OR EXCEPT operation we have into a correlated EXISTS or NOT EXISTS test, respectively. We take the sub-query, and AND into it a constraint that its base expression is equal to the first queries base expression, and then do either an exists: or a notExists:, depending on aSelector."		| newQuery |	newQuery := queries first copy.	2 to: queries size do: [:i | | q expression mainExpression |		q := (queries at: i) copy.		expression := RelationExpression new outerJoin: false; relation: #=; leftChild: newQuery baseExpression; rightChild: q baseExpression.		mainExpression := RelationExpression new outerJoin: false; relation: #AND; leftChild: q whereClause; rightChild: expression.		q whereClause: mainExpression.		newQuery AND: [:each | each perform: aSelector with: q]].	^newQuery.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	super postCopy.	queries := queries collect: [:each | each copy].	primaryQuery := queries first.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="removeNestedParensFromString:">removeNestedParensFromString: aString	"Return a Smalltalk instance of the type indicated by aGlorpType.  SQL-Server wraps aString in parentheses, so uwrap it first.  If aString is nil, ensure we return nil."	| debracket |	aString size &lt; 2 ifTrue: [^aString].	"relies on nil size = 0"	debracket := aString copy.	[debracket first = $( and: [debracket last = $)]]		whileTrue: [debracket := debracket copyFrom: 2 to: debracket size - 1].	^debracket</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>enumerating</category><body package="GlorpQueries" selector="select:">select: aBlock	^self isInstantiated ifTrue: [self realObjects select: aBlock] ifFalse: [self copy AND: aBlock].</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>enumerating</category><body package="GlorpQueries" selector="reject:">reject: aBlock	^self copy AND: [:each | (aBlock value: each) not].</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	query := query copy.	realObjects := nil.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	allTracings := allTracings copy.	retrievalExpressions := retrievalExpressions copy.	alsoFetchExpressions := alsoFetchExpressions copy.</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>converting</category><body package="GlorpQueries" selector="asSimpleQueryFor:">asSimpleQueryFor: aClass	| newQuery newCriteria newBase |	"Rebuild the expression, because this means a full query is being split into multiple sub-queries, e.g. for an inheritance read. The expression may get prepared differently in each case (e.g. table aliases), so we can't share"	newBase := BaseExpression new.	newBase descriptor: (session system descriptorFor: aClass).	newCriteria := whereClause rebuildOn: newBase startingFrom: newBase withOuterScopeBase: newBase.	newQuery := SimpleQuery new		initResultClass: aClass		whereClause: newCriteria		singleObject: readsOneObject.	self copyAttributesTo: newQuery.	newQuery session: session.	newQuery setOrdering: ordering.	newQuery setGrouping: grouping.	newQuery setUpExpressions.	newQuery tracing: tracing copy.	^newQuery.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>table creation</category><body package="GlorpCore" selector="migrateFromSystem:toSystem:">migrateFromSystem: from toSystem: to	| fromTables toTables toDelete toAdd toModify newVersion |	fromTables := from allTables copy.	toTables := to allTables copy.	toDelete := fromTables reject: [:each | 		toTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toAdd := toTables reject: [:each | 		fromTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toModify := fromTables reject: [:each | (toDelete includes: each) or: [toAdd includes: each]].	self doDDLOperation: [		self createTables: toAdd.		self dropTables: toDelete.		toModify do: [:each | 			newVersion := to tableNamed: each sqlString.			self updateTableFrom: each to: newVersion]].</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>copying</category><body package="GlorpCore" selector="postCopy">postCopy	super postCopy.	self initializeCache.	currentUnitOfWork := nil.	accessor := accessor copy.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>converting</category><body package="GlorpExpressions" selector="asGlorpExpressionOn:">asGlorpExpressionOn: aBaseExpression	| copy |	copy := self copy.	copy joins: (copy joins collect: [:each | each asGlorpExpressionOn: aBaseExpression]).	^copy.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="asGeneralGlorpExpressionWithFields">asGeneralGlorpExpressionWithFields	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	| result |	result := self copy.	result leftChild: leftChild asGeneralGlorpExpressionWithFields.	result rightChild: rightChild asGeneralGlorpExpressionWithFields.	^result.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="asGeneralGlorpExpression">asGeneralGlorpExpression	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	| result |	result := self copy.	result leftChild: leftChild asGeneralGlorpExpression.	result rightChild: rightChild asGeneralGlorpExpression.	^result.</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="mappedFields">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	| fields |	fields := super mappedFields copy.	fields addAll: keyMapping mappedFields.	valueMapping isNil ifFalse: [		fields addAll: valueMapping mappedFields].	^fields.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="typeNamed:ifAbsentPut:">typeNamed: aSymbol ifAbsentPut: aBlock	| type |	type := self types at: aSymbol ifAbsentPut: [		| newType |		newType := aBlock value.		newType platform: self.		newType selector: aSymbol].	type hasParameters ifTrue: [type := type copy].	^type.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="typeWithDatabaseName:characterWidth:">typeWithDatabaseName: aString characterWidth: aNumber	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now."	| baseType matchingTypes simpleTypes |	matchingTypes := self typesWithValues values asArray select: [:each | each typeName asLowercase = aString asLowercase].	matchingTypes isEmpty ifTrue: [		Transcript cr; show: 'Cannot find type ', aString, ' using integer instead.'. matchingTypes := Array with: self integer].	"We may get generated and non-generated both matching, e.g. inMemorySequence and int. Prefer the non-generated."	simpleTypes := matchingTypes reject: [:each | each isGenerated].	baseType := simpleTypes isEmpty ifTrue: [matchingTypes first] ifFalse: [simpleTypes first].	^baseType hasWidth ifTrue: [baseType copy width: aNumber] ifFalse: [baseType].</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>copying</category><body package="GlorpDatabase" selector="withTable:">withTable: aTable	"Return a copy of ourselves, with the table set to aTable. Presumably aTable is an aliased version of our table"	^self copy table: aTable.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions" selector="copyOld">copyOld	| new |	new := super copy.	"We need to make sure we copy these before the base gets set. This is horribly ugly."	new selectListVersion: selectListVersion copy.	new whereClauseVersion: whereClauseVersion copy.	^new.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions" selector="createFor:withBase:symbol:">createFor: argumentList withBase: anExpression symbol: aSymbol	| new newBase newArgument newFunction |	new := super createFor: argumentList withBase: anExpression symbol: aSymbol.	"For the where clause version, we've got a dualRoleFunction. We can't just rebuild the whole thing, so rebuild the children, and then re-assemble it recreating from the template."	newBase := new whereClauseVersion base isNil ifTrue: [anExpression] ifFalse: [new whereClauseVersion base rebuildOn: anExpression].	newArgument := new whereClauseVersion argument rebuildOn: anExpression.	newFunction := self whereClauseVersion copy.	newFunction symbol: aSymbol.	newFunction base: newBase.	newFunction argument: newArgument.	new whereClauseVersion: newFunction.	"Don't try to rebuild the selectListVersion at all, because at least for the motivating case we have, it's just a shell, not a full blown expression, and it will already have been copied."	^new.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions" selector="copy">copy	| new |	new := super copy.	"We need to make sure we copy these before the base gets set. This is horribly ugly."	new selectListVersion: selectListVersion copy.	new whereClauseVersion: whereClauseVersion copy.	^new.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuiltBase rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	rebuiltBase := base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	rebuilt := self copy.	rebuilt base: rebuiltBase.	rebuilt query: (query rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression).	^rebuilt."	^query asGlorpExpressionOn: aBaseExpression."</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	super postCopy.	queries := queries collect: [:each | each copy].</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>class lookup</category><body package="GlorpExtensions" selector="removeObsolete">removeObsolete	| workingNames |	self isVisualWorks ifFalse: [^self].	(workingNames := self lookedUpNames) copy keysAndValuesDo: 		[:key :value |		value isObsolete ifTrue: [workingNames removeKey: key ifAbsent: nil]]</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="reverseAdjustIn:">reverseAdjustIn: aRowMapForMementos	"Adjust ourselves to refer to the originals rather than the copies"	| adjusted |	adjusted := self copy.	adjusted keys: (keys collect: [:each | 		aRowMapForMementos reversedCorrespondenceMap at: each ifAbsent: [each]]).	^adjusted.</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="adjustIn:">adjustIn: aCorrespondenceMap	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copy.	adjusted keys: (keys collect: [:each | aCorrespondenceMap at: each ifAbsent: [each]]).	^adjusted.</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>printing</category><body package="GlorpQueries" selector="printLeftoverTablesOn:">printLeftoverTablesOn: aCommand	"Now there might be leftover tables whose joins were implied directly by the where clause"	| leftOverTables |	leftOverTables := self allTables asSet copy.	availableTables do: [:each | leftOverTables remove: each ifAbsent: []].	leftOverTables isEmpty ifFalse: [aCommand nextPutAll: ', '].	GlorpHelper		print: [:each | each sqlTableName]		on: aCommand		for: leftOverTables		separatedBy: ', '.</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>printing</category><body package="GlorpQueries" selector="printJoinsOn:">printJoinsOn: aCommand	"This is pretty hideous. Figure out an order in which to print these stupid joins. As a bonus, they may be circular, so we may have to collapse joins together. And if we collapse, we can't print as we go because we don't know how many parentheses to add, so store them up and print them all at the end"	| allJoins |	joinsToProcess := query joins copy.	availableTables := Set with: self rootTable.	allJoins := OrderedCollection new.	[joinsToProcess isEmpty] whileFalse: [		| next nextTable allRelatedJoins fullJoin|		next := self nextJoin.		joinsToProcess remove: next.		nextTable := next tableToJoinFrom: availableTables.		allRelatedJoins := joinsToProcess select: [:each | (each tableToJoinFrom: availableTables) = nextTable].		fullJoin := allRelatedJoins inject: next into: [:sum :each | sum AND: each].		joinsToProcess removeAll: allRelatedJoins.		allJoins add: (fullJoin-&gt;nextTable).		availableTables addAll: (next tablesForANSIJoin)].	allJoins size timesRepeat: [aCommand platform parenthesizeCommandsInCompoundQuery ifTrue: [aCommand nextPut: $(]].	aCommand nextPutAll: self rootTable sqlTableName.	allJoins do: [:each | 		each key printForANSIJoinTo: each value on: aCommand.		aCommand platform parenthesizeCommandsInCompoundQuery ifTrue: [aCommand nextPut: $)]].	self printLeftoverTablesOn: aCommand.</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="adjustIn:">adjustIn: aCorrespondenceMap	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copy.	adjusted key1: (aCorrespondenceMap at: key1 ifAbsent: [key1]).	adjusted key2: (aCorrespondenceMap at: key2 ifAbsent: [key2]).	^adjusted.</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="reverseAdjustIn:">reverseAdjustIn: aRowMapForMementos	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copy.	adjusted key1: (aRowMapForMementos reversedCorrespondenceMap at: key1 ifAbsent: [key1]).	adjusted key2: (aRowMapForMementos reversedCorrespondenceMap at: key2 ifAbsent: [key2]).	^adjusted.</body></methods><methods><class-id>Glorp.SQLite3PragmaQuery</class-id> <category>sql generation</category><body package="GlorpQueries" selector="sqlWith:">sqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copy.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^SQLite3PragmaCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| newBase |	newBase := base asExpressionJoiningSource: source toTarget: target.	^self copy function: function; base: newBase.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>copying</category><body package="GlorpExpressions" selector="createFor:">createFor: arguments	| new |	new := self copy.	new arguments: arguments.	new type: type.	^new.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>copying</category><body package="GlorpExpressions" selector="createFor:withBase:symbol:">createFor: arguments withBase: anExpression symbol: aSymbol	| new |	new := self copy.	new base: anExpression.	new symbol: aSymbol.	new type: type.	new arguments: arguments.	^new.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| copy |	self == anExpression ifTrue: [^aBaseExpression].	self base == ultimateBaseExpression ifTrue: [^self].	copy := self copy.	copy base: aBaseExpression.	^copy.</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>registering</category><body package="GlorpUnitOfWork" selector="registerTransientInternalsOfCollection:">registerTransientInternalsOfCollection: aCollection	"If this is a collection, then we may need to register any internal structures it has, e.g. an internal array. This is implementation dependent for the collection. We will also explicitly exclude strings"	aCollection glorpIsCollection ifFalse: [^self].	aCollection class isBits ifTrue: [^self].	(self needsCollectionMementoFor: aCollection)		ifTrue: [collectionMementos at: aCollection put: aCollection copy].	aCollection glorpRegisterCollectionInternalsIn: self."For this to work, the dialect must not copy collections so shallowly that internals are reused identically.In VW, Dictionary copy calls postCopy, which copies the associations or value collection (but not thekeys).  Without this, mementos added to the original would also be added to the copy.  In VA, sendingcopy to a Dictionary does a shallow copy.  In VA, inline the call of copy to shallowCopy and send thepostCopy call to it explicitly to get the behaviour we need without changing Dictionary copy behaviourin VA, which might have side-effects.  This feature's tests have been altered to check this copy safety."</body></methods><methods><class-id>Glorp.Join</class-id> <category>api</category><body package="GlorpExpressions" selector="asOuterJoin">asOuterJoin	^self copy beOuterJoin.</body></methods><methods><class-id>Glorp.Join</class-id> <category>api</category><body package="GlorpExpressions" selector="asGlorpExpressionOn:">asGlorpExpressionOn: aBaseExpression	| copy |	copy := self copy.	copy base: aBaseExpression.	copy outerJoin: outerJoin.	^copy.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>bound values</category><body package="GlorpDatabase" selector="rowAtATimeBindings">rowAtATimeBindings	"Return multiple sets of bindings in a form suitable for iterating over"	| allBindings fields rowTemplate |	fields := self arrayBoundFields.	rowTemplate := Array new: fields size.	allBindings := Array new: allRows size.	1 to: allBindings size do: [:i | | currentRow input |		currentRow := rowTemplate copy.		input := allRows at: i.		allBindings at: i put: currentRow.		1 to: fields size do: [:j |			currentRow at: j put: (input at: (fields at: j) ifAbsent: [nil])]].	^allBindings asArray.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>As yet unclassified</category><body package="GlorpCore" selector="sqlWith:">sqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copy.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^QuerySelectCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>preparing</category><body package="GlorpQueries" selector="copyOfBuilders">copyOfBuilders 	"Copy the builders, but make sure that subBuilders also get matched up"	| newBuilders |	newBuilders := builders collect: [:each | each copy].	newBuilders do: [:each | each reconcileWithBuilders: builders andCopy: newBuilders].	^newBuilders.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>As yet unclassified</category><body package="GlorpCore" selector="deleteSqlWith:">deleteSqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copy.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^QueryDeleteCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>fields</category><body package="GlorpExpressions" selector="aliasTable:to:">aliasTable: aDatabaseTable to: aString 	| newTable |	newTable := aDatabaseTable copy.	newTable name: aString.	newTable parent: aDatabaseTable.	newTable schema: ''.	self tableAliases at: aDatabaseTable put: newTable</body></methods><methods><class-id>Text2.FlowLine</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayParagraphLinesOn:">displayParagraphLinesOn: aGraphicsContext	"Draw the paragraph guide lines, a debugging tool."	| gc |	(aGraphicsContext clientDataAt: #showParagraphMarkers ifAbsent: [false]) ifFalse: [^self].	gc := aGraphicsContext copy.	ColorValue orange installOn: gc.	self isParagraphStart ifTrue: [		gc displayRectangle: ((bounds left - 2 @ 0) corner: ((bounds left @ 0) + (0 @ bounds height))).		gc displayRectangle: ((bounds left - 2 @ 0) corner: (bounds left + 6 @ 2))].	self isParagraphStop ifTrue: [		gc displayRectangle: ((bounds right @ 0) corner: (bounds right + 2 @ bounds height)).		gc displayRectangle: ((bounds right - 4 @ (bounds height - 2)) corner: (bounds right + 2 @ bounds height))].</body></methods><methods><class-id>Text2.FlowParagraph</class-id> <category>copying</category><body package="Graphics-Text2-Flow" selector="postCopy">postCopy	bounds := bounds copy</body></methods><methods><class-id>Text2.TreapNode</class-id> <category>private</category><body package="Graphics-Text2-Support" selector="rotateRight">rotateRight	"Re-balance the tree by rotating the nodes to the right"	| temp |	temp := left copy.	temp previous == nil ifFalse: [temp previous next: temp].	temp next == nil ifFalse: [temp next previous: temp].	left := left right.	temp right: self.	^temp</body></methods><methods><class-id>Text2.TreapNode</class-id> <category>private</category><body package="Graphics-Text2-Support" selector="rotateLeft">rotateLeft	"Re-balance the tree by rotating the nodes to the left"	| temp |	temp := right copy.	temp previous == nil ifFalse: [temp previous next: temp].	temp next == nil ifFalse: [temp next previous: temp].	right := right left.	temp left: self.	^temp</body></methods><methods><class-id>Text2.DocumentSpan</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:">splitFrom: anOffset	anOffset = 0 ifTrue: [^self copy].	^self class fromString: string style: style offset: offset + anOffset size: size - anOffset</body></methods><methods><class-id>Text2.DocumentSpan</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:to:">splitFrom: start to: stop	(start = 0 and: [stop = size]) ifTrue: [^self copy].	^self class fromString: string style: style offset: offset + start size: (stop - start)</body></methods><methods><class-id>Text2.DocumentSpan</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitTo:">splitTo: anOffset	anOffset = size ifTrue: [^self copy].	^self class fromString: string style: style offset: offset size: anOffset</body></methods><methods><class-id>Text2.DocumentListItem</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:">splitFrom: anOffset	anOffset = 0 ifTrue: [^self copy].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.DocumentListItem</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:to:">splitFrom: start to: stop	(start = 0 and: [stop = 1]) ifTrue: [^self copy].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.DocumentListItem</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitTo:">splitTo: anOffset	anOffset = 1 ifTrue: [^self copy].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.Document</class-id> <category>copying</category><body package="Graphics-Text2-Document" selector="copyBetween:and:">copyBetween: start and: stop	"Make a copy of the receiver between positions start and stop. The positions are between characters with the position range of 0..size."	| startNode stopNode node copy offset |	stop &lt; start ifTrue: [^self error: 'position contiguity error'].	start &lt; 0 ifTrue: [^self error: 'position out of bounds'].	stop &gt; size ifTrue: [^self error: 'position out of bounds'].	copy := self class new.	copy unicodeProperties: unicodeProperties.	copy size: stop - start.	startNode := self nodeAtPositionAfter: start.	stopNode := start = stop		ifTrue: [startNode]		ifFalse: [self nodeAtPositionBefore: stop].	startNode == stopNode ifTrue: [		copy insertAt: 0 segment: (startNode value splitFrom: start - startNode key to: stop - startNode key).		^copy].	copy insertAt: 0 segment: (startNode value splitFrom: start - startNode key).	offset := startNode value size - (start - startNode key).	node := startNode next.	[node == stopNode] whileFalse: [		copy insertAt: offset segment: node value copy.		offset := offset + node value size.		node := node next].	copy insertAt: offset segment: (stopNode value splitTo: stop - stopNode key).	^copy</body></methods><methods><class-id>Text2.Document</class-id> <category>modifying</category><body package="Graphics-Text2-Document" selector="replaceBetween:and:with:">replaceBetween: start and: stop with: replacement	"Replace between positions start..stop with replacement, which can be a Document or a String. The positions are between characters in the document, with a range of 0..size. This one method can be used to perform an insert, delete or a replace all in one:		insert example: 'Hello World' asDocument replaceBetween: 0 and: 0 with: 'X'.		delete example: 'Hello World' asDocument replaceBetween: 0 and: 1 with: ''		replace example: 'Hello World' asDocument replaceBetween: 0 and: 1 with: 'X'.	"	| startNode stopNode replacementDocument replacementStart replacementStop node delta replacedOffsets |	stop &lt; start ifTrue: [^self error: 'position contiguity error'].	start &lt; 0 ifTrue: [^self error: 'position out of bounds'].	stop &gt; size ifTrue: [^self error: 'position out of bounds'].	replacementDocument := replacement asDocument.	"If we're empty, copy the contents of the other document"	self isEmpty ifTrue: [		replacementDocument offsetsAndSegmentsDo: [:offset :segment | self insertAt: offset segment: segment copy].		cache := nil.		size := replacementDocument size.		^self].	startNode := self nodeAtPositionAfter: start.	stopNode := start = stop		ifTrue: [startNode]		ifFalse: [self nodeAtPositionAfter: stop].	"Remove startNode .. stopNode. We must first copy the nodes because as we remove nodes, the previous/next chain will change as nodes rotate in the treap."	node := startNode.	replacedOffsets := OrderedCollection new.	[replacedOffsets add: node key.	node == stopNode] whileFalse: [node := node next].	replacedOffsets do: [:each | offsets removeKey: each].	"Move stopNode .. lastNode by (replacementDocument size - size removed)."	delta := replacementDocument size - (stop - start).	delta = 0 ifFalse: [		node := stopNode next isNil			ifTrue: [nil]			ifFalse: [self nodeAtPositionAfter: stopNode next key].		[node isNil] whileFalse: [			node key: node key + delta.			node := node next]].	"Create replacement start/stop"	replacementStart := replacementStop := nil.	(start - startNode key) &gt; 0 ifTrue: [		replacementStart := (start - startNode key) = startNode value size			ifTrue: [startNode value]			ifFalse: [startNode value splitTo: start - startNode key]].	(stop - stopNode key) &lt; stopNode value size ifTrue: [		replacementStop := (stop - stopNode key) = 0			ifTrue: [stopNode value]			ifFalse: [stopNode value splitFrom: stop - stopNode key]].	"Insert replacement start + document + stop"	replacementStart isNil ifFalse: [self insertAt: startNode key segment: replacementStart].	replacementDocument offsetsAndSegmentsDo: [:offset :segment | self insertAt: start + offset segment: segment copy].	replacementStop isNil ifFalse: [self insertAt: start + replacementDocument size segment: replacementStop].	"Update our size"	size := size + delta.	cache := nil</body></methods><methods><class-id>Text2.Document</class-id> <category>copying</category><body package="Graphics-Text2-Document" selector="copyBetween:and:apply:">copyBetween: start and: stop apply: aBlockClosure	"Make a copy of the receiver between positions start and stop while applying a change to each intersecting segments styling using aBlockClosure. The positions are between characters with the position range of 0..size."	| startNode stopNode node copy segment offset |	stop &lt; start ifTrue: [^self error: 'position contiguity error'].	start &lt; 0 ifTrue: [^self error: 'position out of bounds'].	stop &gt; size ifTrue: [^self error: 'position out of bounds'].	copy := self class new.	copy unicodeProperties: unicodeProperties.	copy size: stop - start.	startNode := self nodeAtPositionAfter: start.	stopNode := start = stop		ifTrue: [startNode]		ifFalse: [self nodeAtPositionBefore: stop].	startNode == stopNode ifTrue: [		segment := startNode value splitFrom: start - startNode key to: stop - startNode key.		segment style: (aBlockClosure cull: segment style).		copy insertAt: 0 segment: segment.		^copy].	segment := startNode value splitFrom: start - startNode key.	segment style: (aBlockClosure cull: segment style).	copy insertAt: 0 segment: segment.	offset := segment size.		node := startNode next.	[node == stopNode] whileFalse: [		segment := node value copy.		segment style: (aBlockClosure cull: segment style).		copy insertAt: offset segment: segment.		offset := offset + segment size.		node := node next].	segment := stopNode value splitTo: stop - stopNode key.	segment style: (aBlockClosure cull: segment style).	copy insertAt: offset segment: segment.	^copy</body></methods><methods><class-id>Text2.FlowSegment</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayAdornmentOn:y:">displayAdornmentOn: aGraphicsContext y: y	"Render the adornment on aGraphicsContext."	| gc |	gc := aGraphicsContext copy.	self style adornmentColor installOn: gc.	self perform: (self style adornment, 'DisplayOn:y:') asSymbol with: gc with: y</body></methods><methods><class-id>Text2.FlowSegment</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayOn:y:selectingBetween:and:">displayOn: aGraphicsContext y: y selectingBetween: selectionStartPosition and: selectionStopPosition	"Subclasses should implement, display the content of the segment on aGraphicsContext at x@y."	| containedInSelection containsStart containsStop gc clip1 clip2 start stop lineHeight selectionForegroundColor |	selectionForegroundColor := aGraphicsContext		clientDataAt: #selectionForegroundColor		ifAbsent: [^self displayOn: aGraphicsContext y: y].	containedInSelection := self start between: selectionStartPosition and: selectionStopPosition.	containsStart := selectionStartPosition between: self start and: self stop.	containsStop := selectionStopPosition between: self start and: self stop.	"The fast path, when there's no selection on this line or the foreground selection color is black."	(containsStart or: [containsStop]) ifFalse: [		gc := aGraphicsContext.		containedInSelection ifTrue: [			gc := aGraphicsContext copy.			gc paint: selectionForegroundColor].		^self displayOn: gc y: y].	start := (selectionStartPosition - self start) max: 0.	stop := (selectionStopPosition - self start) min: self size.	self isRightToLeft ifTrue: [		start := self size - start.		stop := self size - stop].	lineHeight := paragraph bounds height + 1.	clip1 := self isLeftToRight ifTrue: [0] ifFalse: [paragraph width].	clip2 := self isLeftToRight ifTrue: [paragraph width] ifFalse: [0].	containsStart ifTrue: [clip1 := self pixelXAtCoordinate: start device: aGraphicsContext medium graphicsDevice].	containsStop ifTrue: [clip2 := self pixelXAtCoordinate: stop device: aGraphicsContext medium graphicsDevice].	self isRightToLeft ifTrue: [		| swap |		swap := clip1.		clip1 := clip2.		clip2 := swap].	gc := aGraphicsContext copy.	gc intersectClip: ((0 @ 0) corner: (clip1 @ lineHeight)).	self displayOn: gc y: y.	gc := aGraphicsContext copy.	gc intersectClip: ((clip1 @ 0) corner: (clip2 @ lineHeight)).	gc paint: selectionForegroundColor.	self displayOn: gc y: y.	gc := aGraphicsContext copy.	gc intersectClip: ((clip2 @ 0) corner: (paragraph width @ lineHeight)).	self displayOn: gc y: y</body></methods><methods><class-id>Text2.DocumentImage</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitTo:">splitTo: anOffset	anOffset = 1 ifTrue: [^self copy].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.DocumentImage</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:">splitFrom: anOffset	anOffset = 0 ifTrue: [^self copy].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.DocumentImage</class-id> <category>converting</category><body package="Graphics-Text2-Document" selector="splitFrom:to:">splitFrom: start to: stop	(start = 0 and: [stop = 1]) ifTrue: [^self copy].	^DocumentSpan fromString: '' style: style</body></methods><methods><class-id>Text2.FlowImage</class-id> <category>private - layout</category><body package="Graphics-Text2-Flow" selector="fit:into:device:">fit: maxWidth into: paragraphSegments device: device	(left = 0 and: [((1 - segment wrappingPercentage) * segment image width) &lt;= maxWidth]) ifFalse: [^super fit: maxWidth into: paragraphSegments device: device].	right := maxWidth.		paragraphSegments addFirst:		(self copy			left: right right: segment image width;			yourself).	paragraphSegments addFirst: self</body></methods><methods><class-id>Text2.FlowImage</class-id> <category>displaying</category><body package="Graphics-Text2-Flow" selector="displayOn:y:">displayOn: aGraphicsContext y: y	| gc |	gc := aGraphicsContext copy.	gc intersectClip: ((x @ (y - segment image height + 1)) extent: (right @ segment image height)).	segment image displayOn: gc at: (x - left) @ (y - segment image height + 1)</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private updating</category><body package="System-Code Storage" selector="installChangedClasses:within:">installChangedClasses: aCodeComponent within: aBundleOrNil	"We did not compare the methods of changed classes compareDefinedClassesIn:.	 We need to do that now (at the bottom) after the new class(s) have been installed"	| changedClasses loadOrderedClasses classBuilder overriddenClasses |	changedClasses := (updates at: #changed) select: [:each | each isBehavior].	changedClasses isEmpty ifTrue: [^self].	loadOrderedClasses := properties at: #loadOrderedClasses ifAbsent: [nil].	loadOrderedClasses := loadOrderedClasses isNil		ifTrue: [changedClasses]		ifFalse: [loadOrderedClasses select: [:each | changedClasses includes: each]].	overriddenClasses := OrderedCollection new.	loadOrderedClasses copy do:		[:each |		(Override isOverriddenClassOrNameSpace: each strictReference value in: aCodeComponent relatedPundle) ifTrue:			[loadOrderedClasses remove: each.			overriddenClasses add: each]].	classBuilder := ClassBuilder new.	loadOrderedClasses do:		[:eachClass| 		| classBuilderRecord methodBuilderRecord messageSend |		classBuilderRecord := BehaviorBuilderRecord forClass: eachClass strictReference value.		methodBuilderRecord := MetaclassBuilderRecord forInstance: classBuilderRecord.		messageSend := eachClass definitionMessage.		messageSend selector keywords			with: messageSend arguments			do: 				[:keyword :arg|				keyword ~= 'defineClass:' ifTrue:					[keyword = 'classInstanceVariableNames:'						ifTrue: [methodBuilderRecord instVarString: arg]						ifFalse:							[classBuilderRecord								perform: keyword asSymbol								with: (keyword = 'superclass:' ifTrue: [arg value] ifFalse: [arg])]]].		classBuilder			addRecord: classBuilderRecord;			addRecord: methodBuilderRecord].	loadOrderedClasses notEmpty ifTrue: [classBuilder reviseSystemSilently].	"Here we take overridden things and put the (possibly new) definition in the override object"	overriddenClasses do:		[:each |		| overrides target |		overrides := Override overridesForClassOrNameSpace: each strictReference value.		overrides ifNotNil: 			[target := overrides detect: [:eachOverride | eachOverride sources includes: aCodeComponent relatedPundle] ifNone: [nil]].		target ifNotNil: 			[target setOverriddenDefinition: each definitionMessage.			(updates at: #changed) remove: each ifAbsent: [nil]]].	"Since Bundle structure may have causes us to consider additions	 to be changes we still need to make sure the CodeComponent includes the class."	aCodeComponent addClasses: loadOrderedClasses.	changedClasses do: 		[:each | 		each strictReference ifDefinedDo:			[:systemVersion|			self 				compareMethodsIn: each				withSystemVersion: systemVersion				for: aCodeComponent				within: aBundleOrNil.			self 				compareMethodsIn: each class				withSystemVersion: systemVersion class				for: aCodeComponent				within: aBundleOrNil]].</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private updating</category><body package="System-Code Storage" selector="installChangedNamespaces:">installChangedNamespaces: aCodeComponent	"A more complex implementation would substitute the physical NameSpace,	moving bindings across, etc, but this is potentially very complex.  We will use	the simple approach above until it proves inadequate.	Simply evaluate the definition message substituting the system version of the environment."	| changedNameSpaces |	changedNameSpaces := (updates at: #changed) select: [:each | each isNameSpace].	changedNameSpaces isEmpty ifTrue: [^self].	changedNameSpaces copy do:		[:each |		| overrides target |		overrides := Override overridesForClassOrNameSpace: each strictReference value.		overrides ifNotNil: [target := overrides detect: [:eachOverride | eachOverride sources includes: aCodeComponent relatedPundle] ifNone: [nil]].		target ifNotNil: 			[target setOverriddenDefinition: each definitionMessage.			(updates at: #changed) remove: each ifAbsent: [nil].			changedNameSpaces remove: each]].	changedNameSpaces do:		[:eachNameSpace|		eachNameSpace definitionMessage			receiver: eachNameSpace environment strictReference value;			value]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private updating</category><body package="System-Code Storage" selector="installChangedStatics:">installChangedStatics: aCodeComponent	| changedShareds |	changedShareds := (updates at: #changed) select: [:thing | thing isVariableBinding].	changedShareds isEmpty ifTrue: [^self].	changedShareds copy do:		[:each |		| overrides target |		each environment strictReference bindingOrNil ifNotNil:			[overrides := Override overridesForStatic: each in: each environment strictReference value.			overrides ifNotNil:[target := overrides detect: [:eachOverride | eachOverride sources includes: aCodeComponent relatedPundle] ifNone: [nil]].			target ifNotNil: 				[target setOverriddenDefinition: (target owner asNameSpace definitionMessageOfStatic: each).				(updates at: #changed) remove: each ifAbsent: [nil].				changedShareds remove: each]]].	definedBindings keysAndValuesDo:		[:env :keySet| | shadowEnv systemEnv | 		"env is class or namespace"		systemEnv := env strictReference value.		shadowEnv := self shadowOf: env.		keySet do:			[:key | 			| loadedBinding systemVersion |			loadedBinding := self bindingFor: key within: shadowEnv inSet: changedShareds.			loadedBinding notNil ifTrue:				[systemVersion := systemEnv asNameSpace localBindingFor: key.				loadedBinding environment: systemEnv.				loadedBinding initializer ~~ nil ifTrue:					[loadedBinding initializer method fixEnvironmentTo: systemEnv].				#(isPrivate isConstant category initializer)					with: #(bePrivate: beConstant: category: initializer:) 					do: 						[:getter :setter|						[systemVersion perform: setter with: (loadedBinding perform: getter)]							on: ConstantBindingModificationError							do: [:ex| ex resume]]]]]</body></methods><methods><class-id>Kernel.TimerSystem</class-id> <category>default actions</category><body package="Kernel-Processes" selector="setUp">setUp	| overdue restartPeriod resumption elapsed |	super setUp.	"Configure the native timer system and fallback timer system."	Callback := nil.	self configureTimerSystem.	"We are about to reschedule the timers themselves and any timers that would have expired while the image was	 suspended may be waiting on the TimerLock if their callback happened while the snapshot was being taken.	 We terminate the processes waiting on the TimerLock because we are about to reschedule those timers below	 and they will fire their callbacks then. This ensures the callback will not fire twice."	[TimerLock isEmpty] whileFalse: [TimerLock terminateProcess].	"Some timers are configured to specifically use the native interface. If we have no native interface available, we have to throw those timers away. We do at least put out a warning on the transcript."	NativeInterface ifNil:		[remainingSnapshot keys copy do: [:aTimer |			aTimer usesNativeInterface ifTrue:				[Transcript cr; nextPutAll: ((#UnableToRestartNativeTimer1p &lt;&lt; #dialogs &gt;&gt; 'Unable to restart native Timer: &lt;1p&gt;') expandMacrosWith: aTimer identityHash).				remainingSnapshot removeKey: aTimer]]].	"Reschedule the timers that were active at snapshot."	overdue := OrderedCollection new.	remainingSnapshot keysAndValuesDo: [:aTimer :remaining |		"Invalidate aTimer, as its OS resource no longer exists."		aTimer privateInvalidate.		"We offset each timer by the amount of elapsed time that has passed since the image was saved and resume each timer with the difference. If the clock has traveled back in time, then we do not count any elapsed time as having passed."		resumption := Timestamp nowUTC.		elapsed := resumption - microsecondSnapshot.		elapsed negative ifTrue: [elapsed := Duration zero].		restartPeriod := remaining - elapsed.		[	(restartPeriod isZero not and: [restartPeriod positive])				ifTrue:	[aTimer privateStartAfter: restartPeriod]				ifFalse:					[overdue add: aTimer.					(aTimer period isZero not and: [aTimer period positive]) ifTrue:						[restartPeriod := (restartPeriod asNanoseconds \\ aTimer period asNanoseconds) nanoseconds.						aTimer privateStartAfter: restartPeriod]]		] on: Error do: [ :ex |			"If the timer fails to reschedule (maybe because the default interface has changed and the new one can't handle the timer),			there's nothing else to do. The timer will not be activated."			aTimer flagInvalidTimer: 'Failed to reschedule in TimerSystem&gt;&gt;setUp - ', ex description ]].	remainingSnapshot := nil.	"Allow timers to fire and fire the overdue timers."	overdue do: #privateFire.	TimerLock signal</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>accessing</category><body package="System-Name Spaces" selector="duplicateBinding:under:">duplicateBinding: existingName under: newName	"Duplicate a binding in the receiver under a new name for purposes of variable renaming.	 This is tricky because we want to arrange both that the existing binding changes its name	 and a new binding gets the old name, and that a lookup of either name will succeed at any	 time during the duplication."	| existingTemp newTemp oldBindings tempBindings existingBinding duplicate |	(self includesKey: newName) ifTrue:		[self error: #errNewNameExists &lt;&lt; #dialogs &gt;&gt; 'new name already exists'].	existingBinding := self localBindingFor: existingName.	"First create a temporary set of bindings that contain new bindings for	 existingName and newName to serve while we're changing things."	existingTemp := existingBinding copy.	newTemp := existingBinding copy.	newTemp key: newName.	tempBindings := bindings copyEmpty: bindings basicSize.	bindings do:		[:binding|		binding key == existingName			ifTrue:				[tempBindings add: existingTemp; add: newTemp]			ifFalse:				[tempBindings add: binding]].	oldBindings := bindings.	bindings := tempBindings.	"Now rename the existingBinding, which requires removing it and adding it from	 bindings to ensure it gets hashed correctly, and add a duplicate with the old name."	oldBindings remove: existingBinding.	duplicate := existingBinding copy.	duplicate key: existingName.	existingBinding key: newName.	oldBindings add: existingBinding; add: duplicate.	bindings := oldBindings</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>initialize-release</category><body package="System-Compiler-Names and Scopes" selector="disallowReceiverName:withSuper:">disallowReceiverName: name withSuper: superFlag	"For the method scope, or block scopes that	can name their receiver (not in the language right now)."		| var |	variables == nil ifTrue: [self initVariables].	var := ReceiverVariable new scope: nesting.	var markIllegal.	variables at: name put: var.	superFlag		ifTrue:			[variables				at: 'super'				put: (var copy isSuper: true)]</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>accessing-debugger</category><body package="System-Compiler-Names and Scopes" selector="localTemps">localTemps	"Answer the local variable names	in this scope."	^(self isClonedFromOuter or: [variableList == nil])		ifTrue: [#()]		ifFalse: [variableList collect: [:var | var copy]]</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>initialize-release</category><body package="System-Compiler-Names and Scopes" selector="receiverName:withSuper:">receiverName: name withSuper: superFlag	"For the method scope, or block scopes that	can name their receiver (not in the language right now)."		| var |	variables == nil ifTrue: [self initVariables].	var := ReceiverVariable new scope: nesting.	variables at: name put: var.	superFlag		ifTrue:			[variables				at: 'super'				put: (var copy isSuper: true)]</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>initialize-release</category><body package="System-Compiler-Names and Scopes" selector="newOptimizedBlockScope">newOptimizedBlockScope	"Make an appropriate scope for an inner block."	"WARNING -- the system depends on the fact that the	copy and the original scope share the same collection	as their 'variableList'.  The variableList must be added	to rather than copied when new elements are added."	| inner |	variables == nil ifTrue: [self initVariables].	inner := self copy.	inner outerScope: self.	inner resetVars.	^inner</body></methods><methods><class-id>Kernel.DeferredBinding</class-id> <category>converting</category><body package="Collections-Support" selector="asDeferred">asDeferred	^self copy</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private</category><body package="BOSS" selector="cyclicShortBody:to:">cyclicShortBody: aBody to: bodies	"Add a forwarding reference to an object.  This will be resolved later"	| max bits |	bits := aBody at: 3.	swapBytes ifTrue:		[			bits := bits copy.			self swapShortOopsIn: bits		].	max := 0.	1 to: bits size by: self bytesPerShortOop do:		[:eachIndex | | oop |		oop := self shortOops: bits at: eachIndex.		"Ignore immediate values."		(oop bitAnd: 1) = 1 ifTrue: [oop := 0].		max := max max: oop].	bodies add: (aBody copyWith: max)</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private</category><body package="BOSS" selector="cyclicLongBody:to:">cyclicLongBody: aBody to: bodies	"Add a forwarding reference to an object.  This will be resolved later"	| max bits |	bits := aBody at: 3.	swapBytes ifTrue:		[			bits := bits copy.			self swapLongOopsIn: bits		].	max := 0.	1 to: bits size by: self bytesPerLongOop do:		[:eachIndex | | oop |		oop := self longOops: bits unsignedAt: eachIndex.		"Ignore immediate values."		(oop bitAnd: 1) = 1 ifTrue: [oop := 0].		max := max max: oop].	bodies add: (aBody copyWith: max)</body></methods><methods><class-id>Kernel.StrictBindingReference</class-id> <category>private</category><body package="System-Name Spaces" selector="duplicateWithPath:">duplicateWithPath: aPath	^self copy path: aPath</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="propertiesWithoutVolatileKeys">propertiesWithoutVolatileKeys	"Answer a copy of the component's properties"	| propertiesCopy |	propertiesCopy := properties copy.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesCopy removeKey: each ifAbsent: [nil]].	^propertiesCopy</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>copying</category><body package="System-Code Components" selector="postCopy">postCopy	"Ensure that all relevant sub-structure is copied."	properties := properties copy.	properties keysAndValuesDo:		[ :k :v | properties at: k put: v copy ]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>private-load/unload</category><body package="System-Code Components" selector="purgeUndeclaredIfRequired:">purgeUndeclaredIfRequired: aCodeReader	"If there are any undeclared variables in the package that are also in Undeclared	 then purge unused bindings in Undeclared to try and remove them.  To successfully	 purge we have to discard the bindings from our properties and the codeReader's	 packageUndeclared.  We can just hang on to the keys and rely on Undeclared to hold	 onto the actual bindings."	| undeclaredKeys |	aCodeReader purgeUndeclared.	undeclaredKeys := (properties at: #packageUndeclared) keys.	(undeclaredKeys anySatisfy: [:key | Undeclared includesKey: key]) ifTrue:		[undeclaredKeys do: [:each | Undeclared removeKey: each].		Undeclared purgeUnusedBindings.		undeclaredKeys copy do: [:each | (Undeclared includesKey: each) ifFalse: [undeclaredKeys remove: each]]].	properties at: #packageUndeclared put: undeclaredKeys.</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>accessing</category><body package="System-Code Components" selector="properties">properties	"Answer a copy of the component's properties"	^properties copy</body></methods><methods><class-id>Kernel.InteractiveCompilerErrorHandler</class-id> <category>private-undeclared variables</category><body package="System-Compiler-Support" selector="importContainer:from:">importContainer: varBinding from: codeStream 	| which binding |	binding := varBinding path.	binding := binding copyFrom: 1 to: binding size - 1.	binding size = 0 ifTrue: [binding := #(#Smalltalk) copy].	binding := BindingReference path: binding.	which := Dialog 				choose: (#OKToAddImportQ &lt;&lt; #dialogs 						&gt;&gt; 'Do you want to add "&lt;1s&gt;.*" as&lt;n&gt;an import of the class imports or of the NameSpace?' 							expandMacrosWith: binding asString)				labels: (Array 						with: #toTheClass &lt;&lt; #dialogs &gt;&gt; 'to the class'						with: #toTheNameSpace &lt;&lt; #dialogs &gt;&gt; 'to the name space'						with: #cancel &lt;&lt; #dialogs &gt;&gt; 'cancel')				values: #(#class #nameSpace nil)				default: #proceed				for: editor view.	which == nil ifTrue: [^self abort].	self replaceEditSelectionWith: varBinding simpleName.	which == #class 		ifTrue: 			[RedefinitionNotification redefinedClass: class attributes: nil.			SystemUtils modifySystem: 					[(class asNameSpace)						checkInstalled;						addImport: ((GeneralNameSpaceImport path: binding path) private: true)].			ChangeSet changeClass: class].	which == #nameSpace 		ifTrue: 			[RedefinitionNotification redefinedNameSpace: environment attributes: nil.			SystemUtils modifySystem: 					[environment 						addImport: ((GeneralNameSpaceImport path: binding path) private: true)].			ChangeSet changeNameSpace: environment].	^true</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>copying</category><body package="Kernel-Support" selector="postCopy">postCopy	files := files copy.	names := names copy.	sourceFormatters := sourceFormatters copy.	writableIndices := writableIndices copy.	openIndices := openIndices copy.</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>accessing</category><body package="Kernel-Support" selector="allFiles">allFiles	^names copy</body></methods><methods><class-id>Kernel.InstanceVariableSearch</class-id> <category>opcodes-control</category><body package="Tools-Misc" selector="jump:">jump: delta	delta &gt; 0		ifTrue: [self saveStacks at: self input pc+delta put: stack copy].	^false</body></methods><methods><class-id>Kernel.InstanceVariableSearch</class-id> <category>private</category><body package="Tools-Misc" selector="reloadStack">reloadStack	stack == nil		ifTrue: [stack :=  self saveStacks at: self input pc ifAbsent: [initialStack copy]].</body></methods><methods><class-id>Kernel.InstanceVariableSearch</class-id> <category>searching</category><body package="Tools-Misc" selector="searchFor:type:">searchFor: instVar type: type	"Append to the stream, aStream, a description of each bytecode in the instruction	stream."		| end |	slotIndex := instVar.	searchType := type.	input := InstructionStream on: method.	stack := OrderedCollection new.	method numTemps timesRepeat: [stack add: #temp].	initialStack := stack copy.	end := method bytes size.	[input pc &lt;= end]		whileTrue:			[self reloadStack.			(input interpretNextInstructionFor: self) ifTrue: [^true]].	^false</body></methods><methods><class-id>Kernel.InstanceVariableSearch</class-id> <category>opcodes-control</category><body package="Tools-Misc" selector="jump:if:">jump: delta if: condition	self pop.	delta &gt; 0		ifTrue: [self saveStacks at: self input pc+delta put: stack copy].	^false</body></methods><methods><class-id>Kernel.DecompilerAnalyzer</class-id> <category>opcodes-control</category><body package="System-Compiler-Support" selector="loopHead">loopHead	saved at: pc-1 put: stack copy</body></methods><methods><class-id>Kernel.DecompilerAnalyzer</class-id> <category>opcodes-control</category><body package="System-Compiler-Support" selector="jump:">jump: delta	saved at: pc+delta put: stack copy.	stack := (saved at: pc) copy.</body></methods><methods><class-id>Kernel.DecompilerAnalyzer</class-id> <category>opcodes-control</category><body package="System-Compiler-Support" selector="returnTop">returnTop	pc &gt; method endPC ifTrue: [^self].	stack := (saved at: pc) copy</body></methods><methods><class-id>Kernel.DecompilerAnalyzer</class-id> <category>opcodes-control</category><body package="System-Compiler-Support" selector="jump:if:">jump: delta if: condition	stack removeLast.	saved at: pc+delta put: stack copy.</body></methods><methods><class-id>Kernel.CompiledCodeSegment</class-id> <category>editing</category><body package="System-Compiler-Assembler" selector="removeBytesAt:size:segments:">removeBytesAt: pc size: bytesInBytecodes segments: segmentList	| visited |	modificationIndex := pc.	numBytesAdded := bytesInBytecodes negated.	bytes := bytes copyReplaceFrom: pc to: pc+bytesInBytecodes-1 with: #[].	registry do: [:client |		client updatePCs: [:oldPC || newPC |				newPC := oldPC.				(oldPC first = index and: [oldPC last &gt;= pc])					ifTrue: [(newPC := newPC copy) at: oldPC size put: oldPC last - bytesInBytecodes].				newPC]].	visited := IdentitySet new.	segmentList do: [:seg || def |		def := seg target.		def == nil			ifFalse:				[def := def definition.				(visited includes: seg target)					ifTrue: [def := nil]		"We don't want to do this twice"					ifFalse: [visited add: seg target]].		(def notNil and: [def first = index and: [def last &gt; pc]])			ifTrue: [seg target definition: (def copy at: def size put: def last - bytesInBytecodes; yourself)]].</body></methods><methods><class-id>Kernel.CompiledCodeSegment</class-id> <category>editing</category><body package="System-Compiler-Assembler" selector="insertBytesAt:bytes:for:segments:">insertBytesAt: pc bytes: newBytes for: aClient segments: segmentList	| visited |	modificationIndex := pc.	numBytesAdded := newBytes size.	bytes := bytes copyReplaceFrom: pc to: pc-1 with: newBytes.	self registry do: [:client |		client == aClient			ifFalse: [client updatePCs: [:oldPC || newPC |						newPC := oldPC.						(oldPC class == Array and: [oldPC first = index and: [oldPC last &gt;= pc]])							ifTrue: [(newPC := newPC copy) at: oldPC size put: oldPC last+newBytes size].						newPC]]].	visited := IdentitySet new.	segmentList do: [:seg || def adjust |		def := seg target.		def == nil			ifFalse:				[def := def definition.				(visited includes: seg target)					ifTrue: [def := nil]		"We don't want to do this twice"					ifFalse: [visited add: seg target]].		adjust := def notNil and: [def first = index].		adjust := adjust and: [def first &lt;= seg index				ifTrue: ["backward jump"  def last &gt;= pc]				ifFalse: ["forward jump"  def last &gt; pc]].		adjust			ifTrue: [seg target definition: (def copy at: def size put: def last + newBytes size; yourself)]].</body></methods><methods><class-id>Kernel.CompiledCodeSegment class</class-id> <category>resolving</category><body package="System-Compiler-Assembler" selector="composeSegments:">composeSegments: segments	| unresolved changed output |	unresolved := IdentitySet new.	1 to: segments size do: [:i | | seg |		seg := segments at: i.		seg index: i.		seg target == nil			ifFalse:				[seg initOptions.				unresolved add: seg]].	[changed := false.	unresolved copy do: [:ref |		| jumpInterval min max minOpt maxOpt opt |		jumpInterval := ref targetIndex &gt; ref index			ifTrue: [ref computeForwardJumpIn: segments]			ifFalse: [ref computeBackwardJumpIn: segments].		min := jumpInterval key.		max := jumpInterval value.		minOpt := ref jumpOptionForDelta: min.		maxOpt := ref jumpOptionForDelta: max.			"Assuming that minOpt and maxOpt are both integers			with a single bit set, set opt to be the integer that has			both the minOpt and maxOpt bits set, plus all bits between."		opt := maxOpt + maxOpt - minOpt.		opt = ref jumpOptions ifFalse: [changed := true].		ref jumpOptions: opt.		minOpt = maxOpt ifTrue: [unresolved remove: ref]].	changed] whileTrue.	output := ReadWriteStream on: (ByteArray new: 40).	segments do: [:s |		s basePC: output position+1; updateRegistry.		output nextPutAll: s bytes.		s putJumpOn: output fromSegments: segments].	^output contents</body></methods><methods><class-id>Kernel.BOSSCompiledCodeHolder</class-id> <category>accessing</category><body package="BOSS" selector="computeCodeForStorage:">computeCodeForStorage: storage	| list1 list2 map list1CodeOnly list2CodeOnly |	codeContents class == codeClass ifFalse:		[| aBlockOrNil vars newMeth |		aBlockOrNil := storage readerBlockFor: codeClass.		aBlockOrNil == nil			ifTrue:	[codeContents changeClassToThatOf: (codeClass basicNew: 0)]			ifFalse:	[aBlockOrNil value: codeContents.					class == nil ifFalse: [codeContents mclass: class]].		vars := storage variablesForClass: codeContents mclass.		vars == nil			ifFalse:				[newMeth := codeContents mclass							rebindMethod: codeContents							oldVariableNames: vars.				list1 := self enumerate: codeContents into: OrderedCollection new.				list2 := self enumerate: newMeth into: OrderedCollection new.				list1CodeOnly := self filterOutBlocksFrom: list1 copy.				list2CodeOnly := self filterOutBlocksFrom: list2 copy.				list1CodeOnly size = list2CodeOnly size					ifFalse: [self error: 'Unexplained mismatch between source and translated methods'].				map := IdentityDictionary new.				1 to: list1CodeOnly size do: [:i |					(list1CodeOnly at: i) become: (list2CodeOnly at: i).					map at: (list1CodeOnly at: i) put: (list2CodeOnly at: i).					map at: (list2CodeOnly at: i) put: (list1CodeOnly at: i)].				map at: newMeth put: self.				list1 do: [:obj | self map: obj using: map].					"Not strictly necessary, but for safety...."				list2 do: [:obj | self map: obj using: map].				]].	^codeContents</body></methods><methods><class-id>Kernel.CollationTable</class-id> <category>copying</category><body package="Collections-Collation" selector="testMissing:copyFrom:">testMissing: codePoint copyFrom: otherCollection	"Unlike SegmentedCollection, we're using zero-based indices--keep in mind when computing offsets."	| page |	(otherCollection class == self class			or: [otherCollection species == self species			or: [otherCollection pageSize == self pageSize]])		ifFalse: [self error: 'Incompatible collection implementations'].	page := codePoint // self pageSize + 1.	page &gt; self basicSize		ifTrue: [self become: (self copyWithSize: page*self pageSize)].	(self basicAt: page) == nil		ifTrue: [self basicAt: page put: (otherCollection basicAt: page) copy].</body></methods><methods><class-id>Kernel.CollationTable</class-id> <category>copying</category><body package="Collections-Collation" selector="copyWithSize:">copyWithSize: newSize	"Answer a copy of me that can store at least newSize elements."	| new |	new := self copyEmpty: newSize.	1 to: (self basicSize min: new size) do:		[:i |		new basicAt: i put: (self basicAt: i) copy].	^new</body></methods><methods><class-id>Kernel.CollationTable class</class-id> <category>utilities</category><body package="Collections-Collation" selector="convert:">convert: aLargeWordArray	| pageClass new page |	pageClass := OriginalCollationUnits.	new := self new: aLargeWordArray size/2 pageType: pageClass pageSize: 128.	new basicSize = aLargeWordArray basicSize ifFalse: [self error: 'Size was calculated wrong'].	1 to: new basicSize do: [:index |		page := aLargeWordArray basicAt: index.		page == nil ifFalse: [page := page copy changeClassTo: pageClass].		new basicAt: index put: page].	^new compress</body></methods><methods><class-id>Kernel.AssemblerCodeStream</class-id> <category>private</category><body package="System-Compiler-Assembler" selector="noteScrunch:at:">noteScrunch: amount at: pos	"Note that some code has been removed	just after pos, by decrementing all subsequent	PCs in the source map (if any).  pos is an Array,	with the first element being a 1-based segment	index, and the second element being a 1-based	pc offset within the segment."	self isMappingSource		ifTrue: [sourceMap do: [:m |			m updatePCs: [:oldPC || newPC |				newPC := oldPC.				(oldPC first = pos first and: [oldPC last &gt; pos last])					ifTrue: [(newPC := newPC copy) at: oldPC size put: oldPC last-amount].				newPC]]]</body></methods><methods><class-id>Kernel.IndexedFileMessageCatalog class</class-id> <category>accessing</category><body package="UIBasics-Internationalization" selector="directories">directories	^Directories copy</body></methods><methods><class-id>Kernel.ComponentChange</class-id> <category>accessing</category><body package="System-Code Component Changes" selector="componentClassName">componentClassName	^( self componentType copy asString )		at: 1 put: ( self componentType first asUppercase );		yourself</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>variable names</category><body package="System-Support" selector="validateClassName:confirm:warn:">validateClassName: varName confirm: confirmBlock warn: warnBlock	| cleanString parserClass newVarName firstChar msg |	newVarName := varName asString copy.	newVarName isEmpty		ifTrue:			[warnBlock value: (#emptyClassName &lt;&lt; #dialogs &gt;&gt; 'An empty class name is invalid').			^nil].	parserClass := self preferredParserClass.	cleanString := newVarName select:		[:char | (parserClass isLetter: char) or: [char isDigit or: [char = $. and: [self isVW20LanguageCompatible]]]].	cleanString = newVarName		ifFalse:			[cleanString isEmpty				ifTrue:					[warnBlock value: (#noValidCharsInClass &lt;&lt; #dialogs &gt;&gt; 'No valid characters in class name').					^nil].			newVarName := cleanString.			msg := (#invalidClassCharacters &lt;&lt; #dialogs &gt;&gt; 'Invalid characters in class name.  Should I use &lt;1s&gt;?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [^nil]].	(firstChar := newVarName first) isLowercase		ifTrue:			[newVarName at: 1 put: (newVarName at: 1) asUppercase.			msg := (#capitalizeClassName &lt;&lt; #dialogs &gt;&gt; 'Class names should be capitalized.&lt;n&gt;Should I use &lt;1s&gt;?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [newVarName at: 1 put: firstChar]].	^newVarName asSymbol.</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>variable names</category><body package="System-Support" selector="validateStaticVariableName:confirm:warn:">validateStaticVariableName: varName confirm: confirmBlock warn: warnBlock	| cleanString parserClass newVarName firstChar msg |	newVarName := varName asString copy.	newVarName isEmpty		ifTrue:			[warnBlock value: (#invalidVariableName &lt;&lt; #dialogs &gt;&gt; 'An empty variable name is invalid').			^nil].	parserClass := self preferredParserClass.	cleanString := newVarName select: [:char | (parserClass isLetter: char) or: [char isDigit]].	cleanString = newVarName		ifFalse:			[cleanString isEmpty				ifTrue:					[warnBlock value: (#noValidCharsInVariable &lt;&lt; #dialogs &gt;&gt; 'No valid characters in variable name').					^nil].			newVarName := cleanString.			msg := (#invalidVariableCharacters &lt;&lt; #dialogs &gt;&gt; 'Invalid characters in variable name. Use "&lt;1s&gt;"?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [^nil]].	(firstChar := newVarName first) isLowercase		ifTrue:			[newVarName at: 1 put: firstChar asUppercase.			msg := (#capitalizeSharedNames &lt;&lt; #dialogs &gt;&gt; 'Shared variable names should be capitalized.&lt;n&gt;Change the name to "&lt;1s&gt;"?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [newVarName at: 1 put: firstChar]].	^newVarName asSymbol.</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>variable names</category><body package="System-Support" selector="validateInstanceVariableName:confirm:warn:">validateInstanceVariableName: varName confirm: confirmBlock warn: warnBlock	| cleanString parserClass newVarName msg firstChar |	newVarName := varName asString copy.	newVarName isEmpty		ifTrue:			[warnBlock value: (#invalidVariableName &lt;&lt; #dialogs &gt;&gt; 'An empty variable name is invalid').			^nil].	parserClass := self preferredParserClass.	cleanString := newVarName select: [:char | (parserClass isLetter: char) or: [char isDigit]].	cleanString = newVarName		ifFalse:			[cleanString isEmpty				ifTrue:					[warnBlock value: (#noValidCharsInVariable &lt;&lt; #dialogs &gt;&gt; 'No valid characters in variable name').					^nil].			newVarName := cleanString.			msg := (#invalidVariableCharacters &lt;&lt; #dialogs &gt;&gt; 'Invalid characters in variable name. Use "&lt;1s&gt;"?')					expandMacrosWith: newVarName.			(confirmBlock value: msg					value: newVarName)				ifFalse: [^nil]].	(firstChar := newVarName first) isUppercase		ifTrue:			[newVarName at: 1 put: firstChar asLowercase.			msg := (#doNotCapitalizeInstanceNames &lt;&lt; #dialogs &gt;&gt; 'Instance variable names should not be capitalized.&lt;n&gt;Change the name to "&lt;1s&gt;"?')					expandMacrosWith: newVarName.			(confirmBlock value: msg value: newVarName)				ifFalse: [newVarName at: 1 put: firstChar]].	^newVarName asSymbol.</body></methods><methods><class-id>Kernel.Override</class-id> <category>installation</category><body package="System-Overrides" selector="checkSources:">checkSources: newSources	"Check the receiver's sources against newSources. Answer false if the receiver contains no unique sources."	| sorcesCopy |	( sources == nil 	)  |  ( sources size &lt; 1 )		ifTrue: [ ^false ].		"An error- no sources at all."	sorcesCopy := sources copy.	newSources do:		[ :comp |   | match |		match := sorcesCopy detect: [ :cc | cc comparesTo: comp ] ifNone: [ nil ].		match == nil			ifFalse: [ sorcesCopy remove: match ].		].	^sorcesCopy size &gt; 0.</body></methods><methods><class-id>Kernel.Override class</class-id> <category>management</category><body package="System-Overrides" selector="allOverridesRemoveIf:">allOverridesRemoveIf: aBlock	"Evaluate a block for every override and remove any override that evaluates true."	| actionBlock |	actionBlock :=		[ :assoc :over |  		assoc value removeAllSuchThat: [:each | each == over].		over notifySourcesOverrideBeingReinstalled.		].						ClassesAndNameSpaces associations do:		[ :assoc | 		assoc value copy do:			[ :over | 			( aBlock value: over )				ifTrue: [ actionBlock value: assoc value: over ].			]		].	Methods do:		[ : dict |		dict associations do:			[ :assoc |			assoc value copy do:				[ :over | 	( aBlock value: over ) ifTrue: [ actionBlock value: assoc value: over ] ]			]		].	Statics do:		[ : dict |		dict associations do:			[ :assoc |			assoc value copy do:				[ :over | 	( aBlock value: over ) ifTrue: [ actionBlock value: assoc value: over ] ]			]		].</body></methods><methods><class-id>Kernel.Override class</class-id> <category>management</category><body package="System-Overrides" selector="cleanseLists">cleanseLists		"self cleanseLists"	ClassesAndNameSpaces associations copy do:		[ : assoc | 		( assoc value size == 0 )  |  ( assoc key isObsolete )			ifTrue: [ ClassesAndNameSpaces removeKey: assoc key ].		].	Methods associations copy do:		[ : assoc |  | cls |		cls := assoc key.		( assoc value size == 0 )  |  ( cls isObsolete )			ifTrue: [ Methods removeKey: cls ]			ifFalse:				[ assoc value associations copy do:					[ :sub |  | selector |					selector := sub key.					( sub value size == 0 )						ifTrue: [ ( Methods at: cls ) removeKey: selector ]						ifFalse:							[ ( cls includesSelector: selector )								ifFalse: [ ( Methods at: cls ) removeKey: selector ]							]					]			].		].	Statics associations copy do:		[ : assoc | | namespace |		namespace := assoc key.		( assoc value size == 0 )  |  ( namespace isObsolete )			ifTrue: [ Statics removeKey: namespace ]			ifFalse:				[ assoc value associations copy do:					[ :sub |  | key |					key := sub key.					( sub value size == 0 ) 						ifTrue: [ ( Statics at: namespace ) removeKey: key ]						ifFalse:							[ ( namespace asNameSpace includesKey: key )								ifFalse: [ ( Statics at: namespace ) removeKey: key ]							]					]			]		].</body></methods><methods><class-id>Kernel.Override class</class-id> <category>events</category><body package="System-Overrides" selector="removeClass:">removeClass: class 	"A class has been removed from the system. Propogate changes to about to be nuked selectors and shareds"	( self overriddenMethods at: class ifAbsent: [ #( ) ] ) do: 		[ :list | list copy do: 			[ :over | self removeSelector: over selector class: class ].		].	( self overriddenMethods at: class class ifAbsent: [ #( ) ] ) do: 		[ :list | list copy do: 			[ :over | self removeSelector: over selector class: class class ].		].	( self overriddenStatics at: class ifAbsent: [ #( ) ] ) do:		[ :list | list copy do: 			[ :over | self removeBinding: over binding in: class ].		].	( self overriddenClassesAndNameSpaces at: class ifAbsent: [ #( ) ] ) 		do: [ : over | over sources do: [ :comp | over removeFrom: comp.] ].	self overriddenClassesAndNameSpaces removeKey: class ifAbsent: nil.</body></methods><methods><class-id>Kernel.Override class</class-id> <category>management</category><body package="System-Overrides" selector="prepareMoveOfSelector:class:fromPackage:toPackage:">prepareMoveOfSelector: aSelector class: aClass fromPackage: oldPackage toPackage: newPackage	"This method performs pre-processing of moving the given method from &lt;oldPackage&gt; to &lt;newPackage&gt;.	We focus on changes to override structure.	This method supports the situation when moving an overridden method from one package to another.	If the definition in oldPackage is overridden, we expect the target package to take it over 	and to remove the now obsolete entry from the Override information registry.	IF the override is targeted to a package that is already an overridden package, then we answer false if there is no RB,	or we raise a RefactoryChangeFailureNotification if there is a RB.	This is because we do not EVER want to re-override into an existing overridden package.	Before we do anything rash, we check if the the old package has never been overridden, i.e. its method is installed in the image.	if so, there is nothing to do and we answer true"		| existingOverrides oldOverride currentContainingPackage |	((existingOverrides := Override overrideCollectionForSelector: aSelector class: aClass) isNil or: [existingOverrides isEmpty]) 		ifTrue: [^true].	existingOverrides copy do: 		[:each | 		(each sources includes: newPackage) ifTrue: 			[#{Refactory.Browser.RefactoryChangeFailureNotification} 				ifDefinedDo: [:value | value raiseSignal].			^false]].	oldOverride := existingOverrides detect: [:each | each sources includes: oldPackage] ifNone: [nil].	oldOverride ifNil: [^true].	currentContainingPackage := Store.Registry containingPackageForSelector: aSelector class: aClass.	^currentContainingPackage = newPackage		ifTrue:			[oldOverride				privateReinstall;				purge.			true]		ifFalse:			[(oldOverride sources)				remove: oldPackage;				add: newPackage.			false]</body></methods><methods><class-id>Kernel.Override class</class-id> <category>private</category><body package="System-Overrides" selector="install:list:for:">install: anOverride list: aCollection for: anObject	"Private- add anOverride to a list of overrides. Validate that this does not add the same source twice	to the list. Notify the sources. NOTE: what to do if sources match previous override?"	| newSources  |	newSources := anOverride sources.	aCollection copy do:		[ :over | 		( over comparesTo: anOverride )			ifTrue: [ "?? over addSources: anOverride sources" ].		"duplicate of one already installed"		( over checkSources: newSources )			ifFalse: [ aCollection remove: over ]		"remove the original"		].	aCollection addLast: anOverride.	anOverride notifySourcesOfOverride:  anObject</body></methods><methods><class-id>Kernel.Override class</class-id> <category>events</category><body package="System-Overrides" selector="removeSelector:class:">removeSelector: selector class: class 	"A method has been removed from the system.	Remove all traces and notify components"	| oclass ometh |	oclass := self overriddenMethods at: class ifAbsent: [ ^self ].	ometh := oclass at: selector ifAbsent: [ ^self ].		ometh copy do: [ :over | over sources do: [ :comp | over removeFrom: comp ] ].	oclass removeKey: selector ifAbsent: nil.	oclass isEmpty		ifTrue: [ self overriddenMethods removeKey: class ].</body></methods><methods><class-id>Kernel.ClassOrganizer</class-id> <category>copying</category><body package="Kernel-Support" selector="postCopy">postCopy	"Ensure that the receiver's sub-structure is also copied."	super postCopy.	self commentKey: self commentKey.	categoryArray := categoryArray copy.	categoryStops := categoryStops copy.	elementArray := elementArray copy.</body></methods><methods><class-id>Kernel.CodeRegenerator</class-id> <category>code generation-jumps</category><body package="System-Compiler-Public Access" selector="jump:if:">jump: delta if: condition 	| newPC label currentLabels |	self pushAll.	newPC := pc + delta.	(pcLabels at: newPC) == nil		ifTrue:	[pcLabels at: newPC put: pcStack copy].	delta &lt; 0		ifTrue: [self error: (#DidNotExpectBackwardBranch &lt;&lt; #dialogs &gt;&gt; 'Did not expect backward branch')]		ifFalse: 			["Target has not yet been defined.  When multiple jumps all			arrive at the same pc, they each have to have separate			CodeLabels assigned, or the code generator will screw up"			label := self code newLabel.			currentLabels := self labels at: newPC.			currentLabels == nil				ifTrue: [self labels at: newPC put: (Array with: label)]				ifFalse: [self labels at: newPC put: (currentLabels copyWith: label)].			self code putBranchTo: label if: condition]</body></methods><methods><class-id>Kernel.CodeRegenerator</class-id> <category>code generation-jumps</category><body package="System-Compiler-Public Access" selector="jump:">jump: delta 	| newPC label currentLabels |	self pushAll.	newPC := pc + delta.	(pcLabels at: newPC) == nil		ifTrue:	[pcLabels at: newPC put: pcStack copy].	self checkMerge.	delta &lt; 0		ifTrue: 			["Target (a loopHead instruction) has already been defined"			label := self labels at: newPC.			self code putBranchBack: label]		ifFalse: 			["Target has not yet been defined.  When multiple jumps all			arrive at the same pc, they each have to have separate			CodeLabels assigned, or the code generator will screw up"			label := self code newLabel.			currentLabels := self labels at: newPC.			currentLabels == nil				ifTrue: [self labels at: newPC put: (Array with: label)]				ifFalse: [self labels at: newPC put: (currentLabels copyWith: label)].			self code putBranch: label]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>queries</category><body package="System-Code Components" selector="classesAndSelectorsDo:">classesAndSelectorsDo: aBlock 	"Evaluate the argument with each behavior and its selectors	 defined by the receiver."	classSelectors copy keysAndValuesDo:		[:aBehavior :selectors |		aBlock value: aBehavior value: selectors copy]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>queries</category><body package="System-Code Components" selector="definedClasses">definedClasses	^definedClasses copy.</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>queries</category><body package="System-Code Components" selector="definedBindings">definedBindings	^definedBindings copy.</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>ui</category><body package="System-Code Components" selector="saveParcelDialogFor:preOpen:preSave:">saveParcelDialogFor: aVisualOrNil preOpen: aBlockForDialog preSave: aBlockForSave	"UI for writing out a parcel in fast-loading binary format."	"parcels first saveParcelDialogFor: nil"	| pfe pse parcelName baseName dialog error save hide overwrite republish backup parcelFile parcelExists sourceExists sourceFile sourceIsSystemSource pad |	pfe := self class fileExtension.	pse := self class sourceExtension.	(parcelName := self name) isNil ifTrue: [parcelName := (#parcelNameScratch &lt;&lt; #dialogs &gt;&gt; 'scratch') asString].	"properties at: #parcel) remembers the Parcel's save filename	 without extension as a sequence of filename components."	baseName := properties at: #parcel ifAbsent: [Filename filterFilename: parcelName].	baseName isString ifFalse:		[baseName := baseName copy.		(baseName isEmpty not and: ['#:' match: baseName first])			ifTrue: [baseName at: 1 put: baseName first, '\'].		baseName := (Filename fromComponents: baseName) asString].	baseName := ValueHolder with: baseName.	republish := (loaded and: [(self propertyAt: #sourceIndex) notNil]) asValue.	overwrite := false asValue.	backup := false asValue.	[dialog := SimpleDialog initializedFor: aVisualOrNil.	dialog setInitialGap.	error := nil.	error notNil ifTrue:		[dialog addMessage: error centered: true. 		dialog addGap: 8].	dialog		addMessage: ((#saveParcel &lt;&lt; #dialogs &gt;&gt; 'Save  &lt;1s&gt; on name&lt;2s&gt; (+ name&lt;3s&gt;)')  expandMacrosWith: parcelName with: pfe with: pse)		centered: true.	dialog addGap: 4.	dialog addTextLine: baseName.	dialog addGap: 8.	dialog		"Extra space in the second label to get both columns to line up."		addCheckLabels: ((Array new: 3) at: 1 put: (#saveSourceFile &lt;&lt; #labels &gt;&gt; 'save source file') asString;										at: 2 put: (#hideSouce &lt;&lt; #labels &gt;&gt; 'hide source on load    ') asString;										at: 3 put: (#padSource &lt;&lt; #labels &gt;&gt; 'pad source') asString;										yourself)		values: (Array					with: (save := (properties at: #saveSource ifAbsent: self name notNil) asValue)					with: (hide := (properties at: #hideSource ifAbsent: false) asValue)					with: (pad := (properties at: #padded ifAbsent: false) asValue))		equalize: true		columns: 1.	dialog addDivider.	dialog		addCheckLabels: ((Array new: 3) at: 1 put: (#parcelRepublish &lt;&lt; #labels &gt;&gt; 'republish') asString;										at: 2 put: (#parcelBackup &lt;&lt; #labels &gt;&gt; 'backup') asString;										at: 3 put: (#parcelOverwrite &lt;&lt; #labels &gt;&gt; 'overwrite existing files') asString;										yourself)		values: (Array with: republish with: backup with: overwrite)		equalize: true		columns: 1.	dialog addDivider.	dialog addOK: [true].	dialog addGap: 6.	aBlockForDialog value: dialog.	dialog openDialog.	dialog cancel value ifTrue: [^false].	"check file safety..."	parcelFile := baseName value, pfe.	parcelExists := overwrite value not and: [parcelFile asFilename exists].	sourceExists := false.	sourceIsSystemSource := false.	(properties at: #saveSource put: save value) ifTrue:		[sourceFile := baseName value, pse.		sourceIsSystemSource := SourceFileManager default isSourceFile: sourceFile asLogicalFileSpecification.		sourceExists := overwrite value not and: [sourceFile asLogicalFileSpecification exists]].	"Check for overwriting unless republishing to the same source file."	(republish value	and: [save value	and: [(self propertyAt: #sourceIndex) notNil	and: [(SourceFileManager default logicalNameAt: (self propertyAt: #sourceIndex)) = sourceFile asLogicalFileSpecification]]]) ifFalse:		[sourceIsSystemSource			ifTrue: [error := ((#systemSource &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; is a system source file.&lt;n&gt;Saving will corrupt the sources.&lt;n&gt;Choose a new name.' ) expandMacrosWith: sourceFile) ]			ifFalse:				[parcelExists					ifTrue:						[error := sourceExists									ifTrue: [((#parcelAndSourceExist &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;  &amp; &lt;2s&gt; already exist.') expandMacrosWith: parcelFile with: sourceFile)]									ifFalse: [((#fileExists &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; already exists.') expandMacrosWith: parcelFile)]]					ifFalse:						[sourceExists ifTrue:							[error := ((#fileExists &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; already exists.') expandMacrosWith: sourceFile)]].				error notNil ifTrue: [error := ((#errOverWriteCheck &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;&lt;n&gt;Check overwrite to overwrite.' ) expandMacrosWith: error)]]].	error notNil] whileTrue.	properties		at: #parcel		put: (Filename logicalComponents: baseName value) asArray.	pad value		ifTrue: [properties at: #padded put: true]		ifFalse: [properties removeKey: #padded ifAbsent: nil].	aBlockForSave value: self.	self		parcelOutOn: parcelFile		withSource: (save value ifTrue: [sourceFile])		hideOnLoad: (properties at: #hideSource put: hide value)		republish: republish value		backup: backup value.	republish value ifTrue:		[self markNotModified.		(Dialog confirm: ((#parcelSaveImageRecommendation2 &lt;&lt; #dialogs &gt;&gt; 'It is recommended to save the image now&lt;n&gt;to ensure it stays in sync with the new parcel source file.&lt;n&gt;Save the image?') expandMacros))			ifTrue: [ObjectMemory snapshot]]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>queries</category><body package="System-Code Components" selector="definedObjects">definedObjects	^definedObjects copy</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>copying</category><body package="System-Code Components" selector="postCopy">postCopy	"Ensure that all relevant sub-structure is copied."	super postCopy.	definedClasses := definedClasses copy.	definedObjects := definedObjects copy.	definedBindings := definedBindings copy.	classSelectors := classSelectors copyWithCopiedValues.	namedObjects := namedObjects copy.</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>dependents access</category><body package="System-Code Components" selector="removeDependent:">removeDependent: anObject	"Override to manage flushing the classParcelMap when all browsers have closed.	 Prune any old dependents to prevent dangling references."	super removeDependent: anObject.	#{ApplicationModel} isDefined ifTrue:		[| applicationModel scheduledControllers |		applicationModel := #{ApplicationModel} value.		scheduledControllers := #{ScheduledControllers} valueOrDo: nil.		self dependents copy do:			[:dep|			((dep isKindOf: applicationModel)			and: [scheduledControllers isNil				or: [dep builder isNil				or: [dep builder window isNil				or: [(scheduledControllers isScheduled: dep builder window controller) not]]]]) ifTrue:				[super removeDependent: dep]]].	self dependents isEmpty ifTrue: [self flushClassParcelMap].	^anObject</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>api</category><body package="System-Code Components" selector="parcels">parcels	"Answer a collection of parcels."	^self parcelList copy</body></methods><methods><class-id>Kernel.DefineOpcodePool class</class-id> <category>private-initialization</category><body package="System-Compiler-Support" selector="vw40ExtendedSpecialSelectors">vw40ExtendedSpecialSelectors	"These are the most common selectors	(with at least 20 occurrences)	in the current license image"	^#(		#do: #cr #on: #nextPut: #bounds #x #y #isEmpty		#copy #name #with: #at:ifAbsent: #-&gt; #error: #first #bitShift:		#includes: #contents #key #asString #last #extent #componentAt: #printString		#bitAnd: #scaledRed:scaledGreen:scaledBlue: #view #rounded #window #/ #next #paint:		#yourself #space #asSymbol #controller #sensor #max: #height #isKindOf:		#subclassResponsibility #default #with:with: #asValue #collect: #tab #addLast: #print:		#initialize #builder #extent: #width #handle:do: #top #copyFrom:to: #negated		#widget #close #errorSignal #left #displayRectangle: #current #origin #layout		#perform: #asInteger #min: #black #selection #asPointerParameter #bottom #model		#removeLast #list #component #externalAccessFailedWith: #environment #raise #select: #extent:depth:bitsPerPixel:palette:usingBits:		#peekForTypeNoPush: #asFilename #asText #adapt:forAspect:channel: #showWhile: #tab: #organization #displayOn:at:		#primitiveFailed #release #notifierString: #writeStream #menuItemLabeled: #monoMaskPalette #atEnd #selector		#show: #addAll: #aspectAt:put: #nameClass:message: #model: #right #preferredBounds #emphasis:		#bindValue:to: #indexOf: #expected: #keyboard #disable #white #matchAt:put: #invalidate		#scale #replaceFrom:to:with:startingAt: #on:do: #to: #value:value: #fullName #readStream #valueNowOrOnUnwindDo:		#removeDependent: #byteAt: #onChangeSend:to: #asArray #asFloat #changed: #corner: #text		#labeled: #detect:ifNone: #warn: #name: #center #decodeAsLiteralArray #isSymbol #isString		#changed:with: #label: #position #printOn: #wait #\\ #keysAndValuesDo: #asValueReference		#preferenceFor: #includesKey: #abs #return #shouldNotImplement #returnWith: #critical: #list:		#displayBox #species #withCRs #replaceStackTop: #components #foregroundColor #with:with:with: #selection:		#bitOr: #label #parameter #string #lineGrid #backgroundColor #type #withColors:		#separator #palette #hash #graphicsContext #layout: #sender #open #enable		#remove:ifAbsent: #skip: #textStyle #| #scanToken #insetBy: #targetClass #selectionIndexHolder		#changeRequest #byteAt:put: #memberAt:put: #htmlEntity #wrapper #isEnabled #raiseWith: #displayOn:		#addDependent: #bounds: #perform:with: #x: #containsPoint: #preferenceModelFor: #numArgs #keyboardProcessor		#component: #cursorPoint #externalAccessFailedSignal #intersects: #origin:extent: #store: #zero #widgetState		#remove: #extent:depth:palette:bits:pad: #topComponent #memberAt: #fromBytes:	)</body></methods><methods><class-id>Kernel.ChangeScanner class</class-id> <category>class initialization</category><body package="System-Changes" selector="initialize">initialize	"ChangeScanner initialize"	"change the type table to treat #-quoted symbols as a single unit	rather than a # followed by a symbol"	ChangeTypeTable := TypeTable copy.	ChangeTypeTable at: $# asInteger put: #xLitQuote</body></methods><methods><class-id>Kernel.Decompiler class</class-id> <category>class initialization</category><body package="System-Compiler-Public Access" selector="initialize">initialize	"Decompiler initialize"	CascadeFlag := 'cascade' copy.  "a unique object"	CascadeLastFlag := 'cascadeLast' copy  "ditto"</body></methods><methods><class-id>Kernel.CompiledMainBlock</class-id> <category>copying</category><body package="Kernel-Methods" selector="withAdditionalProperties:">withAdditionalProperties: anArrayOfMessages	"Return a copy of this method suitably modified to have the given attributes.	 These attributes currently include resource annotations, and marking for unwind, propagate &amp; handler."	|  method allMessages | 	anArrayOfMessages == nil ifTrue: [^self].	anArrayOfMessages isEmpty ifTrue: [^self].	allMessages := (self attributeMessages copy ifNil: [OrderedCollection new]) asOrderedCollection.	anArrayOfMessages do: [:each | 		(allMessages includes: each) ifFalse: [allMessages add: each]].	allMessages isEmpty ifTrue: [^self].	method := ((allMessages anySatisfy: [:msg | msg selector == #exception:])					ifTrue: [MarkedMethod]					ifFalse: [(allMessages anySatisfy:									[:msg |									 msg selector == #primitive:module:									 or: [msg selector == #primitive:module:errorCode:]])								ifTrue: [UserPrimitiveMethod]								ifFalse: [AnnotatedMethod]])						fromMethod: self.	method attributeMessages: allMessages.	^method</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>formatting</category><body package="XML-source" selector="putBodyOn:attributes:value:">putBodyOn: aStream attributes: attributes value: aValue	"Put the body of a method or of a class comment	on the stream. This means mapping all text emphases	to XML tags so that they aren't lost."	| emph stack start end oldEmph removed added |	emph := #().	stack := OrderedCollection new.	self on: aStream tag: 'body' attributes: attributes do:		[:ignored :stream |		| oldLineEnd |		oldLineEnd := stream lineEndConvention.		start := 1.		[stream lineEndTransparent.		[start &gt; aValue size] whileFalse:			[end := (aValue runLengthFor: start) + start - 1.			oldEmph := emph.			emph := self makeArrayFrom: (aValue emphasisAt: start).			removed := self subtractEmphasis: emph from: oldEmph.			added := self subtractEmphasis: oldEmph from: emph.			self closeTags: removed from: stack on: stream.			self addTags: added to: stack on: stream.			self on: stream value: (aValue copyFrom: start to: end).			start := end+1]		] ensure: [stream lineEndConvention: oldLineEnd].		self closeTags: stack copy from: stack on: stream].</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>formatting</category><body package="XML-source" selector="putBodyOn:value:">putBodyOn: aStream value: aValue	"Put the body of a method or of a class comment	on the stream. This means mapping all text emphases	to XML tags so that they aren't lost."	| emph stack start end oldEmph removed added |	emph := #().	stack := OrderedCollection new.	self on: aStream tag: 'body' do:		[:xml :str |		start := 1.		[start &gt; aValue size] whileFalse:			[end := (aValue runLengthFor: start) + start - 1.			oldEmph := emph.			emph := self makeArrayFrom: (aValue emphasisAt: start).			removed := self subtractEmphasis: emph from: oldEmph.			added := self subtractEmphasis: oldEmph from: emph.			self closeTags: removed from: stack on: str.			self addTags: added to: stack on: str.			self on: str value: (aValue copyFrom: start to: end).			start := end+1].		self closeTags: stack copy from: stack on: str].</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>copying</category><body package="Debugger-Support" selector="postCopy">postCopy	"Finish doing whatever is required, 	beyond a shallowCopy, to implement 'copy'. 	Answer the receiver. 	Subclasses may add functionality, 	but they should always do super postCopy first."	super postCopy.	1 to: self numLiterals do: 		[:i | | lit cl |		lit := self literalAt: i.		cl := lit class.		((lit isKindOf: CompiledBlock) or: [cl == BlockClosure])			ifTrue: 				[self literalAt: i put: (lit := lit copy).				cl = BlockClosure					ifTrue: [lit method outerMethod: self]					ifFalse: [lit outerMethod: self]]			ifFalse: [self literalAt: i put: lit]].	^self</body></methods><methods><class-id>Kernel.JumpDecomposer</class-id> <category>private</category><body package="System-Compiler-Assembler" selector="updateCurrentPC">updateCurrentPC	| altPC target |	altPC := self logicalPC.	target := registry at: pc.	target do: [:tgt |		tgt updatePCs: [:oldPC |			oldPC = pc ifTrue: [altPC copy] ifFalse: [oldPC]]].	segments last registry addAll: target</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>copying</category><body package="Kernel-Methods" selector="postCopy">postCopy	"Finish doing whatever is required, 	beyond a shallowCopy, to implement 'copy'. 	Answer the receiver. 	Subclasses may add functionality, 	but they should always do super postCopy first."	super postCopy.	method := method copy.	^self</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="Assets" selector="becomeCached">becomeCached	"convert myself to my caching subclass with the result of my value loaded in the cache"	| withCache |	withCache := ((self copy changeClassTo: Array) copyWith: self value) 				changeClassTo: CachedBlockClosure.	self become: withCache</body></methods><methods><class-id>Kernel.BindingReference</class-id> <category>private</category><body package="System-Name Spaces" selector="duplicateWithPath:">duplicateWithPath: aPath	^self copy path: aPath</body></methods><methods><class-id>Kernel.PrerequisiteDescription</class-id> <category>copying</category><body package="System-Code Components" selector="postCopy">postCopy	super postCopy.	properties := properties copy</body></methods><methods><class-id>Kernel.SpecialSelectorCounter class</class-id> <category>utilities</category><body package="System-Compiler-Support" selector="specialSelectors">specialSelectors	^#(#+ #- #&lt; #&gt; #&lt;= #&gt;= #= #~= #* #// #@ #, #not #isNil #notNil #basicAt: #at: #at:put: #size #~~ #basicNew #nextPutAll: #== #class #add: #value #value: #basicSize #new #new: #basicAt:put: #basicNew: #do: #cr #on: #nextPut: #bounds #x #y #isEmpty #copy #name #with: #at:ifAbsent: #-&gt; #error: #first #bitShift: #includes: #contents #key #asString #last #extent #componentAt: #printString #bitAnd: #scaledRed:scaledGreen:scaledBlue: #view #rounded #window #/ #next #paint: #yourself #space #asSymbol #controller #sensor #max: #height #isKindOf: #subclassResponsibility #default #with:with: #asValue #collect: #tab #addLast: #print: #initialize #builder #extent: #width #handle:do: #top #copyFrom:to: #negated #widget #close #errorSignal #left #displayRectangle: #current #origin #layout #perform: #asInteger #min: #black #selection #asPointerParameter #bottom #model #removeLast #list #component #externalAccessFailedWith: #environment #raise #select: #extent:depth:bitsPerPixel:palette:usingBits: #peekForTypeNoPush: #asFilename #asText #adapt:forAspect:channel: #showWhile: #tab: #organization #displayOn:at: #primitiveFailed #release #notifierString: #writeStream #menuItemLabeled: #monoMaskPalette #atEnd #selector #show: #addAll: #aspectAt:put: #nameClass:message: #model: #right #preferredBounds #emphasis: #bindValue:to: #indexOf: #expected: #keyboard #disable #white #matchAt:put: #invalidate #scale #replaceFrom:to:with:startingAt: #on:do: #to: #value:value: #fullName #readStream #valueNowOrOnUnwindDo: #removeDependent: #byteAt: #onChangeSend:to: #asArray #asFloat #changed: #corner: #text #labeled: #detect:ifNone: #warn: #name: #center #decodeAsLiteralArray #isSymbol #isString #changed:with: #label: #position #printOn: #wait #\\ #keysAndValuesDo: #asValueReference #preferenceFor: #includesKey: #abs #return #shouldNotImplement #returnWith: #critical: #list: #displayBox #species #withCRs #replaceStackTop: #components #foregroundColor #with:with:with: #selection: #bitOr: #label #parameter #string #lineGrid #backgroundColor #type #withColors: #separator #palette #hash #graphicsContext #layout: #sender #open #enable #remove:ifAbsent: #skip: #textStyle #| #scanToken #insetBy: #targetClass #selectionIndexHolder #changeRequest #byteAt:put: #memberAt:put: #htmlEntity #wrapper #isEnabled #raiseWith: #displayOn: #addDependent: #bounds: #perform:with: #x: #containsPoint: #preferenceModelFor: #numArgs #keyboardProcessor #component: #cursorPoint #externalAccessFailedSignal #intersects: #origin:extent: #store: #zero #widgetState #remove: #extent:depth:palette:bits:pad: #topComponent #memberAt: #fromBytes:)</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>system backup/exit file names</category><body package="System-Support" selector="promptForChangesFileLocation">promptForChangesFileLocation	| prompt choiceStrings choices result newChanges possibleOldFile |	prompt := ((#MissingChangesFileWarning &lt;&lt; #dialogs &gt;&gt; 'When this image was last saved, its name was &lt;n&gt;"&lt;1s&gt;&lt;2s&gt;"&lt;n&gt;The changes file is missing, perhaps because the image file was copied or renamed to &lt;n&gt;"&lt;3s&gt;"&lt;n&gt;What would you like to do?')			expandMacrosWith: ImagePrefix			with: Filename imageExtension			with: self imageName).	choiceStrings := OrderedCollection new.	choices := OrderedCollection new.	newChanges := self changesFilenameInImageDirectoryForPrefix: self imageFilePrefixWithoutPath.	"Is there an old change file we can copy over to the new location"	possibleOldFile := self changesFilenameInImageDirectoryForPrefix: self imagePrefix.	possibleOldFile exists 		ifTrue: 			[choiceStrings 				add: ((#Copy1sTo2s &lt;&lt; #dialogs &gt;&gt; 'Copy "&lt;1s&gt;" to "&lt;2s&gt;"')			expandMacrosWith: possibleOldFile asString			with: newChanges asString).			choices add: #copy].	choiceStrings add: ((#CreateEmptyChangesFileQ &lt;&lt; #dialogs &gt;&gt; 'Create "&lt;1s&gt;" as an empty changes file.')			expandMacrosWith: newChanges asString).	choices add: #continue.	choiceStrings add: (#ExitTheImage &lt;&lt; #dialogs &gt;&gt; 'Exit the Image').	choices add: #quit.	result := Dialog 				choose: prompt				fromVerticallyAlignedButtonsWithLabels: choiceStrings				values: choices				default: #new.	result = #quit ifTrue: [self quit].	result = #copy 		ifTrue:			[SourceFileManager default changesFileName: possibleOldFile.			SourceFileManager default copyChangesTo: newChanges asString].	result = #continue		ifTrue: [			Transcript cr; show: ((#CreatingEmptyChangeLog &lt;&lt; #dialogs &gt;&gt; 'Creating a new empty log file &lt;1s&gt;.') expandMacrosWith: newChanges).			SourceFileManager default changesFileName: newChanges].</body></methods><methods><class-id>Kernel.CachedBlockClosure</class-id> <category>private</category><body package="Assets" selector="becomeUncached">becomeUncached	"convert myself back to my uncaching superclass"	| withoutCache |	withoutCache := ((self copy changeClassTo: Array) allButLast: 1) 				changeClassTo: BlockClosure.	self become: withoutCache</body></methods><methods><class-id>Kernel.Snapshot</class-id> <category>private-saving</category><body package="System-Support" selector="logSnapshot">logSnapshot	| msg dateAndTime dateAndTime2 log |	SourceFileManager default logChange: '''----SNAPSHOT----'''.	dateAndTime := Time dateAndTimeNow.	dateAndTime2 := dateAndTime collect: [:t | | str |		str := '' copy writeStream.		(Locale named: #C) timePolicy printLong: t on: str.		str contents].	msg := (Array with: self imageFilename asString), dateAndTime2.	log := String new writeStream.	log nextPut: $";		store: msg;		nextPut: $";		cr;		nextPut: $";		nextPutAll: (#snapShotCreatedLong &lt;&lt; #dialogs &gt;&gt; 'An image file &lt;1s&gt; was created at &lt;3p&gt; on &lt;2p&gt;.'			expandMacrosWith: msg first			with: (dateAndTime at: 1)			with: (dateAndTime at: 2));		nextPut: $".	SourceFileManager default logChange: log contents.	Transcript		cr;		show: (#snapShotCreated &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; created at &lt;2p&gt; &lt;3p&gt;'			expandMacrosWith: msg first			with: (dateAndTime at: 1)			with: (dateAndTime at: 2)).</body></methods><methods><class-id>Security.MD5</class-id> <category>private-digest</category><body package="MD5" selector="backupRegisters">backupRegisters"This has to match with #restoreRegisters:"	^Array		with: a copy		with: b copy		with: c copy		with: d copy</body></methods><methods><class-id>Security.HMAC</class-id> <category>services-basic</category><body package="HashesBase" selector="copyOld">copyOld"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self class new		setIHash: ihash copy		oHash: ohash copy		iPad: ipad copy		oPad: opad copy;		yourself</body></methods><methods><class-id>Security.HMAC</class-id> <category>services-basic</category><body package="HashesBase" selector="copy">copy"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self class new		setIHash: ihash copy		oHash: ohash copy		iPad: ipad copy		oPad: opad copy;		yourself</body></methods><methods><class-id>Security.HMAC</class-id> <category>initialize-release</category><body package="HashesBase" selector="setHash:">setHash: aHash	ihash := aHash.	ohash := aHash copy</body></methods><methods><class-id>OSkSocketListenerService</class-id> <category>start/stop</category><body package="OSkSocketServices" selector="closeEverything">closeEverything	"^selfI close down all my socket activity.  First I shut down the existing accepted connections, then I shut down my accept loop and lastly I close the listener socket."	self acceptedConnections copy do: [:each | each close].	self acceptLoop notNil 		ifTrue: 			[self acceptLoop terminate.			acceptLoop := nil].	self socket notNil 		ifTrue: 			[self socket close.			socket := nil].	^self</body></methods><shared-variable><name>EventDispatchTable</name><environment>UI.InputState</environment><private>true</private><constant>true</constant><category>As yet unclassified</category><initializer>#(#send:noOp: #send:eventKeyPress: #send:eventKeyRelease: #send:eventButtonPress: #send:eventButtonRelease: #send:eventMouseMoved: #send:eventEnter: #send:eventExit: #send:eventDamage: #send:eventResize: #send:eventQuit: #send:eventCollapse: #send:eventExpand: #send:eventWidgetColorChange: #send:eventDestroy: nil nil #send:eventMouseWheel: #send:eventQuitSystem: #send:eventButtonDoubleClick: #send:eventInputManager:)	copy</initializer><attributes><package>OS-Window System</package></attributes></shared-variable><shared-variable><name>MoveOutIcon</name><environment>Store.Glorp.ChangeResolver</environment><private>false</private><constant>false</constant><category>MoveOutIcon</category><initializer>MergeIcons move copy image: MergeIcons move image copy reflectedInX</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><remove-selector><class-id>Glorp.Query</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Store.Glorp.StorePundleWriter</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>BST</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Protocols.Struct</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Glorp.DualRoleFunction</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>UI.AssociationTree</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Tools.UIMaskEditor</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Core.Symbol</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Graphics.DispatchTable</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Graphics.CharacterBlock</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Glorp.ElementBuilder</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Text2.Document</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Store.Glorp.StoreObject</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Glorp.GlorpVirtualCollection</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Glorp.Tracing</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Core.Object</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Glorp.DatabaseAccessor</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Security.HMAC</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Security.MessageDigest</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Security.Hash</class-id> <selector>copyOld</selector></remove-selector><remove-selector><class-id>Glorp.GlorpSession</class-id> <selector>copyOld</selector></remove-selector><methods><class-id>BST</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	root := nil.	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="map:">map: aBlock	| newBST |	root isNil		ifFalse: 			[newBST := BST new.			root do: [:x | newBST add: (aBlock value: x)].			root := newBST].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="do:">do: aBlock	root notNil ifTrue: [ root do: aBlock].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject	root notNil ifTrue: [root := root remove: anObject].	^self</body></methods><methods><class-id>BSTNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	super initialize.	left := nil.	right := nil.	value := nil.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="do:">do: aBlock	left isNil ifFalse: [left do: aBlock].	aBlock value: self value.	right isNil ifFalse: [right do: aBlock].	^self</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="do:">do: aBlock	left notNil ifTrue: [left do: aBlock].	aBlock value: self value.	right notNil ifTrue: [right do: aBlock].	^self</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject	| temp |	temp := self.	value = anObject		ifTrue: 			[left isNil				ifTrue: [temp := right]				ifFalse: 					[value := left max.					left := left remove: value]]		ifFalse: 			[anObject &lt; value				ifTrue: [left notNil ifTrue: [left := left remove: anObject]]				ifFalse: [right notNil ifTrue: [right := right remove: anObject]]].	^temp</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"This stub method was generated by UIDefiner"	s1 notNil		ifTrue: [leftView value: s1 asString]		ifFalse: [leftView value: ''].	s2 notNil		ifTrue: [rightView value: s2 asString]		ifFalse: [rightView value: ''].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="intersection">intersection	"This stub method was generated by UIDefiner"	s1 notNil ifTrue: [s1 := s1 intersection: s2].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="remove">remove	"This stub method was generated by UIDefiner"	s1 notNil ifTrue: [s1 remove: input value asNumber].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 notNil ifTrue: [s1 := s1 map: (BlockClosure readFromString: input value)].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 notNil		ifTrue: [s1 := s1 map: (BlockClosure readFromString: input value)].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="union">union	"This stub method was generated by UIDefiner"	s1 isNil ifTrue: [s1 := s1 union: s2.].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="union">union	"This stub method was generated by UIDefiner"	s1 notNil ifTrue: [s1 := s1 union: s2.].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"This stub method was generated by UIDefiner"	s1 notNil		ifTrue: [s1 := s1 map: (BlockClosure readFromString: input value)].	self display.	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="union:">union: anotherBST	anotherBST notNil		ifTrue: 			[anotherBST root isNil				ifFalse: [anotherBST root do: [:value | self add: value]]].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="clear">clear	"This stub method was generated by UIDefiner"	s1 clear.	self display.	^self</body></methods><comment><class-id>UserInterface</class-id><body>The UserInterface is the interface that the user interacts with.Instance Variables	input	&lt;ValueModel&gt;	an input field	leftView	&lt;ValueModel&gt;	a display for set 1	rightView	&lt;ValueModel&gt;	a  display for set 2	s1	&lt;BST&gt;	the first set	s2	&lt;BST&gt;	the second set</body></comment><comment><class-id>BSTNode</class-id><body>A BSTNode encapsulates a node of a binary search tree.Instance Variables	left	&lt;BSTNode&gt;	the left node	right	&lt;BSTNode&gt;	the right node	value	&lt;BSTNode | CharacterArray | CharacterBlock | Magnitude | SpDate&gt;	the stored value</body></comment><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>root</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>root</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="root">root	"getter for the root"	^root</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="root:">root: anObject	"setter for the root"	root := anObject</body></methods><methods><class-id>BST</class-id> <category>converting</category><body package="CS474" selector="asString">asString	"converts the BST to a string"	^root notNil ifTrue: ['{' , root asString , '}'] ifFalse: ['']</body></methods><methods><class-id>BST</class-id> <category>copying</category><body package="CS474" selector="postCopy">postCopy	"overrides postCopy to provide for a deep copy"	root notNil ifTrue: [root := root copy].	^self</body></methods><methods><class-id>BST</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	root := nil.	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="intersection:">intersection: anotherBST	"performs the intersection with another BST"	| temp |	temp := self copy.	anotherBST do: [:value | temp remove: value].	temp do: [:value | self remove: value].	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="map:">map: aBlock	"maps a block onto a new BST and returns the new BST"	| newBST |	root isNil		ifFalse: 			[newBST := BST new.			root do: [:x | newBST add: (aBlock value: x)].			root := newBST].	^self</body></methods><methods><class-id>BST</class-id> <category>set-operations</category><body package="CS474" selector="union:">union: anotherBST	"performs a union with another BST"	anotherBST notNil		ifTrue: 			[anotherBST root isNil				ifFalse: [anotherBST root do: [:value | self add: value]]].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="add:">add: anObject	"adds an object to a BST"	root isNil		ifTrue: [root := BSTNode new: anObject]		ifFalse: [root add: anObject].	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>clear</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>clear</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="clear">clear	"clears a BST"	root := nil.	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="copy">copy	"performs a copy and returns a new BST, assuming the BSTNode performs a deep copy"	^BST new root: root copy</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="do:">do: aBlock	"executes a block on each element of the BST"	root notNil ifTrue: [root do: aBlock].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject	"removes an object from a BST"	root notNil ifTrue: [root := root remove: anObject].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject	"removes an object from a BST"	root notNil ifTrue: [root := root remove: anObject].	^self</body></methods><methods><class-id>BST</class-id> <category>updating</category><body package="CS474" selector="swap:">swap: anotherBST	"swaps two BST's with each other"	| temp |	temp := root.	root := anotherBST root.	anotherBST root: temp.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="contains:">contains: anObject	"returns true if the node or any children nodes contain an object"	| contains |	contains := false.	value = anObject		ifTrue: [contains := true]		ifFalse: 			[(value &lt; anObject and: [left notNil])				ifTrue: [contains := left contains: anObject].			(value &gt; anObject and: [right notNil])				ifTrue: [contains := right contains: anObject]].	^contains</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>hasChildren</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>hasChildren</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="hasChildren">hasChildren	"returns true if the node has children"	^left notNil or: [right notNil]</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>left</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>left</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left">left	"getter for the left"	^left</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left:">left: anObject	"setter for left"	left := anObject.	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>max</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>max</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="max">max	"returns the maximum value in the tree"	^right isNil ifTrue: [value] ifFalse: [right max]</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>min</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>min</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="min">min	"returns the minimum value in the tree"	^left isNil ifTrue: [value] ifFalse: [left min]</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right">right	"getter for the right"	^right</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right:">right: anObject	"setter for the right"	right := anObject.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="value">value	"getter for value"	^value</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="value:">value: anObject		value := anObject.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="value:">value: anObject	"setter for value"	value := anObject.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&lt;">&lt; anotherBSTNode	"returns true if the value of this node is less than the value of another node"	^anotherBSTNode class = self class		ifTrue: [self value &lt; anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&lt;=">&lt;= anotherBSTNode	"returns true if the value of this node is less than or equal to the value of another node"	^anotherBSTNode class = self class		ifTrue: [self value &lt;= anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="=">= anotherBSTNode	"returns true if the value of this node equal to the value of another node"	^anotherBSTNode class = self class		ifTrue: [self value = anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&gt;">&gt; anotherBSTNode	"returns true if the value of this node is greater than the value of another node"	^anotherBSTNode class = self class		ifTrue: [self value &gt; anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="&gt;=">&gt;= anotherBSTNode	"returns true if the value of this node is greater than or equal to the value of another node"	^anotherBSTNode class = self class		ifTrue: [self value &gt;= anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>comparing</category><body package="CS474" selector="~=">~= anotherBSTNode	"returns true if the value of this node is not equal to the value of another node"	^anotherBSTNode class = self class		ifTrue: [self value ~= anotherBSTNode value]		ifFalse: [false]</body></methods><methods><class-id>BSTNode</class-id> <category>converting</category><body package="CS474" selector="asString">asString	"returns a string representation of a tree"	| aString |	aString := value printString.	left notNil ifTrue: [aString := left asString , ' ' , aString].	right notNil ifTrue: [aString := aString , ' ' , right asString].	^aString</body></methods><methods><class-id>BSTNode</class-id> <category>copying</category><body package="CS474" selector="postCopy">postCopy	"overrides postCopy to implement a deep copy"	left notNil ifTrue: [left := left copy].	right notNil ifTrue: [right := right copy].	^self</body></methods><methods><class-id>BSTNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"initializes the object"	super initialize.	left := nil.	right := nil.	value := nil.	^self</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="add:">add: anObject	"recursively adds an object to the tree"	| temp |	temp := nil.	anObject = value		ifFalse: 			[anObject &lt; value				ifTrue: 					[left isNil						ifTrue: 							[temp := BSTNode new: anObject.							left := temp]						ifFalse: [left add: anObject]]				ifFalse: 					[right isNil						ifTrue: 							[temp := BSTNode new: anObject.							right := temp]						ifFalse: [right add: anObject]]].	^temp</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="do:">do: aBlock	"performs an in order traversal and maps the block across values"	left notNil ifTrue: [left do: aBlock].	aBlock value: self value.	right notNil ifTrue: [right do: aBlock].	^self</body></methods><methods><class-id>BSTNode</class-id> <category>updating</category><body package="CS474" selector="remove:">remove: anObject	"removes an object from a tree, if it exists"	| temp |	temp := self.	value = anObject		ifTrue: 			[left isNil				ifTrue: [temp := right]				ifFalse: 					[value := left max.					left := left remove: value]]		ifFalse: 			[anObject &lt; value				ifTrue: [left notNil ifTrue: [left := left remove: anObject]]				ifFalse: [right notNil ifTrue: [right := right remove: anObject]]].	^temp</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="add">add	"Adds a number to set 1"	s1 isNil ifTrue: [s1 := BST new].	s1 add: input value asNumber.	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="clear">clear	"Clears set 1"	s1 clear.	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"Refreshes the display to reflect the current state of set 1 and set 2"	s1 notNil		ifTrue: [leftView value: s1 asString]		ifFalse: [leftView value: ''].	s2 notNil		ifTrue: [rightView value: s2 asString]		ifFalse: [rightView value: ''].	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="intersection">intersection	"Performs an intersection of set 1 and set 2 and puts the result in set 1"	s1 notNil ifTrue: [s1 := s1 intersection: s2].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="remove">remove	"Removes a number from set 1"	s1 notNil ifTrue: [s1 remove: input value asNumber].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="save">save	"Makes a copy of set 1 and sets set 2 to that copy"	s2 := s1 copy.	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="switch">switch	"Switches the trees of set 1 and set 2"	| temp |	temp := s1.	s1 := s2.	s2 := temp.	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="transform">transform	"Performs the block specified in the input on each element of set 1 and creates a new set out of the results.  Set 1 is then assigned to the new set."	s1 notNil		ifTrue: [s1 := s1 map: (BlockClosure readFromString: input value)].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="union">union	"Adds all elements of set 2 to set 1, performing a union on the sets."	s1 notNil ifTrue: [s1 := s1 union: s2].	self display.	^self</body></methods><methods><class-id>UserInterface</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"initializes the instance variables"	s1 := BST new.	s2 := BST new.	^self</body></methods><methods><class-id>BSTNode class</class-id> <category>instance creation</category><body package="CS474" selector="new:">new: anObject	"Instantiator with value"	^super new initialize value: anObject</body></methods><methods><class-id>BSTNode class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Instantiator"	^super new initialize</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 21, 2014' '3:15:07 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 3:15:07 PM on February 21, 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 21, 2014' '3:16:27 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 3:16:27 PM on February 21, 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 22, 2014' '11:37:12 AM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 11:37:12 AM on February 22, 2014."</do-it><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#min: #(#{Core.Point} 685 400 ) 			#max: #(#{Core.Point} 685 400 ) 			#bounds: #(#{Graphics.Rectangle} 694 343 1379 743 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 102 351 182 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 92 370 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 191 351 271 370 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><methods><class-id>UserInterface</class-id> <category>actions</category><body package="CS474" selector="display">display	"Refreshes the display to reflect the current state of set 1 and set 2"	s1 notNil		ifTrue: [leftView value: s1 asString]		ifFalse: [leftView value: '{}'].	s2 notNil		ifTrue: [rightView value: s2 asString]		ifFalse: [rightView value: '{}'].	^self</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#min: #(#{Core.Point} 685 400 ) 			#max: #(#{Core.Point} 685 400 ) 			#bounds: #(#{Graphics.Rectangle} 694 343 1379 743 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 102 351 182 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 92 370 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 191 351 271 370 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><methods><class-id>UserInterface class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Smalltalk Set Operations' 			#min: #(#{Core.Point} 685 400 ) 			#max: #(#{Core.Point} 685 400 ) 			#bounds: #(#{Graphics.Rectangle} 694 343 1379 743 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #lightGray ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 6 ) 					#name: #Label1 					#flags: 8 					#label: 'Set 1' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 413 6 ) 					#name: #Label2 					#flags: 8 					#label: 'Set 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 74 385 93 ) 					#name: #ActionButton1 					#model: #save 					#label: 'Save -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 102 351 182 371 ) 					#name: #ActionButton3 					#model: #remove 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 12 351 92 370 ) 					#name: #ActionButton4 					#model: #add 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 110 266.5 167 286.5 ) 					#name: #ActionButton5 					#model: #clear 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 100.0 385 122.5 ) 					#name: #ActionButton6 					#model: #switch 					#label: '&lt;- Switch -&gt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 191 351 271 370 ) 					#name: #ActionButton7 					#model: #transform 					#label: 'Transform' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 160.5 385 180.5 ) 					#name: #ActionButton8 					#model: #union 					#label: '&lt;- Union' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 287 129.5 385 153.5 ) 					#name: #ActionButton9 					#model: #intersection 					#label: '&lt;- Intersection' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 9 318 274 344 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #input 					#type: #string ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 9 28 274 257 ) 					#name: #DocumentView1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #leftView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.Rectangle} 411 28 676 263 ) 					#name: #DocumentView2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #rightView 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 23, 2014' '2:17:02 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 2:17:02 PM on February 23, 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/VisualWorks Projects/hw1/hw1.im' 'February 23, 2014' '2:25:33 PM')""An image file /home/wcmonty/VisualWorks Projects/hw1/hw1.im was created at 2:25:33 PM on February 23, 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/Projects/474/hw1/hw1.im' 'February 23, 2014' '2:30:25 PM')""An image file /home/wcmonty/Projects/474/hw1/hw1.im was created at 2:30:25 PM on February 23, 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/Projects/474/hw1/hw1.im' 'February 23, 2014' '2:31:59 PM')""An image file /home/wcmonty/Projects/474/hw1/hw1.im was created at 2:31:59 PM on February 23, 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/wcmonty/Projects/474/hw1/hw1.im' 'February 23, 2014' '2:46:54 PM')""An image file /home/wcmonty/Projects/474/hw1/hw1.im was created at 2:46:54 PM on February 23, 2014."</do-it>